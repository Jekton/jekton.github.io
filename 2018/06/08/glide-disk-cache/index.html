<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Glide 源码分析(1) - DiskCache 详解 | 程序员虾饺</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Glide 源码分析(1) - DiskCache 详解</h1><a id="logo" href="/.">程序员虾饺</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Glide 源码分析(1) - DiskCache 详解</h1><div class="post-meta">Jun 8, 2018<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/06/08/glide-disk-cache/" href="/2018/06/08/glide-disk-cache/#disqus_thread"></a><div class="post-content"><p>作为一个合格的图片加载框架，一般都会有内存缓存和硬盘缓存。在本篇，我们就先来看看 Glide 的硬盘缓存实现。</p>
<a id="more"></a>

<blockquote>
<p>Glide 使用版本 4.7.1</p>
</blockquote>
<h2 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h2><p>Glide 的硬盘缓存由接口 <code>DiskCache</code> 定义，用户可以根据需要，提供自己实现的 <code>DiskCache</code>，或者使用 Glide 内置的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An interface for writing to and reading from a disk cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiskCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * An interface for lazily creating a disk cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 250 MB of cache. */</span></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_DISK_CACHE_SIZE = <span class="number">250</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    String DEFAULT_DISK_CACHE_DIR = <span class="string">"image_manager_disk_cache"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a new disk cache, or &#123;<span class="doctag">@code</span> null&#125; if no disk cache could be created. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">DiskCache <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * An interface to actually write data to a key in the disk cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Writes data to the file and returns true if the write was successful and should be committed,</span></span><br><span class="line"><span class="comment">     * and false if the write should be aborted.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file The File the Writer should write to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">write</span><span class="params">(@NonNull File file)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the cache for the value at the given key.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; Note - This is potentially dangerous, someone may write a new value to the file at any</span></span><br><span class="line"><span class="comment">   * point in time and we won't know about it. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key in the cache.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> An InputStream representing the data at key at the time get is called.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">File <span class="title">get</span><span class="params">(Key key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write to a key in the cache. &#123;<span class="doctag">@link</span> Writer&#125; is used so that the cache implementation can</span></span><br><span class="line"><span class="comment">   * perform actions after the write finishes, like commit (via atomic file rename).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key    The key to write to.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> writer An interface that will write data given an OutputStream for the key.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Writer writer)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove the key and value from the cache.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key to remove.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// Public API.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clear the cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口并没有太多值得玩味的地方，读者自己看一看就好。</p>
<h2 id="Factory-工厂"><a href="#Factory-工厂" class="headerlink" title="Factory 工厂"></a>Factory 工厂</h2><p><code>DiskCache.Factory</code> 作为一个工厂，用来 build 出实际的 <code>DiskCache</code> 实例。Glide 内部共有 3 个 <code>Factory</code> 的实现，分别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiskLruCacheFactory</span> <span class="keyword">implements</span> <span class="title">DiskCache</span>.<span class="title">Factory</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InternalCacheDiskCacheFactory</span> <span class="keyword">extends</span> <span class="title">DiskLruCacheFactory</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExternalPreferredCacheDiskCacheFactory</span> <span class="keyword">extends</span> <span class="title">DiskLruCacheFactory</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>InternalCacheDiskCacheFactory</code> 所创建的 <code>DiskCache</code> 将文件存储在 internal storage，存放在这里的文件只有我们自己能够读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalCacheDiskCacheFactory</span> <span class="keyword">extends</span> <span class="title">DiskLruCacheFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InternalCacheDiskCacheFactory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认情况下，文件夹名字是 image_manager_disk_cache</span></span><br><span class="line">    <span class="comment">// 缓存大小为 250M</span></span><br><span class="line">    <span class="keyword">this</span>(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,</span><br><span class="line">        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InternalCacheDiskCacheFactory</span><span class="params">(Context context, <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InternalCacheDiskCacheFactory</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> String diskCacheName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> CacheDirectoryGetter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从这里可以看到，我们确实是用的 internal storage</span></span><br><span class="line">        File cacheDirectory = context.getCacheDir();</span><br><span class="line">        <span class="keyword">if</span> (cacheDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (diskCacheName != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> File(cacheDirectory, diskCacheName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheDirectory;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ExternalPreferredCacheDiskCacheFactory</code> 优先使用 external storage，在 external storage 不可写的情况下，会转而使用 internal storage。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@link</span> com.bumptech.glide.disklrucache.DiskLruCache&#125; based disk cache in the external</span></span><br><span class="line"><span class="comment"> * disk cache directory, which falls back to the internal disk cache if no external storage is</span></span><br><span class="line"><span class="comment"> * available. If ever fell back to the internal disk cache, will use that one from that moment on.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Images can be read by everyone when using external disk cache.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Public API.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"WeakerAccess"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalPreferredCacheDiskCacheFactory</span> <span class="keyword">extends</span> <span class="title">DiskLruCacheFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExternalPreferredCacheDiskCacheFactory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,</span><br><span class="line">        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExternalPreferredCacheDiskCacheFactory</span><span class="params">(Context context, <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExternalPreferredCacheDiskCacheFactory</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> String diskCacheName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">final</span> <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> CacheDirectoryGetter() &#123;</span><br><span class="line">      <span class="meta">@Nullable</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> File <span class="title">getInternalCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File cacheDirectory = context.getCacheDir();</span><br><span class="line">        <span class="keyword">if</span> (cacheDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (diskCacheName != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> File(cacheDirectory, diskCacheName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheDirectory;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File internalCacheDirectory = getInternalCacheDirectory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Already used internal cache, so keep using that one,</span></span><br><span class="line">        <span class="comment">// thus avoiding using both external and internal with transient errors.</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">null</span> != internalCacheDirectory) &amp;&amp; internalCacheDirectory.exists()) &#123;</span><br><span class="line">          <span class="keyword">return</span> internalCacheDirectory;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File cacheDirectory = context.getExternalCacheDir();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shared storage is not available.</span></span><br><span class="line">        <span class="keyword">if</span> ((cacheDirectory == <span class="keyword">null</span>) || (!cacheDirectory.canWrite())) &#123;</span><br><span class="line">          <span class="keyword">return</span> internalCacheDirectory;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (diskCacheName != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> File(cacheDirectory, diskCacheName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheDirectory;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 external storage 的时候，路径为 <code>/sdcard/Android/data/your.package.name/</code>，这里路径所有程序都可以访问。我们自己往里面写东西，也不需要声明权限，在应用被删除后，这个文件夹会被系统一起删除。</p>
<p>缓存不管是放在 internal storage 还是 external storage，唯一的差异，其实就是存放的路径不同。所以，<code>InternalCacheDiskCacheFactory</code>、<code>ExternalPreferredCacheDiskCacheFactory</code> 都只是用于指定一个路径，实际的 factory 的职责由他们共同的父类 <code>DiskLruCacheFactory</code> 来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@link</span> com.bumptech.glide.disklrucache.DiskLruCache&#125; based disk cache in the specified</span></span><br><span class="line"><span class="comment"> * disk cache directory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If you need to make I/O access before returning the cache directory use the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, long)&#125; constructor variant.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Public API.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskLruCacheFactory</span> <span class="keyword">implements</span> <span class="title">DiskCache</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> diskCacheSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CacheDirectoryGetter cacheDirectoryGetter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Interface called out of UI thread to get the cache folder.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheDirectoryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">File <span class="title">getCacheDirectory</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们可以不使用 InternalCacheDiskCacheFactory、ExternalPreferredCacheDiskCacheFactory</span></span><br><span class="line">  <span class="comment">// 直接通过这个接口构建 DiskLruCacheFactory。通过这种方式，我们可以指定任意的缓存路</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DiskLruCacheFactory</span><span class="params">(<span class="keyword">final</span> String diskCacheFolder, <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> CacheDirectoryGetter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(diskCacheFolder);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DiskLruCacheFactory</span><span class="params">(<span class="keyword">final</span> String diskCacheFolder, <span class="keyword">final</span> String diskCacheName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> CacheDirectoryGetter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(diskCacheFolder, diskCacheName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * When using this constructor &#123;<span class="doctag">@link</span> CacheDirectoryGetter#getCacheDirectory()&#125; will be called out</span></span><br><span class="line"><span class="comment">   * of UI thread, allowing to do I/O access without performance impacts.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> cacheDirectoryGetter Interface called out of UI thread to get the cache folder.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> diskCacheSize        Desired max bytes size for the LRU disk cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// Public API.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DiskLruCacheFactory</span><span class="params">(CacheDirectoryGetter cacheDirectoryGetter, <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.diskCacheSize = diskCacheSize;</span><br><span class="line">    <span class="keyword">this</span>.cacheDirectoryGetter = cacheDirectoryGetter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DiskCache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File cacheDir = cacheDirectoryGetter.getCacheDirectory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cacheDir.mkdirs() &amp;&amp; (!cacheDir.exists() || !cacheDir.isDirectory())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 DiskLruCacheWrapper 的工厂方法构造一个 DiskLruCacheWrapper，DiskLruCacheWrapper</span></span><br><span class="line">    <span class="comment">// 是 glide 内建的 DiskCache 实现</span></span><br><span class="line">    <span class="keyword">return</span> DiskLruCacheWrapper.create(cacheDir, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Factory</code> 的实现很简单，到这里我们就看完了。下面我们看看 DiskLruCacheWrapper。</p>
<h2 id="wrapper-实现"><a href="#wrapper-实现" class="headerlink" title="wrapper 实现"></a>wrapper 实现</h2><p>Glide 的硬盘缓存，实际上上并不是自己实现的，而是使用别人实现好的 disklrucache。在 build.gradle 可以看到：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// library/build.gradle</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    api <span class="keyword">project</span>(<span class="string">':third_party:disklrucache'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>DiskCache</code> 是 Glide 自动定义的接口，disklrucache 并没有实现它，所以这里我们借助 <code>DiskLruCacheWrapper</code> 来解决接口的问题（设计模式迷此时估计会大喊：adapter 模式!）。</p>
<h3 id="DiskLruCacheWrapper-的构造"><a href="#DiskLruCacheWrapper-的构造" class="headerlink" title="DiskLruCacheWrapper 的构造"></a>DiskLruCacheWrapper 的构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new DiskCache in the given directory with a specified max size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> directory The directory for the disk cache</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxSize   The max size for the disk cache</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The new disk cache with the given arguments</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskCache <span class="title">create</span><span class="params">(File directory, <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DiskLruCacheWrapper(directory, maxSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> Do not extend this class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="comment">// Deprecated public API.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"WeakerAccess"</span>, <span class="string">"DeprecatedIsStillUsed"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DiskLruCacheWrapper</span><span class="params">(File directory, <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.directory = directory;</span><br><span class="line">  <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">  <span class="keyword">this</span>.safeKeyGenerator = <span class="keyword">new</span> SafeKeyGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SafeKeyGenerator</code> 用于将一个 <code>Key</code> 转换为 <code>String</code> 类型的 key，它跟主干逻辑没有太多关系，这里我们就不看了。</p>
<h3 id="获取文件"><a href="#获取文件" class="headerlink" title="获取文件"></a>获取文件</h3><p>获取文件由 <code>get(Key)</code> 完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DiskLruCache diskLruCache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> DiskLruCache <span class="title">getDiskCache</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 懒加载</span></span><br><span class="line">  <span class="comment">// 注意，这里跟 double check 不一样，diskLruCache 并不需要是 volatile。具体原因这里就不展开谈了。</span></span><br><span class="line">  <span class="keyword">if</span> (diskLruCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">    diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> diskLruCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  String safeKey = safeKeyGenerator.getSafeKey(key);</span><br><span class="line">  <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">    Log.v(TAG, <span class="string">"Get: Obtained: "</span> + safeKey + <span class="string">" for for Key: "</span> + key);</span><br><span class="line">  &#125;</span><br><span class="line">  File result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// It is possible that the there will be a put in between these two gets. If so that shouldn't</span></span><br><span class="line">    <span class="comment">// be a problem because we will always put the same value at the same key so our input streams</span></span><br><span class="line">    <span class="comment">// will still represent the same data.</span></span><br><span class="line">    <span class="keyword">final</span> DiskLruCache.Value value = getDiskCache().get(safeKey);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = value.getFile(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">      Log.w(TAG, <span class="string">"Unable to get from disk cache"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DiskCacheWriteLocker writeLocker = <span class="keyword">new</span> DiskCacheWriteLocker();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Writer writer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We want to make sure that puts block so that data is available when put completes. We may</span></span><br><span class="line">  <span class="comment">// actually not write any data if we find that data is written by the time we acquire the lock.</span></span><br><span class="line">  String safeKey = safeKeyGenerator.getSafeKey(key);</span><br><span class="line">  <span class="comment">// 获取针对 safeKey 的锁</span></span><br><span class="line">  writeLocker.acquire(safeKey);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">"Put: Obtained: "</span> + safeKey + <span class="string">" for for Key: "</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// We assume we only need to put once, so if data was written while we were trying to get</span></span><br><span class="line">      <span class="comment">// the lock, we can simply abort.</span></span><br><span class="line">      DiskLruCache diskCache = getDiskCache();</span><br><span class="line">      Value current = diskCache.get(safeKey);</span><br><span class="line">      <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      DiskLruCache.Editor editor = diskCache.edit(safeKey);</span><br><span class="line">      <span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Had two simultaneous puts for: "</span> + safeKey);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = editor.getFile(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (writer.write(file)) &#123;</span><br><span class="line">          editor.commit();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// DiskLruCache 实现了日志系统，写文件作为一个事务来处理</span></span><br><span class="line">        editor.abortUnlessCommitted();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Unable to put to disk cache"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLocker.release(safeKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写文件的时候，不同的文件直接的写并不会相互影响，<code>writeLocker.acquire(safeKey)</code> 中会给每个 key 分配一个锁。关于 <code>DiskCacheWriteLocker</code> 的实现，由于篇幅关系，这里就不看了。</p>
<h3 id="删除文件、情况缓存"><a href="#删除文件、情况缓存" class="headerlink" title="删除文件、情况缓存"></a>删除文件、情况缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  String safeKey = safeKeyGenerator.getSafeKey(key);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    getDiskCache().remove(safeKey);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">      Log.w(TAG, <span class="string">"Unable to delete from disk cache"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    getDiskCache().delete();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">      Log.w(TAG, <span class="string">"Unable to clear disk cache or disk cache cleared externally"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Delete can close the cache but still throw. If we don't null out the disk cache here, every</span></span><br><span class="line">    <span class="comment">// subsequent request will try to act on a closed disk cache and fail. By nulling out the disk</span></span><br><span class="line">    <span class="comment">// cache we at least allow for attempts to open the cache in the future. See #2465.</span></span><br><span class="line">    resetDiskCache();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">resetDiskCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  diskLruCache = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法是在没有什么值得说的。下面我们接着看 <code>DiskLruCache</code> 的实现。</p>
<h2 id="DiskLruCache-实现"><a href="#DiskLruCache-实现" class="headerlink" title="DiskLruCache 实现"></a>DiskLruCache 实现</h2><p>在看代码之前，我们先来聊聊为什么需要日志。最简单的情况，我们想要把某个图片缓存起来，由于写硬盘是一个比较耗时的操作，我们把它放到一个后台线程来执行。假设在写文件的过程中，很不幸的，其他某个线程抛出了未捕获的异常，导致程序终止了。这时候，我们刚才想要保存的图片，其实才写了一半。在这种情况下，我们就需要一种机制，可以表明这个文件是损坏了的，在程序下次启动的时候移它。</p>
<p>为了实现日志（journal）系统，一般的思路是，比方说上面的情况，我们在保存文件的前，先往一个日志文件写入一条日志，说我们马上就要写某某某文件了。写完后，我们再来执行文件保存动作。保存成功后，我们再一次修改日志文件，说我们已经保存成功了。</p>
<p>这时候，万一我们在保存文件的过程中跪了，程序下次启动的时候，只要检查日志文件，就知道哪些文件是损坏的（最倒霉的情况是，我们保存成功，在修改日志的时候跪了。此时，正常的这个文件也会被清除，但是，对于一个缓存，这又有什么所谓呢）。</p>
<p>我们先看看 <code>DiskLruCache</code> 里面关于日志文件的一段注释，它对我们理解代码有非常大的帮助：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This cache uses a journal file named &quot;journal&quot;. A typical journal file</span><br><span class="line"> * looks like this:</span><br><span class="line"> *     libcore.io.DiskLruCache</span><br><span class="line"> *     1</span><br><span class="line"> *     100</span><br><span class="line"> *     2</span><br><span class="line"> *</span><br><span class="line"> *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054</span><br><span class="line"> *     DIRTY 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342</span><br><span class="line"> *     REMOVE 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> *     DIRTY 1ab96a171faeeee38496d8b330771a7a</span><br><span class="line"> *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</span><br><span class="line"> *     READ 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</span><br><span class="line"> *</span><br><span class="line"> * The first five lines of the journal form its header. They are the</span><br><span class="line"> * constant string &quot;libcore.io.DiskLruCache&quot;, the disk cache&apos;s version,</span><br><span class="line"> * the application&apos;s version, the value count, and a blank line.</span><br><span class="line"> *</span><br><span class="line"> * Each of the subsequent lines in the file is a record of the state of a</span><br><span class="line"> * cache entry. Each line contains space-separated values: a state, a key,</span><br><span class="line"> * and optional state-specific values.</span><br><span class="line"> *   o DIRTY lines track that an entry is actively being created or updated.</span><br><span class="line"> *     Every successful DIRTY action should be followed by a CLEAN or REMOVE</span><br><span class="line"> *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that</span><br><span class="line"> *     temporary files may need to be deleted.</span><br><span class="line"> *   o CLEAN lines track a cache entry that has been successfully published</span><br><span class="line"> *     and may be read. A publish line is followed by the lengths of each of</span><br><span class="line"> *     its values.</span><br><span class="line"> *   o READ lines track accesses for LRU.</span><br><span class="line"> *   o REMOVE lines track entries that have been deleted.</span><br><span class="line"> *</span><br><span class="line"> * The journal file is appended to as cache operations occur. The journal may</span><br><span class="line"> * occasionally be compacted by dropping redundant lines. A temporary file named</span><br><span class="line"> * &quot;journal.tmp&quot; will be used during compaction; that file should be deleted if</span><br><span class="line"> * it exists when the cache is opened.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h3 id="DiskLruCache-实例的创建"><a href="#DiskLruCache-实例的创建" class="headerlink" title="DiskLruCache 实例的创建"></a>DiskLruCache 实例的创建</h3><p>上面看 <code>DiskLruCacheWrapper</code> 的时候我们就知道，创建 <code>DiskLruCache</code> 时使用的是它的静态方法 <code>open</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Opens the cache in &#123;<span class="doctag">@code</span> directory&#125;, creating a cache if none exists</span></span><br><span class="line"><span class="comment"> * there.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> directory a writable directory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueCount the number of values per cache entry. Must be positive.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxSize the maximum number of bytes this cache should use to store</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if reading or writing the cache directory fails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"valueCount &lt;= 0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a bkp file exists, use it instead.</span></span><br><span class="line">  File backupFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">  <span class="keyword">if</span> (backupFile.exists()) &#123;</span><br><span class="line">    File journalFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE);</span><br><span class="line">    <span class="comment">// If journal file also exists just delete backup file.</span></span><br><span class="line">    <span class="keyword">if</span> (journalFile.exists()) &#123;</span><br><span class="line">      backupFile.delete();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      renameTo(backupFile, journalFile, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prefer to pick up where we left off.</span></span><br><span class="line">  DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">  <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cache.readJournal();</span><br><span class="line">      cache.processJournal();</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line">      System.out</span><br><span class="line">          .println(<span class="string">"DiskLruCache "</span></span><br><span class="line">              + directory</span><br><span class="line">              + <span class="string">" is corrupt: "</span></span><br><span class="line">              + journalIsCorrupt.getMessage()</span><br><span class="line">              + <span class="string">", removing"</span>);</span><br><span class="line">      cache.delete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new empty cache.</span></span><br><span class="line">  directory.mkdirs();</span><br><span class="line">  cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">  cache.rebuildJournal();</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，跟我们上面讲的差不多，在创建的时候，会读取日志文件，然后做一些清理工作。下面我们先看 <code>readJournal</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  StrictLineReader reader = <span class="keyword">new</span> StrictLineReader(<span class="keyword">new</span> FileInputStream(journalFile), Util.US_ASCII);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String magic = reader.readLine();</span><br><span class="line">    String version = reader.readLine();</span><br><span class="line">    String appVersionString = reader.readLine();</span><br><span class="line">    String valueCountString = reader.readLine();</span><br><span class="line">    String blank = reader.readLine();</span><br><span class="line">    <span class="comment">// 判断一些文件头。关于文件头的格式，在上面那段注释中有说明</span></span><br><span class="line">    <span class="keyword">if</span> (!MAGIC.equals(magic)</span><br><span class="line">        || !VERSION_1.equals(version)</span><br><span class="line">        || !Integer.toString(appVersion).equals(appVersionString)</span><br><span class="line">        || !Integer.toString(valueCount).equals(valueCountString)</span><br><span class="line">        || !<span class="string">""</span>.equals(blank)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal header: ["</span> + magic + <span class="string">", "</span> + version + <span class="string">", "</span></span><br><span class="line">          + valueCountString + <span class="string">", "</span> + blank + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lineCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取并处理一条日志记录</span></span><br><span class="line">        readJournalLine(reader.readLine());</span><br><span class="line">        lineCount++;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (EOFException endOfJournal) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// readJournalLine 会把已经 REMOVE 的 entry 移除掉，多出来的行数是冗余的(redundant)；</span></span><br><span class="line">    <span class="comment">// 并且，一个缓存项也可能对应多行（DIRTY/CLEAN/READ/...)，但其实只需要一个 CLEAN 就够了。</span></span><br><span class="line">    <span class="comment">// 当冗余的行数过多的时候，我们就需要清理日志文件</span></span><br><span class="line">    redundantOpCount = lineCount - lruEntries.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写了一半，应用就跪了</span></span><br><span class="line">    <span class="comment">// If we ended on a truncated line, rebuild the journal before appending to it.</span></span><br><span class="line">    <span class="keyword">if</span> (reader.hasUnterminatedLine()) &#123;</span><br><span class="line">      rebuildJournal();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">          <span class="keyword">new</span> FileOutputStream(journalFile, <span class="keyword">true</span>), Util.US_ASCII));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Util.closeQuietly(reader);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournalLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> firstSpace = line.indexOf(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">if</span> (firstSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> keyBegin = firstSpace + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> secondSpace = line.indexOf(<span class="string">' '</span>, keyBegin);</span><br><span class="line">  <span class="keyword">final</span> String key;</span><br><span class="line">  <span class="keyword">if</span> (secondSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">    key = line.substring(keyBegin);</span><br><span class="line">    <span class="keyword">if</span> (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123;</span><br><span class="line">      <span class="comment">// 每个操作就会记录一个日志信息，当我们删除一个缓存项的时候，添加一个 REMOVE。</span></span><br><span class="line">      <span class="comment">// 既然缓存都已经 remove 掉了，这个 entry 也就就没有存在的必要的了</span></span><br><span class="line">      <span class="comment">// 在 REMOVE 前，一定会有对应的 DIRTY/CLEAN 等，所以此时这个 key 对应的 entry</span></span><br><span class="line">      <span class="comment">// 一定是存在的</span></span><br><span class="line">      lruEntries.remove(key);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    key = line.substring(keyBegin, secondSpace);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 Entry 代表缓存中的一项</span></span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">    lruEntries.put(key, entry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (secondSpace != -<span class="number">1</span> &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</span><br><span class="line">    String[] parts = line.substring(secondSpace + <span class="number">1</span>).split(<span class="string">" "</span>);</span><br><span class="line">    entry.readable = <span class="keyword">true</span>;</span><br><span class="line">    entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">    entry.setLengths(parts);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</span><br><span class="line">    entry.currentEditor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</span><br><span class="line">    <span class="comment">// This work was already done by calling lruEntries.get().</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们再看看 <code>rebuildJournal</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new journal that omits redundant information. This replaces the</span></span><br><span class="line"><span class="comment"> * current journal if it exists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">rebuildJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (journalWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    journalWriter.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Writer writer = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">      <span class="comment">// 注意，这里我们写的是 tmp 文件</span></span><br><span class="line">      <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(journalFileTmp), Util.US_ASCII));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    writer.write(MAGIC);</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(VERSION_1);</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(Integer.toString(appVersion));</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(Integer.toString(valueCount));</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        writer.write(DIRTY + <span class="string">' '</span> + entry.key + <span class="string">'\n'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writer.write(CLEAN + <span class="string">' '</span> + entry.key + entry.getLengths() + <span class="string">'\n'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writer.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (journalFile.exists()) &#123;</span><br><span class="line">    renameTo(journalFile, journalFileBackup, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  renameTo(journalFileTmp, journalFile, <span class="keyword">false</span>);</span><br><span class="line">  journalFileBackup.delete();</span><br><span class="line"></span><br><span class="line">  journalWriter = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">      <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(journalFile, <span class="keyword">true</span>), Util.US_ASCII));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">renameTo</span><span class="params">(File from, File to, <span class="keyword">boolean</span> deleteDestination)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (deleteDestination) &#123;</span><br><span class="line">    deleteIfExists(to);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!from.renameTo(to)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，就是先写一个文件头，然后把已有的 entry 一条一条写进去。</p>
<p>比较有意思的是后面那几个 rename。前面我们说，日志文件是为了在程序崩溃（还有内核崩溃，但这个比较少见）时恢复信息用的。当日志中冗余的行数太多的时候，我们也需要 rebuild 一下。在这里，我们同样需要写文件，万一在 rebuild journal 的时候跪了呢？！</p>
<p>解决办法就是，原来的日志文件不动，我们先把新的日志写到一个 tmp 文件里，等写完再用一个相对清理的 rename 来替换文件。由于 rename 的时候会删除原文件，这就存在一种可能，我们删除了 journal，而 rename tmp to journal 却失败了。此时，日志就丢失了。</p>
<p>所以，在把 tmp rename 为 journal 前，我们又把 journal rename 为 backup。在这种情况下，如果第一个 rename 成功，第二个失败，我们就能够通过这个 backup 来恢复原来的日志（在 <code>DiskLruCache</code> 的构造函数中，我们就检查了 backup 是否存在）。接着，如果第二个 rename 成功了，那么 backup 就没用了，于是删掉它。</p>
<p><code>Entry</code> 的主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Lengths of this entry's files. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Memoized File objects for this entry to avoid char[] allocations. */</span></span><br><span class="line">  File[] cleanFiles;</span><br><span class="line">  File[] dirtyFiles;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** True if this entry has ever been published. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> readable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The ongoing edit or null if this entry is not being edited. */</span></span><br><span class="line">  <span class="keyword">private</span> Editor currentEditor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.lengths = <span class="keyword">new</span> <span class="keyword">long</span>[valueCount];</span><br><span class="line">    cleanFiles = <span class="keyword">new</span> File[valueCount];</span><br><span class="line">    dirtyFiles = <span class="keyword">new</span> File[valueCount];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The names are repetitive so re-use the same builder to avoid allocations.</span></span><br><span class="line">    StringBuilder fileBuilder = <span class="keyword">new</span> StringBuilder(key).append(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">int</span> truncateTo = fileBuilder.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">        fileBuilder.append(i);</span><br><span class="line">        cleanFiles[i] = <span class="keyword">new</span> File(directory, fileBuilder.toString());</span><br><span class="line">        fileBuilder.append(<span class="string">".tmp"</span>);</span><br><span class="line">        dirtyFiles[i] = <span class="keyword">new</span> File(directory, fileBuilder.toString());</span><br><span class="line">        fileBuilder.setLength(truncateTo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，对于 entry 中的每个数据项，都有对应 dirty/clean 两个文件。这个也是为了数据的一致性而存在的，后面我们会看到他们的作用。</p>
<p>读取完日志文件后，<code>DiskLruCache</code> 又调用 <code>processJournal</code> 来处理它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes the initial size and collects garbage as a part of opening the</span></span><br><span class="line"><span class="comment"> * cache. Dirty entries are assumed to be inconsistent and will be deleted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  deleteIfExists(journalFileTmp);</span><br><span class="line">  <span class="keyword">for</span> (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    Entry entry = i.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor == <span class="keyword">null</span>) &#123; <span class="comment">// 这个 entry 处于 CLEAN 状态</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">        <span class="comment">// size 是当前硬盘缓存占用的字节数</span></span><br><span class="line">        size += entry.lengths[t];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// DIRTY，说明上次有人写了一半就跪了。这种情况下，需要删除对应的文件</span></span><br><span class="line">      entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// valueCount 是我们在构造 DiskLruCache 时传递进来的，表示一个 entry 有多少个 value</span></span><br><span class="line">      <span class="comment">// 我们用它来缓存文件，一个 entry 对应一个文件，valueCount == 1</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">        deleteIfExists(entry.getCleanFile(t));</span><br><span class="line">        deleteIfExists(entry.getDirtyFile(t));</span><br><span class="line">      &#125;</span><br><span class="line">      i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，<code>DiskLruCache</code> 就构建完成了。</p>
<h3 id="写文件到缓存"><a href="#写文件到缓存" class="headerlink" title="写文件到缓存"></a>写文件到缓存</h3><p>我们先来回顾一下 <code>DiskLruCacheWrapper</code> 中是怎么写文件的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Writer writer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  DiskLruCache.Editor editor = diskCache.edit(safeKey);</span><br><span class="line">  <span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Had two simultaneous puts for: "</span> + safeKey);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    File file = editor.getFile(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (writer.write(file)) &#123;</span><br><span class="line">      editor.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    editor.abortUnlessCommitted();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上分为 4 步：</p>
<ol>
<li>获取一个 editor</li>
<li>写文件</li>
<li>commit</li>
<li>如果失败了，做一些清理工作</li>
</ol>
<p>下面我们一个个来看。</p>
<ol>
<li>获取一个 editor</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an editor for the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if another</span></span><br><span class="line"><span class="comment"> * edit is in progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> edit(key, ANY_SEQUENCE_NUMBER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Editor <span class="title">edit</span><span class="params">(String key, <span class="keyword">long</span> expectedSequenceNumber)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == <span class="keyword">null</span></span><br><span class="line">      || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Value is stale.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 新建一个缓存</span></span><br><span class="line">    entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">    lruEntries.put(key, entry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Another edit is in progress.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Editor editor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">  entry.currentEditor = editor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush the journal before creating files to prevent file leaks.</span></span><br><span class="line">  journalWriter.append(DIRTY);</span><br><span class="line">  journalWriter.append(<span class="string">' '</span>);</span><br><span class="line">  journalWriter.append(key);</span><br><span class="line">  journalWriter.append(<span class="string">'\n'</span>);</span><br><span class="line">  journalWriter.flush();</span><br><span class="line">  <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里验证了我上面说的，在实际写文件前，先写了一个日志（啊，当然，你也可以说我是先看了代码，才写了上面那段话。如果如果能够做到这个，也是很不错的。学习一个特定的知识点，把它泛化后，你就得到了一个通用的问题解决方案）。</p>
<ol start="2">
<li>写文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = editor.getFile(<span class="number">0</span>);</span><br><span class="line">writer.write(file);</span><br></pre></td></tr></table></figure>

<p>写文件分两步，或者一个 file，然后 write 进去实际的数据。前面我们提到过，<code>valueCount</code> 代表每个缓存项中的数据数，我们只是存一个文件，所以这个 <code>getFile(0)</code> 获取第一个数据项（也是唯一的一个）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">        written[index] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File dirtyFile = entry.getDirtyFile(index);</span><br><span class="line">    <span class="keyword">if</span> (!directory.exists()) &#123;</span><br><span class="line">        directory.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dirtyFile;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们知道，写入的实际上是 dirty file。</p>
<ol start="3">
<li>commit</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Commits this edit so it is visible to readers.  This releases the</span></span><br><span class="line"><span class="comment"> * edit lock so another edit may be started on the same key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// The object using this Editor must catch and handle any errors</span></span><br><span class="line">  <span class="comment">// during the write. If there is an error and they call commit</span></span><br><span class="line">  <span class="comment">// anyway, we will assume whatever they managed to write was valid.</span></span><br><span class="line">  <span class="comment">// Normally they should call abort.</span></span><br><span class="line">  completeEdit(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">  committed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">completeEdit</span><span class="params">(Editor editor, <span class="keyword">boolean</span> success)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Entry entry = editor.entry;</span><br><span class="line">  <span class="keyword">if</span> (entry.currentEditor != editor) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this edit is creating the entry for the first time, every index must have a value.</span></span><br><span class="line">  <span class="keyword">if</span> (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!editor.written[i]) &#123;</span><br><span class="line">        editor.abort();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Newly created entry didn't create value for index "</span> + i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">        editor.abort();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">    File dirty = entry.getDirtyFile(i);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty.exists()) &#123;</span><br><span class="line">        File clean = entry.getCleanFile(i);</span><br><span class="line">        dirty.renameTo(clean);</span><br><span class="line">        <span class="keyword">long</span> oldLength = entry.lengths[i];</span><br><span class="line">        <span class="keyword">long</span> newLength = clean.length();</span><br><span class="line">        entry.lengths[i] = newLength;</span><br><span class="line">        size = size - oldLength + newLength;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      deleteIfExists(dirty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (entry.readable | success) &#123;</span><br><span class="line">    entry.readable = <span class="keyword">true</span>;</span><br><span class="line">    journalWriter.append(CLEAN);</span><br><span class="line">    journalWriter.append(<span class="string">' '</span>);</span><br><span class="line">    journalWriter.append(entry.key);</span><br><span class="line">    journalWriter.append(entry.getLengths());</span><br><span class="line">    journalWriter.append(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      entry.sequenceNumber = nextSequenceNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 写失败，对应的缓存项也不再有效</span></span><br><span class="line">    lruEntries.remove(entry.key);</span><br><span class="line">    journalWriter.append(REMOVE);</span><br><span class="line">    journalWriter.append(<span class="string">' '</span>);</span><br><span class="line">    journalWriter.append(entry.key);</span><br><span class="line">    journalWriter.append(<span class="string">'\n'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  journalWriter.flush();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用的总空间太多，或者冗余的日志太多</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; maxSize || journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;Void&gt; cleanupCallable = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Closed.</span></span><br><span class="line">      &#125;</span><br><span class="line">      trimToSize();</span><br><span class="line">      <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        rebuildJournal();</span><br><span class="line">        redundantOpCount = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (size &gt; maxSize) &#123;</span><br><span class="line">    Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.entrySet().iterator().next();</span><br><span class="line">    remove(toEvict.getKey());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里唯一需要注意的是，我们必须在 rename dirty to clean 成功后，才能写一个 CLEAN 日志。否则，如果我们写入 CLEAN 成功但 rename 却失败了，就会导致客户读取到错误的缓存数据。</p>
<ol start="4">
<li>如果失败了，做一些清理工作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor.abortUnlessCommitted();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Aborts this edit. This releases the edit lock so another edit may be</span></span><br><span class="line"><span class="comment"> * started on the same key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 传入 false 会导致对应的 entry 被删除</span></span><br><span class="line">  completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abortUnlessCommitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!committed) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      abort();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们再看读文件部分。</p>
<h3 id="从缓存中读取文件"><a href="#从缓存中读取文件" class="headerlink" title="从缓存中读取文件"></a>从缓存中读取文件</h3><p>还是一样，我们先看看 <code>DiskLruCacheWrapper</code> 中对 <code>DiskLruCache</code> 的调用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> DiskLruCache.Value value = getDiskCache().get(safeKey);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = value.getFile(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot of the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if it doesn't</span></span><br><span class="line"><span class="comment"> * exist is not currently readable. If a value is returned, it is moved to</span></span><br><span class="line"><span class="comment"> * the head of the LRU queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Value <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (File file : entry.cleanFiles) &#123;</span><br><span class="line">      <span class="comment">// A file must have been deleted manually!</span></span><br><span class="line">      <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  journalWriter.append(READ);</span><br><span class="line">  journalWriter.append(<span class="string">' '</span>);</span><br><span class="line">  journalWriter.append(key);</span><br><span class="line">  journalWriter.append(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Value(key, entry.sequenceNumber, entry.cleanFiles, entry.lengths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较简单，读者自己看一看就好。</p>
<h3 id="删除一个缓存项"><a href="#删除一个缓存项" class="headerlink" title="删除一个缓存项"></a>删除一个缓存项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Drops the entry for &#123;<span class="doctag">@code</span> key&#125; if it exists and can be removed. Entries</span></span><br><span class="line"><span class="comment"> * actively being edited cannot be removed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if an entry was removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span> || entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">    File file = entry.getCleanFile(i);</span><br><span class="line">    <span class="keyword">if</span> (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"failed to delete "</span> + file);</span><br><span class="line">    &#125;</span><br><span class="line">    size -= entry.lengths[i];</span><br><span class="line">    entry.lengths[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  journalWriter.append(REMOVE);</span><br><span class="line">  journalWriter.append(<span class="string">' '</span>);</span><br><span class="line">  journalWriter.append(key);</span><br><span class="line">  journalWriter.append(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">  lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和前面其他文件况类似，这里我们需要先删除文件，然后再写日志。这样一来，即便文件删除成功而写日志失败，只要在下次读取时检测文件是否存在就可以了。如果反过来写日志成功但删除文件失败，则会导致缓存文件残留下来。</p>
<h3 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes the cache and deletes all of its stored values. This will delete</span></span><br><span class="line"><span class="comment"> * all files in the cache directory including files that weren't created by</span></span><br><span class="line"><span class="comment"> * the cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  close();</span><br><span class="line">  <span class="comment">// 所有的缓存文件都放在 directory 里，整个目录删掉就“清空”了</span></span><br><span class="line">  Util.deleteContents(directory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Closes this cache. Stored values will remain on the filesystem. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// Already closed.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Entry entry : <span class="keyword">new</span> ArrayList&lt;Entry&gt;(lruEntries.values())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      entry.currentEditor.abort();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  trimToSize();</span><br><span class="line">  journalWriter.close();</span><br><span class="line">  journalWriter = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不容易啊，到这里，<code>DiskCache</code> 就算是讲完了。</p>
<hr>
<h2 id="2018-06-20-补几个面试遇到的问题"><a href="#2018-06-20-补几个面试遇到的问题" class="headerlink" title="2018.06.20 补几个面试遇到的问题"></a>2018.06.20 补几个面试遇到的问题</h2><h3 id="日志文件的作用"><a href="#日志文件的作用" class="headerlink" title="日志文件的作用"></a>日志文件的作用</h3><ol>
<li>应用崩溃后回收损坏的文件</li>
<li>日志文件记录了访问的顺序，通过日志文件，我们可以重新建立 LRU</li>
</ol>
<h3 id="考虑日志文件对回收损坏文件的作用，不用日志文件能够解决吗？"><a href="#考虑日志文件对回收损坏文件的作用，不用日志文件能够解决吗？" class="headerlink" title="考虑日志文件对回收损坏文件的作用，不用日志文件能够解决吗？"></a>考虑日志文件对回收损坏文件的作用，不用日志文件能够解决吗？</h3><p>不能，因为我们没有办法知道一个文件是否是有效文件。</p>
</div><div class="tags"><a href="/tags/Glide/">Glide</a></div><div class="post-nav"><a class="pre" href="/2018/06/20/glide-mem-cache1/">Glide 源码分析(2) - 内存缓存和数组缓存</a><a class="next" href="/2018/05/25/logd-reading/">Android log 机制 - 读取 logd 中的 log 数据</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://jekton.github.io/2018/06/08/glide-disk-cache/';
    this.page.identifier = '2018/06/08/glide-disk-cache/';
    this.page.title = 'Glide 源码分析(1) - DiskCache 详解';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jekton-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jekton-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jekton-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">31</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dart/">Dart</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android-arch/" style="font-size: 15px;">Android arch</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/Coroutine/" style="font-size: 15px;">Coroutine</a> <a href="/tags/parallel-programming/" style="font-size: 15px;">parallel-programming</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/openjdk/" style="font-size: 15px;">openjdk</a> <a href="/tags/Android-source/" style="font-size: 15px;">Android source</a> <a href="/tags/ProcessLifecycleOwner/" style="font-size: 15px;">ProcessLifecycleOwner</a> <a href="/tags/Dart/" style="font-size: 15px;">Dart</a> <a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/logd/" style="font-size: 15px;">logd</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/native-crash/" style="font-size: 15px;">native-crash</a> <a href="/tags/Glide/" style="font-size: 15px;">Glide</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/kotlin-coroutine-dispatcher/">Kotlin 协程到底运行在哪个线程里</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/28/kotlin-coroutine-context/">kotlin 协程上下文那点事</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/21/android-jetpack-ProcessLifecycleOwner/">Android 源码秘密（1）—— ProcessLifecycleOwner</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/28/android-fragment-pitfall/">Fragment 使用陷阱</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/08/android-scrollview-impl/">ScrollView 实现指北</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/26/java-multi-singleton/">如何使用 Java 和 double-check 实现支持多实例的单例</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/native-crash-catching/">Android native 崩溃信息捕获实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/android9-lmk-lmkd/">Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/android9-logd-init/">Android P 源码分析 4 - logd 的初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/19/android9-sp/">Android P 源码分析 3 - SharedPreferences 源码分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jekton-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">程序员虾饺.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>