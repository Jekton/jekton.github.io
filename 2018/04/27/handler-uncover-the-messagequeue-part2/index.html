<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MessageQueue 实现详解（下）- C++ 世界对 Message 的支持 | Jekton</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MessageQueue 实现详解（下）- C++ 世界对 Message 的支持</h1><a id="logo" href="/.">Jekton</a><p class="description">Keep on Learning, Keep on Thinking</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MessageQueue 实现详解（下）- C++ 世界对 Message 的支持</h1><div class="post-meta">Apr 27, 2018<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/04/27/handler-uncover-the-messagequeue-part2/" href="/2018/04/27/handler-uncover-the-messagequeue-part2/#disqus_thread"></a><div class="post-content"><p>除了 Java 层，<code>Handler</code> 框架在 C++ 层也有支持。本篇，我们就来看看 C++ 部分。</p>
<a id="more"></a>
<h2 id="Looper-C-的创建"><a href="#Looper-C-的创建" class="headerlink" title="Looper(C++) 的创建"></a>Looper<sup>(C++)</sup> 的创建</h2><p>在<a href="/2018/04/24/handler-uncover-the-messagequeue-part1/">上一篇</a>中我们已经看到了 Looper 的初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">        mPollEnv(<span class="literal">NULL</span>), mPollObj(<span class="literal">NULL</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libutils/Looper.cpp</span></span><br><span class="line">sp&lt;Looper&gt; Looper::getForThread() &#123;</span><br><span class="line">    <span class="keyword">int</span> result = pthread_once(&amp; gTLSOnce, initTLSKey);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"pthread_once failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Looper*)pthread_getspecific(gTLSKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libutils/Looper.cpp</span></span><br><span class="line"><span class="keyword">void</span> Looper::setForThread(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) &#123;</span><br><span class="line">    sp&lt;Looper&gt; old = getForThread(); <span class="comment">// also has side-effect of initializing TLS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        looper-&gt;incStrong((<span class="keyword">void</span>*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_setspecific(gTLSKey, looper.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old-&gt;decStrong((<span class="keyword">void</span>*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和 Java 层的 Looper 一样，C++ 中的 Looper 也是一个 thread specific 对象。首先，调用静态方法 <code>Looper::getForThread()</code> 尝试获取一个 <code>Looper</code><sup>(C++)</sup>，如果 <code>mLooper == null</code>，说明这个线程还没有初始化 <code>Looper</code>，需要创建一个新的实例。</p>
<p>我们在 Java 层创建 <code>Looper</code><sup>(Java)</sup> 时已经检查过是否已经初始化，<code>NativeMessageQueue</code> 这里之所以再检查一遍，是因为 native 层也可以初始化 <code>Looper</code><sup>(C++)</sup>。和 Java 层一样，也是通过一个 <code>prepare</code> 函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//system/core/libutils/Looper.cpp</span></span><br><span class="line">sp&lt;Looper&gt; Looper::prepare(<span class="keyword">int</span> opts) &#123;</span><br><span class="line">    <span class="keyword">bool</span> allowNonCallbacks = opts &amp; PREPARE_ALLOW_NON_CALLBACKS;</span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        looper = <span class="keyword">new</span> Looper(allowNonCallbacks);</span><br><span class="line">        Looper::setForThread(looper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (looper-&gt;getAllowNonCallbacks() != allowNonCallbacks) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Looper already prepared for this thread with a different value for the "</span></span><br><span class="line">                <span class="string">"LOOPER_PREPARE_ALLOW_NON_CALLBACKS option."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> looper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Looper</code><sup>(C++)</sup> 的初始化到这里就讲完了，下面我们看 native 层的 <code>Message</code> 是如何入队的。</p>
<h2 id="发送一个-native-层的-Message-C"><a href="#发送一个-native-层的-Message-C" class="headerlink" title="发送一个 native 层的 Message(C++)"></a>发送一个 native 层的 Message<sup>(C++)</sup></h2><p>C++ 世界里的 <code>Message</code> 相对 Java 世界的兄弟来说，会更简单一些：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/include/utils/Looper.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Message</span> &#123;</span></span><br><span class="line">    Message() : what(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    Message(<span class="keyword">int</span> w) : what(w) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The message type. (interpretation is left up to the handler) */</span></span><br><span class="line">    <span class="keyword">int</span> what;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>同样，也有一个 Handler：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/include/utils/Looper.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MessageHandler();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">const</span> Message&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>C++ 层的 Handler 跟 Java 层的比起来，同样更加简单。它只是负责处理 <code>Message</code><sup>C++</sup>，而不再负责把 Message 插入队列。Message 的入队由 Looper 直接处理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::sendMessageAtTime(<span class="keyword">nsecs_t</span> uptime, <span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler,</span><br><span class="line">        <span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> messageCount = mMessageEnvelopes.size();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">MessageEnvelope <span class="title">messageEnvelope</span><span class="params">(uptime, handler, message)</span></span>;</span><br><span class="line">        mMessageEnvelopes.insertAt(messageEnvelope, i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optimization: If the Looper is currently sending a message, then we can skip</span></span><br><span class="line">        <span class="comment">// the call to wake() because the next thing the Looper will do after processing</span></span><br><span class="line">        <span class="comment">// messages is to decide when the next wakeup time should be.  In fact, it does</span></span><br><span class="line">        <span class="comment">// not even matter whether this code is running on the Looper thread.</span></span><br><span class="line">        <span class="keyword">if</span> (mSendingMessage) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake the poll loop only when we enqueue a new message at the head.</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Looper 也有 <code>sendMessage, sendMessageDelayed</code> 成员函数，但最终都是由 <code>sendMessageAtTime</code> 处理的。</p>
<p>和 Java 层对 Message 的处理类似，C++ 中也是按 <code>Message</code> 的触发时间排序。不同的是，C++ 世界的 Message 还被封装到了一个 <code>MessageEnvelope</code> 对象里。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/include/utils/Looper.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MessageEnvelope</span> &#123;</span></span><br><span class="line">    MessageEnvelope() : uptime(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    MessageEnvelope(<span class="keyword">nsecs_t</span> u, <span class="keyword">const</span> sp&lt;MessageHandler&gt; h,</span><br><span class="line">            <span class="keyword">const</span> Message&amp; m) : uptime(u), handler(h), message(m) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> uptime;</span><br><span class="line">    sp&lt;MessageHandler&gt; handler;</span><br><span class="line">    Message message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="native-层-Message-C-的处理"><a href="#native-层-Message-C-的处理" class="headerlink" title="native 层 Message(C++) 的处理"></a>native 层 Message<sup>(C++)</sup> 的处理</h2><p>我们知道，Looper<sup>(Java)</sup> 会在一个无线循环中调用 <code>MessageQueue.next()</code>，<code>next()</code> 则调用 <code>nativePollOnce</code>，然后是 <code>pollOnce</code>，最终到达 <code>pollInner</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/Looper.cpp</span></span><br><span class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// stuff of mResponses</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libutils/Looper.cpp</span></span><br><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are about to idle.</span></span><br><span class="line">    mPolling = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No longer idling.</span></span><br><span class="line">    mPolling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire lock.</span></span><br><span class="line">    mLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                awoken();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake event fd."</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke pending message callbacks.</span></span><br><span class="line">    mNextMessageUptime = LLONG_MAX;</span><br><span class="line">    <span class="keyword">while</span> (mMessageEnvelopes.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">// Remove the envelope from the list.</span></span><br><span class="line">            <span class="comment">// We keep a strong reference to the handler until the call to handleMessage</span></span><br><span class="line">            <span class="comment">// finishes.  Then we drop it so that the handler can be deleted *before*</span></span><br><span class="line">            <span class="comment">// we reacquire our lock.</span></span><br><span class="line">            &#123; <span class="comment">// obtain handler</span></span><br><span class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">                Message message = messageEnvelope.message;</span><br><span class="line">                mMessageEnvelopes.removeAt(<span class="number">0</span>);</span><br><span class="line">                mSendingMessage = <span class="literal">true</span>;</span><br><span class="line">                mLock.unlock();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行外部代码时不持有锁</span></span><br><span class="line">                handler-&gt;handleMessage(message);</span><br><span class="line">            &#125; <span class="comment">// release handler</span></span><br><span class="line"></span><br><span class="line">            mLock.lock();</span><br><span class="line">            mSendingMessage = <span class="literal">false</span>;</span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The last message left at the head of the queue determines the next wakeup time.</span></span><br><span class="line">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release lock.</span></span><br><span class="line">    mLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在 native 层有 <code>Message</code> 可以执行时，会先执行 native 层的消息，<code>pollOnce</code> 返回后，才会执行 Java 层的消息。</p>
<p>值得注意的是，在调用 <code>handler-&gt;handleMessage(message)</code> 时我们不持有锁。在实际工作中，执行第三方代码是，我们应该总是尽量不持有锁。因为我们不知道接下来将要运行的代码会做什么（也许他又会获取哪个锁，或者直接进入休眠）。</p>
<h2 id="Looper-C-的销毁"><a href="#Looper-C-的销毁" class="headerlink" title="Looper(C++) 的销毁"></a>Looper<sup>(C++)</sup> 的销毁</h2><p>我们知道，Java 层执行 <code>Looper.quit()</code> 后，最终会执行 <code>Message.dispose()</code> 释放一下 native 层的资源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/MessageQueue.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPtr != <span class="number">0</span>) &#123;</span><br><span class="line">        nativeDestroy(mPtr);</span><br><span class="line">        mPtr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeDestroy</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;decStrong(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>nativeMessageQueue-&gt;decStrong(env)</code> 后，<code>nativeMessageQueue</code> 的强引用计数降为 0，对象被销毁。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class="line">NativeMessageQueue::~NativeMessageQueue() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_os_MessageQueue.cpp</span></span><br><span class="line">MessageQueue::~MessageQueue() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>NativeMessageQueue</code> 继承了 <code>MessageQueue</code>，但是，两者的析构函数都没有做什么。</p>
<p>接下来，我们注意到 <code>mLooper</code> 是一个 <code>sp</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    sp&lt;Looper&gt; mLooper;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，<code>MessageQueue</code> 被销毁后，<code>mLooper</code> 也会自动销毁。如果 <code>mLooper</code> 销毁后强引用计数为 0，那么，<code>Looper</code><sup>(C++)</sup> 对象也就销毁了。</p>
<p>遗憾的是，<code>Looper</code> 对象并不是在这里销毁的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/Looper.cpp</span></span><br><span class="line"><span class="keyword">void</span> Looper::setForThread(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) &#123;</span><br><span class="line">    sp&lt;Looper&gt; old = getForThread(); <span class="comment">// also has side-effect of initializing TLS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        looper-&gt;incStrong((<span class="keyword">void</span>*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_setspecific(gTLSKey, looper.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old-&gt;decStrong((<span class="keyword">void</span>*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在调用 <code>setForThread</code> 的时候，强引用计数被加 1。如此一来，<code>mLooper</code> 成员变量销毁后，<code>Looper</code> 对象并不会销毁。</p>
<p>答案其实隐藏在 <code>gTLSKey</code> 对象中，pthread 在构造 TLS 对象的时候，可以设置一个 destructor，在线程对出的时候，pthread 会自动调用这个析构函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/Looper.cpp</span></span><br><span class="line">sp&lt;Looper&gt; Looper::getForThread() &#123;</span><br><span class="line">    <span class="keyword">int</span> result = pthread_once(&amp; gTLSOnce, initTLSKey);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"pthread_once failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Looper*)pthread_getspecific(gTLSKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libutils/Looper.cpp</span></span><br><span class="line"><span class="keyword">void</span> Looper::initTLSKey() &#123;</span><br><span class="line">    <span class="keyword">int</span> result = pthread_key_create(&amp; gTLSKey, threadDestructor);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not allocate TLS key."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>getForThread()</code> 使用 <code>pthread_once</code> 保证 <code>initTLSKey()</code> 只会被执行一次（即使多个线程同时、多次调用它）。在 <code>initTLSKey()</code> 中创建 key 时，传递了 <code>threadDestructor</code> 函数作为对象的析构函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/Looper.cpp</span></span><br><span class="line"><span class="keyword">void</span> Looper::threadDestructor(<span class="keyword">void</span> *st) &#123;</span><br><span class="line">    Looper* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;Looper*&gt;(st);</span><br><span class="line">    <span class="keyword">if</span> (self != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        self-&gt;decStrong((<span class="keyword">void</span>*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当线程退出后，<code>threadDestructor</code> 把 Looper 对象的强引用计数减 1 后得到 0，进而销毁 Looper 对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/Looper.cpp</span></span><br><span class="line">Looper::~Looper() &#123;</span><br><span class="line">    close(mWakeEventFd);</span><br><span class="line">    mWakeEventFd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(mEpollFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br>注：<code>Looper</code><sup>(C++)</sup>还可以添加文件描述符，对这部分感兴趣的读者，可以自行阅读源码。</p>
</div><div class="tags"><a href="/tags/Android-source/">Android source</a><a href="/tags/Handler/">Handler</a></div><div class="post-nav"><a class="pre" href="/2018/05/11/logd-overview/">Android log 机制 - logd 总览</a><a class="next" href="/2018/04/24/handler-uncover-the-messagequeue-part1/">MessageQueue 实现详解（上）- Java 世界中的 Message</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://jekton.github.io/2018/04/27/handler-uncover-the-messagequeue-part2/';
    this.page.identifier = '2018/04/27/handler-uncover-the-messagequeue-part2/';
    this.page.title = 'MessageQueue 实现详解（下）- C++ 世界对 Message 的支持';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jekton-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jekton-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jekton-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Android-source/" style="font-size: 15px;">Android source</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/openjdk/" style="font-size: 15px;">openjdk</a> <a href="/tags/way-to-JVM/" style="font-size: 15px;">way to JVM</a> <a href="/tags/Android-arch/" style="font-size: 15px;">Android arch</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/logd/" style="font-size: 15px;">logd</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/Glide/" style="font-size: 15px;">Glide</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/flutter-first-app/">Flutter 开发（1）- 开发框架、流程、编译打包、调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/way-to-JVM-1/">JVM 之路（1）- cmake 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/way-to-JVM-0/">JVM 之路（0）- 我将去往何方？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/25/jdk-FutureTask/">JDK 源码分析（1）- FutureTask</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/java-translation-jep-193-Variable-Handles/">翻译 - JEP 193：Variable Handles</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/openjdk-build/">个人记录帖 - 编译 OpenJDK 10</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/14/android-arch-LiveData/">Android arch components 源码分析（3）—— LiveData</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/06/android-arch-lifecycle/">Android arch components 源码分析（2）—— Lifecycle</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/30/android-arch-ViewModel/">Android arch components 源码分析（1）—— ViewModel</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/23/socket-intro/">TCP/IP、Socket 和协议设计</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jekton-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Jekton.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>