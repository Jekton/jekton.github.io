<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>binder 情景分析 - service 的注册（中） | Jekton</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">binder 情景分析 - service 的注册（中）</h1><a id="logo" href="/.">Jekton</a><p class="description">Keep on Learning, Keep on Thinking</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">binder 情景分析 - service 的注册（中）</h1><div class="post-meta">Apr 13, 2018<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/04/13/binder-service-registration-part2/" href="/2018/04/13/binder-service-registration-part2/#disqus_thread"></a><div class="post-content"><p>本篇是 service 注册的第二篇，主要描述应用层、binder驱动对写入数据的处理。</p>
<a id="more"></a>
<h2 id="向-binder-写入数据"><a href="#向-binder-写入数据" class="headerlink" title="向 binder 写入数据"></a>向 binder 写入数据</h2><p>注册服务将调用 <code>BpServiceManager::addService()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IServiceManager.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">bool</span> allowIsolated)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">    data.writeString16(name);</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过 <code>parcel.writeStrongBinder()</code> 写入 <code>IBinder</code> 对象。由于是注册服务，这里的 <code>IBinder</code> 是一个 <code>BBinder</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/Parcel.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/binder/Parcel.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; <span class="comment">/*proc*/</span>,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    IBinder* local = binder-&gt;localBinder();</span><br><span class="line"></span><br><span class="line">    obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">    obj.binder = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local-&gt;getWeakRefs());</span><br><span class="line">    obj.cookie = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/binder/Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> status_t <span class="title">finish_flatten_binder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*binder*/</span>, <span class="keyword">const</span> flat_binder_object&amp; flat, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out-&gt;writeObject(flat, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们提到，这里传递进来的 <code>IBinder</code> 实际上是一个 <code>BBinder</code>，所以 <code>localBinder()</code> 所指向的是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/Binder.cpp</span></span><br><span class="line">BBinder* BBinder::localBinder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是，向 <code>flat_binder_object</code> 写入的，是 <code>BBinder</code> 的地址。也是通过这个地址，在 binder 驱动收到数据后，能够把数据回送给 <code>BBinder</code>。关于数据的接收，我们以后再讨论。</p>
<p>另一个需要特别注意的是，<code>type</code> 为 <code>BINDER_TYPE_BINDER</code>。</p>
<p>把数据都写入 <code>Parcel</code> 后，执行 <code>remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</code>。</p>
<p>其中，<code>remote()</code> 返回的是前面我们拿到的指向 context manager 的 <code>BpBinder</code>，前面我们把它存在了 <code>BpRefBase::mRemote</code> 里。</p>
<p>随后，<code>BpBinder</code> 又通过 <code>IPCThreadState</code> 执行实际的写入数据操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/BpBinder.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>调用 <code>writeTransactionData()</code> 写数据</li>
<li>如果出错，直接返回</li>
<li>调用不同的 <code>waitForResponse()</code> 写入并读取返回的数据</li>
</ol>
<p>下面我们先看看 <code>writeTransactionData()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>;</span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    tr.data_size = data.ipcDataSize();</span><br><span class="line">    tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">    tr.offsets_size = data.ipcObjectsCount() * <span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">    tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>几个值得注意的地方：</p>
<ol>
<li><code>cmd</code> 为 <code>BC_TRANSACTION</code>。</li>
<li><code>tr.data.ptr.buffer</code> 指向实际的普通数据</li>
<li><code>tr.data.ptr.offsets</code> 指向 objects 的偏移数组。也就是前面我们通过 <code>writeObject(flat, false)</code> 写入的 <code>flat_binder_object</code>。</li>
<li><code>mOut</code> 同样是一个 <code>Parcel</code>，我们将 <code>cmd</code> 和所构造的 <code>binder_transaction_data</code> 放在了这个 <code>mOut</code> 里面。比较容易令人迷惑的是，虽然函数名叫 <code>writeTransactionData</code>，实际上只是把数据写入了 <code>mOut</code> 里（还没有写入 binder 驱动）。</li>
</ol>
<p>写入数据后如下图所示：<br><img src="/2018/04/13/binder-service-registration-part2/IPCThreadState__writeTransactionData.png" alt="IPCThreadState__writeTransactionData"></p>
<p><code>waitForResponse()</code> 的第二个参数带有默认实参，所有上面的三个调用，<code>acquireResult</code> 都是 <code>NULL</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/include/binder/IPCThreadState.h</span></span><br><span class="line"><span class="keyword">status_t</span> waitForResponse(Parcel *reply,</span><br><span class="line">                         <span class="keyword">status_t</span> *acquireResult=<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    err=talkWithDriver();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>waitForResponse()</code> 向 binder 驱动写入数据，并读取返回值。关于返回值的处理，不是我们这里关心的东西，就直接略过了。感兴趣的读者可以自行查阅源码。函数中最关键的是 <code>talkWithDriver()</code>，正是它执行了读写工作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/include/uapi/linux/android/binder.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>     write_size;     <span class="comment">// bytes to write</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>     write_consumed; <span class="comment">// bytes consumed by driver</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>  write_buffer;</span><br><span class="line">    <span class="keyword">binder_size_t</span>     read_size;      <span class="comment">// bytes to read</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>     read_consumed;  <span class="comment">// bytes consumed by driver</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>  read_buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>struct binder_write_read</code> 作为一个媒介，在写入数据的同时，binder 驱动也通过它向应用返回数据。<code>bwr.write_buffer</code> 就指向 <code>Parcel mOut</code> 里的数据。<code>Parcel mIn</code> 用于读取数据。</p>
<p>数据的写入由 <code>ioctl</code> 完成，<code>command</code> 为 <code>BINDER_WRITE_READ</code>。</p>
<p>此时各个数据的关系如下图所示。</p>
<p><img src="/2018/04/13/binder-service-registration-part2/binder_write_read.png" alt="binder_write_read"></p>
<p><br></p>
<h2 id="传递数据给-context-manager"><a href="#传递数据给-context-manager" class="headerlink" title="传递数据给 context manager"></a>传递数据给 context manager</h2><p>我们知道，调用 <code>ioctl</code>，最后是由 binder 驱动的 <code>binder_ioctl()</code> 完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line"></span><br><span class="line">    copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr));</span><br><span class="line">    <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = binder_thread_write(proc, thread,</span><br><span class="line">                                  bwr.write_buffer,</span><br><span class="line">                                  bwr.write_size,</span><br><span class="line">                                  &amp;bwr.write_consumed);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">                                 bwr.read_size,</span><br><span class="line">                                 &amp;bwr.read_consumed,</span><br><span class="line">                                 filp-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们调用 <code>ioctl</code> 传递进来的 <code>struct binder_write_read</code> 实际上是处于用户空间的。这里用 <code>copy_from_user()</code> 将用户空间的数据拷贝到内核。同样的，修改了 <code>bwr</code> 后，又通过 <code>copy_to_user()</code> 将结果拷贝回用户空间。</p>
<p>下面我们看看 <code>binder_thread_write</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">binder_size_t</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> = <span class="title">proc</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user *buffer = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr,</span><br><span class="line">                               cmd == BC_REPLY, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        *consumed = ptr - buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面我们说，<code>IPCThreadState::transact()</code> 先是把数据写到 <code>mOut</code> 里，然后才把 <code>mOut</code> 的数据写到 binder 驱动。所以一次写入可能会有多个请求，这里使用 <code>while</code> 每个循环处理一个。</p>
<p>现在，我们最好再看一次上面画的图：<br><img src="/2018/04/13/binder-service-registration-part2/binder_write_read.png" alt="binder_write_read"></p>
<p>在 <code>binder_ioctl_write_read()</code> 我们第一次调用 <code>copy_from_user()</code>，拷贝的是 <code>binder_write_read</code>。<code>bwr.write_buffer</code> 指向的是 <code>IPCThreadState::mOut</code> 中的数据，所以这里再一次调用 <code>copy_from_user()</code>，可以读到一个 transaction 的 <code>cmd</code>（<code>cmd</code>放在头部）。</p>
<p>接下来，我们再次调用 <code>copy_from_user()</code> 把 <code>binder_transaction_data</code> 也拷贝到内核。然后把 <code>binder_transaction_data</code> 交给 <code>binder_transaction()</code> 处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_node = context-&gt;binder_context_mgr_node;</span><br><span class="line">    &#125;</span><br><span class="line">    target_proc = target_node-&gt;proc;</span><br><span class="line"></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sender_euid = task_euid(proc-&gt;tsk);</span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    t-&gt;buffer = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size,</span><br><span class="line">          tr-&gt;offsets_size, extra_buffers_size,</span><br><span class="line">          !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line"></span><br><span class="line">    off_start = (<span class="keyword">binder_size_t</span> *)(t-&gt;buffer-&gt;data +</span><br><span class="line">          ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    offp = off_start;</span><br><span class="line"></span><br><span class="line">    copy_from_user(t-&gt;buffer-&gt;data, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">                   tr-&gt;data.ptr.buffer, tr-&gt;data_size);</span><br><span class="line">    copy_from_user(offp, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">                   tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先看 <code>binder_transaction()</code> 是前半部分。</p>
<ol>
<li>分配了两个对象 <code>binder_transaction</code> 和 <code>binder_work</code>。<code>binder_work</code> 后面我们就会看到它的作用，这里先忽略。</li>
<li>调用 <code>binder_alloc_new_buf</code> 分配了一块缓存。这里分配的缓存是 context manager 的调用 <code>mmap</code> 时候所创建的。</li>
<li>拷贝 <code>Parcel</code> 的数据</li>
<li>拷贝 <code>Parcel</code> 的对象的偏移数组</li>
</ol>
<p>我们知道，内核的页和用户空间的页同时执行 <code>mmap</code> 所分配的缓存。所以这里虽然是拷贝到了内核，context manager 也能够直接读取这里拷贝的到 <code>Parcel</code> 的数据。也就是说，从一个进程到另一个进程，数据只拷贝了一次。这就是 binder 高效的原因。</p>
<p>读取到数据后，开始循环处理 <code>Parcel</code> 里所有的对象：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)off_start + tr-&gt;offsets_size;</span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span> *<span class="title">hdr</span>;</span></span><br><span class="line"></span><br><span class="line">        hdr = (struct binder_object_header *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        <span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">            fp = to_flat_binder_object(hdr);</span><br><span class="line">            ret = binder_translate_binder(fp, t, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不知道你还记不记得，前面把 <code>BBinder</code> 写入 <code>Parcel</code> 时，我们设置 <code>type</code> 为 <code>BINDER_TYPE_BINDER</code>。</p>
<p>下面继续处理 <code>flat_binder_object</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_translate_binder</span><span class="params">(struct flat_binder_object *fp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        node = binder_new_node(proc, fp);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">                fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">                &amp;thread-&gt;todo, &amp;rdata);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_BINDER)</span><br><span class="line">        <span class="comment">// XXX NOTICE!!</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">    fp-&gt;binder = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;handle = rdata.desc;</span><br><span class="line">    fp-&gt;cookie = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    binder_put_node(node);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里发生了一件非常关键的事：我们把 <code>flat_binder_object</code> 的类型修改为 <code>BINDER_TYPE_HANDLE</code> 了！</strong> 所以，当 context manager 从 <code>Parcel</code> 里面读取 <code>IBinder</code> 的时候，拿到的将会是 <code>BpBinder</code>（而不是原来的 <code>BBinder</code>）。这一点很重要，因为 context manager 跟我们的服务运行在不同的进程中，所以 context manager 理应持有 <code>BpBinder</code>。</p>
<p>服务向 context manager 注册的时候，是第一次传递 <code>IBinder</code>，所以这里的 <code>binder_get_node()</code> 会返回 <code>NULL</code>。接着便会为服务创建一个 <code>binder_node</code>。</p>
<p><code>binder_proc.nodes</code> 是一个 <code>struct rb_node</code>。它是 Linux 内核实现的红黑树数据结构。<code>binder_get_node</code> 尝试获取一个 <code>binder_node</code>，如果找不到，就会新建一个，然后插入 <code>binder_proc.nodes</code> 这棵红黑树中。这里插入的是调用进程的 <code>binder_proc</code>。</p>
<p><code>binder_inc_ref_for_node()</code> 则生成一个 <code>struct binder_ref</code>。他同时会插入 <code>binder_proc.refs_by_desc</code> 和 <code>binder_proc.refs_by_node</code>。<code>binder_ref</code> 可以看成 <code>binder_node</code> 的指针。只要持有 <code>binder_ref</code>，就可以拿到对应的 <code>binder_node</code>。（注意，函数的第一个参数是 <code>target_proc</code>，<code>binder_ref</code> 插入的是 context manager 的 <code>binder_proc</code>。</p>
<p>当其他进程向 context manager 查询服务时，binder 驱动就会为它生成一个 <code>binder_ref</code>，它指向对应服务的 <code>binder_node</code>。当然，真正的 <code>binder_node</code> 保存在了所属的 <code>binder_proc</code> 里。一个服务永远只对应一个 <code>binder_node</code>，<code>binder_ref</code> 却可以有多个。</p>
<p>我们下面看 <code>binder_transaction</code> 的最后一部分：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    binder_enqueue_work(proc, tcomplete, &amp;thread-&gt;todo);</span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;target_thread-&gt;todo);</span><br><span class="line">        wake_up_interruptible_sync(&amp;target_thread-&gt;wait);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们将上面创建的 <code>struct binder_work *tcomplete</code> 放入调用线程（也就是要注册服务的那个线程）的工作队列 <code>thread-&gt;todo</code> 中。<code>struct binder_work *t</code> 则放入 context manager 的任务队列，然后唤醒 context manager。context manager 醒来后，就会取出工作队列中的 <code>binder_work</code> 进行处理（注意，这里会运行在 context manager 的 binder 线程中。</p>
<p>在 <code>binder_ioctl_write_read()</code> 中，共有两部分，write 我们已经讲完了；read 部分等到服务在 context manager 注册完成后，再进行讲解。这里的 <code>tcomplete</code> 任务也会在 read 部分得到执行。</p>
<p>最后总结一下数据写入操作的函数调用流程：</p>
<p><img src="/2018/04/13/binder-service-registration-part2/binder_work_flow_write_data.png" alt="binder_work_flow_write_data"></p>
</div><div class="tags"><a href="/tags/Android-source/">Android source</a><a href="/tags/Binder/">Binder</a></div><div class="post-nav"><a class="pre" href="/2018/04/14/binder-service-registration-part3/">binder 情景分析 - service 的注册（下）</a><a class="next" href="/2018/04/12/binder-service-registration-part1/">binder 情景分析 - service 的注册（上）</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://jekton.github.io/2018/04/13/binder-service-registration-part2/';
    this.page.identifier = '2018/04/13/binder-service-registration-part2/';
    this.page.title = 'binder 情景分析 - service 的注册（中）';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jekton-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jekton-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jekton-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dart/">Dart</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Dart/" style="font-size: 15px;">Dart</a> <a href="/tags/Android-source/" style="font-size: 15px;">Android source</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/openjdk/" style="font-size: 15px;">openjdk</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Android-arch/" style="font-size: 15px;">Android arch</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/logd/" style="font-size: 15px;">logd</a> <a href="/tags/parallel-programming/" style="font-size: 15px;">parallel-programming</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/Glide/" style="font-size: 15px;">Glide</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/linux-wait-event/">Java 程序员眼里的 Linux 内核 —— wait_event 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/linux-page-table-setup/">Linux 内核页表的创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/note-x86-provisional-kernel-page-table-setup/">《深入理解 LINUX 内核》读书笔记 - 临时内核页表</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/flutter-plugin-dev/">Flutter 开发（5）- 插件的使用、开发和发布</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/dart-tutorial/">Dart 语言入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/flutter-io-basic/">Flutter 开发（4）- 文件、存储和网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/29/flutter-ux-basic/">Flutter 开发（3）- 交互、动画、手势和事件处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/flutter-ui-basic/">Flutter 开发（2）- UI控件和布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/flutter-first-app/">Flutter 开发（1）- 开发框架、流程、编译打包、调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/25/jdk-FutureTask/">JDK 源码分析（1）- FutureTask</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jekton-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Jekton.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>