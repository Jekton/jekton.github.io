<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>binder 情景分析 - 为什么注册后的 BBinder 不会被意外释放？（下）—— binder 生命周期管理机制概述 | 程序员虾饺</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">binder 情景分析 - 为什么注册后的 BBinder 不会被意外释放？（下）—— binder 生命周期管理机制概述</h1><a id="logo" href="/.">程序员虾饺</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">binder 情景分析 - 为什么注册后的 BBinder 不会被意外释放？（下）—— binder 生命周期管理机制概述</h1><div class="post-meta">Apr 17, 2018<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/04/17/binder-why-BBinder-not-released-after-registered-part2/" href="/2018/04/17/binder-why-BBinder-not-released-after-registered-part2/#disqus_thread"></a><div class="post-content"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们先回顾一下问题。<a href="/2018/04/16/binder-why-BBinder-not-released-after-registered-part1">上篇</a>我们提到，<code>BBinder</code> 在弱引用计数为 0 的情况下，<code>mRefs</code> 会被释放。然而实际上却没有发生，所以 binder 驱动应该有其他机制来保证。在本篇，我们就一起来讨论这个问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">obj.binder = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local-&gt;getWeakRefs());</span><br><span class="line">obj.cookie = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RefBase::weakref_type* RefBase::getWeakRefs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mRefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发起一个增加强引用计数的任务"><a href="#发起一个增加强引用计数的任务" class="headerlink" title="发起一个增加强引用计数的任务"></a>发起一个增加强引用计数的任务</h2><p>通过 <a href="/2018/04/13/binder-service-registration-part2/">binder 情景分析 - service 的注册（中篇）</a> 中，我们了解到，在往 binder 驱动写入 <code>BBinder</code> 时，经由一系列调用，最后会到达 binder 驱动的 <code>binder_transaction</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)off_start + tr-&gt;offsets_size;</span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span> *<span class="title">hdr</span>;</span></span><br><span class="line"></span><br><span class="line">        hdr = (struct binder_object_header *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        <span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">            fp = to_flat_binder_object(hdr);</span><br><span class="line">            ret = binder_translate_binder(fp, t, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_translate_binder</span><span class="params">(struct flat_binder_object *fp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        node = binder_new_node(proc, fp);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">                fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">                &amp;thread-&gt;todo, &amp;rdata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>binder_new_node</code> 后，我们又执行了 <code>binder_inc_ref_for_node</code>。“inc ref”！！或许答案就藏在这里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_inc_ref_for_node</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   struct binder_node *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">bool</span> strong,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   struct list_head *target_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   struct binder_ref_data *rdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">new_ref</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    binder_proc_lock(proc);</span><br><span class="line">    ref = binder_get_ref_for_node_olocked(proc, node, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ref) &#123;</span><br><span class="line">        binder_proc_unlock(proc);</span><br><span class="line">        new_ref = kzalloc(<span class="keyword">sizeof</span>(*ref), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!new_ref)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        binder_proc_lock(proc);</span><br><span class="line">        ref = binder_get_ref_for_node_olocked(proc, node, new_ref);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = binder_inc_ref_olocked(ref, strong, target_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们尝试获取一个 <code>binder_ref</code>，如果获取不到，就新生成一个。接下来，调用 <code>binder_inc_ref_olocked()</code>，它又调用 <code>binder_inc_node()</code>，紧接着是 <code>binder_inc_node_nilocked()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_inc_node_nilocked</span><span class="params">(struct binder_node *node, <span class="keyword">int</span> strong,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    struct list_head *target_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strong) &#123;</span><br><span class="line">        <span class="keyword">if</span> (internal) &#123;</span><br><span class="line">            node-&gt;internal_strong_refs++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;has_strong_ref &amp;&amp; target_list) &#123;</span><br><span class="line">        binder_dequeue_work_ilocked(&amp;node-&gt;work);</span><br><span class="line">        binder_enqueue_work_ilocked(&amp;node-&gt;work, target_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们讨论的情况下，参数 <code>strong, internal</code> 都是 1。对于刚创建的 <code>binder_node</code>，<code>node-&gt;has_strong_ref</code> 也是 0。<code>target_list</code> 是调用线程对应的 <code>binder_thread.todo</code> 工作队列。我们把 <code>node-&gt;work</code> 这个任务放入了调用线程的工作队列中。于是，这里就保证了在线程写入 <code>BBinder</code> 这个动作返回之前，先处理这个任务。</p>
<p>也就是说，如果我们在这个在任务中增加 <code>BBinder</code> 的强引用计数，即便写入 <code>BBinder</code> 的线程在返回后马上销毁 <code>sp</code>，实际对象也不会销毁。</p>
<h2 id="node-gt-work-的初始化"><a href="#node-gt-work-的初始化" class="headerlink" title="node-&gt;work 的初始化"></a>node-&gt;work 的初始化</h2><p>下面，我们看看这个 <code>node-&gt;work</code> 是什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_init_node_ilocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                        struct binder_node *new_node,</span></span></span><br><span class="line"><span class="function"><span class="params">                        struct flat_binder_object *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    node-&gt;work.type = BINDER_WORK_NODE;</span><br><span class="line">    INIT_LIST_HEAD(&amp;node-&gt;work.entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>binder_new_node()</code> 后，会对 <code>binder_node</code> 做一些初始化工作。<code>node-&gt;work</code> 也是在这里初始化的。</p>
<h2 id="binder-驱动对-node-gt-work-的处理"><a href="#binder-驱动对-node-gt-work-的处理" class="headerlink" title="binder 驱动对 node-&gt;work 的处理"></a>binder 驱动对 node-&gt;work 的处理</h2><p>前面我们说，<code>node-&gt;work</code> 放入了调用线程的 <code>todo</code> 工作队列里。所以，他会在 <code>binder_thread_read()</code> 中得到处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kernel_common/drivers/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                              struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        w = binder_dequeue_work_head_ilocked(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(w-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_NODE: &#123;</span><br><span class="line">            <span class="comment">// 此时 node-&gt;internal_strong_refs == 1</span></span><br><span class="line">            <span class="comment">// has_strong_ref == 0</span></span><br><span class="line">            strong = node-&gt;internal_strong_refs ||</span><br><span class="line">                        node-&gt;local_strong_refs;</span><br><span class="line">            has_strong_ref = node-&gt;has_strong_ref;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (strong &amp;&amp; !has_strong_ref) &#123;</span><br><span class="line">                node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">                node-&gt;pending_strong_ref = <span class="number">1</span>;</span><br><span class="line">                node-&gt;local_strong_refs++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ret &amp;&amp; strong &amp;&amp; !has_strong_ref)</span><br><span class="line">                ret = binder_put_node_cmd(</span><br><span class="line">                        proc, thread, &amp;ptr, node_ptr,</span><br><span class="line">                        node_cookie, node_debug_id,</span><br><span class="line">                        BR_ACQUIRE, <span class="string">"BR_ACQUIRE"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，binder 驱动实际上只是更新了内部的一些引用计数，随后向应用发了一个 <code>BR_ACQUIRE</code> 请求。这个请求将会在 <code>IPCThreadState</code> 中得到处理。</p>
<h2 id="IPCThreadState-对-BR-ACQUIRE-的处理"><a href="#IPCThreadState-对-BR-ACQUIRE-的处理" class="headerlink" title="IPCThreadState 对 BR_ACQUIRE 的处理"></a><code>IPCThreadState</code> 对 <code>BR_ACQUIRE</code> 的处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// framework/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BR_ACQUIRE:</span><br><span class="line">        refs = (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj = (BBinder*)mIn.readPointer();</span><br><span class="line">        obj-&gt;incStrong(mProcess.get());</span><br><span class="line">        mOut.writeInt32(BC_ACQUIRE_DONE);</span><br><span class="line">        mOut.writePointer((<span class="keyword">uintptr_t</span>)refs);</span><br><span class="line">        mOut.writePointer((<span class="keyword">uintptr_t</span>)obj);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_RELEASE:</span><br><span class="line">        refs = (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj = (BBinder*)mIn.readPointer();</span><br><span class="line">        mPendingStrongDerefs.push(obj);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们把对象的强引用计数增加了 1。也是因为如此，对象才不会被意外释放。</p>
<p>顺带一提，对象的释放使用的是 <code>BR_RELEASE</code>，此外还有 <code>BR_INCREFS, BR_DECREFS, BR_ATTEMPT_ACQUIRE</code> 等。这些就不一一分析了。</p>
<p><br><br></p>
</div><div class="tags"><a href="/tags/Android-source/">Android source</a><a href="/tags/Binder/">Binder</a></div><div class="post-nav"><a class="pre" href="/2018/04/18/binder-service-query/">binder 情景分析 - service 查询</a><a class="next" href="/2018/04/16/binder-why-BBinder-not-released-after-registered-part1/">binder 情景分析 - 为什么注册后的 BBinder 不会被意外释放？（上）—— 理解 RefBase、sp、wp</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://jekton.github.io/2018/04/17/binder-why-BBinder-not-released-after-registered-part2/';
    this.page.identifier = '2018/04/17/binder-why-BBinder-not-released-after-registered-part2/';
    this.page.title = 'binder 情景分析 - 为什么注册后的 BBinder 不会被意外释放？（下）—— binder 生命周期管理机制概述';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jekton-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jekton-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jekton-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">30</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dart/">Dart</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android-arch/" style="font-size: 15px;">Android arch</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/parallel-programming/" style="font-size: 15px;">parallel-programming</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/openjdk/" style="font-size: 15px;">openjdk</a> <a href="/tags/Android-source/" style="font-size: 15px;">Android source</a> <a href="/tags/Dart/" style="font-size: 15px;">Dart</a> <a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/logd/" style="font-size: 15px;">logd</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/native-crash/" style="font-size: 15px;">native-crash</a> <a href="/tags/Glide/" style="font-size: 15px;">Glide</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/10/28/android-fragment-pitfall/">Fragment 使用陷阱</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/08/android-scrollview-impl/">ScrollView 实现指北</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/26/java-multi-singleton/">如何使用 Java 和 double-check 实现支持多实例的单例</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/native-crash-catching/">Android native 崩溃信息捕获实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/android9-lmk-lmkd/">Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/android9-logd-init/">Android P 源码分析 4 - logd 的初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/19/android9-sp/">Android P 源码分析 3 - SharedPreferences 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/android9-sp-wp/">Android P 源码分析 2 - 强弱指针的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/android9-light-sp/">Android P 源码分析 1 - 轻量级智能指针的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/linux-wait-event/">Java 程序员眼里的 Linux 内核 —— wait_event 源码分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jekton-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">程序员虾饺.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>