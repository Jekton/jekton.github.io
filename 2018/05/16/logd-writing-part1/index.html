<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android log 机制 - logd 如何接收 log 数据（上） | Jekton</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android log 机制 - logd 如何接收 log 数据（上）</h1><a id="logo" href="/.">Jekton</a><p class="description">Keep on Learning, Keep on Thinking</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android log 机制 - logd 如何接收 log 数据（上）</h1><div class="post-meta">May 16, 2018<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/05/16/logd-writing-part1/" href="/2018/05/16/logd-writing-part1/#disqus_thread"></a><div class="post-content"><p>按计划，在本篇，我们先看 <code>LogBuffer</code> 的初始化，然后深入 <code>LogListener</code>。<code>LogListener</code> 用于接受客户写入的 log 数据。虽然在 <code>main</code> 函数里先创建的是 <code>LogReader</code>，这里我们还是先看 <code>LogListener</code>，毕竟，先写了 log，才有东西可以读。</p>
<p>可是计划总是赶不上变化，<code>LogListener</code> 的镜头被 <code>SocketListener</code> 抢了，所以还是 log 数据的读取这一部分留到下一篇吧。</p>
<h2 id="LogBuffer-的初始化"><a href="#LogBuffer-的初始化" class="headerlink" title="LogBuffer 的初始化"></a>LogBuffer 的初始化</h2><p>在<a href="/2018/05/11/logd-overview/">上一篇</a>我们了解到，<code>LogBuffer</code> 是在 <code>main</code> 函数里初始化的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serves the purpose of managing the last logs times read on a</span></span><br><span class="line">    <span class="comment">// socket connection, and as a reader lock on a range of log</span></span><br><span class="line">    <span class="comment">// entries.</span></span><br><span class="line"></span><br><span class="line">    LastLogTimes* times = <span class="keyword">new</span> LastLogTimes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogBuffer is the object which is responsible for holding all</span></span><br><span class="line">    <span class="comment">// log entries.</span></span><br><span class="line"></span><br><span class="line">    logBuf = <span class="keyword">new</span> LogBuffer(times);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>LastLogTimes</code> 实际上是一个 <code>std::list</code>，可以看到，实际上这里只是 new 了一个空的 <code>list</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogTimes.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;LogTimeEntry*&gt; LastLogTimes;</span><br></pre></td></tr></table></figure></p>
<p>下面我们看看 <code>LogBuffer</code> 构造函数里面做了什么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line">LogBuffer::LogBuffer(LastLogTimes* times)</span><br><span class="line">    : monotonic(android_log_clockid() == CLOCK_MONOTONIC), mTimes(*times) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;mLogElementsLock, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    log_id_for_each(i) &#123;</span><br><span class="line">        lastLoggedElements[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        droppedElements[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/liblog/include/log/log_id.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> log_id &#123;</span><br><span class="line">  LOG_ID_MIN = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  LOG_ID_MAIN = <span class="number">0</span>,</span><br><span class="line">  LOG_ID_RADIO = <span class="number">1</span>,</span><br><span class="line">  LOG_ID_EVENTS = <span class="number">2</span>,</span><br><span class="line">  LOG_ID_SYSTEM = <span class="number">3</span>,</span><br><span class="line">  LOG_ID_CRASH = <span class="number">4</span>,</span><br><span class="line">  LOG_ID_SECURITY = <span class="number">5</span>,</span><br><span class="line">  LOG_ID_KERNEL = <span class="number">6</span>, <span class="comment">/* place last, third-parties can not use it */</span></span><br><span class="line"></span><br><span class="line">  LOG_ID_MAX</span><br><span class="line">&#125; <span class="keyword">log_id_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogStatistics.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_id_for_each(i) \</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">log_id_t</span> i = LOG_ID_MIN; (i) &lt; LOG_ID_MAX; (i) = (<span class="keyword">log_id_t</span>)((i) + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p><code>monotonic</code> 表示时间的格式，如果为 <code>true</code>，表示使用的是 CPU 的 up time（系统上电后从 0 开始计数）。一般我们用的是 real time（就是我们一般说的时间的概念）。这里就假定它是 <code>false</code> 好了。</p>
<p><code>mLogElementsLock</code> 用于保护内部的数据结构。</p>
<p><code>log_id_for_each</code> 是一个宏，用来遍历所有的 log 类型。每一种 log 类型，都有一个 <code>log_id</code> 来表示。</p>
<p><code>lastLoggedElements</code> 和 <code>droppedElements</code> 是<code>LogBufferElement *</code>类型的数组，数组的每个元素对应一种 log 类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogBuffer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    LogBufferElement* lastLoggedElements[LOG_ID_MAX];</span><br><span class="line">    LogBufferElement* droppedElements[LOG_ID_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，调用 <code>init</code> 函数，我们把它分成 3 个部分来看。</p>
<p>先看 <code>init</code> 函数的第 1 部分，这部分依然是做一些初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="keyword">void</span> LogBuffer::init() &#123;</span><br><span class="line">    log_id_for_each(i) &#123;</span><br><span class="line">        mLastSet[i] = <span class="literal">false</span>;</span><br><span class="line">        mLast[i] = mLogElements.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (setSize(i, __android_logger_get_buffer_size(i))) &#123;</span><br><span class="line">            setSize(i, LOG_BUFFER_MIN_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;LogBufferElement*&gt; LogBufferElementCollection;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogBuffer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    LogBufferElementCollection mLogElements;</span><br><span class="line">    LogBufferElementCollection::iterator mLast[LOG_ID_MAX];</span><br><span class="line">    <span class="keyword">bool</span> mLastSet[LOG_ID_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>又是一个 <code>typedef</code>，*￥#%#&amp;￥%#￥%#@，此处略去一百字。</p>
<p><code>setSize()</code> 用于设置各种 log 的最大容量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_buffer_size(id) mMaxSize[id]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set the total space allocated to "id"</span></span><br><span class="line"><span class="keyword">int</span> LogBuffer::setSize(<span class="keyword">log_id_t</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> size) &#123;</span><br><span class="line">    <span class="comment">// Reasonable limits ...</span></span><br><span class="line">    <span class="keyword">if</span> (!__android_logger_valid_buffer_size(size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_lock(&amp;mLogElementsLock);</span><br><span class="line">    log_buffer_size(id) = size;</span><br><span class="line">    pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，是 <code>init()</code> 的第二部分。这部分检查时间格式是否发生了变化，如果是，就变换已经存在 log 的时间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="keyword">void</span> LogBuffer::init() &#123;</span><br><span class="line">    <span class="comment">// 第一部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> lastMonotonic = monotonic;</span><br><span class="line">    monotonic = android_log_clockid() == CLOCK_MONOTONIC;</span><br><span class="line">    <span class="keyword">if</span> (lastMonotonic != monotonic) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Fixup all timestamps, may not be 100% accurate, but better than</span></span><br><span class="line">        <span class="comment">// throwing what we have away when we get 'surprised' by a change.</span></span><br><span class="line">        <span class="comment">// In-place element fixup so no need to check reader-lock. Entries</span></span><br><span class="line">        <span class="comment">// should already be in timestamp order, but we could end up with a</span></span><br><span class="line">        <span class="comment">// few out-of-order entries if new monotonics come in before we</span></span><br><span class="line">        <span class="comment">// are notified of the reinit change in status. A Typical example would</span></span><br><span class="line">        <span class="comment">// be:</span></span><br><span class="line">        <span class="comment">//  --------- beginning of system</span></span><br><span class="line">        <span class="comment">//      10.494082   184   201 D Cryptfs : Just triggered post_fs_data</span></span><br><span class="line">        <span class="comment">//  --------- beginning of kernel</span></span><br><span class="line">        <span class="comment">//       0.000000     0     0 I         : Initializing cgroup subsys</span></span><br><span class="line">        <span class="comment">// as the act of mounting /data would trigger persist.logd.timestamp to</span></span><br><span class="line">        <span class="comment">// be corrected. 1/30 corner case YMMV.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        pthread_mutex_lock(&amp;mLogElementsLock);</span><br><span class="line">        LogBufferElementCollection::iterator it = mLogElements.begin();</span><br><span class="line">        <span class="keyword">while</span> ((it != mLogElements.end())) &#123;</span><br><span class="line">            LogBufferElement* e = *it;</span><br><span class="line">            <span class="keyword">if</span> (monotonic) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!android::isMonotonic(e-&gt;mRealTime)) &#123;</span><br><span class="line">                    LogKlog::convertRealToMonotonic(e-&gt;mRealTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (android::isMonotonic(e-&gt;mRealTime)) &#123;</span><br><span class="line">                    LogKlog::convertMonotonicToReal(e-&gt;mRealTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>LogKlog::convertRealToMonotonic()</code> 和 <code>LogKlog::convertMonotonicToReal()</code> 的工作是相当直观的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogKlog.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convertMonotonicToReal</span><span class="params">(log_time&amp; real)</span> </span>&#123;</span><br><span class="line">    real += correction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convertRealToMonotonic</span><span class="params">(log_time&amp; real)</span> </span>&#123;</span><br><span class="line">    real -= correction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>correction</code> 是一个静态的成员变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogKlog.h</span></span><br><span class="line">log_time LogKlog::correction =</span><br><span class="line">    (log_time(CLOCK_REALTIME) &lt; log_time(CLOCK_MONOTONIC))</span><br><span class="line">        ? log_time::EPOCH</span><br><span class="line">        : (log_time(CLOCK_REALTIME) - log_time(CLOCK_MONOTONIC));</span><br></pre></td></tr></table></figure></p>
<p>正常情况下，<code>correction = (log_time(CLOCK_REALTIME) - log_time(CLOCK_MONOTONIC))</code>，即这行代码执行时实际时间跟 monotonic 时间的差值。</p>
<p>最后，我们看 <code>init()</code> 的第3部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="keyword">void</span> LogBuffer::init() &#123;</span><br><span class="line">    <span class="comment">// 第 1 部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 2 部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We may have been triggered by a SIGHUP. Release any sleeping reader</span></span><br><span class="line">    <span class="comment">// threads to dump their current content.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NB: this is _not_ performed in the context of a SIGHUP, it is</span></span><br><span class="line">    <span class="comment">// performed during startup, and in context of reinit administrative thread</span></span><br><span class="line">    LogTimeEntry::lock();</span><br><span class="line"></span><br><span class="line">    LastLogTimes::iterator times = mTimes.begin();</span><br><span class="line">    <span class="keyword">while</span> (times != mTimes.end()) &#123;</span><br><span class="line">        LogTimeEntry* entry = (*times);</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;owned_Locked()) &#123;</span><br><span class="line">            entry-&gt;triggerReader_Locked();</span><br><span class="line">        &#125;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一个需要读取 log 数据的客户端都对应 <code>mTimes</code> 里面的一个元素。就像注释里说的，收到信号 <code>SIGHUP</code> 会调用 <code>init</code>，这个时候需要重新唤醒 <code>LogTimeEntry</code>。如果是刚刚初始化 <code>LogBuffer</code>，<code>mTimes</code> 为空，循环不执行。<code>SIGHUP</code> 在 <code>main</code> 函数中注册，这一部分就不展开讲了，后面有机会再聊。</p>
<p>到这里，<code>LogBuffer</code> 就的初始化就完成了。</p>
<h2 id="LogListener-的初始化"><a href="#LogListener-的初始化" class="headerlink" title="LogListener 的初始化"></a>LogListener 的初始化</h2><p><code>LogListener</code> 是在 <code>main</code> 函数里初始化的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogReader listens on /dev/socket/logdr. When a client</span></span><br><span class="line">    <span class="comment">// connects, log entries in the LogBuffer are written to the client.</span></span><br><span class="line"></span><br><span class="line">    LogReader* reader = <span class="keyword">new</span> LogReader(logBuf);</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogListener listens on /dev/socket/logdw for client</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogListener* swl = <span class="keyword">new</span> LogListener(logBuf, reader);</span><br><span class="line">    <span class="comment">// Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value</span></span><br><span class="line">    <span class="keyword">if</span> (swl-&gt;startListener(<span class="number">600</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogListener.cpp</span></span><br><span class="line">LogListener::LogListener(LogBuffer* buf, LogReader* reader)</span><br><span class="line">    : SocketListener(getLogSocket(), <span class="literal">false</span>), logbuf(buf), reader(reader) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>LogReader</code> 在客户从 logd 中读取数据时使用，这里我们先把它放一放。在本篇，我们先看往 logd 写数据这一部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogListener.cpp</span></span><br><span class="line">LogListener::LogListener(LogBuffer* buf, LogReader* reader)</span><br><span class="line">    : SocketListener(getLogSocket(), <span class="literal">false</span>), logbuf(buf), reader(reader) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogListener.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogListener</span> :</span> <span class="keyword">public</span> SocketListener &#123;</span><br><span class="line">    LogBuffer* logbuf;</span><br><span class="line">    LogReader* reader;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    LogListener(LogBuffer* buf, LogReader* reader);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">onDataAvailable</span><span class="params">(SocketClient* cli)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLogSocket</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>LogListener</code> 构造函数里并没有太多的工作要做，只是调用父类的构造函数，然后把传递进来的参数存起来。</p>
<p><code>getLogSocket()</code> 用于获取 UNIX 域 socket <code>/dev/socket/logdw</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogListener.cpp</span></span><br><span class="line"><span class="keyword">int</span> LogListener::getLogSocket() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> socketName[] = <span class="string">"logdw"</span>;</span><br><span class="line">    <span class="keyword">int</span> sock = android_get_control_socket(socketName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sock = socket_local_server(</span><br><span class="line">            socketName, ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_DGRAM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_PASSCRED, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libcutils/include/cutils/sockets.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux "abstract" (non-filesystem) namespace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_SOCKET_NAMESPACE_ABSTRACT 0</span></span><br><span class="line"><span class="comment">// Android "reserved" (/dev/socket) namespace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_SOCKET_NAMESPACE_RESERVED 1</span></span><br><span class="line"><span class="comment">// Normal filesystem namespace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_SOCKET_NAMESPACE_FILESYSTEM 2</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要关注的是 <code>setsockopt()</code>，通过设置 <code>SO_PASSCRED</code>，能够接收一个 <code>SCM_CREDENTIALS</code> 消息，消息中包含发送者的 pid, uid, 和 gid。该消息通过 <code>struct ucred</code> 结构返回。通过这个选项，我们就能够知道是谁写入了 log。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> &#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;    <span class="comment">/* process ID of the sending process */</span></span><br><span class="line">    <span class="keyword">uid_t</span> uid;    <span class="comment">/* user ID of the sending process */</span></span><br><span class="line">    <span class="keyword">gid_t</span> gid;    <span class="comment">/* group ID of the sending process */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另外，由于 <code>/dev/socket/logdw</code> 的类型是 dgram，所以传给 <code>SocketListener</code> 的第二个参数 <code>listen == false</code>。</p>
<p>父类 <code>SocketListener</code> 是 sysutils 库提供的类，用于监听 socket。当有数据可读的时候，<code>SocketListener</code> 会回调子类的 <code>onDataAvailable</code>。在本篇，我们先看看它的实现。</p>
<p>不多废话了，直接看代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SocketListener::SocketListener(<span class="keyword">int</span> socketFd, <span class="keyword">bool</span> listen) &#123;</span><br><span class="line">    init(<span class="literal">NULL</span>, socketFd, listen, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SocketListener::init(<span class="keyword">const</span> <span class="keyword">char</span> *socketName, <span class="keyword">int</span> socketFd, <span class="keyword">bool</span> listen, <span class="keyword">bool</span> useCmdNum) &#123;</span><br><span class="line">    mListen = listen;</span><br><span class="line">    mSocketName = socketName;</span><br><span class="line">    mSock = socketFd;</span><br><span class="line">    mUseCmdNum = useCmdNum;</span><br><span class="line">    pthread_mutex_init(&amp;mClientsLock, <span class="literal">NULL</span>);</span><br><span class="line">    mClients = <span class="keyword">new</span> SocketClientCollection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libsysutils/include/sysutils/SocketClient.h</span></span><br><span class="line"><span class="keyword">typedef</span> android::sysutils::List&lt;SocketClient *&gt; SocketClientCollection;</span><br></pre></td></tr></table></figure></p>
<p><code>LocketListener</code> 的构造函数里，依然是很简单的。其中，<code>SocketClient</code> 表示一个客户的连接。</p>
<h2 id="监听客户端请求"><a href="#监听客户端请求" class="headerlink" title="监听客户端请求"></a>监听客户端请求</h2><p>初始化 <code>LogListener</code> 后，<code>main</code> 函数执行 <code>swl-&gt;startListener(600)</code> 开始监听客户请求。<code>startListener</code> 是 <code>SocketListener</code> 中的方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> SocketListener::startListener(<span class="keyword">int</span> backlog) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mSocketName &amp;&amp; mSock == <span class="number">-1</span>) &#123;</span><br><span class="line">        SLOGE(<span class="string">"Failed to start unbound listener"</span>);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSocketName) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mSock = android_get_control_socket(mSocketName)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">"Obtaining file descriptor socket '%s' failed: %s"</span>,</span><br><span class="line">                 mSocketName, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SLOGV(<span class="string">"got mSock = %d for %s"</span>, mSock, mSocketName);</span><br><span class="line">        fcntl(mSock, F_SETFD, FD_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mListen &amp;&amp; listen(mSock, backlog) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        SLOGE(<span class="string">"Unable to listen on socket (%s)"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mListen)</span><br><span class="line">        mClients-&gt;push_back(<span class="keyword">new</span> SocketClient(mSock, <span class="literal">false</span>, mUseCmdNum));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(mCtrlPipe)) &#123;</span><br><span class="line">        SLOGE(<span class="string">"pipe failed (%s)"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;mThread, <span class="literal">NULL</span>, SocketListener::threadStart, <span class="keyword">this</span>)) &#123;</span><br><span class="line">        SLOGE(<span class="string">"pthread_create (%s)"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 <code>LogListener</code> 的情况，<code>mSocketName == null, mSock != -1, mListen == false, mUseCmdNum == false</code>，这里实际执行的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mClients-&gt;push_back(<span class="keyword">new</span> SocketClient(mSock, <span class="literal">false</span>, mUseCmdNum));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe(mCtrlPipe)) &#123;</span><br><span class="line">    SLOGE(<span class="string">"pipe failed (%s)"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_create(&amp;mThread, <span class="literal">NULL</span>, SocketListener::threadStart, <span class="keyword">this</span>)) &#123;</span><br><span class="line">    SLOGE(<span class="string">"pthread_create (%s)"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>现在，是时候看看 <code>SocketClient</code> 了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libsysutils/src/SocketClient.cpp</span></span><br><span class="line">SocketClient::SocketClient(<span class="keyword">int</span> socket, <span class="keyword">bool</span> owned, <span class="keyword">bool</span> useCmdNum) &#123;</span><br><span class="line">    init(socket, owned, useCmdNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libsysutils/src/SocketClient.cpp</span></span><br><span class="line"><span class="keyword">void</span> SocketClient::init(<span class="keyword">int</span> socket, <span class="keyword">bool</span> owned, <span class="keyword">bool</span> useCmdNum) &#123;</span><br><span class="line">    mSocket = socket;</span><br><span class="line">    mSocketOwned = owned;</span><br><span class="line">    mUseCmdNum = useCmdNum;</span><br><span class="line">    pthread_mutex_init(&amp;mWriteMutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mRefCountMutex, <span class="literal">NULL</span>);</span><br><span class="line">    mPid = <span class="number">-1</span>;</span><br><span class="line">    mUid = <span class="number">-1</span>;</span><br><span class="line">    mGid = <span class="number">-1</span>;</span><br><span class="line">    mRefCount = <span class="number">1</span>;</span><br><span class="line">    mCmdNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> <span class="title">creds</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> szCreds = <span class="keyword">sizeof</span>(creds);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;creds, <span class="number">0</span>, szCreds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &amp;creds, &amp;szCreds);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">        mPid = creds.pid;</span><br><span class="line">        mUid = creds.uid;</span><br><span class="line">        mGid = creds.gid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要注意的是，上面的那个 <code>getsockopt</code> 虽然会返回成功，但是 <code>creds</code> 里面的指都是无效的，毕竟，这个就是我们本地生成的 socket （而不是某个客户的连接）。</p>
<p>把 <code>mSock</code> 放到 <code>mClients</code> 里面后，再创建一个 <code>mCtrlPipe</code>，这个 pipe 将会用于唤醒 <code>select</code> 系统调用。这是一种非常常见的用法。</p>
<p>随后，创建一个线程监听 <code>mClients</code> 和 <code>mCtrlPipe</code>。下面我们看看这个线程里做了什么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libsysutils/src/SocketListener.cpp</span></span><br><span class="line"><span class="keyword">void</span> *SocketListener::threadStart(<span class="keyword">void</span> *obj) &#123;</span><br><span class="line">    SocketListener *me = <span class="keyword">reinterpret_cast</span>&lt;SocketListener *&gt;(obj);</span><br><span class="line"></span><br><span class="line">    me-&gt;runListener();</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libsysutils/src/SocketListener.cpp</span></span><br><span class="line"><span class="keyword">void</span> SocketListener::runListener() &#123;</span><br><span class="line"></span><br><span class="line">    SocketClientCollection pendingList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        SocketClientCollection::iterator it;</span><br><span class="line">        fd_set read_fds;</span><br><span class="line">        <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        FD_ZERO(&amp;read_fds);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mListen) &#123;</span><br><span class="line">            max = mSock;</span><br><span class="line">            FD_SET(mSock, &amp;read_fds);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FD_SET(mCtrlPipe[<span class="number">0</span>], &amp;read_fds);</span><br><span class="line">        <span class="keyword">if</span> (mCtrlPipe[<span class="number">0</span>] &gt; max)</span><br><span class="line">            max = mCtrlPipe[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">        <span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123;</span><br><span class="line">            <span class="comment">// NB: calling out to an other object with mClientsLock held (safe)</span></span><br><span class="line">            <span class="keyword">int</span> fd = (*it)-&gt;getSocket();</span><br><span class="line">            FD_SET(fd, &amp;read_fds);</span><br><span class="line">            <span class="keyword">if</span> (fd &gt; max) &#123;</span><br><span class="line">                max = fd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line">        SLOGV(<span class="string">"mListen=%d, max=%d, mSocketName=%s"</span>, mListen, max, mSocketName);</span><br><span class="line">        <span class="keyword">if</span> ((rc = select(max + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            SLOGE(<span class="string">"select failed (%s) mListen=%d, max=%d"</span>, strerror(errno), mListen, max);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!rc)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(mCtrlPipe[<span class="number">0</span>], &amp;read_fds)) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = CtrlPipe_Shutdown;</span><br><span class="line">            TEMP_FAILURE_RETRY(read(mCtrlPipe[<span class="number">0</span>], &amp;c, <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (c == CtrlPipe_Shutdown) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mListen &amp;&amp; FD_ISSET(mSock, &amp;read_fds)) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = TEMP_FAILURE_RETRY(accept4(mSock, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, SOCK_CLOEXEC));</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                SLOGE(<span class="string">"accept failed (%s)"</span>, strerror(errno));</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">            mClients-&gt;push_back(<span class="keyword">new</span> SocketClient(c, <span class="literal">true</span>, mUseCmdNum));</span><br><span class="line">            pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Add all active clients to the pending list first */</span></span><br><span class="line">        pendingList.clear();</span><br><span class="line">        pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">        <span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123;</span><br><span class="line">            SocketClient* c = *it;</span><br><span class="line">            <span class="comment">// NB: calling out to an other object with mClientsLock held (safe)</span></span><br><span class="line">            <span class="keyword">int</span> fd = c-&gt;getSocket();</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(fd, &amp;read_fds)) &#123;</span><br><span class="line">                pendingList.push_back(c);</span><br><span class="line">                c-&gt;incRef();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Process the pending list, since it is owned by the thread,</span></span><br><span class="line"><span class="comment">         * there is no need to lock it */</span></span><br><span class="line">        <span class="keyword">while</span> (!pendingList.empty()) &#123;</span><br><span class="line">            <span class="comment">/* Pop the first item from the list */</span></span><br><span class="line">            it = pendingList.begin();</span><br><span class="line">            SocketClient* c = *it;</span><br><span class="line">            pendingList.erase(it);</span><br><span class="line">            <span class="comment">/* Process it, if false is returned, remove from list */</span></span><br><span class="line">            <span class="keyword">if</span> (!onDataAvailable(c)) &#123;</span><br><span class="line">                release(c, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            c-&gt;decRef();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然这段代码很长，但是它的逻辑还是很直接的：</p>
<ol>
<li>用 <code>select</code> 在所有描述符上等待</li>
<li>往 <code>mCtrlPipe</code> 写入 <code>CtrlPipe_Shutdown</code> 后，线程退出。其他字符只会唤醒 <code>select</code></li>
<li>如果 <code>mSock</code> 是个监听套接字并且可读，表示有客户连接，<code>accept</code> socket 连接</li>
<li>处理所有可读的 socket（回调子类的 <code>onDataAvailable</code> 函数）</li>
</ol>
<p>对于 <code>LogListener</code> 来说，<code>mClients</code> 永远只会有一个 socket（就是前面我们创建的那一个）。当它可读时，表示有客户端要写入 log。</p>
<p>如果 <code>onDataAvailable</code> 返回了 <code>false</code>，调用 <code>release</code> 函数删除对应的 socket：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libsysutils/src/SocketListener.cpp</span></span><br><span class="line"><span class="keyword">bool</span> SocketListener::release(SocketClient* c, <span class="keyword">bool</span> wakeup) &#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* if our sockets are connection-based, remove and destroy it */</span></span><br><span class="line">    <span class="keyword">if</span> (mListen &amp;&amp; c) &#123;</span><br><span class="line">        <span class="comment">/* Remove the client from our array */</span></span><br><span class="line">        SLOGV(<span class="string">"going to zap %d for %s"</span>, c-&gt;getSocket(), mSocketName);</span><br><span class="line">        pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">        SocketClientCollection::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it == c) &#123;</span><br><span class="line">                mClients-&gt;erase(it);</span><br><span class="line">                ret = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            ret = c-&gt;decRef();</span><br><span class="line">            <span class="keyword">if</span> (wakeup) &#123;</span><br><span class="line">                <span class="keyword">char</span> b = CtrlPipe_Wakeup;</span><br><span class="line">                TEMP_FAILURE_RETRY(write(mCtrlPipe[<span class="number">1</span>], &amp;b, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为此时我们还在工作线程的循环里，把对应的 <code>SocketClient</code> 删掉后，在下一轮循环就会重新初始化 <code>select</code> 的参数，所以这里传递给 <code>release</code> 的 <code>wakeup</code> 参数为 <code>false</code>。</p>
<p>刚创建的 <code>SocketClient</code> 的 <code>mRefCount == 1</code>，所以，<code>SocketListener::release()</code> 里面执行 <code>c-&gt;decRef()</code> 后还不会删除对象。对象要在 <code>release</code> 返回后再次执行 <code>c-&gt;decRef()</code> 时才会真正释放。</p>
<p>按道理，接下来就应该看 <code>LogListener::onDataAvailable</code>，但是，这篇文章实在是太长了，我已经写得很不耐烦。所以，还是把它留到下一篇吧。</p>
<p>出于完整性，下面我们顺便看看 <code>SocketListener</code> 是如何停止的工作线程的。</p>
<h2 id="SocketListener-的停止"><a href="#SocketListener-的停止" class="headerlink" title="SocketListener 的停止"></a>SocketListener 的停止</h2><p><code>SocketListener</code> 的停止由 <code>stopListener</code> 负责：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libsysutils/src/SocketListener.cpp</span></span><br><span class="line"><span class="keyword">int</span> SocketListener::stopListener() &#123;</span><br><span class="line">    <span class="keyword">char</span> c = CtrlPipe_Shutdown;</span><br><span class="line">    <span class="keyword">int</span>  rc;</span><br><span class="line"></span><br><span class="line">    rc = TEMP_FAILURE_RETRY(write(mCtrlPipe[<span class="number">1</span>], &amp;c, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGE(<span class="string">"Error writing to control pipe (%s)"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(mThread, &amp;ret)) &#123;</span><br><span class="line">        SLOGE(<span class="string">"Error joining to listener thread (%s)"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(mCtrlPipe[<span class="number">0</span>]);</span><br><span class="line">    close(mCtrlPipe[<span class="number">1</span>]);</span><br><span class="line">    mCtrlPipe[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    mCtrlPipe[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSocketName &amp;&amp; mSock &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        close(mSock);</span><br><span class="line">        mSock = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SocketClientCollection::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end();) &#123;</span><br><span class="line">        <span class="keyword">delete</span> (*it);</span><br><span class="line">        it = mClients-&gt;erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用 <code>stopListener</code> 的时候，工作线程可能还在 <code>select</code> 上阻塞。这里，通过往 <code>mCtrlPipe</code> 写入数据，就可以唤醒 <code>select</code>。随后，就像我们上面看到，写入 <code>CtrlPipe_Shutdown</code> 后将导致工作线程退出循环。</p>
<p><br><br></p>
</div><div class="tags"><a href="/tags/Android-source/">Android source</a><a href="/tags/logd/">logd</a></div><div class="post-nav"><a class="pre" href="/2018/05/17/logd-writing-part2/">Android log 机制 - logd 如何接收 log 数据（下）</a><a class="next" href="/2018/05/11/how-to-read-android-source-code/">如何使用 Visual Studio Code 阅读 Android 源码</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://jekton.github.io/2018/05/16/logd-writing-part1/';
    this.page.identifier = '2018/05/16/logd-writing-part1/';
    this.page.title = 'Android log 机制 - logd 如何接收 log 数据（上）';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jekton-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jekton-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jekton-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dart/">Dart</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Dart/" style="font-size: 15px;">Dart</a> <a href="/tags/Android-source/" style="font-size: 15px;">Android source</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/openjdk/" style="font-size: 15px;">openjdk</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Android-arch/" style="font-size: 15px;">Android arch</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/logd/" style="font-size: 15px;">logd</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/parallel-programming/" style="font-size: 15px;">parallel-programming</a> <a href="/tags/Glide/" style="font-size: 15px;">Glide</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/linux-wait-event/">Java 程序员眼里的 Linux 内核 —— wait_event 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/linux-page-table-setup/">Linux 内核页表的创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/note-x86-provisional-kernel-page-table-setup/">《深入理解 LINUX 内核》读书笔记 - 临时内核页表</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/flutter-plugin-dev/">Flutter 开发（5）- 插件的使用、开发和发布</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/dart-tutorial/">Dart 语言入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/flutter-io-basic/">Flutter 开发（4）- 文件、存储和网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/29/flutter-ux-basic/">Flutter 开发（3）- 交互、动画、手势和事件处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/flutter-ui-basic/">Flutter 开发（2）- UI控件和布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/flutter-first-app/">Flutter 开发（1）- 开发框架、流程、编译打包、调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/25/jdk-FutureTask/">JDK 源码分析（1）- FutureTask</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jekton-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Jekton.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>