<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android log 机制 - 读取 logd 中的 log 数据 | 程序员虾饺</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android log 机制 - 读取 logd 中的 log 数据</h1><a id="logo" href="/.">程序员虾饺</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android log 机制 - 读取 logd 中的 log 数据</h1><div class="post-meta">May 25, 2018<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/05/25/logd-reading/" href="/2018/05/25/logd-reading/#disqus_thread"></a><div class="post-content"><p>当客户端想要读取 log 数据的时候，可以使用 socket 连接至 <code>/dev/socket/logdr</code>。对应的连接由 <code>LogReader</code> 处理。这里的 reader 是从用户的角度来看的。如果站在 logd 的位置，实际上是把 log 数据写入 socket。为了避免混淆，后文统称“写回数据”。</p>
<h2 id="LogReader-初始化"><a href="#LogReader-初始化" class="headerlink" title="LogReader 初始化"></a>LogReader 初始化</h2><p>在 <a href="/2018/05/11/logd-overview">logd 总览</a>一篇中，我们知道，<code>LogReader</code> 是在 <code>main</code> 函数里启动的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogReader listens on /dev/socket/logdr. When a client</span></span><br><span class="line">    <span class="comment">// connects, log entries in the LogBuffer are written to the client.</span></span><br><span class="line"></span><br><span class="line">    LogReader* reader = <span class="keyword">new</span> LogReader(logBuf);</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们看看它的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogReader.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogReader</span> :</span> <span class="keyword">public</span> SocketListener &#123;</span><br><span class="line">    LogBuffer&amp; mLogbuf;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line">LogReader::LogReader(LogBuffer* logbuf)</span><br><span class="line">    : SocketListener(getLogSocket(), <span class="literal">true</span>), mLogbuf(*logbuf) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line"><span class="keyword">int</span> LogReader::getLogSocket() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> socketName[] = <span class="string">"logdr"</span>;</span><br><span class="line">    <span class="keyword">int</span> sock = android_get_control_socket(socketName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sock = socket_local_server(</span><br><span class="line">            socketName, ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_SEQPACKET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 <code>LogListener</code> 一样，<code>LogReader</code> 也继承了 <code>SocketListener</code>，关于 <code>SocketListener</code>，不熟悉的读者，可以看<a href="/2018/05/16/logd-writing-part1">这篇</a>。</p>
<h2 id="读取客户请求参数"><a href="#读取客户请求参数" class="headerlink" title="读取客户请求参数"></a>读取客户请求参数</h2><p>当有客户端连接的时候，<code>SocketListener</code> 会回调子类的 <code>onDataAvailable</code> 函数。在这个函数中，<code>LogReader</code> 主要做 3 件事：</p>
<ol>
<li>设置线程名</li>
<li>读取客户端传过来的参数</li>
<li>生成一个 <code>FlushCommand</code> 用于向客户端写回 log 数据。</li>
</ol>
<p>这里我们先看前两个工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line"><span class="keyword">bool</span> LogReader::onDataAvailable(SocketClient* cli) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> name_set;</span><br><span class="line">    <span class="keyword">if</span> (!name_set) &#123;</span><br><span class="line">        prctl(PR_SET_NAME, <span class="string">"logd.reader"</span>);</span><br><span class="line">        name_set = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = read(cli-&gt;getSocket(), buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        doSocketDelete(cli);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[len] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _tail[] = <span class="string">" tail="</span>;</span><br><span class="line">    <span class="keyword">char</span>* cp = <span class="built_in">strstr</span>(buffer, _tail);</span><br><span class="line">    <span class="keyword">if</span> (cp) &#123;</span><br><span class="line">        tail = atol(cp + <span class="keyword">sizeof</span>(_tail) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">log_time <span class="title">start</span><span class="params">(log_time::EPOCH)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _start[] = <span class="string">" start="</span>;</span><br><span class="line">    cp = <span class="built_in">strstr</span>(buffer, _start);</span><br><span class="line">    <span class="keyword">if</span> (cp) &#123;</span><br><span class="line">        <span class="comment">// Parse errors will result in current time</span></span><br><span class="line">        start.strptime(cp + <span class="keyword">sizeof</span>(_start) - <span class="number">1</span>, <span class="string">"%s.%q"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _timeout[] = <span class="string">" timeout="</span>;</span><br><span class="line">    cp = <span class="built_in">strstr</span>(buffer, _timeout);</span><br><span class="line">    <span class="keyword">if</span> (cp) &#123;</span><br><span class="line">        timeout = atol(cp + <span class="keyword">sizeof</span>(_timeout) - <span class="number">1</span>) * NS_PER_SEC +</span><br><span class="line">                  log_time(CLOCK_REALTIME).nsec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> logMask = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _logIds[] = <span class="string">" lids="</span>;</span><br><span class="line">    cp = <span class="built_in">strstr</span>(buffer, _logIds);</span><br><span class="line">    <span class="keyword">if</span> (cp) &#123;</span><br><span class="line">        logMask = <span class="number">0</span>;</span><br><span class="line">        cp += <span class="keyword">sizeof</span>(_logIds) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*cp &amp;&amp; *cp != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*cp)) &#123;</span><br><span class="line">                val = val * <span class="number">10</span> + *cp - <span class="string">'0'</span>;</span><br><span class="line">                ++cp;</span><br><span class="line">            &#125;</span><br><span class="line">            logMask |= <span class="number">1</span> &lt;&lt; val;</span><br><span class="line">            <span class="keyword">if</span> (*cp != <span class="string">','</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _pid[] = <span class="string">" pid="</span>;</span><br><span class="line">    cp = <span class="built_in">strstr</span>(buffer, _pid);</span><br><span class="line">    <span class="keyword">if</span> (cp) &#123;</span><br><span class="line">        pid = atol(cp + <span class="keyword">sizeof</span>(_pid) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> nonBlock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fastcmp&lt;<span class="built_in">strncmp</span>&gt;(buffer, <span class="string">"dumpAndClose"</span>, <span class="number">12</span>)) &#123;</span><br><span class="line">        <span class="comment">// Allow writer to get some cycles, and wait for pending notifications</span></span><br><span class="line">        sched_yield();</span><br><span class="line">        LogTimeEntry::lock();</span><br><span class="line">        LogTimeEntry::unlock();</span><br><span class="line">        sched_yield();</span><br><span class="line">        nonBlock = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通信用的是文本协议，主要设置 <code>tail, start, timeout, logMask, pid, 和 nonblock</code>。如果客户没有传递对应的参数，会使用默认值。</p>
<p>其中，<code>tail</code> 表示读取 log 的最新 <code>tail</code> 条数据；<code>start</code> 是 log 的起始时间；<code>timeout</code> 比较诡异，表示读取 log 前，先睡 <code>timeout</code> 这么一个时长。</p>
<p>在实际读取 log 前，会先执行下面一个优化措施：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line"><span class="keyword">bool</span> LogReader::onDataAvailable(SocketClient* cli) &#123;</span><br><span class="line">    <span class="comment">// 参数读取部分</span></span><br><span class="line"></span><br><span class="line">    log_time sequence = start;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This somewhat expensive data validation operation is required</span></span><br><span class="line">    <span class="comment">// for non-blocking, with timeout.  The incoming timestamp must be</span></span><br><span class="line">    <span class="comment">// in range of the list, if not, return immediately.  This is</span></span><br><span class="line">    <span class="comment">// used to prevent us from from getting stuck in timeout processing</span></span><br><span class="line">    <span class="comment">// with an invalid time.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Find if time is really present in the logs, monotonic or real, implicit</span></span><br><span class="line">    <span class="comment">// conversion from monotonic or real as necessary to perform the check.</span></span><br><span class="line">    <span class="comment">// Exit in the check loop ASAP as you find a transition from older to</span></span><br><span class="line">    <span class="comment">// newer, but use the last entry found to ensure overlap.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (nonBlock &amp;&amp; (sequence != log_time::EPOCH) &amp;&amp; timeout) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LogFindStart</span> &#123;</span>  <span class="comment">// A lambda by another name</span></span><br><span class="line">           <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">pid_t</span> mPid;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">unsigned</span> mLogMask;</span><br><span class="line">            <span class="keyword">bool</span> mStartTimeSet;</span><br><span class="line">            log_time mStart;</span><br><span class="line">            <span class="comment">// 注意，mSequence 是一个引用</span></span><br><span class="line">            log_time&amp; mSequence;</span><br><span class="line">            log_time mLast;</span><br><span class="line">            <span class="keyword">bool</span> mIsMonotonic;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">public</span>:</span><br><span class="line">            LogFindStart(<span class="keyword">pid_t</span> pid, <span class="keyword">unsigned</span> logMask, log_time&amp; sequence,</span><br><span class="line">                         <span class="keyword">bool</span> isMonotonic)</span><br><span class="line">                : mPid(pid),</span><br><span class="line">                  mLogMask(logMask),</span><br><span class="line">                  mStartTimeSet(<span class="literal">false</span>),</span><br><span class="line">                  mStart(sequence),</span><br><span class="line">                  mSequence(sequence),</span><br><span class="line">                  mLast(sequence),</span><br><span class="line">                  mIsMonotonic(isMonotonic) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> LogBufferElement* element, <span class="keyword">void</span>* obj)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// ojb 就是我们传递给 LogBuffer::flushTo 的第 7 个参数</span></span><br><span class="line">                LogFindStart* me = <span class="keyword">reinterpret_cast</span>&lt;LogFindStart*&gt;(obj);</span><br><span class="line">                <span class="keyword">if</span> ((!me-&gt;mPid || (me-&gt;mPid == element-&gt;getPid())) &amp;&amp;</span><br><span class="line">                    (me-&gt;mLogMask &amp; (<span class="number">1</span> &lt;&lt; element-&gt;getLogId()))) &#123;</span><br><span class="line">                    log_time real = element-&gt;getRealTime();</span><br><span class="line">                    <span class="keyword">if</span> (me-&gt;mStart == real) &#123;</span><br><span class="line">                        me-&gt;mSequence = real;</span><br><span class="line">                        me-&gt;mStartTimeSet = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!me-&gt;mIsMonotonic || android::isMonotonic(real)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (me-&gt;mStart &lt; real) &#123;</span><br><span class="line">                            me-&gt;mSequence = me-&gt;mLast;</span><br><span class="line">                            me-&gt;mStartTimeSet = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        me-&gt;mLast = real;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        me-&gt;mLast = real;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">found</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mStartTimeSet;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; logFindStart(pid, logMask, sequence,</span><br><span class="line">                       logbuf().isMonotonic() &amp;&amp; android::isMonotonic(start));</span><br><span class="line"></span><br><span class="line">        logbuf().flushTo(cli, sequence, <span class="literal">nullptr</span>, FlushCommand::hasReadLogs(cli),</span><br><span class="line">                         FlushCommand::hasSecurityLogs(cli),</span><br><span class="line">                         logFindStart.callback, &amp;logFindStart);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!logFindStart.found()) &#123;</span><br><span class="line">            doSocketDelete(cli);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>nonBlock &amp;&amp; (sequence != log_time::EPOCH) &amp;&amp; timeout</code> 成立时，这里会先扫描一遍 log 队列，确保有符合条件的 log 项，如果没有，直接关闭 socket 并返回。</p>
<p>关于 <code>LogBuffer::flushTo</code> 函数，我们后面再仔细看它的实现。</p>
<p>他的第 6 个参数是一个函数指针，作为过滤器使用：</p>
<ol>
<li>如果返回 <code>true</code>，则写入对应的 log 项</li>
<li>返回 <code>false</code>，跳过 log 项</li>
<li>返回其他值，则结束迭代</li>
</ol>
<p>接下来，生成一个 <code>FlushCommand</code> 实例，开始真正的读取 log 工作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line"><span class="keyword">bool</span> LogReader::onDataAvailable(SocketClient* cli) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function">FlushCommand <span class="title">command</span><span class="params">(*<span class="keyword">this</span>, nonBlock, tail, logMask, pid, sequence, timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set acceptable upper limit to wait for slow reader processing b/27242723</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t</span> = &#123;</span> LOGD_SNDTIMEO, <span class="number">0</span> &#125;;</span><br><span class="line">    setsockopt(cli-&gt;getSocket(), SOL_SOCKET, SO_SNDTIMEO, (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;t,</span><br><span class="line">               <span class="keyword">sizeof</span>(t));</span><br><span class="line"></span><br><span class="line">    command.runSocketCommand(cli);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动读-log-线程"><a href="#启动读-log-线程" class="headerlink" title="启动读 log 线程"></a>启动读 log 线程</h2><p><code>FlushCommand</code> 继承了 <code>SocketClientCommand</code>，<code>SocketClientCommand</code> 是 <code>SocketListener</code> 框架的一部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/FlushCommand.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlushCommand</span> :</span> <span class="keyword">public</span> SocketClientCommand &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">runSocketCommand</span><span class="params">(SocketClient* client)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以如此，是为了在写入 log 的时候，利用 <code>SocketListener</code> 的“广播”功能。在 <a href="/2018/05/17/logd-writing-part2/">log的写入</a>一篇中我们说过，当写入 log 数据后，由于此时可能有客户端在等待读取数据，所以需要唤醒他们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// When we are notified a new log entry is available, inform</span></span><br><span class="line"><span class="comment">// all of our listening sockets.</span></span><br><span class="line"><span class="keyword">void</span> LogReader::notifyNewLog() &#123;</span><br><span class="line">    <span class="function">FlushCommand <span class="title">command</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    runOnEachSocket(&amp;command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>runOnEachSocket</code> 会对所有的 socket 执行 <code>command-&gt;runSocketCommand(client)</code>。</p>
<p>就像本节的标题预示的那样，<code>FlushCommand</code> 的实际工作其实是启动读取 log 线程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/FlushCommand.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// runSocketCommand is called once for every open client on the</span></span><br><span class="line"><span class="comment">// log reader socket. Here we manage and associated the reader</span></span><br><span class="line"><span class="comment">// client tracking and log region locks LastLogTimes list of</span></span><br><span class="line"><span class="comment">// LogTimeEntrys, and spawn a transitory per-client thread to</span></span><br><span class="line"><span class="comment">// work at filing data to the  socket.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// global LogTimeEntry::lock() is used to protect access,</span></span><br><span class="line"><span class="comment">// reference counts are used to ensure that individual</span></span><br><span class="line"><span class="comment">// LogTimeEntry lifetime is managed when not protected.</span></span><br><span class="line"><span class="keyword">void</span> FlushCommand::runSocketCommand(SocketClient* client) &#123;</span><br><span class="line">    LogTimeEntry* entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 每个读者都对应 times 列表里的一个元素</span></span><br><span class="line">    LastLogTimes&amp; times = mReader.logbuf().mTimes;</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::lock();</span><br><span class="line">    LastLogTimes::iterator it = times.begin();</span><br><span class="line">    <span class="keyword">while</span> (it != times.end()) &#123;</span><br><span class="line">        entry = (*it);</span><br><span class="line">        <span class="comment">// 遍历列表，找到自己</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;mClient == client) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;mTimeout.tv_sec || entry-&gt;mTimeout.tv_nsec) &#123;</span><br><span class="line">                <span class="comment">// 等 timeout 结束后就会醒来，所以直接 return</span></span><br><span class="line">                <span class="keyword">if</span> (mReader.logbuf().isMonotonic()) &#123;</span><br><span class="line">                    LogTimeEntry::unlock();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If the user changes the time in a gross manner that</span></span><br><span class="line">                <span class="comment">// invalidates the timeout, fall through and trigger.</span></span><br><span class="line">                <span class="function">log_time <span class="title">now</span><span class="params">(CLOCK_REALTIME)</span></span>;</span><br><span class="line">                <span class="comment">// 如果时间被修改，可能会导致 timeout 无效，用当前时间判断 timeout 是否还有效</span></span><br><span class="line">                <span class="comment">// 这里其实是一个bug，mEnd 是创建 entry 时的时间，而后面在使用 mTimeout 的时候，直</span></span><br><span class="line">                <span class="comment">// 接把它传递给了 pthread_cond_timedwait，也就是说， mTimeout 也是一个绝对时间</span></span><br><span class="line">                <span class="keyword">if</span> (((entry-&gt;mEnd + entry-&gt;mTimeout) &gt; now) &amp;&amp;</span><br><span class="line">                    (now &gt; entry-&gt;mEnd)) &#123;</span><br><span class="line">                    LogTimeEntry::unlock();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒读 log 线程</span></span><br><span class="line">            entry-&gt;triggerReader_Locked();</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;runningReader_Locked()) &#123;</span><br><span class="line">                <span class="comment">// 线程已经在运行，直接返回</span></span><br><span class="line">                LogTimeEntry::unlock();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有在创建是 entry 后，创建线程失败才会执行到这些，后面重新尝试启动线程</span></span><br><span class="line">            entry-&gt;incRef_Locked();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it == times.end()) &#123;</span><br><span class="line">        <span class="comment">// Create LogTimeEntry in notifyNewLog() ?</span></span><br><span class="line">        <span class="keyword">if</span> (mTail == (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">            LogTimeEntry::unlock();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        entry = <span class="keyword">new</span> LogTimeEntry(mReader, client, mNonBlock, mTail, mLogMask,</span><br><span class="line">                                 mPid, mStart, mTimeout);</span><br><span class="line">        times.push_front(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client-&gt;incRef();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release client and entry reference counts once done</span></span><br><span class="line">    entry-&gt;startReader_Locked();</span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>entry-&gt;startReader_Locked()</code> 会启动读 log 的线程，从 <code>LogBuffer</code> 读取 log 后写回客户端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogTimes.cpp</span></span><br><span class="line"><span class="keyword">void</span> LogTimeEntry::startReader_Locked(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    threadRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pthread_attr_init(&amp;attr)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pthread_create(&amp;mThread, &amp;attr, LogTimeEntry::threadStart,</span><br><span class="line">                                <span class="keyword">this</span>)) &#123;</span><br><span class="line">                pthread_attr_destroy(&amp;attr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line">    &#125;</span><br><span class="line">    threadRunning = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mClient) &#123;</span><br><span class="line">        mClient-&gt;decRef();</span><br><span class="line">    &#125;</span><br><span class="line">    decRef_Locked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑比较简单，读者自己看一看就好。</p>
<h2 id="log-读取线程"><a href="#log-读取线程" class="headerlink" title="log 读取线程"></a>log 读取线程</h2><p>现在，我们来看看上一节所启动的线程到底做了些什么工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogTimes.cpp</span></span><br><span class="line"><span class="keyword">void</span>* LogTimeEntry::threadStart(<span class="keyword">void</span>* obj) &#123;</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">"logd.reader.per"</span>);</span><br><span class="line"></span><br><span class="line">    LogTimeEntry* me = <span class="keyword">reinterpret_cast</span>&lt;LogTimeEntry*&gt;(obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个清理函数</span></span><br><span class="line">    pthread_cleanup_push(threadStop, obj);</span><br><span class="line"></span><br><span class="line">    SocketClient* client = me-&gt;mClient;</span><br><span class="line">    <span class="keyword">if</span> (!client) &#123;</span><br><span class="line">        me-&gt;error();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogBuffer&amp; logbuf = me-&gt;mReader.logbuf();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> privileged = FlushCommand::hasReadLogs(client);</span><br><span class="line">    <span class="keyword">bool</span> security = FlushCommand::hasSecurityLogs(client);</span><br><span class="line"></span><br><span class="line">    me-&gt;leadingDropped = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    lock();</span><br><span class="line"></span><br><span class="line">    log_time start = me-&gt;mStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (me-&gt;threadRunning &amp;&amp; !me-&gt;isError_Locked()) &#123;</span><br><span class="line">        <span class="comment">// 如果带 timeout，先睡 timeout 时长，再读 log</span></span><br><span class="line">        <span class="keyword">if</span> (me-&gt;mTimeout.tv_sec || me-&gt;mTimeout.tv_nsec) &#123;</span><br><span class="line">            <span class="comment">// LogBuffer::prune 可能会唤醒它，此时返回值不等于 ETIMEDOUT，下个循环还将继续</span></span><br><span class="line">            <span class="comment">// 等待 timeout 时长</span></span><br><span class="line">            <span class="keyword">if</span> (pthread_cond_timedwait(&amp;me-&gt;threadTriggeredCondition,</span><br><span class="line">                                       &amp;timesLock, &amp;me-&gt;mTimeout) == ETIMEDOUT) &#123;</span><br><span class="line">                <span class="comment">// 清零后，就不再执行这个操作了</span></span><br><span class="line">                me-&gt;mTimeout.tv_sec = <span class="number">0</span>;</span><br><span class="line">                me-&gt;mTimeout.tv_nsec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!me-&gt;threadRunning || me-&gt;isError_Locked()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unlock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mTail 表示读取最新的 mTail 条 log，为了达到这个目的，需要先遍历一遍</span></span><br><span class="line">        <span class="keyword">if</span> (me-&gt;mTail) &#123;</span><br><span class="line">            logbuf.flushTo(client, start, <span class="literal">nullptr</span>, privileged, security,</span><br><span class="line">                           FilterFirstPass, me);</span><br><span class="line">            me-&gt;leadingDropped = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实际的读取 log 操作</span></span><br><span class="line">        start = logbuf.flushTo(client, start, me-&gt;mLastTid, privileged,</span><br><span class="line">                               security, FilterSecondPass, me);</span><br><span class="line"></span><br><span class="line">        lock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果向客户端写回 log 数据失败，将返回 LogBufferElement::FLUSH_ERROR</span></span><br><span class="line">        <span class="keyword">if</span> (start == LogBufferElement::FLUSH_ERROR) &#123;</span><br><span class="line">            me-&gt;error_Locked();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        me-&gt;mStart = start + log_time(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mNonBlock 的情况下，读完当前的 log 后，就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (me-&gt;mNonBlock || !me-&gt;threadRunning || me-&gt;isError_Locked()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip 表示要跳过的 log 条数，我们刚读了所有的 log，skip 已经没有意义了</span></span><br><span class="line">        me-&gt;cleanSkip_Locked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!me-&gt;mTimeout.tv_sec &amp;&amp; !me-&gt;mTimeout.tv_nsec) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;me-&gt;threadTriggeredCondition, &amp;timesLock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行清理函数 threadStop </span></span><br><span class="line">    pthread_cleanup_pop(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假定 <code>mTail != 0</code>，这个时候会执行两次遍历操作。第一次遍历的回调函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogTimes.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A first pass to count the number of elements</span></span><br><span class="line"><span class="keyword">int</span> LogTimeEntry::FilterFirstPass(<span class="keyword">const</span> LogBufferElement* element, <span class="keyword">void</span>* obj) &#123;</span><br><span class="line">    LogTimeEntry* me = <span class="keyword">reinterpret_cast</span>&lt;LogTimeEntry*&gt;(obj);</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;leadingDropped) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element-&gt;getDropped()) &#123;</span><br><span class="line">            LogTimeEntry::unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        me-&gt;leadingDropped = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;mCount == <span class="number">0</span>) &#123;</span><br><span class="line">        me-&gt;mStart = element-&gt;getRealTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((!me-&gt;mPid || (me-&gt;mPid == element-&gt;getPid())) &amp;&amp;</span><br><span class="line">        (me-&gt;isWatching(element-&gt;getLogId()))) &#123;</span><br><span class="line">        ++me-&gt;mCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就跟函数的注释说的，这里就是计算所有复合条件的 log 的数目。</p>
<p>下面我们看第二个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogTimes.cpp</span></span><br><span class="line"><span class="comment">// A second pass to send the selected elements</span></span><br><span class="line"><span class="keyword">int</span> LogTimeEntry::FilterSecondPass(<span class="keyword">const</span> LogBufferElement* element, <span class="keyword">void</span>* obj) &#123;</span><br><span class="line">    LogTimeEntry* me = <span class="keyword">reinterpret_cast</span>&lt;LogTimeEntry*&gt;(obj);</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::lock();</span><br><span class="line"></span><br><span class="line">    me-&gt;mStart = element-&gt;getRealTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip 是在 LogBuffer::prune 里设置的，快速跳过对应的 log 项后，prune 就能够把他们</span></span><br><span class="line">    <span class="comment">// 释放掉了</span></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;skipAhead[element-&gt;getLogId()]) &#123;</span><br><span class="line">        me-&gt;skipAhead[element-&gt;getLogId()]--;</span><br><span class="line">        <span class="keyword">goto</span> skip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leading drop 其实是空的 log 项</span></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;leadingDropped) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element-&gt;getDropped()) &#123;</span><br><span class="line">            <span class="keyword">goto</span> skip;</span><br><span class="line">        &#125;</span><br><span class="line">        me-&gt;leadingDropped = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Truncate to close race between first and second pass</span></span><br><span class="line">    <span class="comment">// 总共只有 mCount 条 log，mIndex &gt;= mCount 表示已经没有更多的 log 了</span></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;mNonBlock &amp;&amp; me-&gt;mTail &amp;&amp; (me-&gt;mIndex &gt;= me-&gt;mCount)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> stop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!me-&gt;isWatching(element-&gt;getLogId())) &#123;</span><br><span class="line">        <span class="keyword">goto</span> skip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;mPid &amp;&amp; (me-&gt;mPid != element-&gt;getPid())) &#123;</span><br><span class="line">        <span class="keyword">goto</span> skip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;isError_Locked()) &#123;</span><br><span class="line">        <span class="keyword">goto</span> stop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!me-&gt;mTail) &#123;</span><br><span class="line">        <span class="keyword">goto</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++me-&gt;mIndex;</span><br><span class="line">    <span class="comment">// 我们只需要读取 mTail 条 log，所以忽略前面的 mCount - mTail 条 log</span></span><br><span class="line">    <span class="keyword">if</span> ((me-&gt;mCount &gt; me-&gt;mTail) &amp;&amp; (me-&gt;mIndex &lt;= (me-&gt;mCount - me-&gt;mTail))) &#123;</span><br><span class="line">        <span class="keyword">goto</span> skip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!me-&gt;mNonBlock) &#123;</span><br><span class="line">        me-&gt;mTail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">    <span class="keyword">if</span> (!me-&gt;skipAhead[element-&gt;getLogId()]) &#123;</span><br><span class="line">        LogTimeEntry::unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// FALLTHRU</span></span><br><span class="line"></span><br><span class="line">skip:</span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程清理函数比较简单，就不看了。</p>
<h2 id="读取-log"><a href="#读取-log" class="headerlink" title="读取 log"></a>读取 log</h2><p>现在，是时候看看那个神秘的 <code>LogBuffer::flushTo</code> 了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line">log_time LogBuffer::flushTo(SocketClient* reader, <span class="keyword">const</span> log_time&amp; start,</span><br><span class="line">                            <span class="keyword">pid_t</span>* lastTid, <span class="keyword">bool</span> privileged, <span class="keyword">bool</span> security,</span><br><span class="line">                            <span class="keyword">int</span> (*filter)(<span class="keyword">const</span> LogBufferElement* element,</span><br><span class="line">                                          <span class="keyword">void</span>* arg),</span><br><span class="line">                            <span class="keyword">void</span>* arg) &#123;</span><br><span class="line">    LogBufferElementCollection::iterator it;</span><br><span class="line">    <span class="keyword">uid_t</span> uid = reader-&gt;getUid();</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mLogElementsLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 start 参数找到开始迭代的地方</span></span><br><span class="line">    <span class="keyword">if</span> (start == log_time::EPOCH) &#123;</span><br><span class="line">        <span class="comment">// client wants to start from the beginning</span></span><br><span class="line">        it = mLogElements.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3 second limit to continue search for out-of-order entries.</span></span><br><span class="line">        log_time min = start - pruneMargin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cap to 300 iterations we look back for out-of-order entries.</span></span><br><span class="line">        <span class="keyword">size_t</span> count = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Client wants to start from some specified time. Chances are</span></span><br><span class="line">        <span class="comment">// we are better off starting from the end of the time sorted list.</span></span><br><span class="line">        LogBufferElementCollection::iterator last;</span><br><span class="line">        <span class="keyword">for</span> (last = it = mLogElements.end(); it != mLogElements.begin();</span><br><span class="line">             <span class="comment">/* do nothing */</span>) &#123;</span><br><span class="line">            --it;</span><br><span class="line">            LogBufferElement* element = *it;</span><br><span class="line">            <span class="keyword">if</span> (element-&gt;getRealTime() &gt; start) &#123;</span><br><span class="line">                last = it;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!--count || (element-&gt;getRealTime() &lt; min)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_time max = start;</span><br><span class="line"></span><br><span class="line">    LogBufferElement* lastElement = <span class="literal">nullptr</span>;  <span class="comment">// iterator corruption paranoia</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxSkip = <span class="number">4194304</span>;    <span class="comment">// maximum entries to skip</span></span><br><span class="line">    <span class="keyword">size_t</span> skip = maxSkip;</span><br><span class="line">    <span class="keyword">for</span> (; it != mLogElements.end(); ++it) &#123;</span><br><span class="line">        LogBufferElement* element = *it;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!--skip) &#123;</span><br><span class="line">            android::prdebug(<span class="string">"reader.per: too many elements skipped"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (element == lastElement) &#123;</span><br><span class="line">            android::prdebug(<span class="string">"reader.per: identical elements"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastElement = element;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!privileged &amp;&amp; (element-&gt;getUid() != uid)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!security &amp;&amp; (element-&gt;getLogId() == LOG_ID_SECURITY)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (element-&gt;getRealTime() &lt;= start) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// filter 就是我们前面多次传递进来的函数</span></span><br><span class="line">        <span class="comment">// 1. 返回 true 表示写回该 log 项</span></span><br><span class="line">        <span class="comment">// 2. false 表示忽略</span></span><br><span class="line">        <span class="comment">// 3. 其他值则结束迭代</span></span><br><span class="line">        <span class="comment">// NB: calling out to another object with mLogElementsLock held (safe)</span></span><br><span class="line">        <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = (*filter)(element, arg);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> sameTid = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (lastTid) &#123;</span><br><span class="line">            sameTid = lastTid[element-&gt;getLogId()] == element-&gt;getTid();</span><br><span class="line">            <span class="comment">// Dropped (chatty) immediately following a valid log from the</span></span><br><span class="line">            <span class="comment">// same source in the same log buffer indicates we have a</span></span><br><span class="line">            <span class="comment">// multiple identical squash.  chatty that differs source</span></span><br><span class="line">            <span class="comment">// is due to spam filter.  chatty to chatty of different</span></span><br><span class="line">            <span class="comment">// source is also due to spam filter.</span></span><br><span class="line">            lastTid[element-&gt;getLogId()] =</span><br><span class="line">                (element-&gt;getDropped() &amp;&amp; !sameTid) ? <span class="number">0</span> : element-&gt;getTid();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里把单个 log 项的数据写回客户端</span></span><br><span class="line">        <span class="comment">// range locking in LastLogTimes looks after us</span></span><br><span class="line">        max = element-&gt;flushTo(reader, <span class="keyword">this</span>, privileged, sameTid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (max == element-&gt;FLUSH_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skip = maxSkip;</span><br><span class="line">        pthread_mutex_lock(&amp;mLogElementsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们看看 <code>LogBufferElement::flushTo</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBufferElement.cpp</span></span><br><span class="line">log_time LogBufferElement::flushTo(SocketClient* reader, LogBuffer* parent,</span><br><span class="line">                                   <span class="keyword">bool</span> privileged, <span class="keyword">bool</span> lastSame) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">logger_entry_v4</span> <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;entry, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct logger_entry_v4));</span><br><span class="line"></span><br><span class="line">    entry.hdr_size = privileged ? <span class="keyword">sizeof</span>(struct logger_entry_v4)</span><br><span class="line">                                : <span class="keyword">sizeof</span>(struct logger_entry_v3);</span><br><span class="line">    entry.lid = mLogId;</span><br><span class="line">    entry.pid = mPid;</span><br><span class="line">    entry.tid = mTid;</span><br><span class="line">    entry.uid = mUid;</span><br><span class="line">    entry.sec = mRealTime.tv_sec;</span><br><span class="line">    entry.nsec = mRealTime.tv_nsec;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec</span>[2];</span></span><br><span class="line">    iovec[<span class="number">0</span>].iov_base = &amp;entry;</span><br><span class="line">    iovec[<span class="number">0</span>].iov_len = entry.hdr_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mMsg) &#123;</span><br><span class="line">        entry.len = populateDroppedMessage(buffer, parent, lastSame);</span><br><span class="line">        <span class="keyword">if</span> (!entry.len) <span class="keyword">return</span> mRealTime;</span><br><span class="line">        iovec[<span class="number">1</span>].iov_base = buffer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry.len = mMsgLen;</span><br><span class="line">        iovec[<span class="number">1</span>].iov_base = mMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    iovec[<span class="number">1</span>].iov_len = entry.len;</span><br><span class="line"></span><br><span class="line">    log_time retval = reader-&gt;sendDatav(iovec, <span class="number">1</span> + (entry.len != <span class="number">0</span>))</span><br><span class="line">                          ? FLUSH_ERROR</span><br><span class="line">                          : mRealTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer) <span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们需要将多个缓冲的数据写回客户端，这里使用是是 <code>writev</code>。实际的数据写入在 <code>SocketClient</code> 中实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libsysutils/src/SocketClient.cpp</span></span><br><span class="line"><span class="keyword">int</span> SocketClient::sendDatav(struct iovec *iov, <span class="keyword">int</span> iovcnt) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mWriteMutex);</span><br><span class="line">    <span class="keyword">int</span> rc = sendDataLockedv(iov, iovcnt);</span><br><span class="line">    pthread_mutex_unlock(&amp;mWriteMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SocketClient::sendDataLockedv(struct iovec *iov, <span class="keyword">int</span> iovcnt) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSocket &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errno = EHOSTUNREACH;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iovcnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>; <span class="comment">// SLOGW and sigaction are not inert regarding errno</span></span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当向一个写入端已经被关闭的 socket 写入数据的时候，内核会发送 SIGPIPE，</span></span><br><span class="line">    <span class="comment">// 默认的行为是结束进程。这里我们要忽略它</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">new_action</span>, <span class="title">old_action</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;new_action, <span class="number">0</span>, <span class="keyword">sizeof</span>(new_action));</span><br><span class="line">    new_action.sa_handler = SIG_IGN;</span><br><span class="line">    sigaction(SIGPIPE, &amp;new_action, &amp;old_action);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> rc = TEMP_FAILURE_RETRY(</span><br><span class="line">            writev(mSocket, iov + current, iovcnt - current));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> written = rc;</span><br><span class="line">            <span class="comment">// 可能只是部分写入了数据。逐个检查那些已经写入成功的 iov</span></span><br><span class="line">            <span class="keyword">while</span> ((current &lt; iovcnt) &amp;&amp; (written &gt;= iov[current].iov_len)) &#123;</span><br><span class="line">                written -= iov[current].iov_len;</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current == iovcnt) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这个 iov 有部分数据已经写入</span></span><br><span class="line">            iov[current].iov_base = (<span class="keyword">char</span> *)iov[current].iov_base + written;</span><br><span class="line">            iov[current].iov_len -= written;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            e = EIO;</span><br><span class="line">            SLOGW(<span class="string">"0 length write :("</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            e = errno;</span><br><span class="line">            SLOGW(<span class="string">"write error (%s)"</span>, strerror(e));</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGPIPE, &amp;old_action, &amp;new_action);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="number">0</span>) &#123;</span><br><span class="line">        errno = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，恭喜你，log 数据的读取到这里就结束了。</p>
<p><br><br></p>
</div><div class="tags"><a href="/tags/Android-source/">Android source</a><a href="/tags/logd/">logd</a></div><div class="post-nav"><a class="pre" href="/2018/06/08/glide-disk-cache/">Glide 源码分析(1) - DiskCache 详解</a><a class="next" href="/2018/05/17/logd-prune/">Android log 机制 - 删除过多的 log</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://jekton.github.io/2018/05/25/logd-reading/';
    this.page.identifier = '2018/05/25/logd-reading/';
    this.page.title = 'Android log 机制 - 读取 logd 中的 log 数据';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jekton-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jekton-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jekton-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">31</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dart/">Dart</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/parallel-programming/" style="font-size: 15px;">parallel-programming</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/Android-arch/" style="font-size: 15px;">Android arch</a> <a href="/tags/ProcessLifecycleOwner/" style="font-size: 15px;">ProcessLifecycleOwner</a> <a href="/tags/Dart/" style="font-size: 15px;">Dart</a> <a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/Android-source/" style="font-size: 15px;">Android source</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/openjdk/" style="font-size: 15px;">openjdk</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/logd/" style="font-size: 15px;">logd</a> <a href="/tags/Glide/" style="font-size: 15px;">Glide</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/native-crash/" style="font-size: 15px;">native-crash</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/21/android-jetpack-ProcessLifecycleOwner/">Android 源码秘密（1）—— ProcessLifecycleOwner</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/28/android-fragment-pitfall/">Fragment 使用陷阱</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/08/android-scrollview-impl/">ScrollView 实现指北</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/26/java-multi-singleton/">如何使用 Java 和 double-check 实现支持多实例的单例</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/native-crash-catching/">Android native 崩溃信息捕获实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/android9-lmk-lmkd/">Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/android9-logd-init/">Android P 源码分析 4 - logd 的初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/19/android9-sp/">Android P 源码分析 3 - SharedPreferences 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/android9-sp-wp/">Android P 源码分析 2 - 强弱指针的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/android9-light-sp/">Android P 源码分析 1 - 轻量级智能指针的实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jekton-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">程序员虾饺.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>