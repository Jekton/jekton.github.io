<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员虾饺</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jekton.github.io/"/>
  <updated>2020-01-21T00:16:37.705Z</updated>
  <id>https://jekton.github.io/</id>
  
  <author>
    <name>Jekton</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 源码秘密（1）—— ProcessLifecycleOwner</title>
    <link href="https://jekton.github.io/2020/01/21/android-jetpack-ProcessLifecycleOwner/"/>
    <id>https://jekton.github.io/2020/01/21/android-jetpack-ProcessLifecycleOwner/</id>
    <published>2020-01-21T00:22:18.000Z</published>
    <updated>2020-01-21T00:16:37.705Z</updated>
    
    <content type="html"><![CDATA[<p>尝试过事无巨细一行一行代码分析源码，也试过以感性的方式总结源码；第一种方式总觉得容易把读者绕进去，第二种则有些人看后觉得好像什么也没说。这里我尝试使用第三种方法，回到我们阅读源码的初衷——学习如何写代码，只是摘抄出源码里有教寓意义的片段，来展示它所使用的小技巧。</p><h2 id="如何无侵入地初始化库程序"><a href="#如何无侵入地初始化库程序" class="headerlink" title="如何无侵入地初始化库程序"></a>如何无侵入地初始化库程序</h2><p>通常情况下，如果我们的库函数需要在使用前先初始化一次，会对外保留一个 <code>init</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLibrary.init(context);</span><br></pre></td></tr></table></figure><p>这种方法会带来一个问题，那就是 <code>Application</code> 的 <code>onCreate</code> 会堆了好多 <code>xxx.init</code>；此外如果用户忘记调用 <code>init</code>，也会出现一些问题。下面我们看看 <code>ProcessLifecycleOwner</code> 是如何解决这个问题的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleOwnerInitializer</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LifecycleDispatcher.init(getContext());</span><br><span class="line">        ProcessLifecycleOwner.init(getContext());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过注册一个 <code>ContentProvider</code>，可以保证在进程启动的时候 <code>onCreate</code> 被调用，如此一来即可以实现无侵入式的初始化。当然，要承担一点点 <code>ContentProvider</code> 带来的成本，用户也没办法进行延迟初始化。</p><h2 id="context-getApplicationContext-返回的是什么"><a href="#context-getApplicationContext-返回的是什么" class="headerlink" title="context.getApplicationContext() 返回的是什么"></a>context.getApplicationContext() 返回的是什么</h2><p>我们顺着这个 <code>init</code> 调用看看 <code>ProcessLifecycleOwner</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleOwner</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        sInstance.attach(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Application app = (Application) context.getApplicationContext();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>androidx 里强制把 <code>context.getApplicationContext()</code> 的返回值强制转换为了 <code>Application</code>，从实用主义的角度，我们有理由相信，至少短时间内，<code>context.getApplicationContext()</code> 返回的就是 <code>Application</code> 实例。</p><h2 id="Android-10-的-Application-ActivityLifecycleCallbacks"><a href="#Android-10-的-Application-ActivityLifecycleCallbacks" class="headerlink" title="Android 10 的 Application.ActivityLifecycleCallbacks"></a>Android 10 的 Application.ActivityLifecycleCallbacks</h2><p>我们继续往下看，会发现 <code>ActivityLifecycleCallbacks</code> 在 Android 10 多了不少新的生命周期回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleOwner</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        Application app = (Application) context.getApplicationContext();</span><br><span class="line">        app.registerActivityLifecycleCallbacks(<span class="keyword">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreCreated</span><span class="params">(@NonNull Activity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">                    @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">                activity.registerActivityLifecycleCallbacks(<span class="keyword">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostStarted</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">                        activityStarted();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostResumed</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">                        activityResumed();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">                    ReportFragment.get(activity).setProcessListener(mInitializationListener);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                activityPaused();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                activityStopped();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，主要是多出了 Pre/Post 回调，用于在特定生命周期的前面/后面执行一些操作。后面我们还会看到，在没有系统支持的情况下，要实现这个功能还是挺折腾的。</p><p><code>onActivityPreCreated</code> 是 Android 10 新增的接口，在 10 以下不会被调用，低版本的 <code>onActivityPostStarted</code> 和 <code>onActivityPostResumed</code> 通过一个辅助的 <code>ReportFragment</code> 来间接获取。</p><h2 id="如何保证每个-activity-都有一个-ReportFragment"><a href="#如何保证每个-activity-都有一个-ReportFragment" class="headerlink" title="如何保证每个 activity 都有一个 ReportFragment"></a>如何保证每个 activity 都有一个 ReportFragment</h2><p><code>ReportFragment</code> 有一个 <code>injectIfNeededIn</code> 静态方法，用来给 <code>activity</code> 实例注入一个 <code>reportFragment</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">            <span class="comment">// On API 29+, we can register for the correct Lifecycle callbacks directly</span></span><br><span class="line">            activity.registerActivityLifecycleCallbacks(</span><br><span class="line">                    <span class="keyword">new</span> LifecycleCallbacks());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Prior to API 29 and to maintain compatibility with older versions of</span></span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and</span></span><br><span class="line">        <span class="comment">// need to support activities that don't extend from FragmentActivity from support lib),</span></span><br><span class="line">        <span class="comment">// use a framework fragment to get the correct timing of Lifecycle events</span></span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了一个我们不太常见的调用 <code>executePendingTransactions</code>，它可以立即执行一个 <code>fragmentTransaction</code>，这样一来，即使<em>连续多次调用</em>，在第一次执行后，紧接着的调用也能 find 到刚刚添加的实例。（如果没有 <code>executePendingTransactions</code>，会添加多个 <code>reportFragment</code>）</p><p>调用 <code>injectIfNeededIn</code> 的地方一共有三个：</p><ol><li><code>LifecycleDispatcher</code> 里注册的 <code>ActivityLifecycleCallbacks</code> 在 <code>onActivityCreated</code> 的时候调用一次</li><li><code>androidx.activity.ComponentActivity</code> 和 <code>androidx.core.app.ComponentActivity</code> 的 <code>onCreate</code>；其中，前者继承了后者</li></ol><p>由于在 <code>Activity.onCreate</code> 里最终会调用到 <code>ActivityLifecycleCallbacks.onActivityCreated</code>，这里其实我们只需要第一个。是否有重复调用问题影响不大，这里就不纠结了。</p><h2 id="如何在-Android-10-以下获取-onActivityPostStarted-事件"><a href="#如何在-Android-10-以下获取-onActivityPostStarted-事件" class="headerlink" title="如何在 Android 10 以下获取 onActivityPostStarted 事件"></a>如何在 Android 10 以下获取 onActivityPostStarted 事件</h2><p>了解了 <code>ReportFragment</code> 后，我们现在可以来看看 <code>onActivityPostStarted</code> 是如何在低于 Android 10 的系统实现的。需要说明的是，我们前面通过 <code>application</code> 注册的回调的 <code>onActivityStarted</code> 是在 <code>Activity.onStart</code> 里调用的，如果我们想要在 <code>onStart</code> 这个生命周期函数完全执行后再做一些操作，就不能直接使用 <code>onActivityStarted</code>；当然，Android 10 以后可以使用 <code>onActivityPostStarted</code>。</p><p>为了获取 <code>onActivityPostStarted</code>，需要借助前面我们提到的 <code>ReportFragment</code>，当 api level 小于 29 时，我们设置了 processListener：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleOwner</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        Application app = (Application) context.getApplicationContext();</span><br><span class="line">        app.registerActivityLifecycleCallbacks(<span class="keyword">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">                    ReportFragment.get(activity).setProcessListener(mInitializationListener);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityInitializationListener mProcessListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProcessListener</span><span class="params">(ActivityInitializationListener processListener)</span> </span>&#123;</span><br><span class="line">        mProcessListener = processListener;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后，在 <code>fragment</code> 对应的生命周期回调我们就可以拿到所需的那个 <code>onActivityPostStarted</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也提示我们，<code>Fragment</code> 的 <code>onStart</code> 会在 <code>Activity</code> 的 <code>onStart</code> <strong>后面</strong>执行。此外，<code>onResume</code> 的情况也一样。至于其他生命周期函数的调用顺序，后面 lifecycle 的时候我们再研究了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;尝试过事无巨细一行一行代码分析源码，也试过以感性的方式总结源码；第一种方式总觉得容易把读者绕进去，第二种则有些人看后觉得好像什么也没说。这里我尝试使用第三种方法，回到我们阅读源码的初衷——学习如何写代码，只是摘抄出源码里有教寓意义的片段，来展示它所使用的小技巧。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android arch" scheme="https://jekton.github.io/tags/Android-arch/"/>
    
      <category term="ProcessLifecycleOwner" scheme="https://jekton.github.io/tags/ProcessLifecycleOwner/"/>
    
  </entry>
  
  <entry>
    <title>Fragment 使用陷阱</title>
    <link href="https://jekton.github.io/2019/10/28/android-fragment-pitfall/"/>
    <id>https://jekton.github.io/2019/10/28/android-fragment-pitfall/</id>
    <published>2019-10-28T14:10:46.000Z</published>
    <updated>2019-10-28T13:25:56.289Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要总结过去在项目里遇到的由于 <code>Fragment</code> 误用带来的一些问题，不涉及 <code>Fragment</code> 的具体用法。这里说的 <code>Fragment</code> 带来的问题，基本是由 <code>Activity</code> 被系统销毁后自动重新创建所引发的。下面我们从 <code>Fragment</code> 的基本使用、参数传递和 <code>ViewPager</code> 的交互这三个方面来分别讨论。</p><h2 id="Fragment-的基本使用"><a href="#Fragment-的基本使用" class="headerlink" title="Fragment 的基本使用"></a><code>Fragment</code> 的基本使用</h2><p>使用 <code>Fragment</code> 的一种很常见的用法是，通过 <code>FragmentManager</code> 把一个实例添加到 view 里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        FragmentManager manager = getSupportFragmentManager();</span><br><span class="line">        FragmentTransaction transaction = manager.beginTransaction();</span><br><span class="line">        transaction.replace(R.id.container, <span class="keyword">new</span> YourFragment());</span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在继续往下看之前，请读者先想想，这段代码有什么问题？（后面基本都遵循这一个模式，先给出有问题的代码，然后说明问题，再解决它）</p><p>一开始我们就提到过，<code>Fragment</code> 带来的问题基本上都跟 <code>Activity</code> 重建有关。在这个例子中，<code>Activity</code> 重建时，系统会自动帮我们恢复 <code>Fragment</code>（<code>super.onCreate</code>），接下来我们自己又创建了一个新的实例，然后把系统创建的那个 replace 掉。表面上程序运行正常，实际上我们自己创建的那个 <code>Fragment</code> 是不必要的。正确的做法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FragmentManager manager = getSupportFragmentManager();</span><br><span class="line"><span class="keyword">if</span> (manager.findFragmentById(R.id.container) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    FragmentTransaction transaction = manager.beginTransaction();</span><br><span class="line">    transaction.replace(R.id.container, <span class="keyword">new</span> YourFragment());</span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，直接把 <code>Fragment</code> 写在 xml 里面不会有这个问题，即便 <code>onCreate</code> 的时候我们总是调用 <code>setContentView</code>。我们有理由推断，这种情况下他也使用了类似的方法来防止重复创建 fragment，因为它要求我们给 <code>&lt;fragment&gt;</code> 加一个 id 或 tag，否则将会有一个 warning。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>如果是普通的类，一般我们可以这样传参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeFragment</span> </span>&#123;</span><br><span class="line">    Foo mFoo;</span><br><span class="line">    Bar mBar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFoo</span><span class="params">(Foo foo)</span> </span>&#123; mFoo = foo; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBar</span><span class="params">(Bar bar)</span> </span>&#123; mBar = bar; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeFragment</span> </span>&#123;</span><br><span class="line">    Foo mFoo;</span><br><span class="line">    Bar mBar;</span><br><span class="line"></span><br><span class="line">    SomeFragment(Foo foo, Bar bar) &#123;</span><br><span class="line">        mFoo = foo;</span><br><span class="line">        mBar = bar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遗憾的是，对 <code>Fragment</code> 来说，这都是有问题的。对于第二个，还会有警告说，<code>Fragment</code> 应该有无参的构造函数。之所以要求 <code>Fragment</code> 的构造函数不带参数，是因为系统恢复它时，使用的就是无参构造函数。</p><p>和第一个例子差不多，当 <code>Fragment</code> 由系统创建的时候，<code>mFoo</code> 和 <code>mBar</code> 都会是 <code>null</code>。正确的做法应该是使用 <code>setArgument</code> 来传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> YourFragment <span class="title">makeInstance</span><span class="params">(<span class="comment">/* param0, param1, ... */</span>)</span> </span>&#123;</span><br><span class="line">        YourFragment fragment = <span class="keyword">new</span> YourFragment();</span><br><span class="line">        Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">        <span class="comment">// args.putXXX</span></span><br><span class="line">        fragment.setArguments(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        Bundle args = getArguments();</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// unpack arguments</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，即便是系统恢复 <code>Activity</code> 时自动创建的 <code>Fragment</code>，也可以 get 到原来设置的参数（不需要在 <code>onSaveInstanceState</code> 的时候保存）。当然，有些数据可能不适合放在 <code>Bundle</code> 里，这个时候可以另外用一个 <code>setRetainInstance(true)</code> 的 <code>fragment</code> 来保存（或者用 <code>ViewModel</code>）。</p><h2 id="与-ViewPager-的交互"><a href="#与-ViewPager-的交互" class="headerlink" title="与 ViewPager 的交互"></a>与 <code>ViewPager</code> 的交互</h2><p>看下面一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomePagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Fragment[] mFragments = <span class="keyword">new</span> Fragment[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomePagerAdapter</span><span class="params">(FragmentManager fm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFragments[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mFragments[i] = createFragment(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mFragments[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Fragment <span class="title">createFragment</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fragment1();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fragment2();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fragment3();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFragments.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码的问题跟前面两个比起来隐晦得多，也不是所有这样写的代码都会出问题。某些情况下，比方说，用户触发了某个动作后，我们想获取当前的 <code>fragment</code> 并做一些操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Fragment fragment = mPagerAdapter.getItem(mViewPager.getCurrentItem());</span><br><span class="line">    fragment.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再假设 <code>bar()</code> 方法里调用了 <code>getActivity()</code>，这样，线上就会出现当前 <code>fragment</code> 的 <code>getActivity</code> 竟然返回 <code>null</code> 的崩溃……</p><p>这个时候我们开始推断：用户触发动作（比方说按钮点击），说明 view 已经创建完成并且是可用的，这说明 fragment 肯定是 attach 过的；这样一来，<code>getActivity</code> 不可能为空。。。（此处需要一个抓狂的表情）</p><p>哎，肯定是用户的手机出了什么毛病，加个判断保护一下好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fragment1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Activity activity = getActivity();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对了，别忘记给所有 <code>getActivity</code> 都加上判空。</p><p>这里说个题外话，如果 <code>getActivity</code> 真的需要在每个地方都加上判空，那么在 <code>Fragment</code> 中定义的时候，就应该加上 <code>@Nullable</code>。只是在很多情况下，我们使用它的时候是明确知道不会为空的（比如我们例子中的情形），此时加上判空只会让代码更难理解。这应该也是它没有加 <code>@Nullable</code> 的原因。</p><p>如果你厌倦了给每个 <code>getActivity</code> 加判空，下面我们来真正解决他。和文章开头说的一样，遇到这些没走生命周期的 fragment，首先我们就需要怀疑是不是发生了 activity 的重建。按照前面我们说的，如果 activity 重建，系统会自动帮我们恢复所有的 fragment。这样一来，adapter 就不应该再创建 fragment 了。</p><p>我们可以通过 <code>FragmentPagerAdapter</code> 的 <code>instantiateItem</code> 来确认这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentPagerAdapter</span> <span class="keyword">extends</span> <span class="title">PagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> itemId = getItemId(position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do we already have this fragment?</span></span><br><span class="line">        String name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">        Fragment fragment = mFragmentManager.findFragmentByTag(name);</span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Attaching item #"</span> + itemId + <span class="string">": f="</span> + fragment);</span><br><span class="line">            mCurTransaction.attach(fragment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fragment = getItem(position);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Adding item #"</span> + itemId + <span class="string">": f="</span> + fragment);</span><br><span class="line">            mCurTransaction.add(container.getId(), fragment,</span><br><span class="line">                    makeFragmentName(container.getId(), itemId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">            fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">            fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在调用 <code>getItem</code> 前，它会先 <code>findFragmentByTag</code>。显然，在 activity 重建的情况下，<code>findFragmentByTag</code> 会返回系统创建的那个 fragment。而后，在上面的例子中，当用户触发了 <code>bar</code> 的执行时，我们调用 <code>getItem</code> 创建了一个新的 fragment，这个新创建的 fragment 并没有 attach 到 activity，所以它的 <code>getActivity</code> 返回 <code>null</code> 也就不奇怪了。</p><p>现在，我们有足够的理由说，adapter 的最佳实践应该是， <code>getItem</code> 总返回一个新创建的 fragment（如果它叫 makeItem、createItem，就不会有这么多麻烦事了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomePagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Fragment[] mFragments = <span class="keyword">new</span> Fragment[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomePagerAdapter</span><span class="params">(FragmentManager fm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(@NonNull ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">super</span>.instantiateItem(container, position);</span><br><span class="line">        mFragments[position] = (Fragment) object;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getFragment</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFragments[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fragment1();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fragment2();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fragment3();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFragments.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为一个妥协，我们把父类 <code>instantiateItem</code> 返回的 fragment 缓存了起来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章主要总结过去在项目里遇到的由于 &lt;code&gt;Fragment&lt;/code&gt; 误用带来的一些问题，不涉及 &lt;code&gt;Fragment&lt;/code&gt; 的具体用法。这里说的 &lt;code&gt;Fragment&lt;/code&gt; 带来的问题，基本是由 &lt;code&gt;Activity&lt;
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://jekton.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ScrollView 实现指北</title>
    <link href="https://jekton.github.io/2019/07/08/android-scrollview-impl/"/>
    <id>https://jekton.github.io/2019/07/08/android-scrollview-impl/</id>
    <published>2019-07-08T01:08:47.000Z</published>
    <updated>2019-07-10T11:43:00.709Z</updated>
    
    <content type="html"><![CDATA[<p>在这之前，好几次想了解 <code>ScrollView</code> 实现，粗略翻翻，每次都没抓到要点；又实在没有非常迫切的需求，也就没有花太多心思了。最近工作上有个任务需要类似 <code>ScrollView</code> 的实现，只得下功夫研究一翻，于是有了这篇小短文。</p><p>首先要澄清的是，我不打算去分析 <code>ScrollView</code> 的源码，我们的目的只是为了弄清楚他最根本的实现方式。另外，涉及 <code>View</code> 的绘制时，也仅仅当他是一个黑盒，我们将会了解到如何使用 <code>View</code> 提供的 API 来实现自己的 scroll view。</p><p>对 <code>ScrollView</code> 来说，核心的有两部分 —— 滑动和绘制。滑动指竖直或水平的滚动；绘制则是说，子 view 只绘制一遍，每次滑动后，虽然可视内容变化了，子 view 的 <code>onDraw</code> 并不需要重新执行。下面我们分两小节来看看他们的实现。</p><h3 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h3><p>如果你对 UI 比较熟悉，又或者曾经粗略浏览过 <code>ScrollView</code> 的源码，应该不难猜到滑动的实现。其实他滑动的就是 <code>View#scrollTo/scrollBy</code>。此外，如果需要 fling，<code>OverScroller</code> 可以帮上大忙。</p><p>现在（虽然还没写几个字），你不妨打开电脑：</p><ol><li>创建一个类 <code>MyScrollView</code> 并让他继承 <code>LinearLayout</code></li><li>设置 <code>orientation</code> 为 <code>vertical</code>，并添加上足够多的 <code>TextView</code></li><li>在竖直滑动的时候，调用 <code>scrollBy</code> 滑动内容；检测滑动最简单的方式就是使用 <code>GestureDetector</code> 了</li><li>滑动的边界可以先忽略（滑动到哪里需要停止）</li></ol><p>如果你的实现没问题，应该可以流畅地对 view 的内容进行滑动。唯一的问题是，滑出来的区域是空白的。不要慌，下面我们就来解决它。</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>老实说，<code>ScrollView</code> 的绘制这个问题困扰了我挺久，每次看他的源码，都找不到原因；这次因为一个偶然的机会，才发现了他的奥秘。</p><p>当我们把一个 <code>LinearLayout</code> 嵌在 <code>ScrollView</code> 里面的时候，<code>onMeasure</code> 拿到的高度是 unspecified 的，最后 <code>LinearLayout</code> 得到的高度会超过 <code>ScrollView</code>，并在绘制的时候把所有的内容都一次性绘制出来。具体的验证方法是，我们继承 <code>LinearLayout</code>，并把他嵌在 <code>ScrollView</code>，然后重写 <code>onMeasure</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    Log.d(<span class="string">"Jekton"</span>, TAG + <span class="string">".onMeasure: mode = "</span> + MeasureSpec.getMode(heightMeasureSpec) +</span><br><span class="line">            <span class="string">", size = "</span> + MeasureSpec.getSize(heightMeasureSpec));</span><br><span class="line">    Log.d(<span class="string">"Jekton"</span>, TAG + <span class="string">".onMeasure: mode = "</span> + MeasureSpec.getMode(heightMeasureSpec) +</span><br><span class="line">            <span class="string">", size = "</span> + MeasureSpec.getSize(heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 measure 这一步，<code>ScrollView</code> 实际上什么也没做，它继承了 <code>FrameLayout</code>，这些工作是父类帮它完成的。也就是说，如果我们需要实现自己的 scroll view，最简单的方法就是继承 <code>FrameLayout</code>。</p><p>现在，我们知道了 <code>LinearLayout</code> measure 的高度大于可见区域高度，下面需要解决的问题是如何绘制超出屏幕的内容。老样子，我们继续重写 <code>LinearLayout</code> 的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    Log.d(<span class="string">"Jekton"</span>, TAG + <span class="string">".dispatchDraw: "</span> + canvas + <span class="string">", "</span> + canvas.getWidth() +</span><br><span class="line">            <span class="string">"-"</span> + canvas.getHeight(), <span class="keyword">new</span> RuntimeException());</span><br><span class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是我手机的一个打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">D/Jekton: MyLinearLayout.onMeasure: mode = 0, size = 1552</span><br><span class="line">D/Jekton: MyLinearLayout.onMeasure: 3024</span><br><span class="line">D/Jekton: MyLinearLayout.dispatchDraw: android.view.DisplayListCanvas@fe4d0c5, 1080-3024</span><br><span class="line">    java.lang.RuntimeException</span><br><span class="line">        at com.example.ashmemdemo.MyLinearLayout.dispatchDraw(MyLinearLayout.java:37)</span><br><span class="line">        at android.view.View.updateDisplayListIfDirty(View.java:18241)</span><br><span class="line">        at android.view.View.draw(View.java:19042)</span><br><span class="line">        at android.view.ViewGroup.drawChild(ViewGroup.java:4271)</span><br><span class="line">        at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4054)</span><br><span class="line">        at android.view.View.draw(View.java:19317)</span><br><span class="line">        at android.widget.ScrollView.draw(ScrollView.java:1777)</span><br><span class="line">        at android.view.View.updateDisplayListIfDirty(View.java:18250)</span><br><span class="line">        at android.view.View.draw(View.java:19042)</span><br><span class="line">        at android.view.ViewGroup.drawChild(ViewGroup.java:4271)</span><br><span class="line">        at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4054)</span><br><span class="line">        at android.view.View.updateDisplayListIfDirty(View.java:18241)</span><br><span class="line">        at android.view.View.draw(View.java:19042)</span><br><span class="line">        at android.view.ViewGroup.drawChild(ViewGroup.java:4271)</span><br><span class="line">        at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4054)</span><br><span class="line">        at android.view.View.updateDisplayListIfDirty(View.java:18241)</span><br><span class="line">        at android.view.View.draw(View.java:19042)</span><br><span class="line">        at android.view.ViewGroup.drawChild(ViewGroup.java:4271)</span><br><span class="line">        at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4054)</span><br><span class="line">        at android.view.View.updateDisplayListIfDirty(View.java:18241)</span><br><span class="line">        at android.view.View.draw(View.java:19042)</span><br><span class="line">        at android.view.ViewGroup.drawChild(ViewGroup.java:4271)</span><br><span class="line">        at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4054)</span><br><span class="line">        at android.view.View.updateDisplayListIfDirty(View.java:18241)</span><br><span class="line">        at android.view.View.draw(View.java:19042)</span><br><span class="line">        at android.view.ViewGroup.drawChild(ViewGroup.java:4271)</span><br><span class="line">        at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4054)</span><br><span class="line">        at android.view.View.draw(View.java:19317)</span><br><span class="line">        at com.android.internal.policy.DecorView.draw(DecorView.java:915)</span><br><span class="line">        at android.view.View.updateDisplayListIfDirty(View.java:18250)</span><br><span class="line">        at android.view.ThreadedRenderer.updateViewTreeDisplayList(ThreadedRenderer.java:684)</span><br><span class="line">        at android.view.ThreadedRenderer.updateRootDisplayList(ThreadedRenderer.java:690)</span><br><span class="line">        at android.view.ThreadedRenderer.draw(ThreadedRenderer.java:804)</span><br><span class="line">        at android.view.ViewRootImpl.draw(ViewRootImpl.java:3199)</span><br><span class="line">        at android.view.ViewRootImpl.performDraw(ViewRootImpl.java:2997)</span><br><span class="line">        at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2526)</span><br><span class="line">        at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1515)</span><br><span class="line">        at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:7266)</span><br><span class="line">        at android.view.Choreographer$CallbackRecord.run(Choreographer.java:981)</span><br><span class="line">        at android.view.Choreographer.doCallbacks(Choreographer.java:790)</span><br><span class="line">        at android.view.Choreographer.doFrame(Choreographer.java:721)</span><br><span class="line">        at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:967)</span><br><span class="line">        at android.os.Handler.handleCallback(Handler.java:808)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:101)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:166)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7529)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:245)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:921)</span><br></pre></td></tr></table></figure><p>这段 log 有一个很关键的信息—— <strong>canvas 的高度跟 measure 出来的高度一样</strong>，这说明我们确确实实对超出屏幕的内容进行了绘制。</p><p>接下来我们根据调用栈来查找生成 canvas 的代码的位置。最后，在 <code>ViewGroup</code> 的 <code>updateDisplayListIfDirty</code> 可以找到这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);</span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明一下，log 显示 updateDisplayListIfDirty 是 View 的方法，但我却在 <code>ViewGroup</code> 里找到他，是因为我测试手机是 Android 8，但源码用的是 Android 9。另外，之所以使用这种查找问题的方法，是因为我确实没看过 <code>View</code> 的源码，也不熟（流下了不学无术的泪水）。正因为如此，文章到这里就准备结束了，<code>View</code> 相关的东西，有机会再聊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这之前，好几次想了解 &lt;code&gt;ScrollView&lt;/code&gt; 实现，粗略翻翻，每次都没抓到要点；又实在没有非常迫切的需求，也就没有花太多心思了。最近工作上有个任务需要类似 &lt;code&gt;ScrollView&lt;/code&gt; 的实现，只得下功夫研究一翻，于是有了这篇小短
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://jekton.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Java 和 double-check 实现支持多实例的单例</title>
    <link href="https://jekton.github.io/2019/05/26/java-multi-singleton/"/>
    <id>https://jekton.github.io/2019/05/26/java-multi-singleton/</id>
    <published>2019-05-26T12:13:52.000Z</published>
    <updated>2019-05-26T13:09:31.762Z</updated>
    
    <content type="html"><![CDATA[<p>考虑这样一个需求，我们有两个业务 A 和 B，他们共同使用一个硬盘缓存 <code>DiskCache</code> 的实现。由于在单个业务内只需要一份缓存，这很容易让我们想到单例模式。在本篇文章中，我们从最简单的传统的单例模式的实现开始，一步步实现一个优雅高效的多实例的单例模式。</p><a id="more"></a><p>首先我们看最简单情况——使用 double-check 实现单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DiskCache sInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMaxSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskCache <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DiskCache.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sInstance = <span class="keyword">new</span> DiskCache();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DiskCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMaxSize = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 2M</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于后面进行更深入的讨论，这里需要强调一下 <code>volatile</code> 的作用。虚拟机执行 <code>sInstance = new DiskCache()</code> 这一行代码时，做了下面几件事：</p><ol><li>为对象分配内存</li><li>初始化对象。也就是给 <code>mMaxSize</code> 赋值，设置 Class 指针等</li><li>把对象的引用写到变量 <code>sInstance</code> 上</li></ol><p>Java 的语言规范要求，任何线程如果读取到针对 <code>volatile</code> 变量的写操作的结果，那么这个写操作前的任何操作，都发生在这个读操作之前（happens-before 关系）。在我们的例子里，任何线程如果读到 <code>sInstance</code> 的值不为 <code>null</code>，<code>DiskCache</code> 的构造函数一定已经执行完成。</p><p>如果没有 <code>volatile</code>，某个线程可能会拿到一个 <code>sInstance</code>，但 <code>sInstance.mMaxSize</code> 为 0 或者任意数值。</p><p>现在我们考虑多个实例的情况。为了支持多个实例，我们把 <code>sInstance</code> 的类型改成 <code>DiskCache[]</code> 并定义几个常量代表相关的业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_COUNT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DiskCache[] sInstances;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMaxSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskCache <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstances == <span class="keyword">null</span> || sInstances[client] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DiskCache.class) &#123;</span><br><span class="line">                <span class="comment">// instantiate instance...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstances[client];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DiskCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMaxSize = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 2M</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我犯难了，我们需要保证 <code>synchronized</code> 块里面执行初始化操作后，<code>sInstances[client]</code> 对其他线程是可见的并且对应对象的构造函数已经执行完成。</p><p>一个比较天真的实现可能像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskCache <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstances == <span class="keyword">null</span> || sInstances[client] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DiskCache.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstances == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sInstances = <span class="keyword">new</span> DiskCache[CLIENT_COUNT];</span><br><span class="line">            &#125;</span><br><span class="line">            sInstances[client] = <span class="keyword">new</span> DiskCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sInstances[client];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我必须告诉大家，虽然 <code>sInstances</code> 是一个 <code>volatile</code> 变量，但我们对数组的内容的写操作并不会有任何的同步效果。</p><p>由此我们可能会想，能不能给每个实例一个 <code>volatile</code> 变量？当然可以！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DiskCache sInstance0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DiskCache sInstance1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DiskCache sInstance2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskCache <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (client) &#123;</span><br><span class="line">            <span class="keyword">case</span> CLIENT0:</span><br><span class="line">                <span class="keyword">if</span> (sInstance0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (DiskCache.class) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sInstance0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            sInstance0 = <span class="keyword">new</span> DiskCache();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sInstance0;</span><br><span class="line">            <span class="keyword">case</span> CLIENT1:</span><br><span class="line">                <span class="keyword">if</span> (sInstance1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (DiskCache.class) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sInstance1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            sInstance1 = <span class="keyword">new</span> DiskCache();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sInstance2;</span><br><span class="line">            <span class="keyword">case</span> CLIENT2:</span><br><span class="line">                <span class="keyword">if</span> (sInstance2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (DiskCache.class) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sInstance2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            sInstance2 = <span class="keyword">new</span> DiskCache();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sInstance2;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown client "</span> + client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我可以很负责任地说，这段代码是正确的，并且他的运行效率很不错，就是难看了些，扩展性也不好。这意味着，我们还得回到使用数组的那个方法去。</p><p>回想一下前面我们关于 <code>volatile</code> happens-before 关系的论述，结合那个失败的基于数组的实现，我在想，是否有一种方式，让我们在把一个新创建的对象放到数组中后，再来写某个 <code>volatile</code> 变量；同时，在进入 <code>synchronized</code> 块之前，我们通过检查这个变量，来判断数组中对应的实例是否已经初始化。另外，由于我们只能写一个变量，位掩码也自然而然浮了出来。结合这几个点子，我们可以按下面这种方式来实现多实例的单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_COUNT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DiskCache[] sInstances = <span class="keyword">new</span> DiskCache[CLIENT_COUNT];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sInstanceMask;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskCache <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; client;</span><br><span class="line">        <span class="keyword">if</span> ((sInstanceMask &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DiskCache.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sInstanceMask &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">                    sInstances[client] = <span class="keyword">new</span> DiskCache();</span><br><span class="line">                    sInstanceMask |= mask;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstances[client];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，如果客户读到了对应的位为 <code>1</code>，那么 <code>DiskCache</code> 一定是已经初始化完成，并且已经写到了数组里。需要注意的是，这里最多只支持 32 个实例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;考虑这样一个需求，我们有两个业务 A 和 B，他们共同使用一个硬盘缓存 &lt;code&gt;DiskCache&lt;/code&gt; 的实现。由于在单个业务内只需要一份缓存，这很容易让我们想到单例模式。在本篇文章中，我们从最简单的传统的单例模式的实现开始，一步步实现一个优雅高效的多实例的单例模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jekton.github.io/categories/Java/"/>
    
    
      <category term="parallel-programming" scheme="https://jekton.github.io/tags/parallel-programming/"/>
    
  </entry>
  
  <entry>
    <title>Android native 崩溃信息捕获实践</title>
    <link href="https://jekton.github.io/2019/04/06/native-crash-catching/"/>
    <id>https://jekton.github.io/2019/04/06/native-crash-catching/</id>
    <published>2019-04-06T01:35:52.000Z</published>
    <updated>2019-04-06T03:39:15.712Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是 bugly 一篇关于 native crash 捕获的文章的练习。由于他文章中已经给出了相关的大部分知识点，这里我就仅仅补充一些细节，并给出一个完整的 demo。建议大家先阅读 <a href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?" target="_blank" rel="noopener">Android 平台 Native 代码的崩溃捕获机制及实现</a>，熟悉一下相关的知识。</p><p>相关代码可以在 <a href="https://github.com/Jekton/NativeCrashCatching" target="_blank" rel="noopener">https://github.com/Jekton/NativeCrashCatching</a>（目标平台是 Android 8） 找到。</p><h3 id="设置-signal-handler-的运行堆栈"><a href="#设置-signal-handler-的运行堆栈" class="headerlink" title="设置 signal handler 的运行堆栈"></a>设置 signal handler 的运行堆栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetUpStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">stack_t</span> <span class="built_in">stack</span>&#123;&#125;;</span><br><span class="line">  <span class="built_in">stack</span>.ss_sp = <span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) <span class="keyword">char</span>[SIGSTKSZ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">stack</span>.ss_sp) &#123;</span><br><span class="line">    LOGW(kTag, <span class="string">"fail to alloc stack for crash catching"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">stack</span>.ss_size = SIGSTKSZ;</span><br><span class="line">  <span class="built_in">stack</span>.ss_flags = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span>.ss_sp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sigaltstack(&amp;<span class="built_in">stack</span>, <span class="literal">nullptr</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      LOGERRNO(kTag, <span class="string">"fail to setup signal stack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SIGSTKSZ</code> 是一个 <code>signal.h</code> 预定义的常量，我们可以直接用它做目标的栈大小。<code>LOGERRNO, LOGD, LOGE</code> 等是我自己定义的打印 Android log 的宏。</p><h3 id="设置信号处理函数"><a href="#设置信号处理函数" class="headerlink" title="设置信号处理函数"></a>设置信号处理函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, struct sigaction&gt; sOldHandlers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetUpSigHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>&#123;</span>&#125;;</span><br><span class="line">  action.sa_sigaction = SignalHandler;</span><br><span class="line">  action.sa_flags = SA_SIGINFO | SA_ONSTACK;</span><br><span class="line">  <span class="keyword">int</span> signals[] = &#123;</span><br><span class="line">      SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGSEGV, SIGPIPE</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">old_action</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> signo : signals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(signo, &amp;action, &amp;old_action) == <span class="number">-1</span>) &#123;</span><br><span class="line">      LOGERRNO(kTag, <span class="string">"fail to set signal handler for signo %d"</span>, signo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (old_action.sa_handler != SIG_DFL &amp;&amp; old_action.sa_handler != SIG_IGN) &#123;</span><br><span class="line">        sOldHandlers[signo] = old_action;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把旧的 signal handler 保存起来，执行完我们自己的函数后，再调用它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SignalHandler</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">siginfo_t</span>* info, <span class="keyword">void</span>* context)</span> </span>&#123;</span><br><span class="line">  DumpSignalInfo(info);</span><br><span class="line">  DumpStacks(context);</span><br><span class="line"></span><br><span class="line">  CallOldHandler(signo, info, context);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallOldHandler</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">siginfo_t</span>* info, <span class="keyword">void</span>* context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = sOldHandlers.find(signo);</span><br><span class="line">  <span class="keyword">if</span> (it != sOldHandlers.end()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second.sa_flags &amp; SA_SIGINFO) &#123;</span><br><span class="line">      it-&gt;second.sa_sigaction(signo, info, context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      it-&gt;second.sa_handler(signo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DumpSignalInfo</code> 用来打印 <code>siginfo_t</code>，<code>DumpStacks</code> 用来打印堆栈，很快我们就会看到他的实现。</p><h3 id="打印-siginfo-t"><a href="#打印-siginfo-t" class="headerlink" title="打印 siginfo_t"></a>打印 siginfo_t</h3><p>打印 <code>siginfo_t</code> 没什么技术含量，就只是根据 <code>signo</code> 和 <code>si_code</code> 打印对应的消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DumpSignalInfo</span><span class="params">(<span class="keyword">siginfo_t</span>* info)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (info-&gt;si_signo) &#123;</span><br><span class="line">  <span class="keyword">case</span> SIGILL:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGILL caught"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (info-&gt;si_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> ILL_ILLOPC:</span><br><span class="line">      LOGI(kTag, <span class="string">"illegal opcode"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_ILLOPN:</span><br><span class="line">      LOGI(kTag, <span class="string">"illegal operand"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_ILLADR:</span><br><span class="line">      LOGI(kTag, <span class="string">"illegal addressing mode"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_ILLTRP:</span><br><span class="line">      LOGI(kTag, <span class="string">"illegal trap"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_PRVOPC:</span><br><span class="line">      LOGI(kTag, <span class="string">"privileged opcode"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_PRVREG:</span><br><span class="line">      LOGI(kTag, <span class="string">"privileged register"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_COPROC:</span><br><span class="line">      LOGI(kTag, <span class="string">"coprocessor error"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_BADSTK:</span><br><span class="line">      LOGI(kTag, <span class="string">"internal stack error"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOGI(kTag, <span class="string">"code = %d"</span>, info-&gt;si_code);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGFPE:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGFPE caught"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (info-&gt;si_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> FPE_INTDIV:</span><br><span class="line">      LOGI(kTag, <span class="string">"integer divide by zero"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_INTOVF:</span><br><span class="line">      LOGI(kTag, <span class="string">"integer overflow"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTDIV:</span><br><span class="line">      LOGI(kTag, <span class="string">"floating-point divide by zero"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTOVF:</span><br><span class="line">      LOGI(kTag, <span class="string">"floating-point overflow"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTUND:</span><br><span class="line">      LOGI(kTag, <span class="string">"floating-point underflow"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTRES:</span><br><span class="line">      LOGI(kTag, <span class="string">"floating-point inexact result"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTINV:</span><br><span class="line">      LOGI(kTag, <span class="string">"invalid floating-point operation"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTSUB:</span><br><span class="line">      LOGI(kTag, <span class="string">"subscript out of range"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOGI(kTag, <span class="string">"code = %d"</span>, info-&gt;si_code);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGSEGV:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGSEGV caught"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (info-&gt;si_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SEGV_MAPERR:</span><br><span class="line">      LOGI(kTag, <span class="string">"address not mapped to object"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEGV_ACCERR:</span><br><span class="line">      LOGI(kTag, <span class="string">"invalid permissions for mapped object"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOGI(kTag, <span class="string">"code = %d"</span>, info-&gt;si_code);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGBUS:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGBUS caught"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (info-&gt;si_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> BUS_ADRALN:</span><br><span class="line">      LOGI(kTag, <span class="string">"invalid address alignment"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BUS_ADRERR:</span><br><span class="line">      LOGI(kTag, <span class="string">"nonexistent physical address"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BUS_OBJERR:</span><br><span class="line">      LOGI(kTag, <span class="string">"object-specific hardware error"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOGI(kTag, <span class="string">"code = %d"</span>, info-&gt;si_code);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGABRT:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGABRT caught"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGPIPE:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGPIPE caught"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    LOGI(kTag, <span class="string">"signo %d caught"</span>, info-&gt;si_signo);</span><br><span class="line">    LOGI(kTag, <span class="string">"code = %d"</span>, info-&gt;si_code);</span><br><span class="line">  &#125;</span><br><span class="line">  LOGI(kTag, <span class="string">"errno = %d"</span>, info-&gt;si_errno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印堆栈"><a href="#打印堆栈" class="headerlink" title="打印堆栈"></a>打印堆栈</h3><p>最后是我们的重头戏 —— 打印堆栈。按 bugly 那文章的说法，直接在信号处理函数里调用 Java 函数经常会有问题（具体是什么问题，我也还没去看，理论上应该没关系才对），我们这里就先按他的建议，在后台起一个工作线程来打印堆栈。</p><p>我们在应用启动的时候，先启动一个后台线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pid_t</span> sTidToDump;    <span class="comment">// guarded by sMutex</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* sContext;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mutex sMutex;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::condition_variable sCondition;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StackDumpingThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitCrashCaching</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOGD(kTag, <span class="string">"InitCrashCaching"</span>);</span><br><span class="line">  SetUpStack();</span><br><span class="line">  SetUpSigHandler();</span><br><span class="line">  <span class="built_in">std</span>::thread&#123;StackDumpingThread&#125;.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>mutex</code> 和 <code>condition_variable</code> 用来给信号处理函数和这个工作线程通信，我们直接通过两个静态变量传递数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StackDumpingThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock&#123;sMutex&#125;;</span><br><span class="line">  sCondition.wait(lock, [] &#123; <span class="keyword">return</span> sTidToDump &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// dump stack</span></span><br><span class="line"></span><br><span class="line">  sTidToDump = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// tell signal handler that we're done</span></span><br><span class="line">  sCondition.notify_one();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以继续看前面暂时放下的 <code>DumpStack</code> 函数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DumpStacks</span><span class="params">(<span class="keyword">void</span>* context)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock&#123;sMutex&#125;;</span><br><span class="line">  sTidToDump = gettid();    <span class="comment">// 获取线程 id</span></span><br><span class="line">  sContext = context;</span><br><span class="line">  sCondition.notify_one();</span><br><span class="line">  <span class="comment">// 等待工作线程打印堆栈</span></span><br><span class="line">  sCondition.wait(lock, []&#123; <span class="keyword">return</span> sTidToDump == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 native 崩溃捕获的一个基本框架，下面我们看看如何获取堆栈。</p><p>bugly 文章给我们推荐的 libunwind，但这里我们使用另一个朋友推荐的 libbacktrace。libbacktrace 其实也是用 libunwind 实现的。为了绕开 Android N 以后的 classloader namespace 限制，我们用 <a href="https://github.com/Rprop/ndk_dlopen" target="_blank" rel="noopener">ndk_dlopen</a> 来加载 <code>libbacktrace.so</code>。</p><p>使用系统内置的 so 有一个好处，就是不用自己去编译共享库，并且 so 很可能根据不同的系统版本做了调整。坏处就是我们代码的兼容性会比较差（这里我给出的代码只能运行在 Android 8 上，如果是其他版本，读者需要自己根据系统源码做一些调整）。</p><p>libbacktrace 的源码在 <code>system/core</code> 下面，为了了解一个库的用法，一般是看看他相关的文档、头文件。很不幸的，libbacktrace 没有文档，查看源码目录，可以看到一个 <code>Backtrace.h</code>。这种跟库名一样的头文件名，一般就是库对外的接口。</p><p>另一个方向是，既然 libbacktrace 在 <code>system/core</code> 里，系统可能有某个地方使用了它，我们可以全局搜索 <code>system/core</code> 找一个使用了 libbacktrace 的地方，然后参考它的用法。这里我参考的是 <code>CallStack</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/CallStack.cpp</span></span><br><span class="line"><span class="keyword">void</span> CallStack::update(<span class="keyword">int32_t</span> ignoreDepth, <span class="keyword">pid_t</span> tid) &#123;</span><br><span class="line">    mFrameLines.clear();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Backtrace&gt; backtrace(Backtrace::Create(BACKTRACE_CURRENT_PROCESS, tid));</span><br><span class="line">    <span class="keyword">if</span> (!backtrace-&gt;Unwind(ignoreDepth)) &#123;</span><br><span class="line">        ALOGW(<span class="string">"%s: Failed to unwind callstack."</span>, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; backtrace-&gt;NumFrames(); i++) &#123;</span><br><span class="line">      mFrameLines.push_back(String8(backtrace-&gt;FormatFrameData(i).c_str()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，使用 libbacktrace 一共就 3 步：</p><ol><li>使用 <code>Backtrace::Create</code> 创建一个 <code>Backtrace</code> 实例</li><li>调用 <code>Unwind</code> 函数 unwind 一下 stack</li><li><code>FormatFrameData</code> 输出每个栈帧的文本信息（也可以自己根据 frame 自己打印）</li></ol><p>下面我们先看看封装了 <code>libbacktrace</code> 的 <code>GetStackTrace</code> 接口，然后分小节来看这几个步骤。</p><h4 id="GetStackTrace-接口"><a href="#GetStackTrace-接口" class="headerlink" title="GetStackTrace 接口"></a>GetStackTrace 接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTraceCallback</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnFrame</span><span class="params">(<span class="keyword">size_t</span> frame_num, <span class="built_in">std</span>::<span class="built_in">string</span> frame)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnFail</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~GetTraceCallback() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @ctx can be nullptr or context from signal handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetStackTrace</span><span class="params">(<span class="keyword">pid_t</span> tid, <span class="keyword">void</span>* ctx, GetTraceCallback* callback)</span></span>;</span><br></pre></td></tr></table></figure><p><code>tid</code> 是需要打印对象的线程的 id，<code>ctx</code> 是信号处理函数的第三参数 <code>context</code>，<code>callback</code> 用于接收堆栈。之所以我们一个一个 frame 地传，是因为一次性打印堆栈过大，会被 Android 的 log 截断。</p><h4 id="创建-Backtrace-实例"><a href="#创建-Backtrace-实例" class="headerlink" title="创建 Backtrace 实例"></a>创建 <code>Backtrace</code> 实例</h4><p>为了使用 <code>ndk_dlopen</code>，我们先在 <code>InitCrashCaching</code> 的时候初始化它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_example_nativecrashcatching_CrashCatching_initNative(</span><br><span class="line">    JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">  ndk_init(env);</span><br><span class="line">  InitCrashCaching();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了找到 <code>Backtrace::Create</code> 函数的在 so 里的符号，我们可以使用 <code>nm</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ aarch64-linux-android-nm -D libbacktrace.so | grep Create</span><br><span class="line">00004e10 T _ZN12BacktraceMap6CreateEiRKNSt3__16vectorI15backtrace_map_tNS0_9allocatorIS2_EEEE</span><br><span class="line">0000aab8 T _ZN12BacktraceMap6CreateEib</span><br><span class="line">00008dec T _ZN9Backtrace6CreateEiiP12BacktraceMap</span><br></pre></td></tr></table></figure><p><code>aarch64-linux-android-nm</code> 可以在类似 <code>ndk-bundle/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin</code> 的路径里找到。</p><p>由于 so 里的符号都是 mangle 过的（C++ name mangling），我们可以先根据关键字 grep 出相关的符号，然后用 <a href="https://demangler.com/" target="_blank" rel="noopener">https://demangler.com/</a> demangle 出原来的符号名。<code>Backtrace::Create</code> 对应的符号是 <code>_ZN9Backtrace6CreateEiiP12BacktraceMap</code>。</p><p>知道函数对应的符号后，我们就可以用 <code>dlsym</code> 来找他了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* kLibBacktrace = <span class="string">"libbacktrace.so"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> BacktraceStub* <span class="title">CreateBacktrace</span><span class="params">(<span class="keyword">pid_t</span> tid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> deleter = [](<span class="keyword">void</span>* handle) &#123; ndk_dlclose(handle); &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">void</span>, <span class="keyword">decltype</span>(deleter)&gt; handle&#123;ndk_dlopen(kLibBacktrace, RTLD_LAZY), deleter&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">    LOGERRNO(kTag, <span class="string">"CrateBacktrace, fail to dlopen %s"</span>, kLibBacktrace);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> BacktraceCreate = BacktraceStub* (*)(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> tid, <span class="keyword">void</span>* <span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">union</span> &#123; <span class="keyword">void</span>* p; BacktraceCreate fn; &#125; backtrace_create;</span><br><span class="line">  backtrace_create.p = ndk_dlsym(handle.get(), <span class="string">"_ZN9Backtrace6CreateEiiP12BacktraceMap"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!backtrace_create.p) &#123;</span><br><span class="line">    LOGE(kTag, <span class="string">"CrateBacktrace, fail to get symbol Backtrace::Create: %s"</span>, ndk_dlerror());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> backtrace_create.fn(BACKTRACE_CURRENT_PROCESS, tid, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 C++ 不给我们把 <code>void*</code> 转成函数指针，这里只能曲线救国，用一个 <code>union</code> 来转换。<code>Backtrace::Create</code> 后会返回一个 <code>Backtrace</code> 指针。这里我们有两个选择，一是把整个 <code>Backtrace</code> 类的定义后拷贝过来，二是我们仿照他的定义，只加入我们需要的一小部分。我们选择的是后者。至于他的作用，我们很快就会看到。</p><h4 id="调用-Unwind-函数-unwind-一下-stack"><a href="#调用-Unwind-函数-unwind-一下-stack" class="headerlink" title="调用 Unwind 函数 unwind 一下 stack"></a>调用 <code>Unwind</code> 函数 unwind 一下 stack</h4><p>查看原始的 <code>libbacktrace</code>，我们可以知道，<code>Unwind</code> 函数是一个虚函数。为了调用它，有两条路可以选择。</p><ol><li>拿到类的虚函数表，然后根据编译器的规则，算出 <code>Unwind</code> 的 offset</li><li>定义一个跟 <code>Backtrace</code> 具有相同虚函数表的类，然后利用这个类来得到 <code>Unwind</code> 的 offset</li></ol><p>从实现的角度，第二种方法虽然比较骚，但却比第一种简单很多。于是，我们定义了一个 <code>BacktraceStub</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BacktraceStub</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~BacktraceStub() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Unwind</span><span class="params">(<span class="keyword">size_t</span> num_ignore_frames, <span class="keyword">void</span>* context = <span class="literal">NULL</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetFunctionName</span><span class="params">(<span class="keyword">uint64_t</span> pc, <span class="keyword">uint64_t</span>* offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">backtrace_map_t</span>* <span class="built_in">map</span> = <span class="literal">NULL</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">FillInMap</span><span class="params">(<span class="keyword">uint64_t</span> pc, <span class="keyword">backtrace_map_t</span>* <span class="built_in">map</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ReadWord</span><span class="params">(<span class="keyword">uint64_t</span> ptr, <span class="keyword">word_t</span>* out_value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> size_t <span class="title">Read</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint8_t</span>* buffer, <span class="keyword">size_t</span> bytes)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">FormatFrameData</span><span class="params">(<span class="keyword">size_t</span> frame_num)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetFunctionNameRaw</span><span class="params">(<span class="keyword">uint64_t</span> pc, <span class="keyword">uint64_t</span>* offset)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">VerifyReadWordArgs</span><span class="params">(<span class="keyword">uint64_t</span> ptr, <span class="keyword">word_t</span>* out_value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了我们需要用到的 <code>~BacktraceStub</code>、<code>Unwind</code> 和 <code>FormatFrameData</code>，其他函数其实可以随意定义。这部分相关的知识，读者可以参考《深度探索C++对象模型》。</p><p>有了这个 <code>BacktraceStub</code>，我们就可以调用 <code>Unwind</code> 了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetStackTrace</span><span class="params">(<span class="keyword">pid_t</span> tid, <span class="keyword">void</span>* ctx, GetTraceCallback* callback)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;BacktraceStub&gt; backtrace&#123;CreateBacktrace(tid)&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!backtrace) &#123;</span><br><span class="line">    callback-&gt;OnFail();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> ignoreDepth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!backtrace-&gt;Unwind(ignoreDepth)) &#123;</span><br><span class="line">    LOGE(kTag, <span class="string">"GetStackTrace, fail to unwind stack"</span>);</span><br><span class="line">    callback-&gt;OnFail();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ignoreDepth</code> 是忽略掉栈顶的 frame 数，我们传入 0 即可。</p><h4 id="FormatFrameData-输出每个栈帧的文本信息"><a href="#FormatFrameData-输出每个栈帧的文本信息" class="headerlink" title="FormatFrameData 输出每个栈帧的文本信息"></a><code>FormatFrameData</code> 输出每个栈帧的文本信息</h4><p>回忆一下前面的 <code>DumpStacks</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void DumpStacks(void* context) &#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lock&#123;sMutex&#125;;</span><br><span class="line">  sTidToDump = gettid();</span><br><span class="line">  sContext = context;</span><br><span class="line">  sCondition.notify_one();</span><br><span class="line">  sCondition.wait(lock, []&#123; return sTidToDump == 0; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们信号处理函数里又多执行了一部分代码，最后拿到的堆栈会多出来几个。为了去掉这些，我们需要从信号处理函数的 <code>context</code> 里拿到异常发生时的 PC 值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetStackTrace</span><span class="params">(<span class="keyword">pid_t</span> tid, <span class="keyword">void</span>* ctx, GetTraceCallback* callback)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> context = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">ucontext_t</span>*&gt;(ctx);</span><br><span class="line">  <span class="comment">// uc_mcontext.pc is the next instruction to be executed</span></span><br><span class="line">  <span class="keyword">auto</span> pc = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(context-&gt;uc_mcontext.pc) - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了拿到 libbacktrace 中栈帧的数据，我们需要再拷贝多一些类定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BacktraceUnwindError : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">  BACKTRACE_UNWIND_NO_ERROR,</span><br><span class="line">  <span class="comment">// Something failed while trying to perform the setup to begin the unwind.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_SETUP_FAILED,</span><br><span class="line">  <span class="comment">// There is no map information to use with the unwind.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_MAP_MISSING,</span><br><span class="line">  <span class="comment">// An error occurred that indicates a programming error.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_INTERNAL,</span><br><span class="line">  <span class="comment">// The thread to unwind has disappeared before the unwind can begin.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_THREAD_DOESNT_EXIST,</span><br><span class="line">  <span class="comment">// The thread to unwind has not responded to a signal in a timely manner.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_THREAD_TIMEOUT,</span><br><span class="line">  <span class="comment">// Attempt to do an unsupported operation.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_UNSUPPORTED_OPERATION,</span><br><span class="line">  <span class="comment">// Attempt to do an offline unwind without a context.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_NO_CONTEXT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backtrace_map_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uintptr_t</span> end = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uintptr_t</span> load_base = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backtrace_frame_data_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> num;             <span class="comment">// The current fame number.</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> pc;           <span class="comment">// The absolute pc.</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> sp;           <span class="comment">// The top of the stack.</span></span><br><span class="line">  <span class="keyword">size_t</span> stack_size;      <span class="comment">// The size of the stack, zero indicate an unknown stack size.</span></span><br><span class="line">  <span class="keyword">backtrace_map_t</span> <span class="built_in">map</span>;    <span class="comment">// The map associated with the given pc.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> func_name;  <span class="comment">// The function name associated with this pc, NULL if not found.</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> func_offset;  <span class="comment">// pc relative to the start of the function, only valid if func_name is not NULL.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">word_t</span> = <span class="keyword">unsigned</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BacktraceMap</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BacktraceStub</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// virtual functions</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> NumFrames() <span class="keyword">const</span> &#123; <span class="keyword">return</span> frames_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> backtrace_frame_data_t* <span class="title">GetFrame</span><span class="params">(<span class="keyword">size_t</span> frame_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame_num &gt;= frames_.size()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;frames_[frame_num];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">pid_t</span> pid_;</span><br><span class="line">  <span class="keyword">pid_t</span> tid_;</span><br><span class="line"></span><br><span class="line">  BacktraceMap* map_;</span><br><span class="line">  <span class="keyword">bool</span> map_shared_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">backtrace_frame_data_t</span>&gt; frames_;</span><br><span class="line">  <span class="comment">// Skip frames in libbacktrace/libunwindstack when doing a local unwind.</span></span><br><span class="line">  BacktraceUnwindError error_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前面这些都是 libbacktrace 里拷贝出来的。由于我的测试机是 Android 8，所以使用 <code>system/core</code> 的 <code>oreo-release</code> 分支。读者需要根据自己手机系统的版本做一些调整。</p><p>下面是 <code>GetStackTrace</code> 的完整实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void GetStackTrace(pid_t tid, void* ctx, GetTraceCallback* callback) &#123;</span><br><span class="line">  std::unique_ptr&lt;BacktraceStub&gt; backtrace&#123;CreateBacktrace(tid)&#125;;</span><br><span class="line">  if (!backtrace) &#123;</span><br><span class="line">    callback-&gt;OnFail();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  const auto ignoreDepth = 0;</span><br><span class="line">  if (!backtrace-&gt;Unwind(ignoreDepth)) &#123;</span><br><span class="line">    LOGE(kTag, &quot;GetStackTrace, fail to unwind stack&quot;);</span><br><span class="line">    callback-&gt;OnFail();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto context = reinterpret_cast&lt;ucontext_t*&gt;(ctx);</span><br><span class="line">  // uc_mcontext.pc is the next instruction to be executed</span><br><span class="line">  auto pc = static_cast&lt;uint64_t&gt;(context-&gt;uc_mcontext.pc) - 4;</span><br><span class="line">  size_t j = 0;</span><br><span class="line">  for (size_t i = 0, size = backtrace-&gt;NumFrames(); i &lt; size; ++i) &#123;</span><br><span class="line">    auto frame = backtrace-&gt;GetFrame(i);</span><br><span class="line">    // skip frames due to notification of dumping thread</span><br><span class="line">    if (j == 0 &amp;&amp; frame-&gt;pc != pc) continue;</span><br><span class="line">    const_cast&lt;backtrace_frame_data_t*&gt;(frame)-&gt;num = j;</span><br><span class="line">    auto frame_str = backtrace-&gt;FormatFrameData(i);</span><br><span class="line">    ++j;</span><br><span class="line">    callback-&gt;OnFrame(i, frame_str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们忽略掉前面的几个栈帧后，为了让 <code>FormatFrameData</code> 输出的标号从 0 开始，我们还手动修改了 <code>frame-&gt;num</code>。下面是一个输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#00 pc 0000000000019870  /data/app/com.example.nativecrashcatching-cSDYvNiWs8hShuhH39mQUQ==/lib/arm64/libnative-lib.so (_Z3foov+16)</span><br><span class="line">#01 pc 0000000000019894  /data/app/com.example.nativecrashcatching-cSDYvNiWs8hShuhH39mQUQ==/lib/arm64/libnative-lib.so (Java_com_example_nativecrashcatching_CrashCatching_dieNative+20)</span><br><span class="line">#02 pc 00000000001fd700  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#03 pc 00000000001f4638  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#04 pc 00000000000d80b4  /system/lib64/libart.so (_ZN3art9ArtMethod6InvokeEPNS_6ThreadEPjjPNS_6JValueEPKc+260)</span><br><span class="line">#05 pc 00000000002821dc  /system/lib64/libart.so (_ZN3art11interpreter34ArtInterpreterToCompiledCodeBridgeEPNS_6ThreadEPNS_9ArtMethodEPKNS_7DexFile8CodeItemEPNS_11ShadowFrameEPNS_6JValueE+352)</span><br><span class="line">#06 pc 000000000027c8a4  /system/lib64/libart.so (_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE+672)</span><br><span class="line">#07 pc 00000000001dd130  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#08 pc 00000000001e5e94  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#09 pc 000000000025d620  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadEPKNS_7DexFile8CodeItemERNS_11ShadowFrameENS_6JValueEb+444)</span><br><span class="line">#10 pc 0000000000263d20  /system/lib64/libart.so (_ZN3art11interpreter33ArtInterpreterToInterpreterBridgeEPNS_6ThreadEPKNS_7DexFile8CodeItemEPNS_11ShadowFrameEPNS_6JValueE+212)</span><br><span class="line">#11 pc 000000000027c884  /system/lib64/libart.so (_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE+640)</span><br><span class="line">#12 pc 00000000001dd130  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#13 pc 00000000001e5e94  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#14 pc 000000000025d620  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadEPKNS_7DexFile8CodeItemERNS_11ShadowFrameENS_6JValueEb+444)</span><br><span class="line">#15 pc 0000000000263d20  /system/lib64/libart.so (_ZN3art11interpreter33ArtInterpreterToInterpreterBridgeEPNS_6ThreadEPKNS_7DexFile8CodeItemEPNS_11ShadowFrameEPNS_6JValueE+212)</span><br></pre></td></tr></table></figure><p>最后再提一个小知识点。前面打印出来的 pc 是相对地址，我们从信号处理还是里拿到的 <code>pc</code> 值是绝对地址，<code>frame-&gt;pc</code> 也是绝对地址。为了把信号处理函数中的 <code>pc</code> 值转成相对地址，可以使用 <code>dladdr</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static uint64_t GetFaultPcRelative(ucontext_t* context) &#123;</span><br><span class="line">  void* pc = reinterpret_cast&lt;void*&gt;(context-&gt;uc_mcontext.pc);</span><br><span class="line">  Dl_info dl_info;</span><br><span class="line">  if (dladdr(pc, &amp;dl_info)) &#123;</span><br><span class="line">    auto base = reinterpret_cast&lt;uint64_t&gt;(dl_info.dli_fbase);</span><br><span class="line">    return reinterpret_cast&lt;uint64_t&gt;(pc) - base;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pie-release</code> 的 libbacktrace 的 <code>backtrace_frame_data_t</code> 直接带了一个成员变量 <code>rel_pc</code>。低版本的代码读者可以从 libbacktrace 源码中找到将绝对地址转换为相对地址的代码。</p>]]></content>
    
    <summary type="html">
    
      本篇是 bugly 一篇关于 native crash 捕获的文章的练习。由于他文章中已经给出了相关的大部分知识点，这里我就仅仅补充一些细节，并给出一个完整的 demo。
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="native-crash" scheme="https://jekton.github.io/tags/native-crash/"/>
    
  </entry>
  
  <entry>
    <title>Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</title>
    <link href="https://jekton.github.io/2019/03/21/android9-lmk-lmkd/"/>
    <id>https://jekton.github.io/2019/03/21/android9-lmk-lmkd/</id>
    <published>2019-03-21T11:28:58.000Z</published>
    <updated>2019-03-23T03:39:25.644Z</updated>
    
    <content type="html"><![CDATA[<p>本来按顺序这一篇应该也还是 logd，但我刚开始写就碰到了 cgroup，一顿搜索又扯上了 lmk，没办法，只能先解决这拦路的石头，然后再继续 logd。</p><p>Android 早先的版本的 lmk 是以驱动的形式在内核中实现的，这种方式并不为主线内核所接受。后来有人给内核添加了 memory pressure event，这就为应用层实现 lmk 提供了可能性。通过监听 memory pressure 事件，应用可以在内存 low、medium 和 critical 的时候得到通知，从而回收一些优先级比较低的应用。</p><p>下面我们就一起来看看他的实现。</p><h2 id="应用初始化"><a href="#应用初始化" class="headerlink" title="应用初始化"></a>应用初始化</h2><p>跟大多数守护进程一样，lmkd 也是由 init 进程启动的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// system/core/lmkd/lmkd.rc</span><br><span class="line">service lmkd /system/bin/lmkd</span><br><span class="line">    class core</span><br><span class="line">    group root readproc</span><br><span class="line">    critical</span><br><span class="line">    socket lmkd seqpacket 0660 system system</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br></pre></td></tr></table></figure><p>这里创建的 socket lmkd 的 user/group 都是 system，而它的权限是 0660，所以只有 system 应用才能读写（一般是 activity manager）。</p><p>接下来的 writepid 跟 Linux 的 cgroups 相关，目前我也不太了解（流下了没技术的泪水），后面补上相关的知识后再来单独撸一篇（文章）。</p><p>应用启动后，开始执行 <code>main</code> 函数，<code>main</code> 函数主要做三件事：</p><ol><li>读取配置参数</li><li>锁住内存页并设置进程调度器</li><li>初始化 epoll 事件监听</li><li>循环处理事件</li></ol><p>为了让读者有整体感，这里我们先把一整个 <code>main</code> 函数放上了，然后再单独看各个部分的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/lmkd/lmkd.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span></span><br><span class="line">            .sched_priority = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* By default disable low level vmpressure events */</span></span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_LOW] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.low"</span>, OOM_SCORE_ADJ_MAX + <span class="number">1</span>);</span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_MEDIUM] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.medium"</span>, <span class="number">800</span>);</span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_CRITICAL] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.critical"</span>, <span class="number">0</span>);</span><br><span class="line">    debug_process_killing = property_get_bool(<span class="string">"ro.lmk.debug"</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* By default disable upgrade/downgrade logic */</span></span><br><span class="line">    enable_pressure_upgrade =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.critical_upgrade"</span>, <span class="literal">false</span>);</span><br><span class="line">    upgrade_pressure =</span><br><span class="line">        (<span class="keyword">int64_t</span>)property_get_int32(<span class="string">"ro.lmk.upgrade_pressure"</span>, <span class="number">100</span>);</span><br><span class="line">    downgrade_pressure =</span><br><span class="line">        (<span class="keyword">int64_t</span>)property_get_int32(<span class="string">"ro.lmk.downgrade_pressure"</span>, <span class="number">100</span>);</span><br><span class="line">    kill_heaviest_task =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.kill_heaviest_task"</span>, <span class="literal">false</span>);</span><br><span class="line">    low_ram_device = property_get_bool(<span class="string">"ro.config.low_ram"</span>, <span class="literal">false</span>);</span><br><span class="line">    kill_timeout_ms =</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>)property_get_int32(<span class="string">"ro.lmk.kill_timeout_ms"</span>, <span class="number">0</span>);</span><br><span class="line">    use_minfree_levels =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.use_minfree_levels"</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LMKD_LOG_STATS</span></span><br><span class="line">    statslog_init(&amp;log_ctx, &amp;enable_stats_log);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MCL_ONFAULT pins pages as they fault instead of loading</span></span><br><span class="line">    <span class="comment">// everything immediately all at once. (Which would be bad,</span></span><br><span class="line">    <span class="comment">// because as of this writing, we have a lot of mapped pages we</span></span><br><span class="line">    <span class="comment">// never use.) Old kernels will see MCL_ONFAULT and fail with</span></span><br><span class="line">    <span class="comment">// EINVAL; we ignore this failure.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// N.B. read the man page for mlockall. MCL_CURRENT | MCL_ONFAULT</span></span><br><span class="line">    <span class="comment">// pins ⊆ MCL_CURRENT, converging to just MCL_CURRENT as we fault</span></span><br><span class="line">    <span class="comment">// in pages.</span></span><br><span class="line">    <span class="keyword">if</span> (mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT) &amp;&amp; errno != EINVAL)</span><br><span class="line">        ALOGW(<span class="string">"mlockall failed: errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    sched_setscheduler(<span class="number">0</span>, SCHED_FIFO, &amp;param);</span><br><span class="line">    <span class="keyword">if</span> (!init())</span><br><span class="line">        mainloop();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LMKD_LOG_STATS</span></span><br><span class="line">    statslog_destroy(&amp;log_ctx);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"exiting"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取配置参数"><a href="#读取配置参数" class="headerlink" title="读取配置参数"></a>读取配置参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/lmkd/lmkd.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* memory pressure levels */</span></span><br><span class="line"><span class="keyword">enum</span> vmpressure_level &#123;</span><br><span class="line">    VMPRESS_LEVEL_LOW = <span class="number">0</span>,</span><br><span class="line">    VMPRESS_LEVEL_MEDIUM,</span><br><span class="line">    VMPRESS_LEVEL_CRITICAL,</span><br><span class="line">    VMPRESS_LEVEL_COUNT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> level_oomadj[VMPRESS_LEVEL_COUNT];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mpevfd[VMPRESS_LEVEL_COUNT] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> debug_process_killing;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> enable_pressure_upgrade;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> upgrade_pressure;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> downgrade_pressure;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> low_ram_device;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> kill_heaviest_task;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> kill_timeout_ms;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> use_minfree_levels;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* By default disable low level vmpressure events */</span></span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_LOW] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.low"</span>, OOM_SCORE_ADJ_MAX + <span class="number">1</span>);</span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_MEDIUM] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.medium"</span>, <span class="number">800</span>);</span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_CRITICAL] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.critical"</span>, <span class="number">0</span>);</span><br><span class="line">    debug_process_killing = property_get_bool(<span class="string">"ro.lmk.debug"</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* By default disable upgrade/downgrade logic */</span></span><br><span class="line">    enable_pressure_upgrade =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.critical_upgrade"</span>, <span class="literal">false</span>);</span><br><span class="line">    upgrade_pressure =</span><br><span class="line">        (<span class="keyword">int64_t</span>)property_get_int32(<span class="string">"ro.lmk.upgrade_pressure"</span>, <span class="number">100</span>);</span><br><span class="line">    downgrade_pressure =</span><br><span class="line">        (<span class="keyword">int64_t</span>)property_get_int32(<span class="string">"ro.lmk.downgrade_pressure"</span>, <span class="number">100</span>);</span><br><span class="line">    kill_heaviest_task =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.kill_heaviest_task"</span>, <span class="literal">false</span>);</span><br><span class="line">    low_ram_device = property_get_bool(<span class="string">"ro.config.low_ram"</span>, <span class="literal">false</span>);</span><br><span class="line">    kill_timeout_ms =</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>)property_get_int32(<span class="string">"ro.lmk.kill_timeout_ms"</span>, <span class="number">0</span>);</span><br><span class="line">    use_minfree_levels =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.use_minfree_levels"</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，就是直接从系统属性里面读配置，然后放到静态变量里。关于这些属性的含义，读者可以参考 <code>system/core/lmkd/README.md</code>。</p><p><code>enum vmpressure_level</code> 代表了内存压力等级，分别是我们前面提到的 low、medium 和 critical。</p><h3 id="锁住内存页并设置进程调度器"><a href="#锁住内存页并设置进程调度器" class="headerlink" title="锁住内存页并设置进程调度器"></a>锁住内存页并设置进程调度器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取配置参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MCL_ONFAULT pins pages as they fault instead of loading</span></span><br><span class="line">    <span class="comment">// everything immediately all at once. (Which would be bad,</span></span><br><span class="line">    <span class="comment">// because as of this writing, we have a lot of mapped pages we</span></span><br><span class="line">    <span class="comment">// never use.) Old kernels will see MCL_ONFAULT and fail with</span></span><br><span class="line">    <span class="comment">// EINVAL; we ignore this failure.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// N.B. read the man page for mlockall. MCL_CURRENT | MCL_ONFAULT</span></span><br><span class="line">    <span class="comment">// pins ⊆ MCL_CURRENT, converging to just MCL_CURRENT as we fault</span></span><br><span class="line">    <span class="comment">// in pages.</span></span><br><span class="line">    <span class="keyword">if</span> (mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT) &amp;&amp; errno != EINVAL)</span><br><span class="line">        ALOGW(<span class="string">"mlockall failed: errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span></span><br><span class="line">            .sched_priority = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    sched_setscheduler(<span class="number">0</span>, SCHED_FIFO, &amp;param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 epoll 事件监听</span></span><br><span class="line">    <span class="comment">// 循环处理事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MCL_CURRENT</code> 把应用里当前已经在内存中的页锁着；<code>MCL_FUTURE</code> 把以后分配的内存区锁着；<code>MCL_ONFAULT</code> 表示不把那些当前不在内存里的页都加载到内存，而是当 page fault 的时候，再将加载进来的页面锁着。关于 <code>mlockall</code> 的更多信息，读者可以参考 man page。</p><p>接下来的 <code>sched_setscheduler</code> 将自己设置为实时进程，使用的调度器是 fifo。实时进程的优先级高于所有普通进程。对 fifo 调度器来说，在进程可运行（runnable）的时候，内核不会抢占它。</p><h3 id="初始化-epoll-事件监听"><a href="#初始化-epoll-事件监听" class="headerlink" title="初始化 epoll 事件监听"></a>初始化 epoll 事件监听</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取配置参数</span></span><br><span class="line">    <span class="comment">// 锁住内存页并设置进程调度器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!init())</span><br><span class="line">        mainloop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll 的初始化由 <code>init</code> 函数完成，<code>mainloop</code> 在一个主循环里处理事件，后者我们在下一小节讨论。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    page_k = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">if</span> (page_k == <span class="number">-1</span>)</span><br><span class="line">        page_k = PAGE_SIZE;</span><br><span class="line">    page_k /= <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    epollfd = epoll_create(MAX_EPOLL_EVENTS);</span><br><span class="line">    <span class="keyword">if</span> (epollfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"epoll_create failed (errno=%d)"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark data connections as not connected</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_DATA_CONN; i++) &#123;</span><br><span class="line">        data_sock[i].sock = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctrl_sock.sock = android_get_control_socket(<span class="string">"lmkd"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ctrl_sock.sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"get lmkd control socket failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = listen(ctrl_sock.sock, MAX_DATA_CONN);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"lmkd control socket listen failed (errno=%d)"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    ctrl_sock.handler_info.handler = ctrl_connect_handler;</span><br><span class="line">    epev.data.ptr = (<span class="keyword">void</span> *)&amp;(ctrl_sock.handler_info);</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, ctrl_sock.sock, &amp;epev) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"epoll_ctl for lmkd control socket failed (errno=%d)"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxevents++;</span><br><span class="line"></span><br><span class="line">    has_inkernel_module = !access(INKERNEL_MINFREE_PATH, W_OK);</span><br><span class="line">    use_inkernel_interface = has_inkernel_module;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_inkernel_interface) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Using in-kernel low memory killer interface"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!init_mp_common(VMPRESS_LEVEL_LOW) ||</span><br><span class="line">            !init_mp_common(VMPRESS_LEVEL_MEDIUM) ||</span><br><span class="line">            !init_mp_common(VMPRESS_LEVEL_CRITICAL)) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Kernel does not support memory pressure events or in-kernel low memory killer"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= ADJTOSLOT(OOM_SCORE_ADJ_MAX); i++) &#123;</span><br><span class="line">        procadjslot_list[i].next = &amp;procadjslot_list[i];</span><br><span class="line">        procadjslot_list[i].prev = &amp;procadjslot_list[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化静态变量 <code>page_k</code>，<code>page_k</code> 表示一个内存页有多少 KB，默认的 <code>PAGE_SIZE</code> 为 4096。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> page_k;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data required to handle events */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_handler_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">void</span> (*handler)(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data required to handle socket events */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_event_handler_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_handler_info</span> <span class="title">handler_info</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* max supported number of data connections */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_DATA_CONN 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* socket event handler data */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_event_handler_info</span> <span class="title">ctrl_sock</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_event_handler_info</span> <span class="title">data_sock</span>[<span class="title">MAX_DATA_CONN</span>];</span></span><br></pre></td></tr></table></figure><p><code>ctrl_sock</code> 是由 init 进程帮我们创建的那个 socket lmkd，通过这个 socket，lmkd 进程监听这个 socket 并等待接受客户的连接。lmkd 最多支持两个客户（<code>MAX_DATA_CONN</code>），这两个客户的 socket fd 就放在 <code>data_sock</code>。</p><p><code>struct event_handler_info</code> 定义了一个接口，<code>epoll</code> 返回时，主循环里就这个事件对应的 <code>handler</code>。调用时，第一个参数 <code>data</code> 是用户在创建 <code>struct event_handler_info</code> 对象时初始化的字段 <code>data</code>，第二个参数 <code>events</code> 是 <code>epoll</code> 返回的事件。</p><p>从上面的初始化代码可以看出，当 socket lmkd 有客户连接时，对应的回调是 <code>ctrl_connect_handler</code>。这里我们没有初始化 <code>ctrl_sock.handler_info.data</code>，是因为 <code>ctrl_connect_handler</code> 不使用这个额外的参数。</p><p><code>INKERNEL_MINFREE_PATH</code> 宏是 <code>/sys/module/lowmemorykiller/parameters/minfree</code>，如果我们不能访问它，表示 lowmemorykiller 使用的是内核中的驱动（没错，目前有两个 lowmemorykiller，一个是我们现在在看的 lmkd，一个是在内核中实现的驱动。系统的编译的时候可以决定使用哪一个）。这里我们假设使用应用层 lmk。</p><p><code>init_mp_common</code> 函数初始化 memory pressure 事件的监听：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMCG_SYSFS_PATH <span class="meta-string">"/dev/memcg/"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mpevfd[VMPRESS_LEVEL_COUNT] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">init_mp_common</span><span class="params">(<span class="keyword">enum</span> vmpressure_level level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mpfd;</span><br><span class="line">    <span class="keyword">int</span> evfd;</span><br><span class="line">    <span class="keyword">int</span> evctlfd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> level_idx = (<span class="keyword">int</span>)level;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *levelstr = level_name[level_idx];</span><br><span class="line"></span><br><span class="line">    mpfd = open(MEMCG_SYSFS_PATH <span class="string">"memory.pressure_level"</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (mpfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"No kernel memory.pressure_level support (errno=%d)"</span>, errno);</span><br><span class="line">        <span class="keyword">goto</span> err_open_mpfd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    evctlfd = open(MEMCG_SYSFS_PATH <span class="string">"cgroup.event_control"</span>, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (evctlfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"No kernel memory cgroup event control (errno=%d)"</span>, errno);</span><br><span class="line">        <span class="keyword">goto</span> err_open_evctlfd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    evfd = eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (evfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"eventfd failed for level %s; errno=%d"</span>, levelstr, errno);</span><br><span class="line">        <span class="keyword">goto</span> err_eventfd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d %d %s"</span>, evfd, mpfd, levelstr);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= (<span class="keyword">ssize_t</span>)<span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cgroup.event_control line overflow for level %s"</span>, levelstr);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = TEMP_FAILURE_RETRY(write(evctlfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cgroup.event_control write failed for level %s; errno=%d"</span>,</span><br><span class="line">              levelstr, errno);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    <span class="comment">/* use data to store event level */</span></span><br><span class="line">    vmpressure_hinfo[level_idx].data = level_idx;</span><br><span class="line">    vmpressure_hinfo[level_idx].handler = mp_event_common;</span><br><span class="line">    epev.data.ptr = (<span class="keyword">void</span> *)&amp;vmpressure_hinfo[level_idx];</span><br><span class="line">    ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, evfd, &amp;epev);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"epoll_ctl for level %s failed; errno=%d"</span>, levelstr, errno);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    maxevents++;</span><br><span class="line">    mpevfd[level] = evfd;</span><br><span class="line">    close(evctlfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    close(evfd);</span><br><span class="line">err_eventfd:</span><br><span class="line">    close(evctlfd);</span><br><span class="line">err_open_evctlfd:</span><br><span class="line">    close(mpfd);</span><br><span class="line">err_open_mpfd:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mpfd</code> 打开的时候利用 C/C++ 的字符串连接特性（相邻的字符串会自动由编译器连接到一起），他打开的实际路径是 <code>/dev/memcg/memory.pressure_level</code>。<code>evctlfd</code> 打开的路径类似。<code>eventfd</code> 是 LINUX 特有的一个系统调用，读者可以查看 man page 了解它的用法。</p><p>这里我们只需要知道，通过这么一顿骚操作之后，我们就能够通过描述符 <code>evfd</code> 得到 memory pressure 事件，就暂时把内核当做一个黑匣子来使用吧。</p><p>对于 memory pressure 事件，处理函数是 <code>mp_event_common</code>，传递给他的 <code>data</code> 是 <code>level_idx</code>（用于区分是发生了哪个级别的 mp 事件）。</p><p>最后要留意的是，<code>evfd</code> 被我们存放在了静态数组 <code>mpevfd</code> 里了，在后面将进程回收的时候（<code>mp_event_common</code> 函数）我们还会用到这个 <code>mpevfd</code>。</p><h3 id="循环处理事件"><a href="#循环处理事件" class="headerlink" title="循环处理事件"></a>循环处理事件</h3><p>事件循环由 <code>mainloop</code> 函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mainloop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_handler_info</span>* <span class="title">handler_info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">evt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">maxevents</span>];</span></span><br><span class="line">        <span class="keyword">int</span> nevents;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        nevents = epoll_wait(epollfd, events, maxevents, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nevents == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ALOGE(<span class="string">"epoll_wait failed (errno=%d)"</span>, errno);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * First pass to see if any data socket connections were dropped.</span></span><br><span class="line"><span class="comment">         * Dropped connection should be handled before any other events</span></span><br><span class="line"><span class="comment">         * to deallocate data connection and correctly handle cases when</span></span><br><span class="line"><span class="comment">         * connection gets dropped and reestablished in the same epoll cycle.</span></span><br><span class="line"><span class="comment">         * In such cases it's essential to handle connection closures first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, evt = &amp;events[<span class="number">0</span>]; i &lt; nevents; ++i, evt++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((evt-&gt;events &amp; EPOLLHUP) &amp;&amp; evt-&gt;data.ptr) &#123;</span><br><span class="line">                ALOGI(<span class="string">"lmkd data connection dropped"</span>);</span><br><span class="line">                handler_info = (struct event_handler_info*)evt-&gt;data.ptr;</span><br><span class="line">                ctrl_data_close(handler_info-&gt;data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Second pass to handle all other events */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, evt = &amp;events[<span class="number">0</span>]; i &lt; nevents; ++i, evt++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (evt-&gt;events &amp; EPOLLERR)</span><br><span class="line">                ALOGD(<span class="string">"EPOLLERR on event #%d"</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (evt-&gt;events &amp; EPOLLHUP) &#123;</span><br><span class="line">                <span class="comment">/* This case was handled in the first pass */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (evt-&gt;data.ptr) &#123;</span><br><span class="line">                handler_info = (struct event_handler_info*)evt-&gt;data.ptr;</span><br><span class="line">                handler_info-&gt;handler(handler_info-&gt;data, evt-&gt;events);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就很直观了，就是在一个循环里调用 <code>epoll_wait</code>，然后调用对应的处理函数。其中比较不一致的代码是当客户挂起（<code>EPOLLHUP</code>）的时候，这里我们直接把连接关掉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ctrl_data_close</span><span class="params">(<span class="keyword">int</span> dsock_idx)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"closing lmkd data connection"</span>);</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_DEL, data_sock[dsock_idx].sock, &amp;epev) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// Log a warning and keep going</span></span><br><span class="line">        ALOGW(<span class="string">"epoll_ctl for data connection socket failed; errno=%d"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    maxevents--;</span><br><span class="line"></span><br><span class="line">    close(data_sock[dsock_idx].sock);</span><br><span class="line">    data_sock[dsock_idx].sock = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lmkd-客户端接口"><a href="#lmkd-客户端接口" class="headerlink" title="lmkd 客户端接口"></a>lmkd 客户端接口</h2><p>进程 lmkd 的客户主要是 activity manager，它通过 socket <code>/dev/socket/lmkd</code> 跟 lmkd 进行通信。通过前面的代码我们已经知道，有客户连接时，调用的是 <code>ctrl_connect_handler</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_free_dsock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_DATA_CONN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data_sock[i].sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ctrl_connect_handler</span><span class="params">(<span class="keyword">int</span> data __unused, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> free_dscock_idx = get_free_dsock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (free_dscock_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Number of data connections exceeded max supported. This should not</span></span><br><span class="line"><span class="comment">         * happen but if it does we drop all existing connections and accept</span></span><br><span class="line"><span class="comment">         * the new one. This prevents inactive connections from monopolizing</span></span><br><span class="line"><span class="comment">         * data socket and if we drop ActivityManager connection it will</span></span><br><span class="line"><span class="comment">         * immediately reconnect.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_DATA_CONN; i++) &#123;</span><br><span class="line">            ctrl_data_close(i);</span><br><span class="line">        &#125;</span><br><span class="line">        free_dscock_idx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data_sock[free_dscock_idx].sock = accept(ctrl_sock.sock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (data_sock[free_dscock_idx].sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"lmkd control socket accept failed; errno=%d"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"lmkd data connection established"</span>);</span><br><span class="line">    <span class="comment">/* use data to store data connection idx */</span></span><br><span class="line">    data_sock[free_dscock_idx].handler_info.data = free_dscock_idx;</span><br><span class="line">    data_sock[free_dscock_idx].handler_info.handler = ctrl_data_handler;</span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.ptr = (<span class="keyword">void</span> *)&amp;(data_sock[free_dscock_idx].handler_info);</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, data_sock[free_dscock_idx].sock, &amp;epev) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"epoll_ctl for data connection socket failed; errno=%d"</span>, errno);</span><br><span class="line">        ctrl_data_close(free_dscock_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxevents++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，就是在 <code>ctrl_sock</code> 上调用 <code>accept</code> 接受一个客户的连接，然后放到 <code>data_sock</code>（回想一下，<code>data_sock</code> 存放的是 lmkd 的客户，最多可以有两个）。</p><p>对客户连接来说，它的处理函数是 <code>ctrl_data_handler</code>，<code>handler_info.data</code> 对应 <code>data_sock</code> 数组的下标，这样在 <code>ctrl_data_handler</code> 执行时才知道是哪个客户端可读了。</p><p>这就是 <code>ctrl_sock</code> 所有的职责了——接受客户的连接。下面我们看看客户 socket 可读的时候会发生什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ctrl_data_handler</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EPOLLIN) &#123;</span><br><span class="line">        ctrl_command_handler(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端连接后，将通过 socket 给 lmkd 发送命令，这一部分是由 <code>ctrl_command_handler</code> 处理的。lmkd 接受三种命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Supported LMKD commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> lmk_cmd &#123;</span><br><span class="line">    LMK_TARGET = <span class="number">0</span>,  <span class="comment">/* Associate minfree with oom_adj_score */</span></span><br><span class="line">    LMK_PROCPRIO,    <span class="comment">/* Register a process and set its oom_adj_score */</span></span><br><span class="line">    LMK_PROCREMOVE,  <span class="comment">/* Unregister a process */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>命令的格式分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LMK_TARGET:</span><br><span class="line">+---------+----------+----------------+----------+----------------+----</span><br><span class="line">| lmk_cmd | minfree1 | oom_adj_score1 | minfree2 | oom_adj_score2 | ...</span><br><span class="line">+---------+----------+----------------+----------+----------------+----</span><br><span class="line"></span><br><span class="line">LMK_PROCPRIO:</span><br><span class="line">+---------+-----+-----+---------+</span><br><span class="line">| lmk_cmd | pid | uid | oom_adj |</span><br><span class="line">+---------+-----+-----+---------+</span><br><span class="line"></span><br><span class="line">LMK_PROCREMOVE:</span><br><span class="line">+---------+-----+</span><br><span class="line">| lmk_cmd | pid |</span><br><span class="line">+---------+-----+</span><br></pre></td></tr></table></figure><p>命令的每个字段都是 4 个字节（<code>int</code> 类型），并且使用<strong>网络字节序</strong>（我也表示很懵逼，命名是在本地通信，为什么不直接使用主机字节序）。</p><p><code>LMK_TARGET</code> 是最长的一条协议，他最多可以接受 6 组参数（由 <code>MAX_TARGETS</code> 定义），所以一条控制命令的最大长度是 1 + 6 * 2 = 13 个 <code>int</code>，这个大小由 <code>CTRL_PACKET_MAX_SIZE</code> 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Max number of targets in LMK_TARGET command.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TARGETS 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Max packet length in bytes.</span></span><br><span class="line"><span class="comment"> * Longest packet is LMK_TARGET followed by MAX_TARGETS</span></span><br><span class="line"><span class="comment"> * of minfree and oom_adj_score values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTRL_PACKET_MAX_SIZE (sizeof(int) * (MAX_TARGETS * 2 + 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LMKD packet - first int is lmk_cmd followed by payload */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> LMKD_CTRL_PACKET[CTRL_PACKET_MAX_SIZE / <span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br></pre></td></tr></table></figure><p>了解了基本的数据类型和协议格式后，下面我们来看 <code>ctrl_command_hander</code> 的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ctrl_command_handler</span><span class="params">(<span class="keyword">int</span> dsock_idx)</span> </span>&#123;</span><br><span class="line">    LMKD_CTRL_PACKET packet;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">enum</span> lmk_cmd cmd;</span><br><span class="line">    <span class="keyword">int</span> nargs;</span><br><span class="line">    <span class="keyword">int</span> targets;</span><br><span class="line"></span><br><span class="line">    len = ctrl_data_read(dsock_idx, (<span class="keyword">char</span> *)packet, CTRL_PACKET_MAX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Wrong control socket read length len=%d"</span>, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmd = lmkd_pack_get_cmd(packet);</span><br><span class="line">    nargs = len / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nargs &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> wronglen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> LMK_TARGET:</span><br><span class="line">        targets = nargs / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nargs &amp; <span class="number">0x1</span> || targets &gt; (<span class="keyword">int</span>)ARRAY_SIZE(lowmem_adj))</span><br><span class="line">            <span class="keyword">goto</span> wronglen;</span><br><span class="line">        cmd_target(targets, packet);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LMK_PROCPRIO:</span><br><span class="line">        <span class="keyword">if</span> (nargs != <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">goto</span> wronglen;</span><br><span class="line">        cmd_procprio(packet);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LMK_PROCREMOVE:</span><br><span class="line">        <span class="keyword">if</span> (nargs != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">goto</span> wronglen;</span><br><span class="line">        cmd_procremove(packet);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ALOGE(<span class="string">"Received unknown command code %d"</span>, cmd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">wronglen:</span><br><span class="line">    ALOGE(<span class="string">"Wrong control socket read length cmd=%d len=%d"</span>, cmd, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctrl_data_read</span><span class="params">(<span class="keyword">int</span> dsock_idx, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = TEMP_FAILURE_RETRY(read(data_sock[dsock_idx].sock, buf, bufsz));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"control data socket read failed; errno=%d"</span>, errno);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Got EOF on control data socket"</span>);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆一下，socket lmkd 的类型是 seqpacket，所以每次 <code>read</code> 都会恰好返回一条命令。调用 <code>ctrl_data_read</code> 读到一整条命名后，我们使用 <code>lmkd_pack_get_cmd</code> 函数得到这条命令的 <code>lmkd_cmd</code> 字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get LMKD packet command */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">enum</span> lmk_cmd <span class="title">lmkd_pack_get_cmd</span><span class="params">(LMKD_CTRL_PACKET pack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">enum</span> lmk_cmd)ntohl(pack[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们说，协议数据使用网络字节序，所以这里用 <code>ntohl</code> 转换为主机字节序。三个命令的 cmd 字段都在第一个 int，所以这里直接返回 <code>pack[0]</code>。</p><p>接下来三个命令分别由 <code>cmd_target</code>，<code>cmd_procprio</code>，<code>cmd_procremove</code>处理。我们先看 <code>cmd_target</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lowmem_adj[MAX_TARGETS];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lowmem_minfree[MAX_TARGETS];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lowmem_targets_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LMK_TARGET packet payload */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lmk_target</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minfree;</span><br><span class="line">    <span class="keyword">int</span> oom_adj_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For LMK_TARGET packet get target_idx-th payload.</span></span><br><span class="line"><span class="comment"> * Warning: no checks performed, caller should ensure valid parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lmkd_pack_get_target</span><span class="params">(LMKD_CTRL_PACKET packet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> target_idx, struct lmk_target *target)</span> </span>&#123;</span><br><span class="line">    target-&gt;minfree = ntohl(packet[target_idx * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    target-&gt;oom_adj_score = ntohl(packet[target_idx * <span class="number">2</span> + <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_target</span><span class="params">(<span class="keyword">int</span> ntargets, LMKD_CTRL_PACKET packet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lmk_target</span> <span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ntargets &gt; (<span class="keyword">int</span>)ARRAY_SIZE(lowmem_adj))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ntargets; i++) &#123;</span><br><span class="line">        lmkd_pack_get_target(packet, i, &amp;target);</span><br><span class="line">        lowmem_minfree[i] = target.minfree;</span><br><span class="line">        lowmem_adj[i] = target.oom_adj_score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lowmem_targets_size = ntargets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_inkernel_module) &#123;</span><br><span class="line">        <span class="keyword">char</span> minfreestr[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">char</span> killpriostr[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        minfreestr[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        killpriostr[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lowmem_targets_size; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i) &#123;</span><br><span class="line">                strlcat(minfreestr, <span class="string">","</span>, <span class="keyword">sizeof</span>(minfreestr));</span><br><span class="line">                strlcat(killpriostr, <span class="string">","</span>, <span class="keyword">sizeof</span>(killpriostr));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">"%d"</span>, use_inkernel_interface ? lowmem_minfree[i] : <span class="number">0</span>);</span><br><span class="line">            strlcat(minfreestr, val, <span class="keyword">sizeof</span>(minfreestr));</span><br><span class="line">            <span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">"%d"</span>, use_inkernel_interface ? lowmem_adj[i] : <span class="number">0</span>);</span><br><span class="line">            strlcat(killpriostr, val, <span class="keyword">sizeof</span>(killpriostr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writefilestring(INKERNEL_MINFREE_PATH, minfreestr);</span><br><span class="line">        writefilestring(INKERNEL_ADJ_PATH, killpriostr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cmd_target</code> 设置 <code>lowmem_minfree</code>， <code>lowmem_adj</code>，这两组参数用于控制 low memory 时候的行为。如果使用的是驱动 lmk，那就把参数写到 <code>INKERNEL_MINFREE_PATH</code> 和 <code>INKERNEL_ADJ_PATH</code>。</p><p>接下来是 <code>cmd_procprio</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LMK_PROCPRIO packet payload */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lmk_procprio</span> &#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">uid_t</span> uid;</span><br><span class="line">    <span class="keyword">int</span> oomadj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For LMK_PROCPRIO packet get its payload.</span></span><br><span class="line"><span class="comment"> * Warning: no checks performed, caller should ensure valid parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lmkd_pack_get_procprio</span><span class="params">(LMKD_CTRL_PACKET packet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   struct lmk_procprio *params)</span> </span>&#123;</span><br><span class="line">    params-&gt;pid = (<span class="keyword">pid_t</span>)ntohl(packet[<span class="number">1</span>]);</span><br><span class="line">    params-&gt;uid = (<span class="keyword">uid_t</span>)ntohl(packet[<span class="number">2</span>]);</span><br><span class="line">    params-&gt;oomadj = ntohl(packet[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_procprio</span><span class="params">(LMKD_CTRL_PACKET packet)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">80</span>];</span><br><span class="line">    <span class="keyword">char</span> val[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> soft_limit_mult;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lmk_procprio</span> <span class="title">params</span>;</span></span><br><span class="line"></span><br><span class="line">    lmkd_pack_get_procprio(packet, &amp;params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (params.oomadj &lt; OOM_SCORE_ADJ_MIN ||</span><br><span class="line">        params.oomadj &gt; OOM_SCORE_ADJ_MAX) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Invalid PROCPRIO oomadj argument %d"</span>, params.oomadj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"/proc/%d/oom_score_adj"</span>, params.pid);</span><br><span class="line">    <span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">"%d"</span>, params.oomadj);</span><br><span class="line">    writefilestring(path, val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_inkernel_interface)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (low_ram_device) &#123;</span><br><span class="line">        <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">900</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">800</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">700</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">600</span>) &#123;</span><br><span class="line">            <span class="comment">// Launcher should be perceptible, don't kill it.</span></span><br><span class="line">            params.oomadj = <span class="number">200</span>;</span><br><span class="line">            soft_limit_mult = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">200</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;=   <span class="number">0</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Persistent processes will have a large</span></span><br><span class="line">            <span class="comment">// soft limit 512MB.</span></span><br><span class="line">            soft_limit_mult = <span class="number">64</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path),</span><br><span class="line">             <span class="string">"/dev/memcg/apps/uid_%d/pid_%d/memory.soft_limit_in_bytes"</span>,</span><br><span class="line">             params.uid, params.pid);</span><br><span class="line">        <span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">"%d"</span>, soft_limit_mult * EIGHT_MEGA);</span><br><span class="line">        writefilestring(path, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    procp = pid_lookup(params.pid);</span><br><span class="line">    <span class="keyword">if</span> (!procp) &#123;</span><br><span class="line">            procp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct proc));</span><br><span class="line">            <span class="keyword">if</span> (!procp) &#123;</span><br><span class="line">                <span class="comment">// Oh, the irony.  May need to rebuild our state.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            procp-&gt;pid = params.pid;</span><br><span class="line">            procp-&gt;uid = params.uid;</span><br><span class="line">            procp-&gt;oomadj = params.oomadj;</span><br><span class="line">            proc_insert(procp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        proc_unslot(procp);</span><br><span class="line">        procp-&gt;oomadj = params.oomadj;</span><br><span class="line">        proc_slot(procp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cmd_procprio</code> 用于设置进程的 oomadj，在把 oomadj 写入 <code>&quot;/proc/#pid/oom_score_adj&quot;</code> 后，如果使用的是驱动 lmk，就可以直接返回了（驱动 lmk 会处理剩下的工作）。如果不是，接着往下执行。</p><p>如果机子是 <code>low_ram_device</code>（小内存机器），那么 lmkd 会根据应用的 oomadj 调整应用可用的内存大小。（震惊，原来还有这种骚操作。那在小内存机器里，应用处于后台时就更容易 OOM 了）</p><p>最后的一小段代码将这个应用的 oomadj 保存在一个哈希表里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> <span class="title">asl</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">uid_t</span> uid;</span><br><span class="line">    <span class="keyword">int</span> oomadj;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pidhash_next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIDHASH_SZ 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pidhash</span>[<span class="title">PIDHASH_SZ</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid_hashfn(x) ((((x) &gt;&gt; 8) ^ (x)) &amp; (PIDHASH_SZ - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc *<span class="title">pid_lookup</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (procp = pidhash[pid_hashfn(pid)]; procp &amp;&amp; procp-&gt;pid != pid;</span><br><span class="line">         procp = procp-&gt;pidhash_next)</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> procp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proc_insert</span><span class="params">(struct proc *procp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hval = pid_hashfn(procp-&gt;pid);</span><br><span class="line"></span><br><span class="line">    procp-&gt;pidhash_next = pidhash[hval];</span><br><span class="line">    pidhash[hval] = procp;</span><br><span class="line">    proc_slot(procp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希表 <code>pidhash</code> 是以 pid 做 key，<code>proc_slot</code> 则是把 <code>struct proc</code> 插入到以 <code>oomadj</code> 为 key 的哈希表 <code>procadjslot_list</code> 里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* OOM score values used by both kernel and framework */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_SCORE_ADJ_MIN       (-1000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_SCORE_ADJ_MAX       1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADJTOSLOT(adj) ((adj) + -OOM_SCORE_ADJ_MIN)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> <span class="title">procadjslot_list</span>[<span class="title">ADJTOSLOT</span>(<span class="title">OOM_SCORE_ADJ_MAX</span>) + 1];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proc_slot</span><span class="params">(struct proc *procp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> adjslot = ADJTOSLOT(procp-&gt;oomadj);</span><br><span class="line"></span><br><span class="line">    adjslot_insert(&amp;procadjslot_list[adjslot], &amp;procp-&gt;asl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjslot_insert</span><span class="params">(struct adjslot_list *head, struct adjslot_list *<span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">next</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = head;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    head-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 pid 值不同，oomadj 是数值范围是 <code>[-1000, 1000]</code>，最多只有 2001 种，所以其实一个 oomadj 值就对应  <code>procadjslot_list</code> 的 slot。</p><p>最后是 <code>cmd_procremove</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LMK_PROCREMOVE packet payload */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lmk_procremove</span> &#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For LMK_PROCREMOVE packet get its payload.</span></span><br><span class="line"><span class="comment"> * Warning: no checks performed, caller should ensure valid parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lmkd_pack_get_procremove</span><span class="params">(LMKD_CTRL_PACKET packet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     struct lmk_procremove *params)</span> </span>&#123;</span><br><span class="line">    params-&gt;pid = (<span class="keyword">pid_t</span>)ntohl(packet[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_procremove</span><span class="params">(LMKD_CTRL_PACKET packet)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lmk_procremove</span> <span class="title">params</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_inkernel_interface)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    lmkd_pack_get_procremove(packet, &amp;params);</span><br><span class="line">    pid_remove(params.pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的 <code>pid_remove</code> 把这个 pid 对应的 <code>struct proc</code> 从 <code>pidhash</code> 和 <code>procadjslot_list</code> 里移除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pid_remove</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hval = pid_hashfn(pid);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">prevp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (procp = pidhash[hval], prevp = <span class="literal">NULL</span>; procp &amp;&amp; procp-&gt;pid != pid;</span><br><span class="line">         procp = procp-&gt;pidhash_next)</span><br><span class="line">            prevp = procp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!procp)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prevp)</span><br><span class="line">        pidhash[hval] = procp-&gt;pidhash_next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prevp-&gt;pidhash_next = procp-&gt;pidhash_next;</span><br><span class="line"></span><br><span class="line">    proc_unslot(procp);</span><br><span class="line">    <span class="built_in">free</span>(procp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回收进程"><a href="#回收进程" class="headerlink" title="回收进程"></a>回收进程</h2><p>前面和 socket lmkd 相关的内容主要用于设置 lmk 参数和进程 oomadj。当系统的物理内存不足时，将会触发 mp 事件，这个时候 lmkd 就需要通过杀死一些进程来释放内存页了。</p><p>前面我们已经知道，mp 事件发生后，执行的是 <code>mp_event_common</code>。这个函数比较长，洋洋洒洒两百来行代码，我们一点一点慢慢看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> evcount;</span><br><span class="line">    <span class="keyword">int64_t</span> mem_usage, memsw_usage;</span><br><span class="line">    <span class="keyword">int64_t</span> mem_pressure;</span><br><span class="line">    <span class="keyword">enum</span> vmpressure_level lvl;</span><br><span class="line">    <span class="keyword">union</span> meminfo mi;</span><br><span class="line">    <span class="keyword">union</span> zoneinfo zi;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">last_report_tm</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> skip_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">enum</span> vmpressure_level level = (<span class="keyword">enum</span> vmpressure_level)data;</span><br><span class="line">    <span class="keyword">long</span> other_free = <span class="number">0</span>, other_file = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min_score_adj;</span><br><span class="line">    <span class="keyword">int</span> pages_to_free = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minfree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">reread_data</span> <span class="title">mem_usage_file_data</span> = &#123;</span></span><br><span class="line">        .filename = MEMCG_MEMORY_USAGE,</span><br><span class="line">        .fd = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">reread_data</span> <span class="title">memsw_usage_file_data</span> = &#123;</span></span><br><span class="line">        .filename = MEMCG_MEMORYSW_USAGE,</span><br><span class="line">        .fd = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面这一坨是函数用到的变量的定义。在 ANSI C 那个年代，局部变量都要在函数里先声明，但这对代码的可读性其实没有什么帮助（因为定义跟使用他的上下文脱节了）。这里我们先直接忽略它们，后面再在具体的上下文来看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> vmpressure_level lvl;</span><br><span class="line">    <span class="keyword">enum</span> vmpressure_level level = (<span class="keyword">enum</span> vmpressure_level)data;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Check all event counters from low to critical</span></span><br><span class="line"><span class="comment">     * and upgrade to the highest priority one. By reading</span></span><br><span class="line"><span class="comment">     * eventfd we also reset the event counters.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (lvl = VMPRESS_LEVEL_LOW; lvl &lt; VMPRESS_LEVEL_COUNT; lvl++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mpevfd[lvl] != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            TEMP_FAILURE_RETRY(read(mpevfd[lvl],</span><br><span class="line">                               &amp;evcount, <span class="keyword">sizeof</span>(evcount))) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            evcount &gt; <span class="number">0</span> &amp;&amp; lvl &gt; level) &#123;</span><br><span class="line">            level = lvl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面 <code>init_mp_common</code> 函数里面，我们把 <code>evfd</code> 存在了 <code>mpevfd</code> 数组里，为的就是这个时候能够通过读取它们的来判断是否有更高级别的 mp 事件。至此，变量 <code>level</code> 表示当前发生的最高 level 的 mp 事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">last_report_tm</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> skip_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kill_timeout_ms) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">curr_tm</span>;</span></span><br><span class="line">        gettimeofday(&amp;curr_tm, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (get_time_diff_ms(&amp;last_report_tm, &amp;curr_tm) &lt; kill_timeout_ms) &#123;</span><br><span class="line">            skip_count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skip_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"%lu memory pressure events were skipped after a kill!"</span>,</span><br><span class="line">              skip_count);</span><br><span class="line">        skip_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kill_timeout_ms</code> 是我们在 <code>main</code> 函数里通过读系统属性设置的，表示上一次 kill 后，等多 <code>kill_timeout_ms</code> 再杀下一个。<code>last_report_tm</code> 在后面我们成功回收进程后会更新他的时间。这里要注意，<code>skip_count</code> 和 <code>last_report_tm</code> 都是 <code>static</code> 变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> zoneinfo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int64_t</span> nr_free_pages;</span><br><span class="line">        <span class="keyword">int64_t</span> nr_file_pages;</span><br><span class="line">        <span class="keyword">int64_t</span> nr_shmem;</span><br><span class="line">        <span class="keyword">int64_t</span> nr_unevictable;</span><br><span class="line">        <span class="keyword">int64_t</span> workingset_refault;</span><br><span class="line">        <span class="keyword">int64_t</span> high;</span><br><span class="line">        <span class="comment">/* fields below are calculated rather than read from the file */</span></span><br><span class="line">        <span class="keyword">int64_t</span> totalreserve_pages;</span><br><span class="line">    &#125; field;</span><br><span class="line">    <span class="keyword">int64_t</span> arr[ZI_FIELD_COUNT];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> meminfo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int64_t</span> nr_free_pages;</span><br><span class="line">        <span class="keyword">int64_t</span> cached;</span><br><span class="line">        <span class="keyword">int64_t</span> swap_cached;</span><br><span class="line">        <span class="keyword">int64_t</span> buffers;</span><br><span class="line">        <span class="keyword">int64_t</span> shmem;</span><br><span class="line">        <span class="keyword">int64_t</span> unevictable;</span><br><span class="line">        <span class="keyword">int64_t</span> free_swap;</span><br><span class="line">        <span class="keyword">int64_t</span> dirty;</span><br><span class="line">        <span class="comment">/* fields below are calculated rather than read from the file */</span></span><br><span class="line">        <span class="keyword">int64_t</span> nr_file_pages;</span><br><span class="line">    &#125; field;</span><br><span class="line">    <span class="keyword">int64_t</span> arr[MI_FIELD_COUNT];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> meminfo mi;</span><br><span class="line">    <span class="keyword">union</span> zoneinfo zi;</span><br><span class="line">    <span class="keyword">if</span> (meminfo_parse(&amp;mi) &lt; <span class="number">0</span> || zoneinfo_parse(&amp;zi) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to get free memory!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>union meminfo mi</code> 和 <code>union zoneinfo zi</code> 表示系统当前的内存使用情况。<code>meminfo_parse</code> 和 <code>zoneinfo_parse</code> 分别读取 <code>/proc/meminfo</code> 和 <code>/proc/zoneinfo</code> 并将解析得到的数据填充到 <code>mi/zi</code>。（读者可以开个机器，然后 <code>cat /proc/meminfo</code> 看看具体的输出。关于他们解释，参考 <code>man 5 proc</code>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> other_free = <span class="number">0</span>, other_file = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min_score_adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_minfree_levels) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        other_free = mi.field.nr_free_pages - zi.field.totalreserve_pages;</span><br><span class="line">        <span class="keyword">if</span> (mi.field.nr_file_pages &gt; (mi.field.shmem + mi.field.unevictable + mi.field.swap_cached)) &#123;</span><br><span class="line">            other_file = (mi.field.nr_file_pages - mi.field.shmem -</span><br><span class="line">                          mi.field.unevictable - mi.field.swap_cached);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            other_file = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        min_score_adj = OOM_SCORE_ADJ_MAX + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lowmem_targets_size; i++) &#123;</span><br><span class="line">            minfree = lowmem_minfree[i];</span><br><span class="line">            <span class="keyword">if</span> (other_free &lt; minfree &amp;&amp; other_file &lt; minfree) &#123;</span><br><span class="line">                min_score_adj = lowmem_adj[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min_score_adj == OOM_SCORE_ADJ_MAX + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                ALOGI(<span class="string">"Ignore %s memory pressure event "</span></span><br><span class="line">                      <span class="string">"(free memory=%ldkB, cache=%ldkB, limit=%ldkB)"</span>,</span><br><span class="line">                      level_name[level], other_free * page_k, other_file * page_k,</span><br><span class="line">                      (<span class="keyword">long</span>)lowmem_minfree[lowmem_targets_size - <span class="number">1</span>] * page_k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Free up enough pages to push over the highest minfree level */</span></span><br><span class="line">        pages_to_free = lowmem_minfree[lowmem_targets_size - <span class="number">1</span>] -</span><br><span class="line">            ((other_free &lt; other_file) ? other_free : other_file);</span><br><span class="line">        <span class="keyword">goto</span> do_kill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>use_minfree_levels</code> 同样是从系统属性读取的配置，表示使用当我们准备杀死应用的时候，使用系统剩余的内存和文件缓存阈值作为判断依据。</p><p><code>other_free</code> 表示系统可用的内存页的数目。</p><p><code>nr_file_pages</code> 等于 <code>mi-&gt;field.cached</code>（文件在内存中的缓存）加上 <code>mi-&gt;field.swap_cached</code>（swap 出去又读进了内存的数据）加上 <code>mi-&gt;field.buffers</code>（硬盘的一个临时缓存），</p><p><code>mi.shmem</code> 表示 tmpfs 使用的内存数，<code>unevictable</code> 表示那些不能 swap out 的内存。</p><p>最后 <code>other_file</code> 基本就等于除 tmpfs 和 unevictable 外的缓存在内存的文件所占用的 page 数。</p><p>有了 <code>other_free</code> 和 <code>other_file</code> 后，我们根据 <code>lowmem_minfree</code> 的值来确定 <code>min_score_adj</code>。<code>min_score_adj</code> 表示可以回收的最低的 oomadj 值（oomadj 越大，优先级越低，越容易被杀死），oomadj 小于 <code>min_score_adj</code> 的进程在这次回收过程中不会被杀死。</p><p>回想一下前面的 <code>cmd_target</code>，<code>lowmem_minfree</code> 和 <code>lowmem_adj</code> 值就是在他里面设置的。</p><p><code>goto do_kill</code> 在函数比较靠后的地方，我们后面再看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> min_nr_free_pages; <span class="comment">/* recorded but not used yet */</span></span><br><span class="line">    <span class="keyword">int64_t</span> max_nr_free_pages;</span><br><span class="line">&#125; low_pressure_mem = &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level == VMPRESS_LEVEL_LOW) &#123;</span><br><span class="line">        record_low_pressure_levels(&amp;mi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">record_low_pressure_levels</span><span class="params">(<span class="keyword">union</span> meminfo *mi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low_pressure_mem.min_nr_free_pages == <span class="number">-1</span> ||</span><br><span class="line">        low_pressure_mem.min_nr_free_pages &gt; mi-&gt;field.nr_free_pages) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Low pressure min memory update from %"</span> PRId64 <span class="string">" to %"</span> PRId64,</span><br><span class="line">                low_pressure_mem.min_nr_free_pages, mi-&gt;field.nr_free_pages);</span><br><span class="line">        &#125;</span><br><span class="line">        low_pressure_mem.min_nr_free_pages = mi-&gt;field.nr_free_pages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Free memory at low vmpressure events occasionally gets spikes,</span></span><br><span class="line"><span class="comment">     * possibly a stale low vmpressure event with memory already</span></span><br><span class="line"><span class="comment">     * freed up (no memory pressure should have been reported).</span></span><br><span class="line"><span class="comment">     * Ignore large jumps in max_nr_free_pages that would mess up our stats.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (low_pressure_mem.max_nr_free_pages == <span class="number">-1</span> ||</span><br><span class="line">        (low_pressure_mem.max_nr_free_pages &lt; mi-&gt;field.nr_free_pages &amp;&amp;</span><br><span class="line">         mi-&gt;field.nr_free_pages - low_pressure_mem.max_nr_free_pages &lt;</span><br><span class="line">         low_pressure_mem.max_nr_free_pages * <span class="number">0.1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Low pressure max memory update from %"</span> PRId64 <span class="string">" to %"</span> PRId64,</span><br><span class="line">                low_pressure_mem.max_nr_free_pages, mi-&gt;field.nr_free_pages);</span><br><span class="line">        &#125;</span><br><span class="line">        low_pressure_mem.max_nr_free_pages = mi-&gt;field.nr_free_pages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>low_pressure_mem.min_nr_free_pages</code> 记录的是目前遇到的最低可用内存页数，<code>low_pressure_mem.max_nr_free_pages</code> 记录的是目前遇到的最大可用的内存页数。就像代码中注释说的，有时候可用的内存数会突然暴涨，这里过滤掉了这种情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMCG_MEMORY_USAGE <span class="meta-string">"/dev/memcg/memory.usage_in_bytes"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMCG_MEMORYSW_USAGE <span class="meta-string">"/dev/memcg/memory.memsw.usage_in_bytes"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level_oomadj[level] &gt; OOM_SCORE_ADJ_MAX) &#123;</span><br><span class="line">        <span class="comment">/* Do not monitor this pressure level */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> mem_usage, memsw_usage;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">reread_data</span> <span class="title">mem_usage_file_data</span> = &#123;</span></span><br><span class="line">        .filename = MEMCG_MEMORY_USAGE,</span><br><span class="line">        .fd = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">reread_data</span> <span class="title">memsw_usage_file_data</span> = &#123;</span></span><br><span class="line">        .filename = MEMCG_MEMORYSW_USAGE,</span><br><span class="line">        .fd = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mem_usage = get_memory_usage(&amp;mem_usage_file_data)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> do_kill;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((memsw_usage = get_memory_usage(&amp;memsw_usage_file_data)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> do_kill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> int64_t <span class="title">get_memory_usage</span><span class="params">(struct reread_data *file_data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int64_t</span> mem_usage;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reread_file(file_data, buf, <span class="keyword">sizeof</span>(buf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!parse_int64(buf, &amp;mem_usage)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s parse error"</span>, file_data-&gt;filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mem_usage == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"No memory!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem_usage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get_memory_usage</code> 的实现很简单，就是读取 <code>reread_data.filename</code> 的内容并转换为 <code>int64</code>。这里还需要注意的是 <code>mem_usage_file_data</code> 和 <code>memsw_usage_file_data</code> 是静态变量。第一次打开文件后，会把文件描述符缓存在 <code>reread_data.fd</code> 里。</p><p><code>mem_usage</code> 是所用的内存数，<code>memsw_usage</code> 是内存数加上 swap out 的内存数。接下来的代码根据这两个数据来计算内存压力（压力越大，swap 出去的内存就越多）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate percent for swappinness.</span></span><br><span class="line">    <span class="keyword">int64_t</span> mem_pressure = (mem_usage * <span class="number">100</span>) / memsw_usage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enable_pressure_upgrade &amp;&amp; level != VMPRESS_LEVEL_CRITICAL) &#123;</span><br><span class="line">        <span class="comment">// We are swapping too much.</span></span><br><span class="line">        <span class="keyword">if</span> (mem_pressure &lt; upgrade_pressure) &#123;</span><br><span class="line">            level = upgrade_level(level);</span><br><span class="line">            <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                ALOGI(<span class="string">"Event upgraded to %s"</span>, level_name[level]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the pressure is larger than downgrade_pressure lmk will not</span></span><br><span class="line">    <span class="comment">// kill any process, since enough memory is available.</span></span><br><span class="line">    <span class="keyword">if</span> (mem_pressure &gt; downgrade_pressure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Ignore %s memory pressure"</span>, level_name[level]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level == VMPRESS_LEVEL_CRITICAL &amp;&amp;</span><br><span class="line">               mem_pressure &gt; upgrade_pressure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Downgrade critical memory pressure"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade event, since enough memory available.</span></span><br><span class="line">        level = downgrade_level(level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里 <code>mem_pressure</code> 计算的是 <code>内存数 / (内存数 + swap)</code>，<code>mem_pressure</code> 越小，内存压力就越大。</p><p><code>enable_pressure_upgrade</code>、<code>upgrade_pressure</code> 和 <code>downgrade_pressure</code> 的值是我们在 <code>main</code> 函数里根据系统属性设置的。</p><p>在内存压力比较大并且 <code>enable_pressure_upgrade</code> 打开的情况下，我们把内存压力向上提升一个等级（以期释放更多的内存）；在内存压力小于 <code>downgrade_pressure</code> 的时候，内存是充足的，没有必要通过杀死应用来回收内存；如果内存压力中等（upgrade_pressure &lt; mem_pressure &lt; downgrade_pressure）但是 level 却是 critical，就给他降一级。</p><p>lmkd 在给 mp level 升级的时候需要打开 enable_pressure_upgrade（默认关闭），而降级却总是可行的，说明 lmkd 尽力在不杀死应用的情况下满足系统的内存需求。</p><p>到目前为止，我们得到了三组跟内存压力相关的参数：</p><ol><li>在 <code>use_minfree_levels</code> 的情况下，<code>min_score_adj</code> 和 <code>pages_to_free</code></li><li>内存压力 <code>level</code></li></ol><p>接下来，我们开始真正的进程回收工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">do_kill:</span><br><span class="line">    <span class="keyword">if</span> (low_ram_device) &#123;</span><br><span class="line">        <span class="comment">/* For Go devices kill only one task */</span></span><br><span class="line">        <span class="keyword">if</span> (find_and_kill_processes(level, level_oomadj[level], <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                ALOGI(<span class="string">"Nothing to kill"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回收对象时分两大类，小内存设备和“大”内存设备。小内存设备一次就杀一个进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_and_kill_processes</span><span class="params">(<span class="keyword">enum</span> vmpressure_level level,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> min_score_adj, <span class="keyword">int</span> pages_to_free)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> killed_size;</span><br><span class="line">    <span class="keyword">int</span> pages_freed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = OOM_SCORE_ADJ_MAX; i &gt;= min_score_adj; i--) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            procp = kill_heaviest_task ?</span><br><span class="line">                proc_get_heaviest(i) : proc_adj_lru(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!procp)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            killed_size = kill_one_process(procp, min_score_adj, level);</span><br><span class="line">            <span class="keyword">if</span> (killed_size &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pages_freed += killed_size;</span><br><span class="line">                <span class="keyword">if</span> (pages_freed &gt;= pages_to_free) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pages_freed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pages_freed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们从 oomadj 最大的应用开始回收，直到回收的内存页数达到 <code>pages_to_free</code>。对 <code>low_ram_device</code> 来说，<code>pages_to_free</code> 为 0，只有一个进程会被回收。</p><p><code>kill_heaviest_task</code> 是从系统属性读的，默认为 <code>false</code>。打开的情况下，在相关 oomadj 的进程里，我们优先回收使用内存最多的那个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc *<span class="title">proc_get_heaviest</span><span class="params">(<span class="keyword">int</span> oomadj)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">head</span> = &amp;<span class="title">procadjslot_list</span>[<span class="title">ADJTOSLOT</span>(<span class="title">oomadj</span>)];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">curr</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">maxprocp</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> maxsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != head) &#123;</span><br><span class="line">        <span class="keyword">int</span> pid = ((struct proc *)curr)-&gt;pid;</span><br><span class="line">        <span class="keyword">int</span> tasksize = proc_get_size(pid);</span><br><span class="line">        <span class="keyword">if</span> (tasksize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">next</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">            pid_remove(pid);</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tasksize &gt; maxsize) &#123;</span><br><span class="line">                maxsize = tasksize;</span><br><span class="line">                maxprocp = (struct proc *)curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprocp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是 <code>false</code>，调用的则是 <code>proc_adj_lru</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct adjslot_list *<span class="title">adjslot_tail</span><span class="params">(struct adjslot_list *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">asl</span> = <span class="title">head</span>-&gt;<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> asl == head ? <span class="literal">NULL</span> : asl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc *<span class="title">proc_adj_lru</span><span class="params">(<span class="keyword">int</span> oomadj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (struct proc *)adjslot_tail(&amp;procadjslot_list[ADJTOSLOT(oomadj)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们取的是列表的尾端；而插入新元素时，我们总是把它放在头端。</p><p><code>kill_one_process</code> 通过向应用发送信号 <code>SIGKILL</code> 来杀死对方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/* Kill one process specified by procp.  Returns the size of the process killed */</span><br><span class="line">static int kill_one_process(struct proc* procp, int min_score_adj,</span><br><span class="line">                            enum vmpressure_level level) &#123;</span><br><span class="line">    int pid = procp-&gt;pid;</span><br><span class="line">    uid_t uid = procp-&gt;uid;</span><br><span class="line">    char *taskname;</span><br><span class="line">    int tasksize;</span><br><span class="line">    int r;</span><br><span class="line"></span><br><span class="line">    taskname = proc_get_name(pid);</span><br><span class="line">    if (!taskname) &#123;</span><br><span class="line">        pid_remove(pid);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tasksize = proc_get_size(pid);</span><br><span class="line">    if (tasksize &lt;= 0) &#123;</span><br><span class="line">        pid_remove(pid);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = kill(pid, SIGKILL);</span><br><span class="line">    ALOGI(</span><br><span class="line">        &quot;Killing &apos;%s&apos; (%d), uid %d, adj %d\n&quot;</span><br><span class="line">        &quot;   to free %ldkB because system is under %s memory pressure oom_adj %d\n&quot;,</span><br><span class="line">        taskname, pid, uid, procp-&gt;oomadj, tasksize * page_k,</span><br><span class="line">        level_name[level], min_score_adj);</span><br><span class="line">    pid_remove(pid);</span><br><span class="line"></span><br><span class="line">    if (r) &#123;</span><br><span class="line">        ALOGE(&quot;kill(%d): errno=%d&quot;, pid, errno);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return tasksize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return tasksize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看不是 <code>low_ram_device</code> 的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">do_kill:</span><br><span class="line">    <span class="keyword">if</span> (low_ram_device) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!use_minfree_levels) &#123;</span><br><span class="line">            <span class="comment">/* If pressure level is less than critical and enough free swap then ignore */</span></span><br><span class="line">            <span class="keyword">if</span> (level &lt; VMPRESS_LEVEL_CRITICAL &amp;&amp;</span><br><span class="line">                mi.field.free_swap &gt; low_pressure_mem.max_nr_free_pages) &#123;</span><br><span class="line">                <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                    ALOGI(<span class="string">"Ignoring pressure since %"</span> PRId64</span><br><span class="line">                          <span class="string">" swap pages are available "</span>,</span><br><span class="line">                          mi.field.free_swap);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Free up enough memory to downgrate the memory pressure to low level */</span></span><br><span class="line">            <span class="keyword">if</span> (mi.field.nr_free_pages &lt; low_pressure_mem.max_nr_free_pages) &#123;</span><br><span class="line">                pages_to_free = low_pressure_mem.max_nr_free_pages -</span><br><span class="line">                    mi.field.nr_free_pages;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                    ALOGI(<span class="string">"Ignoring pressure since more memory is "</span></span><br><span class="line">                        <span class="string">"available (%"</span> PRId64 <span class="string">") than watermark (%"</span> PRId64 <span class="string">")"</span>,</span><br><span class="line">                        mi.field.nr_free_pages, low_pressure_mem.max_nr_free_pages);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min_score_adj = level_oomadj[level];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们总结过，在 <code>!use_minfree_levels</code> 的情况下，我们只有一个 mp <code>level</code>，还需要 <code>min_score_adj</code> 和 <code>pages_to_free</code> 才能开始回收进程。</p><p><code>low_pressure_mem.max_nr_free_pages</code> 是前面我们在 <code>record_low_pressure_levels</code> 中记录的，<code>free_swap</code> 是系统 swap 分区空余的大小；如果内存压力不是 critical 并且 swap 分区还足够大，就不回收进程了（lmkd 也是不容易啊，只有在实在没有办法了才杀我们应用）。</p><p>此外，在空余内存页比我们遇到过的发生 mp 事件时系统剩余内存最多的那次还要多的时候（比以往最好的情况还要好），也不回收应用。即便真的需要回收内存，我们也只回收到系统（内存）状态跟以往最好的那次为止（<code>pages_to_free = max_nr_free_pages - nr_free_pages</code>）。</p><p>这里计算出 <code>pages_to_free</code> 和 <code>min_scrore_adj</code> 后，我们下面就该回收进程了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">do_kill:</span><br><span class="line">    <span class="keyword">if</span> (low_ram_device) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!use_minfree_levels) &#123;</span><br><span class="line">            <span class="comment">// compute pages_to_free &amp; min_score_adj</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pages_freed = find_and_kill_processes(level, min_score_adj, pages_to_free);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_minfree_levels) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Killing because cache %ldkB is below "</span></span><br><span class="line">                  <span class="string">"limit %ldkB for oom_adj %d\n"</span></span><br><span class="line">                  <span class="string">"   Free memory is %ldkB %s reserved"</span>,</span><br><span class="line">                  other_file * page_k, minfree * page_k, min_score_adj,</span><br><span class="line">                  other_free * page_k, other_free &gt;= <span class="number">0</span> ? <span class="string">"above"</span> : <span class="string">"below"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pages_freed &lt; pages_to_free) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Unable to free enough memory (pages to free=%d, pages freed=%d)"</span>,</span><br><span class="line">                  pages_to_free, pages_freed);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGI(<span class="string">"Reclaimed enough memory (pages to free=%d, pages freed=%d)"</span>,</span><br><span class="line">                  pages_to_free, pages_freed);</span><br><span class="line">            gettimeofday(&amp;last_report_tm, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>find_and_kill_processes</code> 的实现在前面我们已经看了，他根据进程的 oomajd 值从大到小回收那些 oomadj 值比 <code>min_score_adj</code> 大的应用，并且只回收 <code>pages_to_free</code> 个内存页就停止。</p><p>最后把当前时间记录在 <code>last_report_tm</code>，他表示上次成功回收进程的时间（和 <code>kill_timeout_ms</code> 组合使用）。</p><p>到这里，我们就算是把 lmkd 的实现整个都读完了（长舒一口气）。</p>]]></content>
    
    <summary type="html">
    
      lmkd 是在应用层实现的取代原有 lowmemorykiller 驱动的守护进程。通过监听 memory pressure 事件，lmkd 可以在内存 low、medium 和 critical 的时候得到通知，进而回收优先级比较低的进程
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
  </entry>
  
  <entry>
    <title>Android P 源码分析 4 - logd 的初始化</title>
    <link href="https://jekton.github.io/2019/03/20/android9-logd-init/"/>
    <id>https://jekton.github.io/2019/03/20/android9-logd-init/</id>
    <published>2019-03-20T11:45:44.000Z</published>
    <updated>2019-03-20T12:25:21.225Z</updated>
    
    <content type="html"><![CDATA[<p>为了跟老罗的书保持一个比较一致的步伐，这一篇开始我们来看 logd 的实现。当然，这个 logd 不是老罗书里讲的 log 驱动，而是在应用层实现的一个守护进程。</p><a id="more"></a><p>在进入正题之前先说明一下，logd 虽然是用 C++ 写的，但由于比较接近系统，需要读者对系统编程有一定的了解。不熟悉的读者可以通过《Linux系统编程》快速入个门，《UNIX环境高级程序设计》则是关于这一主题最好的书籍。</p><h2 id="logd-的启动"><a href="#logd-的启动" class="headerlink" title="logd 的启动"></a>logd 的启动</h2><p>通过查看 logd 源码目录，我们可以看到这样一个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// system/core/logd/logd.rc</span><br><span class="line">service logd /system/bin/logd</span><br><span class="line">    socket logd stream 0666 logd logd</span><br><span class="line">    socket logdr seqpacket 0666 logd logd</span><br><span class="line">    socket logdw dgram+passcred 0222 logd logd</span><br><span class="line">    file /proc/kmsg r</span><br><span class="line">    file /dev/kmsg w</span><br><span class="line">    user logd</span><br><span class="line">    group logd system package_info readproc</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line"></span><br><span class="line">service logd-reinit /system/bin/logd --reinit</span><br><span class="line">    oneshot</span><br><span class="line">    disabled</span><br><span class="line">    user logd</span><br><span class="line">    group logd</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    write /dev/event-log-tags &quot;# content owned by logd</span><br><span class="line">&quot;</span><br><span class="line">    chown logd logd /dev/event-log-tags</span><br><span class="line">    chmod 0644 /dev/event-log-tags</span><br></pre></td></tr></table></figure><p>init 进程是在 post-fs 阶段启动 logd 的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// system/core/rootdir/init.rc</span><br><span class="line">on post-fs</span><br><span class="line">    # Load properties from</span><br><span class="line">    #     /system/build.prop,</span><br><span class="line">    #     /odm/build.prop,</span><br><span class="line">    #     /vendor/build.prop and</span><br><span class="line">    #     /factory/factory.prop</span><br><span class="line">    load_system_props</span><br><span class="line">    # start essential services</span><br><span class="line">    start logd</span><br><span class="line">    start servicemanager</span><br><span class="line">    start hwservicemanager</span><br><span class="line">    start vndservicemanage</span><br></pre></td></tr></table></figure><p>从这里我们可以得出几个信息：</p><ol><li>logd 是经由 init 进程启动的</li><li>init 进程为 logd 创建了 3 个（UNIX 域）socket，分别是 <code>/dev/socket/logd, /dev/socket/logdr, /dev/socket/logdw</code></li><li>init 进程为 logd 打开了两个文件 <code>/proc/kmsg, /dev/kmsg</code></li><li>把 logd 的 uid 设置为 logd，gid 设置为 logd、system、package_info 和 readproc</li><li>把 logd 进程的 pid 写到文件 /dev/cpuset/system-background/tasks</li></ol><p>关于 socket 的相关知识，读者可以参考《UNIX 网络编程，卷1》。</p><p>logd-reinit 用来触发 logd 的重新初始化，同样执行的是 logd 程序，只是多了一个参数 <code>--init</code>。后面我们讲 logd 的控制命令时再详细说。</p><p>至于 init 进程如何解析 init.rc，以后有机会写 init 进程相关文章的时候再讨论。</p><h2 id="logd-的初始化"><a href="#logd-的初始化" class="headerlink" title="logd 的初始化"></a>logd 的初始化</h2><p>init 进程启动 logd 后，接下来执行的自然是 logd 的 <code>main</code> 函数。这个函数有点长，这里先把代码放上来，后面再一点点慢慢看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Foreground waits for exit of the main persistent threads</span></span><br><span class="line"><span class="comment">// that are started here. The threads are created to manage</span></span><br><span class="line"><span class="comment">// UNIX domain client sockets for writing, reading and</span></span><br><span class="line"><span class="comment">// controlling the user space logger, and for any additional</span></span><br><span class="line"><span class="comment">// logging plugins like auditd and restart control. Additional</span></span><br><span class="line"><span class="comment">// transitory per-client threads are created for each reader.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// logd is written under the assumption that the timezone is UTC.</span></span><br><span class="line">    <span class="comment">// If TZ is not set, persist.sys.timezone is looked up in some time utility</span></span><br><span class="line">    <span class="comment">// libc functions, including mktime. It confuses the logd time handling,</span></span><br><span class="line">    <span class="comment">// so here explicitly set TZ to UTC, which overrides the property.</span></span><br><span class="line">    setenv(<span class="string">"TZ"</span>, <span class="string">"UTC"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// issue reinit command. KISS argument parsing.</span></span><br><span class="line">    <span class="keyword">if</span> ((argc &gt; <span class="number">1</span>) &amp;&amp; argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--reinit"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> issueReinit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> dev_kmsg[] = <span class="string">"/dev/kmsg"</span>;</span><br><span class="line">    fdDmesg = android_get_control_file(dev_kmsg);</span><br><span class="line">    <span class="keyword">if</span> (fdDmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fdDmesg = TEMP_FAILURE_RETRY(open(dev_kmsg, O_WRONLY | O_CLOEXEC));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fdPmesg = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> klogd = __android_logger_property_get_bool(</span><br><span class="line">        <span class="string">"ro.logd.kernel"</span>,</span><br><span class="line">        BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_ENG | BOOL_DEFAULT_FLAG_SVELTE);</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> proc_kmsg[] = <span class="string">"/proc/kmsg"</span>;</span><br><span class="line">        fdPmesg = android_get_control_file(proc_kmsg);</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fdPmesg = TEMP_FAILURE_RETRY(</span><br><span class="line">                open(proc_kmsg, O_RDONLY | O_NDELAY | O_CLOEXEC));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) android::prdebug(<span class="string">"Failed to open %s\n"</span>, proc_kmsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reinit Thread</span></span><br><span class="line">    sem_init(&amp;reinit, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;uidName, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_name, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">if</span> (!pthread_attr_init(&amp;attr)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(param));</span><br><span class="line">        pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line">        pthread_attr_setschedpolicy(&amp;attr, SCHED_BATCH);</span><br><span class="line">        <span class="keyword">if</span> (!pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED)) &#123;</span><br><span class="line">            <span class="keyword">pthread_t</span> thread;</span><br><span class="line">            reinit_running = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (pthread_create(&amp;thread, &amp;attr, reinit_thread_start, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">                reinit_running = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> auditd =</span><br><span class="line">        __android_logger_property_get_bool(<span class="string">"ro.logd.auditd"</span>, BOOL_DEFAULT_TRUE);</span><br><span class="line">    <span class="keyword">if</span> (drop_privs(klogd, auditd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serves the purpose of managing the last logs times read on a</span></span><br><span class="line">    <span class="comment">// socket connection, and as a reader lock on a range of log</span></span><br><span class="line">    <span class="comment">// entries.</span></span><br><span class="line"></span><br><span class="line">    LastLogTimes* times = <span class="keyword">new</span> LastLogTimes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogBuffer is the object which is responsible for holding all</span></span><br><span class="line">    <span class="comment">// log entries.</span></span><br><span class="line"></span><br><span class="line">    logBuf = <span class="keyword">new</span> LogBuffer(times);</span><br><span class="line"></span><br><span class="line">    signal(SIGHUP, reinit_signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__android_logger_property_get_bool(</span><br><span class="line">            <span class="string">"logd.statistics"</span>, BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_PERSIST |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_ENG |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_SVELTE)) &#123;</span><br><span class="line">        logBuf-&gt;enableStatistics();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogReader listens on /dev/socket/logdr. When a client</span></span><br><span class="line">    <span class="comment">// connects, log entries in the LogBuffer are written to the client.</span></span><br><span class="line"></span><br><span class="line">    LogReader* reader = <span class="keyword">new</span> LogReader(logBuf);</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogListener listens on /dev/socket/logdw for client</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogListener* swl = <span class="keyword">new</span> LogListener(logBuf, reader);</span><br><span class="line">    <span class="comment">// Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value</span></span><br><span class="line">    <span class="keyword">if</span> (swl-&gt;startListener(<span class="number">600</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Command listener listens on /dev/socket/logd for incoming logd</span></span><br><span class="line">    <span class="comment">// administrative commands.</span></span><br><span class="line"></span><br><span class="line">    CommandListener* cl = <span class="keyword">new</span> CommandListener(logBuf, reader, swl);</span><br><span class="line">    <span class="keyword">if</span> (cl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogAudit listens on NETLINK_AUDIT socket for selinux</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogAudit* al = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (auditd) &#123;</span><br><span class="line">        al = <span class="keyword">new</span> LogAudit(logBuf, reader,</span><br><span class="line">                          __android_logger_property_get_bool(</span><br><span class="line">                              <span class="string">"ro.logd.auditd.dmesg"</span>, BOOL_DEFAULT_TRUE)</span><br><span class="line">                              ? fdDmesg</span><br><span class="line">                              : <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogKlog* kl = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        kl = <span class="keyword">new</span> LogKlog(logBuf, reader, fdDmesg, fdPmesg, al != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readDmesg(al, kl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// failure is an option ... messages are in dmesg (required by standard)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kl &amp;&amp; kl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> kl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (al &amp;&amp; al-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> al;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TEMP_FAILURE_RETRY(pause());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打开-dev-kmsg"><a href="#打开-dev-kmsg" class="headerlink" title="打开 /dev/kmsg"></a>打开 /dev/kmsg</h3><p>前面我们看 init.rc 的时候已经知道，init 进程会为我们打开设备文件 <code>/dev/kmsg</code>，所以这里我们只要找到他对应的文件描述符就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fdDmesg = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> dev_kmsg[] = <span class="string">"/dev/kmsg"</span>;</span><br><span class="line">    fdDmesg = android_get_control_file(dev_kmsg);</span><br><span class="line">    <span class="keyword">if</span> (fdDmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fdDmesg = TEMP_FAILURE_RETRY(open(dev_kmsg, O_WRONLY | O_CLOEXEC));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程想要使用父进程为其打开的文件，一般情况下有这么几种方法：</p><ol><li>约定好对应的描述符是多少（比方说，使用 shell 对输入输出进行重定向，就是在 0 1 2 上打开文件）</li><li>通过命令行参数告诉子进程（如，<code>--kmsg 1</code>）</li><li>通过环境变量。这个是 init 进程采用的方法</li></ol><p>下面我们就来看看 <code>android_get_control_file</code> 是如何实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libcutils/android_get_control_file.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_FILE_ENV_PREFIX <span class="meta-string">"ANDROID_FILE_"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libcutils/android_get_control_file.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">android_get_control_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = __android_get_control_from_env(ANDROID_FILE_ENV_PREFIX, path);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__)</span></span><br><span class="line">    <span class="comment">// Find file path from /proc and make sure it is correct</span></span><br><span class="line">    <span class="keyword">char</span> *proc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (asprintf(&amp;proc, <span class="string">"/proc/self/fd/%d"</span>, fd) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!proc) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="comment">// readlink() does not guarantee a nul byte, len+2 so we catch truncation.</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(<span class="built_in">calloc</span>(<span class="number">1</span>, len + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">        <span class="built_in">free</span>(proc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">ssize_t</span> ret = TEMP_FAILURE_RETRY(readlink(proc, buf, len + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(proc);</span><br><span class="line">    <span class="keyword">int</span> cmp = (len != <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(ret)) || <span class="built_in">strcmp</span>(buf, path);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmp != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// It is what we think it is</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bionic/libc/include/unistd.h</span></span><br><span class="line"><span class="comment">/* Used to retry syscalls that can return EINTR. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_FAILURE_RETRY(exp) (&#123;         \</span></span><br><span class="line">    __typeof__(<span class="built_in">exp</span>) _rc;                   \</span><br><span class="line">    <span class="keyword">do</span> &#123;                                   \</span><br><span class="line">        _rc = (<span class="built_in">exp</span>);                       \</span><br><span class="line">    &#125; <span class="keyword">while</span> (_rc == <span class="number">-1</span> &amp;&amp; errno == EINTR); \</span><br><span class="line">    _rc; &#125;)</span><br></pre></td></tr></table></figure><p><code>__android_get_control_from_env</code> 拿到这个 <code>fd</code> 后，如果运行的系统是 Linux，就执行后面的一些检查。具体来说就是读符号链接 <code>/proc/self/fd/#fd_num</code> 的内容，如果这个内容跟 <code>path</code> 相等，就认为这个描述符确实是我们所需要的。</p><p><code>TEMP_FAILURE_RETRY</code> 在系统的源码里出现的频率很高，主要用来处理系统调动被信号中断的情况。<code>__typeof__</code> 是编译器提供的运算符，类似于 C++ 的 <code>decltype</code>。</p><p>下面我们看看 <code>__android_get_control_from_env</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libcutils/android_get_control_file.cpp</span></span><br><span class="line">LIBCUTILS_HIDDEN <span class="keyword">int</span> __android_get_control_from_env(<span class="keyword">const</span> <span class="keyword">char</span>* prefix,</span><br><span class="line">                                                    <span class="keyword">const</span> <span class="keyword">char</span>* name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prefix || !name) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *key = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (asprintf(&amp;key, <span class="string">"%s%s"</span>, prefix, name) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *cp = key;</span><br><span class="line">    <span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(*cp)) *cp = <span class="string">'_'</span>;</span><br><span class="line">        ++cp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* val = getenv(key);</span><br><span class="line">    <span class="built_in">free</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (!val) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> fd = strtol(val, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (errno) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// validity checking</span></span><br><span class="line">    <span class="keyword">if</span> ((fd &lt; <span class="number">0</span>) || (fd &gt; INT_MAX)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since we are inheriting an fd, it could legitimately exceed _SC_OPEN_MAX</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Still open?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(F_GETFD) <span class="comment">// Lowest overhead</span></span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(fcntl(fd, F_GETFD)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(F_GETFL) <span class="comment">// Alternate lowest overhead</span></span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// Hail Mary pass</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(fstat(fd, &amp;s)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们传入的的 <code>ANDROID_FILE_</code> 和 <code>/dev/kmsg</code>，这里我们把他们拼接起来得到 <code>ANDROID_FILE_/dev/kmsg</code>。随后的循环把不是字母、数字的字符换成 <code>_</code>，最后这个 key 是 <code>ANDROID_FILE__dev_kmsg</code>。</p><p>我们拿这个 key 去 <code>getenv</code>，如果存在这个环境变量，就调用 <code>strtol</code> 将其转换为 <code>long</code>。所谓的文件描述符，其实仅仅是一个数字。这里将 <code>val</code> 转换为 <code>long</code>，我们也就拿到了文件对应的 fd。</p><p>拿到这个 fd 后，还要验证一下它是不是还打开着。这里使用的方法是用 <code>fcntl</code> 去获取一下 fd flag。如果成功，文件自然是打开着的。</p><p>获取 fd flag 一般只需要访问文件表，所以是最快的；获取 file flag 要通过文件表去拿 file 对象，这个慢一点；而  file stat 则需要再通过 file 对象拿到 inode 节点的数据，这个是最慢的。</p><p>我们直接通过环境变量取得描述符，这并不能保证它就是我们所期望的文件（比方说，可以先关掉这个 fd，然后再打开任意一个文件，新打开的文件 fd 的数值将会和我们刚刚关闭的那个一样），所以在 <code>android_get_control_file</code> 里还要用 <code>/proc/self/fd/##</code> 验证多一次。</p><p><code>/dev/kmsg</code> 设备文件是用来读写内核 log 的，有兴趣的读者可以参考文档 <a href="https://www.kernel.org/doc/Documentation/ABI/testing/dev-kmsg" target="_blank" rel="noopener">dev-kmsg</a>。logd 本身提供的就是 log 机制，但在自己还没启动完成或者出错的时候，如果需要写 log，就只能写到内核的 log 去了。</p><h3 id="打开-proc-kmsg"><a href="#打开-proc-kmsg" class="headerlink" title="打开 /proc/kmsg"></a>打开 /proc/kmsg</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fdPmesg = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> klogd = __android_logger_property_get_bool(</span><br><span class="line">        <span class="string">"ro.logd.kernel"</span>,</span><br><span class="line">        BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_ENG | BOOL_DEFAULT_FLAG_SVELTE);</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> proc_kmsg[] = <span class="string">"/proc/kmsg"</span>;</span><br><span class="line">        fdPmesg = android_get_control_file(proc_kmsg);</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fdPmesg = TEMP_FAILURE_RETRY(</span><br><span class="line">                open(proc_kmsg, O_RDONLY | O_NDELAY | O_CLOEXEC));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) android::prdebug(<span class="string">"Failed to open %s\n"</span>, proc_kmsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开 <code>/proc/kmsg</code> 是为了读内核的日志，但这个是可选的，这里我们通过读系统属性来判断是否需要读内核的日志。</p><h3 id="启动-reinit-线程"><a href="#启动-reinit-线程" class="headerlink" title="启动 reinit 线程"></a>启动 reinit 线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line">    <span class="comment">// open /proc/kmsg</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reinit Thread</span></span><br><span class="line">    sem_init(&amp;reinit, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;uidName, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_name, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">if</span> (!pthread_attr_init(&amp;attr)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(param));</span><br><span class="line">        pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line">        pthread_attr_setschedpolicy(&amp;attr, SCHED_BATCH);</span><br><span class="line">        <span class="keyword">if</span> (!pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED)) &#123;</span><br><span class="line">            <span class="keyword">pthread_t</span> thread;</span><br><span class="line">            reinit_running = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (pthread_create(&amp;thread, &amp;attr, reinit_thread_start, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">                reinit_running = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reinit 线程主要处理最开始时前面我们提到了 reinit 命令。另外，logd 还使用这个线程做 uid 转 name 的工作。关于他的实现，后面我们讲 logd 的管理接口时再看。</p><h3 id="设置运行时优先级、权限"><a href="#设置运行时优先级、权限" class="headerlink" title="设置运行时优先级、权限"></a>设置运行时优先级、权限</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line">    <span class="comment">// open /proc/kmsg</span></span><br><span class="line">    <span class="comment">// 启动 Reinit Thread</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> auditd =</span><br><span class="line">        __android_logger_property_get_bool(<span class="string">"ro.logd.auditd"</span>, BOOL_DEFAULT_TRUE);</span><br><span class="line">    <span class="keyword">if</span> (drop_privs(klogd, auditd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分代码跟平台相关性比较大，普通的应用开发一般不会使用到这些。这部分我们这里先略过，后面用单独的一篇文章来讲。</p><h3 id="启动各个-log-监听器"><a href="#启动各个-log-监听器" class="headerlink" title="启动各个 log 监听器"></a>启动各个 log 监听器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line">    <span class="comment">// open /proc/kmsg</span></span><br><span class="line">    <span class="comment">// 启动 Reinit Thread</span></span><br><span class="line">    <span class="comment">// 设置运行时优先级、权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serves the purpose of managing the last logs times read on a</span></span><br><span class="line">    <span class="comment">// socket connection, and as a reader lock on a range of log</span></span><br><span class="line">    <span class="comment">// entries.</span></span><br><span class="line"></span><br><span class="line">    LastLogTimes* times = <span class="keyword">new</span> LastLogTimes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogBuffer is the object which is responsible for holding all</span></span><br><span class="line">    <span class="comment">// log entries.</span></span><br><span class="line"></span><br><span class="line">    logBuf = <span class="keyword">new</span> LogBuffer(times);</span><br><span class="line"></span><br><span class="line">    signal(SIGHUP, reinit_signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__android_logger_property_get_bool(</span><br><span class="line">            <span class="string">"logd.statistics"</span>, BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_PERSIST |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_ENG |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_SVELTE)) &#123;</span><br><span class="line">        logBuf-&gt;enableStatistics();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogReader listens on /dev/socket/logdr. When a client</span></span><br><span class="line">    <span class="comment">// connects, log entries in the LogBuffer are written to the client.</span></span><br><span class="line"></span><br><span class="line">    LogReader* reader = <span class="keyword">new</span> LogReader(logBuf);</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogListener listens on /dev/socket/logdw for client</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogListener* swl = <span class="keyword">new</span> LogListener(logBuf, reader);</span><br><span class="line">    <span class="comment">// Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value</span></span><br><span class="line">    <span class="keyword">if</span> (swl-&gt;startListener(<span class="number">600</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Command listener listens on /dev/socket/logd for incoming logd</span></span><br><span class="line">    <span class="comment">// administrative commands.</span></span><br><span class="line"></span><br><span class="line">    CommandListener* cl = <span class="keyword">new</span> CommandListener(logBuf, reader, swl);</span><br><span class="line">    <span class="keyword">if</span> (cl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogAudit listens on NETLINK_AUDIT socket for selinux</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogAudit* al = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (auditd) &#123;</span><br><span class="line">        al = <span class="keyword">new</span> LogAudit(logBuf, reader,</span><br><span class="line">                          __android_logger_property_get_bool(</span><br><span class="line">                              <span class="string">"ro.logd.auditd.dmesg"</span>, BOOL_DEFAULT_TRUE)</span><br><span class="line">                              ? fdDmesg</span><br><span class="line">                              : <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogKlog* kl = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        kl = <span class="keyword">new</span> LogKlog(logBuf, reader, fdDmesg, fdPmesg, al != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readDmesg(al, kl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// failure is an option ... messages are in dmesg (required by standard)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kl &amp;&amp; kl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> kl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (al &amp;&amp; al-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> al;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TEMP_FAILURE_RETRY(pause());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的这些代码实现上算是非常直观的，各个类的作用也都通过注释写得很清楚。<code>LogAudit</code> 读的是 selinux 的 log，<code>LogKlog</code> 读的是内核的 log，<code>readDmsg</code> 用 <code>klogctl</code> 把内核的 log 读出来以后，又把数据通过 <code>LogAudit</code> 和 <code>LogKlog</code> 写到由 logd 管理的 <code>LogBuffer</code> 里面。这两个我都不太熟悉，后面我们先就直接忽略他了。哪天补上了相关知识点，有机会再来写多两篇。</p><p>到目前为止，我们算是了解了 logd 的骨架，后面我们再分 4 篇文章，分别写 Linux 的权限控制、logd 命令控制、读 log 写 log。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了跟老罗的书保持一个比较一致的步伐，这一篇开始我们来看 logd 的实现。当然，这个 logd 不是老罗书里讲的 log 驱动，而是在应用层实现的一个守护进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
  </entry>
  
  <entry>
    <title>Android P 源码分析 3 - SharedPreferences 源码分析</title>
    <link href="https://jekton.github.io/2019/03/19/android9-sp/"/>
    <id>https://jekton.github.io/2019/03/19/android9-sp/</id>
    <published>2019-03-19T11:30:50.000Z</published>
    <updated>2019-03-19T02:14:55.836Z</updated>
    
    <content type="html"><![CDATA[<p>本来按顺序这一篇应该是 logd，但突然有点好奇 SP 在保存数据的时候是怎么同步的，就还是先看 SP 吧，当做在开始啃 logd 这个硬骨头前轻松一下（虽然这么说，SP 还是有很多值得我们学习的地方的）。</p><a id="more"></a><h2 id="获取-SP-实例"><a href="#获取-SP-实例" class="headerlink" title="获取 SP 实例"></a>获取 SP 实例</h2><p>我们通过调用 <code>Context.getSharedPreferences</code> 获取一个 SharedPreferences 实例的时候，真正的实现在 <code>ContextImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(String name, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// At least one application in the world actually passes in a null</span></span><br><span class="line">    <span class="comment">// name.  This happened to work because when we generated the file name</span></span><br><span class="line">    <span class="comment">// we would stringify it to "null.xml".  Nice.</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">            Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = <span class="string">"null"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File file;</span><br><span class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSharedPrefsPaths == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSharedPrefsPaths = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        file = mSharedPrefsPaths.get(name);</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">            file = getSharedPreferencesPath(name);</span><br><span class="line">            mSharedPrefsPaths.put(name, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(File file, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">        sp = cache.get(file);</span><br><span class="line">        <span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkMode(mode);</span><br><span class="line">            <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isCredentialProtectedStorage()</span><br><span class="line">                        &amp;&amp; !getSystemService(UserManager.class)</span><br><span class="line">                                .isUserUnlockingOrUnlocked(UserHandle.myUserId())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"SharedPreferences in credential encrypted "</span></span><br><span class="line">                            + <span class="string">"storage are not available until after user is unlocked"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sp = <span class="keyword">new</span> SharedPreferencesImpl(file, mode);</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="comment">// If somebody else (some other process) changed the prefs</span></span><br><span class="line">        <span class="comment">// file behind our back, we reload it.  This has been the</span></span><br><span class="line">        <span class="comment">// historical (if undocumented) behavior.</span></span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map from package name, to preference name, to cached preferences.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"ContextImpl.class"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"ContextImpl.class"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; <span class="title">getSharedPreferencesCacheLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sSharedPrefsCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sSharedPrefsCache = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String packageName = getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);</span><br><span class="line">    <span class="keyword">if</span> (packagePrefs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        packagePrefs = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个方法的实现都相当的直观，唯一有趣的是 <code>getSharedPreferencesCacheLocked</code> 里面那个 <code>packageName</code>。我们知道，一个应用的包名并不会改变；在访问内存中数据时，不同进程也不会互相干扰。这样看来，用 packageName 做 key 的这个 <code>sSharedPrefsCache</code> 是否有点多余？</p><p>通过查看 git 提交记录 <code>8e3ddab</code> 可以看到这样一句说明：</p><blockquote><p>Otherwise multiple applications using the same process can end up leaking SharedPreferences instances between the apps</p></blockquote><p>其实 Android 有一个相当不常用的特性——多个应用可以共用同一个进程。在这种情况下，这里用 package name 就能够把各个应用的 SP 区分开。</p><p>这里的实现还隐含了 SP 的一个特性：一旦数据加载到内存，除非我们删除整个 SP，内存中的数据在整个进程的生命周期中都存在。正常情况下，SP 中的数据量是非常小的，这个并不会导致什么问题。</p><h2 id="SP-的初始化"><a href="#SP-的初始化" class="headerlink" title="SP 的初始化"></a>SP 的初始化</h2><p>还是跟前面一样，我们直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/core/java/android/app/SharedPreferencesImpl.java</span></span><br><span class="line">SharedPreferencesImpl(File file, <span class="keyword">int</span> mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    mMode = mode;</span><br><span class="line">    mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    mMap = <span class="keyword">null</span>;</span><br><span class="line">    mThrowable = <span class="keyword">null</span>;</span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startLoadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"SharedPreferencesImpl-load"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，SP 一创建就开始在后台加载数据了。利用这个特性，对于比较大的 SP 并且预期很快就要用到，可以提前获取 SP 实例，以触发他的初始化。这样一来，在随后我们真正需要读取里面的数据时，他很可能就已经加载完成，从而避免了第一次读取时的卡顿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLoaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debugging</span></span><br><span class="line">    <span class="keyword">if</span> (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempt to read preferences file "</span> + mFile + <span class="string">" without permission"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">null</span>;</span><br><span class="line">    StructStat stat = <span class="keyword">null</span>;</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        <span class="keyword">if</span> (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                str = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(mFile), <span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">                map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Cannot read "</span> + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">        <span class="comment">// An errno exception means the stat failed. Treat as empty/non-existing by</span></span><br><span class="line">        <span class="comment">// ignoring.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="keyword">true</span>;</span><br><span class="line">        mThrowable = thrown;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It's important that we always signal waiters, even if we'll make</span></span><br><span class="line">        <span class="comment">// them fail with an exception. The try-finally is pretty wide, but</span></span><br><span class="line">        <span class="comment">// better safe than sorry.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (thrown == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mMap = map;</span><br><span class="line">                    <span class="comment">// 文件的最后修改时间</span></span><br><span class="line">                    mStatTimestamp = stat.st_mtim;</span><br><span class="line">                    <span class="comment">// 文件大小</span></span><br><span class="line">                    mStatSize = stat.st_size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// In case of a thrown exception, we retain the old map. That allows</span></span><br><span class="line">            <span class="comment">// any open editors to commit and store updates.</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            mThrowable = t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Os.stat</code> 用来获取文件的元信息，它不是 JDK 提供的 API。关于它的实现，有兴趣的读者可以参考《UNIX 环境高级编程》（APUE）。</p><p>XML 的解析并不是我们关心的东西，只要知道 SP 是用 XML 文件存储的就好。</p><p>加载成功后的 <code>notifyAll</code> 我们要结合 <code>awaitLoadedLocked</code> 来看。在我们准备读、写 SP 的时候，都会先调用 <code>awaitLoadedLocked</code> 等待 <code>loadFromDisk</code>。<code>loadFromDisk</code> 最后的 <code>notifyAll</code> 就是为了唤醒这些等待数据加载完成的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="comment">// Raise an explicit StrictMode onReadFromDisk for this</span></span><br><span class="line">        <span class="comment">// thread, since the real read will be in a different</span></span><br><span class="line">        <span class="comment">// thread and otherwise ignored by StrictMode.</span></span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mThrowable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(mThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mThrowable</code> 是在数据加载失败时由 <code>loadFromDisk</code> 设置的。这里相当于把后台的数据加载线程发生的异常转移到了实际需要读写 SP 的线程，有一定的借鉴的意义。</p><h2 id="从-SP-中读取数据"><a href="#从-SP-中读取数据" class="headerlink" title="从 SP 中读取数据"></a>从 SP 中读取数据</h2><p>读数据的情况很简单，只需要等 <code>loadFromDisk</code> 加载完数据，然后直接从 map 里面 get 就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key, @Nullable String defValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.get(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读其他类型的情况类似，这里就不看了。</p><h2 id="向-SP-写入数据"><a href="#向-SP-写入数据" class="headerlink" title="向 SP 写入数据"></a>向 SP 写入数据</h2><p>写数据的时候，我们要先获取一个 <code>Editor</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> remove the need to call awaitLoadedLocked() when</span></span><br><span class="line">    <span class="comment">// requesting an editor.  will require some work on the</span></span><br><span class="line">    <span class="comment">// Editor, but then we should be able to do:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      context.getSharedPreferences(..).edit().putString(..).apply()</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// ... all without blocking.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EditorImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mEditorLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"mEditorLock"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; mModified = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"mEditorLock"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mClear = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Editor <span class="title">putString</span><span class="params">(String key, @Nullable String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            mModified.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Editor <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            mModified.put(key, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Editor <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            mClear = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EditorImpl</code> 把所有的修改都保存在成员变量 <code>mModified</code> 和 <code>mClear</code> 里，以达到批量修改的目的。下面我们看看他的 <code>apply</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">        <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        mcr.writtenToDiskLatch.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                        Log.d(TAG, mFile.getName() + <span class="string">":"</span> + mcr.memoryStateGeneration</span><br><span class="line">                                + <span class="string">" applied after "</span> + (System.currentTimeMillis() - startTime)</span><br><span class="line">                                + <span class="string">" ms"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">        Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    awaitCommit.run();</span><br><span class="line">                    QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Okay to notify the listeners before it's hit disk</span></span><br><span class="line">        <span class="comment">// because the listeners should always get the same</span></span><br><span class="line">        <span class="comment">// SharedPreferences instance back, which has the</span></span><br><span class="line">        <span class="comment">// changes reflected in memory.</span></span><br><span class="line">        notifyListeners(mcr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分是三个步骤：</p><ol><li>把修改写到内存的缓存里</li><li>把修改写到硬盘（文件）</li><li>通知监听者</li></ol><p>下面我们一个一个步骤来看：</p><h3 id="把修改写到内存的缓存里"><a href="#把修改写到内存的缓存里" class="headerlink" title="把修改写到内存的缓存里"></a>把修改写到内存的缓存里</h3><p>这一步是由 <code>commitToMemory</code> 实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true if any changes were made</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MemoryCommitResult <span class="title">commitToMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> memoryStateGeneration;</span><br><span class="line">        List&lt;String&gt; keysModified = <span class="keyword">null</span>;</span><br><span class="line">        Set&lt;OnSharedPreferenceChangeListener&gt; listeners = <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (SharedPreferencesImpl.<span class="keyword">this</span>.mLock) &#123;</span><br><span class="line">            <span class="comment">// We optimistically don't make a deep copy until</span></span><br><span class="line">            <span class="comment">// a memory commit comes in when we're already</span></span><br><span class="line">            <span class="comment">// writing to disk.</span></span><br><span class="line">            <span class="keyword">if</span> (mDiskWritesInFlight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// We can't modify our mMap as a currently</span></span><br><span class="line">                <span class="comment">// in-flight write owns it.  Clone it before</span></span><br><span class="line">                <span class="comment">// modifying it.</span></span><br><span class="line">                <span class="comment">// noinspection unchecked</span></span><br><span class="line">                mMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(mMap);</span><br><span class="line">            &#125;</span><br><span class="line">            mapToWriteToDisk = mMap;</span><br><span class="line">            mDiskWritesInFlight++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> hasListeners = mListeners.size() &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">                keysModified = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                listeners = <span class="keyword">new</span> HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> changesMade = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mClear) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mapToWriteToDisk.isEmpty()) &#123;</span><br><span class="line">                        changesMade = <span class="keyword">true</span>;</span><br><span class="line">                        mapToWriteToDisk.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mClear = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">                    String k = e.getKey();</span><br><span class="line">                    Object v = e.getValue();</span><br><span class="line">                    <span class="comment">// "this" is the magic value for a removal mutation. In addition,</span></span><br><span class="line">                    <span class="comment">// setting a value to "null" for a given key is specified to be</span></span><br><span class="line">                    <span class="comment">// equivalent to calling remove on that key.</span></span><br><span class="line">                    <span class="keyword">if</span> (v == <span class="keyword">this</span> || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mapToWriteToDisk.remove(k);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                            Object existingValue = mapToWriteToDisk.get(k);</span><br><span class="line">                            <span class="keyword">if</span> (existingValue != <span class="keyword">null</span> &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mapToWriteToDisk.put(k, v);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    changesMade = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">                        keysModified.add(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mModified.clear();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (changesMade) &#123;</span><br><span class="line">                    mCurrentMemoryStateGeneration++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                memoryStateGeneration = mCurrentMemoryStateGeneration;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MemoryCommitResult(memoryStateGeneration, keysModified, listeners,</span><br><span class="line">                mapToWriteToDisk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mDiskWritesInFlight</code> 是 <code>SharedPreferencesImpl</code> 的成员变量，表示当前有多少个正着执行中的硬盘写操作。如果我们不是唯一的写者，表示在前面有某个写操作正把 <code>mMap</code> 的内容写到硬盘。此时我们不能直接修改 <code>mMap</code>，否则硬盘的数据的一致性会有问题（比方说，部分 key 是旧的，部分是新的）。拷贝一份 <code>mMap</code> 后，我们就可以安全地进行修改了。</p><p>SP 提供了一个 <code>registerOnSharedPreferenceChangeListener</code> 方法，通过它我们可以注册监听器，在 SP 修改的时候得到通知。相关的 listener 就放在 <code>mListener</code> 里。</p><p>我们可以把这个方法里的 <code>mapToWriteToDisk</code> 看做是 SP 的一个快照（snapshot）， <code>SharedPreferencesImpl::mCurrentMemoryStateGeneration</code> 用来跟踪这些快照的年龄。当我们往文件里面写入数据的时候，只有年龄最大（数据最新）的那一个快照才需要写到硬盘里（旧的数据即使写了进入，也马上会被覆盖）。关于这一点，在后面我们看 <code>writeToFile</code> 实现的时候就知道了。</p><p>方法最后返回的 <code>MemoryCommitResult</code> 就很简单了，只是一些数据的聚集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return value from EditorImpl#commitToMemory()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCommitResult</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> memoryStateGeneration;</span><br><span class="line">    <span class="meta">@Nullable</span> <span class="keyword">final</span> List&lt;String&gt; keysModified;</span><br><span class="line">    <span class="meta">@Nullable</span> <span class="keyword">final</span> Set&lt;OnSharedPreferenceChangeListener&gt; listeners;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch writtenToDiskLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"mWritingToDiskLock"</span>)</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> writeToDiskResult = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> wasWritten = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MemoryCommitResult</span><span class="params">(<span class="keyword">long</span> memoryStateGeneration, @Nullable List&lt;String&gt; keysModified,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Set&lt;OnSharedPreferenceChangeListener&gt; listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String, Object&gt; mapToWriteToDisk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memoryStateGeneration = memoryStateGeneration;</span><br><span class="line">        <span class="keyword">this</span>.keysModified = keysModified;</span><br><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br><span class="line">        <span class="keyword">this</span>.mapToWriteToDisk = mapToWriteToDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDiskWriteResult</span><span class="params">(<span class="keyword">boolean</span> wasWritten, <span class="keyword">boolean</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wasWritten = wasWritten;</span><br><span class="line">        writeToDiskResult = result;</span><br><span class="line">        writtenToDiskLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="把修改写到硬盘（文件）"><a href="#把修改写到硬盘（文件）" class="headerlink" title="把修改写到硬盘（文件）"></a>把修改写到硬盘（文件）</h3><p>为了帮助你回忆 <code>apply</code> 的工作，这里我再拷贝一份他的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay to notify the listeners before it's hit disk</span></span><br><span class="line">    <span class="comment">// because the listeners should always get the same</span></span><br><span class="line">    <span class="comment">// SharedPreferences instance back, which has the</span></span><br><span class="line">    <span class="comment">// changes reflected in memory.</span></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QueuedWork</code> 是一个全局的工作队列，<code>addFinisher</code> 添加进去的 runnable 不会立即执行，仅仅是放到一个链表里。当某个人想要等待 <code>QueuedWork</code> 所有工作执行完毕时，就调用 <code>QueuedWork.waitToFinish()</code>，在这个方法里面会取出早先所有 <code>addFinisher</code> 的任务，一个一个执行。</p><p>在 <code>awaitCommit</code> 里面，我们调用了 <code>mcr.writtenToDiskLatch.await()</code> 来等待数据写入硬盘，所以这里的把 <code>awaitCommit</code> 放到 <code>QueuedWork</code> 里，就提供了一种机制，让外界等待文件的写入操作。读者可以到 <code>ActivityThread</code> 中搜一下 <code>QueuedWork.waitToFinish</code>，会发现在 activity/service stop 的时候，都会执行这个操作，从而保证在应用退出前 SP 已经写入硬盘。</p><p>接下来的 <code>enqueueDiskWrite</code> 执行真正的写入操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue an already-committed-to-memory result to be written</span></span><br><span class="line"><span class="comment"> * to disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * They will be written to disk one-at-a-time in the order</span></span><br><span class="line"><span class="comment"> * that they're enqueued.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> postWriteRunnable if non-null, we're being called</span></span><br><span class="line"><span class="comment"> *   from apply() and this is the runnable to run after</span></span><br><span class="line"><span class="comment"> *   the write proceeds.  if null (from a regular commit()),</span></span><br><span class="line"><span class="comment"> *   then we're allowed to do this disk write on the main</span></span><br><span class="line"><span class="comment"> *   thread (which in addition to reducing allocations and</span></span><br><span class="line"><span class="comment"> *   creating a background thread, this has the advantage that</span></span><br><span class="line"><span class="comment"> *   we catch them in userdebug StrictMode reports to convert</span></span><br><span class="line"><span class="comment"> *   them where possible to apply() ...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> Runnable postWriteRunnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Typical #commit() path with fewer allocations, doing a write on</span></span><br><span class="line">    <span class="comment">// the current thread.</span></span><br><span class="line">    <span class="keyword">if</span> (isFromSyncCommit) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> wasEmpty = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isFromSyncCommit</code> 是我们直接调用 <code>editor.commit</code> 的情况，这个时候如果我们是唯一的写者（writter），就直接调用 <code>writeToDiskRunnable.run()</code> 执行写入操作。其他情况下，都放到 <code>QueuedWork</code> 里面执行。</p><p><code>QueuedWork</code> 在内部使用一个 <code>HandlerThread</code> 串行地执行所有的工作，<code>queue()</code> 后的任务都会被 post 到这个线程去执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueuedWork</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queue a work-runnable for processing asynchronously.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> work The new runnable to process</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shouldDelay If the message should be delayed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">(Runnable work, <span class="keyword">boolean</span> shouldDelay)</span> </span>&#123;</span><br><span class="line">        Handler handler = getHandler();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            sWork.add(work);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldDelay &amp;&amp; sCanDelay) &#123;</span><br><span class="line">                handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>editor.apply()</code> 而言，这里的 <code>shouldDelay</code> 参数为 <code>true</code>，实际的写入操作会延迟 100 毫秒才执行。接下来看完 <code>writeToFile</code> 的实现以后，我们就会发现，这个小小的延迟在频繁 <code>editor.apply</code> 的时候实际上有一定优化作用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mWritingToDiskLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(MemoryCommitResult mcr, <span class="keyword">boolean</span> isFromSyncCommit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> existsTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> backupExistsTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> outputStreamCreateTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> writeTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> fsyncTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> setPermTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> fstatTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> deleteTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> fileExists = mFile.exists();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rename the current file so it may be used as a backup during the next read</span></span><br><span class="line">    <span class="keyword">if</span> (fileExists) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> needsWrite = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only need to write if the disk state is older than this commit</span></span><br><span class="line">        <span class="keyword">if</span> (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFromSyncCommit) &#123;</span><br><span class="line">                needsWrite = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="comment">// No need to persist intermediate states. Just wait for the latest state to</span></span><br><span class="line">                    <span class="comment">// be persisted.</span></span><br><span class="line">                    <span class="keyword">if</span> (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123;</span><br><span class="line">                        needsWrite = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!needsWrite) &#123;</span><br><span class="line">            mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> backupFileExists = mBackupFile.exists();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            backupExistsTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!backupFileExists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Couldn't rename file "</span> + mFile</span><br><span class="line">                      + <span class="string">" to backup file "</span> + mBackupFile);</span><br><span class="line">                mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attempt to write the file, delete the backup and return true as atomically as</span></span><br><span class="line">    <span class="comment">// possible.  If any exception occurs, delete the new file; next time we will restore</span></span><br><span class="line">    <span class="comment">// from the backup.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            outputStreamCreateTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line"></span><br><span class="line">        writeTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        FileUtils.sync(str);</span><br><span class="line"></span><br><span class="line">        fsyncTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        str.close();</span><br><span class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            setPermTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> StructStat stat = Os.stat(mFile.getPath());</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                mStatTimestamp = stat.st_mtim;</span><br><span class="line">                mStatSize = stat.st_size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            fstatTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Writing was successful, delete the backup file if there is one.</span></span><br><span class="line">        mBackupFile.delete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            deleteTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDiskStateGeneration = mcr.memoryStateGeneration;</span><br><span class="line"></span><br><span class="line">        mcr.setDiskWriteResult(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"write: "</span> + (existsTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (backupExistsTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (outputStreamCreateTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (writeTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (fsyncTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (setPermTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (fstatTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (deleteTime - startTime));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> fsyncDuration = fsyncTime - writeTime;</span><br><span class="line">        mSyncTimes.add((<span class="keyword">int</span>) fsyncDuration);</span><br><span class="line">        mNumSync++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG || mNumSync % <span class="number">1024</span> == <span class="number">0</span> || fsyncDuration &gt; MAX_FSYNC_DURATION_MILLIS) &#123;</span><br><span class="line">            mSyncTimes.log(TAG, <span class="string">"Time required to fsync "</span> + mFile + <span class="string">": "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up an unsuccessfully written file</span></span><br><span class="line">    <span class="keyword">if</span> (mFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFile.delete()) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Couldn't clean up partially-written file "</span> + mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们看看 <code>needsWrite</code> 中 <code>mCurrentMemoryStateGeneration == mcr.memoryStateGeneration</code> 的情况，这个代码当前的快照是最新的，所以需要写入硬盘。之所以单独拿这个出来说，是为了说明前面 <code>QueuedWork.queue()</code> 里面那个 delay 所起到的作用。由于我们用的是异步的 <code>editor.apply</code>，所以这个延迟是隐含在 API 里的，还在正确的语义范畴里；另一方面，考虑应用频繁 <code>apply</code> 的情况，如果前后的 apply 间隔小于 100 毫秒，那么这个条件判断只在最后的写任务会为 <code>true</code>，从而避免了过多的无用的写硬盘操作。</p><p>最后我们看看 <code>mBackupFile</code> 的作用。在开头的 <code>loadFromDisk</code> 有这么一小段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果备份文件存在，我们就把 <code>mFile</code> 删除，然后读备份文件的数据。</p><p>为了考察这个备份文件的作用，我们先假设 SP 是刚刚创建的，此时备份文件不存在，<code>writeToDisk</code> 先把 <code>mFile</code> 保存一个备份，然后往 <code>mFile</code> 写数据。在写数据成功的情况下，我们再删除前面的那个备份，此时只有 <code>mFile</code> 存在。</p><p>另一种可能性是，我们在写 <code>mFile</code> 的时候失败了，此时 <code>mFile</code> 里面是一些垃圾数据，而备份文件 <code>mBackupFile</code> 是我们在这个失败的写操作之前保存的，虽然它的信息不是最新的，却是完整的数据。在这种情况下，<code>loadFromDisk</code> 会加载备份文件的数据。</p><p>最后一种情况是我们在准备写数据的时候备份文件存在，这种只在前一次写文件失败的时候才会发生。此时 <code>mFile</code> 无疑是错误的，所以我们直接删掉它。</p><h3 id="通知监听者"><a href="#通知监听者" class="headerlink" title="通知监听者"></a>通知监听者</h3><p>虽然文章已经很长，处于完整性考虑，还是把 <code>notifyListeners</code> 的代码也一起放上来。这里的实现很简单，我就不多说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mcr.listeners == <span class="keyword">null</span> || mcr.keysModified == <span class="keyword">null</span> ||</span><br><span class="line">            mcr.keysModified.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mcr.keysModified.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> String key = mcr.keysModified.get(i);</span><br><span class="line">                <span class="keyword">for</span> (OnSharedPreferenceChangeListener listener : mcr.listeners) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.onSharedPreferenceChanged(SharedPreferencesImpl.<span class="keyword">this</span>, key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Run this function on the main thread.</span></span><br><span class="line">            ActivityThread.sMainThreadHandler.post(() -&gt; notifyListeners(mcr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来按顺序这一篇应该是 logd，但突然有点好奇 SP 在保存数据的时候是怎么同步的，就还是先看 SP 吧，当做在开始啃 logd 这个硬骨头前轻松一下（虽然这么说，SP 还是有很多值得我们学习的地方的）。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
  </entry>
  
  <entry>
    <title>Android P 源码分析 2 - 强弱指针的实现</title>
    <link href="https://jekton.github.io/2019/03/12/android9-sp-wp/"/>
    <id>https://jekton.github.io/2019/03/12/android9-sp-wp/</id>
    <published>2019-03-12T01:01:01.000Z</published>
    <updated>2019-03-18T11:38:29.179Z</updated>
    
    <content type="html"><![CDATA[<p>继上篇我们学习了 Android 轻量级指针的实现，是时候来看“重量级”指针的实现了。在 Android 里，“重量级”指针指的是 <code>RefBase</code> 和 <code>sp/wp</code> 配合使用的情况，它提供了完整的强、弱指针的支持。</p><a id="more"></a><p>考虑这样一种情况，A 持有 B，B 持有 A，C 持有 A。如果只使用简单的引用计数，在 C 释放 A 后，A、B 各自的计数值都为 1，永远不会被销毁，也无法再访问。这就是经典的循环引用问题。</p><p>引入弱指针后，我们可以让 A 持有 B 的强指针，而 B 指持有 A 的弱指针。这样一来，在 C 释放 A 后，A 的引用计数将降为 0 从而被销魂；A 销毁的同时，A 所持有的 B 的强指针也会销毁，于是 B 的引用计数也降为 0，B 被销毁。</p><p>了解了这些基础知识后，下面我们就来看看 <code>RefBase</code> 的源码</p><h2 id="RefBase"><a href="#RefBase" class="headerlink" title="RefBase"></a>RefBase</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>这里我先把 <code>RefBase</code> 的定义摆上来，后面我们捡最重要的几个看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/RefBase.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">forceIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//! DEBUGGING ONLY: Get current strong ref count.</span></span><br><span class="line">            <span class="keyword">int32_t</span>         getStrongCount() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">weakref_type</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">RefBase*            <span class="title">refBase</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">incWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">decWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquires a strong reference if there is already one.</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquires a weak reference if there is already one.</span></span><br><span class="line">        <span class="comment">// This is not always safe. see ProcessState.cpp and BpBinder.cpp</span></span><br><span class="line">        <span class="comment">// for proper use.</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! DEBUGGING ONLY: Get current weak ref count.</span></span><br><span class="line">        <span class="keyword">int32_t</span>             getWeakCount() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! DEBUGGING ONLY: Print references held on object.</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! DEBUGGING ONLY: Enable tracking for this object.</span></span><br><span class="line">        <span class="comment">// enable -- enable/disable tracking</span></span><br><span class="line">        <span class="comment">// retain -- when tracking is enable, if true, then we save a stack trace</span></span><br><span class="line">        <span class="comment">//           for each reference and dereference; when retain == false, we</span></span><br><span class="line">        <span class="comment">//           match up references and dereferences and keep only the</span></span><br><span class="line">        <span class="comment">//           outstanding ones.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span> enable, <span class="keyword">bool</span> retain)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">weakref_type*   <span class="title">createWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="function">weakref_type*   <span class="title">getWeakRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//! DEBUGGING ONLY: Print references held on object.</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  <span class="keyword">void</span>            <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; getWeakRefs()-&gt;printRefs(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//! DEBUGGING ONLY: Enable tracking of object.</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  <span class="keyword">void</span>            <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span> enable, <span class="keyword">bool</span> retain)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        getWeakRefs()-&gt;trackMe(enable, retain); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RefBase basetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">                            RefBase();</span><br><span class="line">    <span class="keyword">virtual</span>                 ~RefBase();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">        OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">extendObjectLifetime</span><span class="params">(<span class="keyword">int32_t</span> mode)</span></span>;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//! Flags for onIncStrongAttempted()</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        FIRST_INC_STRONG = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Invoked after creation of initial strong pointer/reference.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Invoked when either the last strong reference goes away, or we need to undo</span></span><br><span class="line">    <span class="comment">// the effect of an unnecessary onIncStrongAttempted.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="comment">// Only called in OBJECT_LIFETIME_WEAK case.  Returns true if OK to promote to</span></span><br><span class="line">    <span class="comment">// strong reference. May have side effects if it returns true.</span></span><br><span class="line">    <span class="comment">// The first flags argument is always FIRST_INC_STRONG.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Remove initial flag argument.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(<span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="comment">// Invoked in the OBJECT_LIFETIME_WEAK case when the last reference of either</span></span><br><span class="line">    <span class="comment">// kind goes away.  Unused.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Remove.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">weakref_type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">weakref_impl</span>;</span></span><br><span class="line">    </span><br><span class="line">                            RefBase(<span class="keyword">const</span> RefBase&amp; o);</span><br><span class="line">            RefBase&amp;        <span class="keyword">operator</span>=(<span class="keyword">const</span> RefBase&amp; o);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        weakref_impl* <span class="keyword">const</span> mRefs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在看他的函数的实现前，我们先对比一下 <code>LightRefBase</code>，看看他们两个有什么不同。首先最明显的是，<code>RefBase</code> 不是一个类模板，这个我们在上篇已经提到了；也因此 <code>RefBase::~RefBase</code> 是一个虚函数。其次，<code>RefBase</code> 还定义了一个 <code>weakref_type</code>，他的真正实现是 <code>weakref_impl</code>，所有的引用计数都记录在 <code>weakref_impl</code> 里。</p><p>好事者这个时候就要问了，为什么 <code>RefBase</code> 不像 <code>LightRefBase</code> 把引用计数直接用成员变量来存储？（人家这么写，肯定是有理由的呀）这里的关键就在弱指针上。当用户持有弱指针的时候，需要提供一种途径，让他尝试转换成强指针。如果把引用计数等信息都存放在 <code>RefBase</code> 里，当对象已经销毁但有弱指针指向它的时候，弱指针就没有信息可以判断是否能够升级为强指针了。现在我们把引用计数都放在 <code>weakref_impl</code> 里，<code>RefBase</code> 对象可以先销毁；只要有 <code>weakref_imp</code> 在，<code>wp</code> 就能够根据 <code>weakref_impl</code> 中的信息判断是否能够提升为 <code>sp</code>。</p><p>接下来我们看看 <code>weakref_impl</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/RefBase.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIAL_STRONG_VALUE (1&lt;&lt;28)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefBase</span>:</span>:weakref_impl : <span class="keyword">public</span> RefBase::weakref_type</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt;    mStrong;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt;    mWeak;</span><br><span class="line">    RefBase* <span class="keyword">const</span>          mBase;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt;    mFlags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_REFS</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">weakref_impl</span><span class="params">(RefBase* base)</span></span></span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renameStrongRefId</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*old_id*/</span>, <span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*new_id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renameWeakRefId</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*old_id*/</span>, <span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*new_id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span>, <span class="keyword">bool</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>weakref_impl</code> 继承了 <code>weakref_type</code>，在非 debug 模式下，他的另外一些成员函数都是空实现，我们直接忽略。<code>mFlags</code> 的取值是 <code>RefBase</code> 中定义的 <code>enum</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">    OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">    OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建 <code>weakref_impl</code> 时，使用的是默认的 lifetime <code>OBJECT_LIFETIME_STRONG</code>。</p><p>有了总体的认识后，接下来我们开始看源码，探究一些小细节。</p><h2 id="强指针的实现"><a href="#强指针的实现" class="headerlink" title="强指针的实现"></a>强指针的实现</h2><p>在这一小节我们先来看强指针的实现，弱指针留到后面。上一节我们讲 <code>LightRefBase</code> 的时候已经知道，<code>sp</code> 在创建的时候会调用对象的 <code>incStrong</code>，销毁的时候调用 <code>decStrong</code>。下面我们就来看看 <code>RefBase</code> 这两个函数的实现。</p><p>首先是对象的创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/RefBase.cpp</span></span><br><span class="line">RefBase::RefBase()</span><br><span class="line">    : mRefs(<span class="keyword">new</span> weakref_impl(<span class="keyword">this</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>嗯，是比较单调无趣。下面我们看看 <code>incStrong</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/RefBase.cpp</span></span><br><span class="line"><span class="keyword">void</span> RefBase::incStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;incWeak(id);</span><br><span class="line">    </span><br><span class="line">    refs-&gt;addStrongRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = refs-&gt;mStrong.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    ALOG_ASSERT(c &gt; <span class="number">0</span>, <span class="string">"incStrong() called on %p after last strong ref"</span>, refs);</span><br><span class="line">    <span class="keyword">if</span> (c != INITIAL_STRONG_VALUE)  &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> old __unused = refs-&gt;mStrong.fetch_sub(INITIAL_STRONG_VALUE, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// A decStrong() must still happen after us.</span></span><br><span class="line">    ALOG_ASSERT(old &gt; INITIAL_STRONG_VALUE, <span class="string">"0x%x too small"</span>, old);</span><br><span class="line">    refs-&gt;mBase-&gt;onFirstRef();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>weakref_impl</code> 没有定义 <code>incWeak</code> 函数，这里实际调用的是他的父类 <code>weakref_type</code> 的 <code>incWeak</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::weakref_type::incWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    impl-&gt;addWeakRef(id);  <span class="comment">// 空实现</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c __unused = impl-&gt;mWeak.fetch_add(<span class="number">1</span>,</span><br><span class="line">            <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    ALOG_ASSERT(c &gt;= <span class="number">0</span>, <span class="string">"incWeak called on %p after last weak ref"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为实际的实现就是 <code>weakref_impl</code>，所以这里的强制类型转换不会出错。跟 <code>LightRefBase</code> 的情况一样，由于计数值跟其他的数据没有什么依赖，这里用 <code>memory_order_relaxed</code> 就可以了。</p><p>总的来说，<code>incStrong</code> 所做的就是给 <code>weakref_impl</code> 的 <code>mStrong</code> 和 <code>mWeak</code> 都加 1。</p><p>接下来我们看看 <code>decStrong</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/RefBase.cpp</span></span><br><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);  <span class="comment">// 空实现</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = refs-&gt;mStrong.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(BAD_STRONG(c), <span class="string">"decStrong() called on %p too many times"</span>,</span><br><span class="line">            refs);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">int32_t</span> flags = refs-&gt;mFlags.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// The destructor does not delete refs in this case.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note that even with only strong reference operations, the thread</span></span><br><span class="line">    <span class="comment">// deallocating this may not be the same as the thread deallocating refs.</span></span><br><span class="line">    <span class="comment">// That's OK: all accesses to this happen before its deletion here,</span></span><br><span class="line">    <span class="comment">// and all accesses to refs happen before its deletion in the final decWeak.</span></span><br><span class="line">    <span class="comment">// The destructor can safely access mRefs because either it's deleting</span></span><br><span class="line">    <span class="comment">// mRefs itself, or it's running entirely before the final mWeak decrement.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Since we're doing atomic loads of `flags`, the static analyzer assumes</span></span><br><span class="line">    <span class="comment">// they can change between `delete this;` and `refs-&gt;decWeak(id);`. This is</span></span><br><span class="line">    <span class="comment">// not the case. The analyzer may become more okay with this patten when</span></span><br><span class="line">    <span class="comment">// https://bugs.llvm.org/show_bug.cgi?id=34365 gets resolved. NOLINTNEXTLINE</span></span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就直接了当地多了，直接修改 <code>weakref_impl</code> 的成员变量。</p><p>根据上篇文章我们对 <code>sp</code> 的了解，只有在准备销魂对象的时候才会调用 <code>decStrong</code>。这里 <code>fetch_sub</code> 使用 <code>memory_order_release</code> 就保证了接下来我们要销毁对象时，前面对对象的操作都已经执行完（release 操作相当于在前面放了一个内存屏障，确保前面的操作不会被重排序到 <code>fetch_sub</code> 的后面）。</p><p>如果 <code>c == 1</code>，说明我们是最后一个引用对象的人，接下来就可以准备删除对象了。这里 <code>atomic_thread_fense</code> 的使用跟前面 <code>LightRefBase</code> 的用法是一样的。</p><p>如果 <code>mFlag</code> 是 <code>OBJECT_LIFETIME_STRONG</code>，表示对象的生命周期由强指针控制，当强引用计数值降为 0 的时候，就需要删除对象。</p><p>由于我们在 <code>incStrong</code> 里增加了弱引用计数，这里也要 <code>decWeak</code>。</p><h2 id="弱指针的实现"><a href="#弱指针的实现" class="headerlink" title="弱指针的实现"></a>弱指针的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/RefBase.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> RefBase::weakref_type weakref_type;</span><br><span class="line"></span><br><span class="line">    wp(<span class="keyword">const</span> wp&lt;T&gt;&amp; other);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">wp</span><span class="params">(<span class="keyword">const</span> sp&lt;T&gt;&amp; other)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~wp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// promotion to sp</span></span><br><span class="line">    sp&lt;T&gt; promote() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略去了跟我们关注的主题不相关的其他一大堆函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">sp</span>;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">wp</span>;</span></span><br><span class="line"></span><br><span class="line">    T*              m_ptr;</span><br><span class="line">    weakref_type*   m_refs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>wp</code> 的 <code>m_ptr</code> 指向真正的对象，但这个对象可能已经被销毁了；在使用的时候需要先调用 <code>promote()</code> 提升到 <code>sp</code>，以确保对象不被销毁。<code>m_refs</code> 指针一定是有效的。</p><h3 id="弱指针的创建"><a href="#弱指针的创建" class="headerlink" title="弱指针的创建"></a>弱指针的创建</h3><p>创建 <code>wp</code> 的代码很简单，就是把 <code>weakref_impl</code> 的 <code>mWeak</code> 计数加 1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">wp&lt;T&gt;::wp(<span class="keyword">const</span> wp&lt;T&gt;&amp; other)</span><br><span class="line">    : m_ptr(other.m_ptr), m_refs(other.m_refs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_refs-&gt;incWeak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">wp&lt;T&gt;::wp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other)</span><br><span class="line">    : m_ptr(other.m_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) &#123;</span><br><span class="line">        m_refs = m_ptr-&gt;createWeak(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从弱指针提升至强指针"><a href="#从弱指针提升至强指针" class="headerlink" title="从弱指针提升至强指针"></a>从弱指针提升至强指针</h3><p>下面我们看从 <code>wp</code> 转 <code>sp</code> 的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt; wp&lt;T&gt;::promote() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;T&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr &amp;&amp; m_refs-&gt;attemptIncStrong(&amp;result)) &#123;</span><br><span class="line">        result.set_pointer(m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码并没有做太多事，关键的实现还是在 <code>m_refs-&gt;attemptIncStrong()</code>。<code>m_refs</code> 是一个 <code>RefBase::weakref_type*</code>，执行的是下面这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RefBase::weakref_type::attemptIncStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    incWeak(id);</span><br><span class="line">    </span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">int32_t</span> curCount = impl-&gt;mStrong.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    ALOG_ASSERT(curCount &gt;= <span class="number">0</span>,</span><br><span class="line">            <span class="string">"attemptIncStrong called on %p after underflow"</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount != INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        <span class="comment">// 情况1：</span></span><br><span class="line">        <span class="comment">// we're in the easy/common case of promoting a weak-reference</span></span><br><span class="line">        <span class="comment">// from an existing strong reference.</span></span><br><span class="line">        <span class="keyword">if</span> (impl-&gt;mStrong.compare_exchange_weak(curCount, curCount+<span class="number">1</span>,</span><br><span class="line">                <span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">        <span class="comment">// situation. curCount was updated by compare_exchange_weak.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span> || curCount == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        <span class="comment">// we're now in the harder case of either:</span></span><br><span class="line">        <span class="comment">// - there never was a strong reference on us</span></span><br><span class="line">        <span class="comment">// - or, all strong references have been released</span></span><br><span class="line">        <span class="keyword">int32_t</span> flags = impl-&gt;mFlags.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="comment">// this object has a "normal" life-time, i.e.: it gets destroyed</span></span><br><span class="line">            <span class="comment">// when the last strong reference goes away</span></span><br><span class="line">            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 情况2：</span></span><br><span class="line">                <span class="comment">// the last strong-reference got released, the object cannot</span></span><br><span class="line">                <span class="comment">// be revived.</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况3：</span></span><br><span class="line">            <span class="comment">// here, curCount == INITIAL_STRONG_VALUE, which means</span></span><br><span class="line">            <span class="comment">// there never was a strong-reference, so we can try to</span></span><br><span class="line">            <span class="comment">// promote this object; we need to do that atomically.</span></span><br><span class="line">            <span class="keyword">while</span> (curCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (impl-&gt;mStrong.compare_exchange_weak(curCount, curCount+<span class="number">1</span>,</span><br><span class="line">                        <span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">                <span class="comment">// situation (e.g.: another thread has inc/decStrong'ed us)</span></span><br><span class="line">                <span class="comment">// curCount has been updated.</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// promote() failed, some other thread destroyed us in the</span></span><br><span class="line">                <span class="comment">// meantime (i.e.: strong count reached zero).</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情况4： </span></span><br><span class="line">            <span class="comment">// this object has an "extended" life-time, i.e.: it can be</span></span><br><span class="line">            <span class="comment">// revived from a weak-reference only.</span></span><br><span class="line">            <span class="comment">// Ask the object's implementation if it agrees to be revived</span></span><br><span class="line">            <span class="keyword">if</span> (!impl-&gt;mBase-&gt;onIncStrongAttempted(FIRST_INC_STRONG, id)) &#123;</span><br><span class="line">                <span class="comment">// it didn't so give-up.</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// grab a strong-reference, which is always safe due to the</span></span><br><span class="line">            <span class="comment">// extended life-time.</span></span><br><span class="line">            curCount = impl-&gt;mStrong.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">            <span class="comment">// If the strong reference count has already been incremented by</span></span><br><span class="line">            <span class="comment">// someone else, the implementor of onIncStrongAttempted() is holding</span></span><br><span class="line">            <span class="comment">// an unneeded reference.  So call onLastStrongRef() here to remove it.</span></span><br><span class="line">            <span class="comment">// (No, this is not pretty.)  Note that we MUST NOT do this if we</span></span><br><span class="line">            <span class="comment">// are in fact acquiring the first reference.</span></span><br><span class="line">            <span class="keyword">if</span> (curCount != <span class="number">0</span> &amp;&amp; curCount != INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">                impl-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    impl-&gt;addStrongRef(id);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PRINT_REFS</span></span><br><span class="line">    ALOGD(<span class="string">"attemptIncStrong of %p from %p: cnt=%d\n"</span>, <span class="keyword">this</span>, id, curCount);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// curCount is the value of mStrong before we incremented it.</span></span><br><span class="line">    <span class="comment">// Now we need to fix-up the count if it was INITIAL_STRONG_VALUE.</span></span><br><span class="line">    <span class="comment">// This must be done safely, i.e.: handle the case where several threads</span></span><br><span class="line">    <span class="comment">// were here in attemptIncStrong().</span></span><br><span class="line">    <span class="comment">// curCount &gt; INITIAL_STRONG_VALUE is OK, and can happen if we're doing</span></span><br><span class="line">    <span class="comment">// this in the middle of another incStrong.  The subtraction is handled</span></span><br><span class="line">    <span class="comment">// by the thread that started with INITIAL_STRONG_VALUE.</span></span><br><span class="line">    <span class="keyword">if</span> (curCount == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        impl-&gt;mStrong.fetch_sub(INITIAL_STRONG_VALUE,</span><br><span class="line">                <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次增加强引用计数前，都要先递增一个弱引用计数。由于我们是通过弱指针来执行这个操作，<code>incWeak</code> 总是有效的，这里直接执行就可以。</p><p>前面我们说过，<code>weakref_type</code> 的实际实现是 <code>weakref_impl</code>，所以接下来的强制类型转换也是合法的。后面的操作我们分几种情况来考虑。</p><ol><li>有强指针指向这个对象。此时 <code>curCount &gt; 0 &amp;&amp; curCount != INITIAL_STRONG_VALUE</code>，我们在接下来的循环里尝试递增一个强引用计数。之所以要用 compare exchange，是因为在我们准备给 <code>mStrong</code> 加 1 的同时，其他线程可能要给他减 1。<br>按照 C++ 文档的描述，相对于 <code>compare_exchange_strong</code>，<code>compare_exchange_weak</code> 偶尔会发生假性的（spurious）失败，但它能够在弱一致性保证的机器上提供更好的性能（由于我们是在一个循环里面执行，所以即使发生了假性失败，也会重新执行）。为了更好的性能，这里使用的是后者。</li><li><code>curCount &lt; 0</code>。在这种情况下，如果对象的生命周期是 <code>OBJECT_LIFETIME_STRONG</code>，说明对象受强引用计数控制，此时对象已经销毁。</li><li><code>curCount == INITIAL_STRONG_VALUE</code>，对象创建以后还没有被强指针引用过，说明对象还存活着，此时我们在一个 <code>while</code> 循环里尝试递增 <code>mStrong</code></li><li>这种情况下，<code>mFlags == OBJECT_LIFETIME_WEAK</code>，对象的生命周期受弱引用计数控制。既然我们准备将一个弱引用提升为强引用，此时对象的弱引用计数肯定是不为 0 的。这个时候如果对象允许（<code>onIncStrongAttempted</code> 默认的实现就是返回 <code>true</code>），我们直接递增强引用计数就可以了。</li></ol><h3 id="弱指针的销毁"><a href="#弱指针的销毁" class="headerlink" title="弱指针的销毁"></a>弱指针的销毁</h3><p>回顾一下强指针的内容，我们知道，<code>sp</code> 销毁的时候，会调用对象的 <code>decStrong</code>。<code>RefBase::decStrong</code> 我们在前面已经看过他的实现了，总结起来就是：</p><ol><li>如果对象受强引用计数控制（<code>OBJECT_LIFETIME_STRONG</code>），<code>decStrong</code> 在强引用计数为 0 的时候销毁 <code>this</code>（不销毁 <code>weakref_impl</code>）</li><li>如果受弱引用计数控制，在强引用计数为 0 的时候不直接销毁对象。</li></ol><p>对强指针来说，无论是上面的哪一种情况，最后都会执行 <code>decWeak</code>（强指针会使 <code>mStrong</code>、<code>mWeak</code> 都加 1）。对弱指针来说，他只会递增弱引用计数 <code>mWeak</code>，所以在销毁的时候只需要执行 <code>decWeak</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/RefBase.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">wp&lt;T&gt;::~wp()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们看看 <code>decWeak</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/RefBase.cpp</span></span><br><span class="line"><span class="keyword">void</span> RefBase::weakref_type::decWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    impl-&gt;removeWeakRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = impl-&gt;mWeak.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(BAD_WEAK(c), <span class="string">"decWeak called on %p too many times"</span>,</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> flags = impl-&gt;mFlags.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">        <span class="comment">// This is the regular lifetime case. The object is destroyed</span></span><br><span class="line">        <span class="comment">// when the last strong reference goes away. Since weakref_impl</span></span><br><span class="line">        <span class="comment">// outlives the object, it is not destroyed in the dtor, and</span></span><br><span class="line">        <span class="comment">// we'll have to do it here.</span></span><br><span class="line">        <span class="keyword">if</span> (impl-&gt;mStrong.load(<span class="built_in">std</span>::memory_order_relaxed)</span><br><span class="line">                == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">            <span class="comment">// Decrementing a weak count to zero when object never had a strong</span></span><br><span class="line">            <span class="comment">// reference.  We assume it acquired a weak reference early, e.g.</span></span><br><span class="line">            <span class="comment">// in the constructor, and will eventually be properly destroyed,</span></span><br><span class="line">            <span class="comment">// usually via incrementing and decrementing the strong count.</span></span><br><span class="line">            <span class="comment">// Thus we no longer do anything here.  We log this case, since it</span></span><br><span class="line">            <span class="comment">// seems to be extremely rare, and should not normally occur. We</span></span><br><span class="line">            <span class="comment">// used to deallocate mBase here, so this may now indicate a leak.</span></span><br><span class="line">            ALOGW(<span class="string">"RefBase: Object at %p lost last weak reference "</span></span><br><span class="line">                    <span class="string">"before it had a strong reference"</span>, impl-&gt;mBase);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ALOGV("Freeing refs %p of old RefBase %p\n", this, impl-&gt;mBase);</span></span><br><span class="line">            <span class="keyword">delete</span> impl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is the OBJECT_LIFETIME_WEAK case. The last weak-reference</span></span><br><span class="line">        <span class="comment">// is gone, we can destroy the object.</span></span><br><span class="line">        impl-&gt;mBase-&gt;onLastWeakRef(id);</span><br><span class="line">        <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>atomic_thread_fense</code> 的用法跟 <code>decStrong</code> 里是一样的。在弱引用计数降为 0 的时候，分 3 中情况处理：</p><ol><li><code>OBJECT_LIFETIME_STRONG</code>，但是没有强指针引用过这个对象。这个只有在我们使用弱指针引用对象但却从没把弱指针提升到强指针（也就是说，我们根本没使用过这个对象）的情况下才会发生。由于很可能是个错误，这个写了个 warning 日志。</li><li><code>OBJECT_LIFETIME_STRONG</code>，有强指针引用过这个对象，这是最正常的情况。此时不存在任何的强、弱指针指向对象，所以把 <code>weakref_impl</code> 也删掉。</li><li><code>OBJECT_LIFETIME_WEAK</code>，由于对象受弱引用计数控制而此时弱引用计数为 0，所以需要删除对象（<code>delete impl-&gt;mBase</code>）。</li></ol><p>无论是 <code>decStrong</code> 还是 <code>decWeak</code>，删除对象后，最终都会执行到 <code>RefBase::~RefBase</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RefBase::~RefBase()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> flags = mRefs-&gt;mFlags.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// Life-time of this object is extended to WEAK, in</span></span><br><span class="line">    <span class="comment">// which case weakref_impl doesn't out-live the object and we</span></span><br><span class="line">    <span class="comment">// can free it now.</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) &#123;</span><br><span class="line">        <span class="comment">// It's possible that the weak count is not 0 if the object</span></span><br><span class="line">        <span class="comment">// re-acquired a weak reference in its destructor</span></span><br><span class="line">        <span class="keyword">if</span> (mRefs-&gt;mWeak.load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> mRefs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mRefs-&gt;mStrong.load(<span class="built_in">std</span>::memory_order_relaxed)</span><br><span class="line">            == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        <span class="comment">// We never acquired a strong reference on this object.</span></span><br><span class="line">        LOG_ALWAYS_FATAL_IF(mRefs-&gt;mWeak.load() != <span class="number">0</span>,</span><br><span class="line">                <span class="string">"RefBase: Explicit destruction with non-zero weak "</span></span><br><span class="line">                <span class="string">"reference count"</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Always report if we get here. Currently MediaMetadataRetriever</span></span><br><span class="line">        <span class="comment">// C++ objects are inconsistently managed and sometimes get here.</span></span><br><span class="line">        <span class="comment">// There may be other cases, but we believe they should all be fixed.</span></span><br><span class="line">        <span class="keyword">delete</span> mRefs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For debugging purposes, clear mRefs.  Ineffective against outstanding wp's.</span></span><br><span class="line">    <span class="keyword">const_cast</span>&lt;weakref_impl*&amp;&gt;(mRefs) = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对象受弱引用计数控制，在 <code>decWeak</code> 中我们删除对象，而后 <code>weakref_impl</code> 在 <code>~RefBase</code> 中删除。</p><p>前面 <code>decWeak</code> 的第一种情况下，我们只是写了个日志然后什么也没做。如果受强引用计数控制但却没有被强指针引用过，并且执行了 <code>~RefBase</code>，说明对象要么是被手动 <code>delete</code>，要么是在栈上分配的。不管哪种情况，此时都应该释放 <code>mRefs</code>，否则将会有内存泄漏。</p><p>最后做个总结。在正常的情况下，</p><ol><li>如果对象的生命周期是 <code>OBJECT_LIFETIME_STRONG</code>，这也是默认的情况。在 <code>decStrong</code> 中，如果强引用计数为 0，将删除对象；在 <code>decWeak</code> 中，如果弱引用计数为 0，将删除 <code>weakref_impl</code></li><li>如果对象的生命周期是 <code>OBJECT_LIFETIME_WEAK</code>，对象将在 <code>decWeak</code> 中删除，<code>weakref_impl</code> 则是在 <code>~RefBase</code> 中回收的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继上篇我们学习了 Android 轻量级指针的实现，是时候来看“重量级”指针的实现了。在 Android 里，“重量级”指针指的是 &lt;code&gt;RefBase&lt;/code&gt; 和 &lt;code&gt;sp/wp&lt;/code&gt; 配合使用的情况，它提供了完整的强、弱指针的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
  </entry>
  
  <entry>
    <title>Android P 源码分析 1 - 轻量级智能指针的实现</title>
    <link href="https://jekton.github.io/2019/03/06/android9-light-sp/"/>
    <id>https://jekton.github.io/2019/03/06/android9-light-sp/</id>
    <published>2019-03-06T11:23:28.000Z</published>
    <updated>2019-03-09T13:09:44.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇词"><a href="#开篇词" class="headerlink" title="开篇词"></a>开篇词</h2><p>去年（2018）二季度写过几篇 Android 源码相关的文章，后来由于太懒中断了，一晃眼一整年什么也没干成。经过几个月的迷茫，终于在年底开始发奋学习。慢慢把一些基础捡回来后，兜兜转转，看源码的时机又来了。文章标题里的那个“1”显然表示此刻的我雄心勃勃，也希望自己能够坚持下去，改掉虎头蛇尾的毛病。</p><p>分析 Android 源码的书籍中，最厚重的无疑是老罗的《Android 源代码情景分析》，目前我也是使用它作为主要的参考书。前期的写作基本会按照老罗书中的脉络进行，如果有幸坚持下来，再另外找话题继续探索。跟老罗书中不同的是，喜新厌旧的我将会基于 Android P（<code>pie-release</code>分支）来讲解，不然就太没意思了。</p><p>由于作者水平有限，没办法在文章把涉及的知识点给大家一一罗列，只能在相关地方推荐几本参考书。如果大家对某个知识点有疑惑，可以是找个安静的时间，慢慢享受一本纸质书。</p><p>下面我们进入正题，先拿 Android 的轻量级指针来热热身。</p><h2 id="关于智能指针的一点点背景知识"><a href="#关于智能指针的一点点背景知识" class="headerlink" title="关于智能指针的一点点背景知识"></a>关于智能指针的一点点背景知识</h2><p>文章假设你有一定的 C++ 基础，不熟悉的读者可以参考《C++ Primer》。也希望读者可以下载一份源码，毕竟在网页上没法在代码直接进行跳转，整体性也差一点。如果你想了解更多智能指针的知识，《More Effective C++》将会是一本很棒的书，很值得一读。</p><p>标准的 C++ 并支持垃圾收集，这就需要用户手动释放内存资源。当多个模块通过一个指针共享对象实例时，对象的所有权往往非常地模糊，这就很容易让用户在什么时候删除对象这个问题上产生疑惑。幸运的时候，利用 RAII(Resource Acquisition Is Initialization，参考《The C++ Programming Language》，不了解也没关系)，我们可以系统地、自动地管理对象的生命周期。</p><p>所谓的智能指针，就是在对象的内部维持一个计数；我们在类的构造函数里对计数增加 1，并在析构函数减 1。如果当前我们是最后一个人引用这个对象，那么计数值在析构函数里减 1 后就应该等于 0，此时对象可以被安全地删除。</p><h2 id="轻量级指针的用法"><a href="#轻量级指针的用法" class="headerlink" title="轻量级指针的用法"></a>轻量级指针的用法</h2><p>先了解一下 API，对我们阅读源码是非常有帮助的，这里我们先看看一个小例子，学一学怎么使用轻量级指针。</p><p>首先，对应希望被智能指针引用的类应该继承 <code>LightRefBase</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> LightRefBase&lt;Foo&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，我们通过 <code>sp</code> 来引用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 sp，sp 指 strong pointer，它是一个智能指针，用来管理我们的 Foo 对象</span></span><br><span class="line">  sp&lt;Foo&gt; p&#123;<span class="keyword">new</span> Foo&#125;;   <span class="comment">// 此时计数值为 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> p2 = p;    <span class="comment">// 计数值 = 2</span></span><br><span class="line">    p2-&gt;foo();</span><br><span class="line">  &#125; <span class="comment">// p2 销毁，计数值 = 1</span></span><br><span class="line">  p-&gt;foo();</span><br><span class="line">&#125;   <span class="comment">// p 销毁，计数值 = 0，Foo 对象也销毁</span></span><br></pre></td></tr></table></figure><p>下面我们一起来看看它的源码。</p><h2 id="计数器-LightRefBase-的实现"><a href="#计数器-LightRefBase-的实现" class="headerlink" title="计数器 LightRefBase 的实现"></a>计数器 LightRefBase 的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/LightRefBase.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LightRefBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    inline LightRefBase() : mCount(0) &#123; &#125;</span><br><span class="line">    inline void incStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">        mCount.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCount.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! DEBUGGING ONLY: Get current strong ref count.</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> int32_t <span class="title">getStrongCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mCount.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> LightRefBase&lt;T&gt; basetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 注意，析构函数是 protected，这就限定了 LightRefBase 只能被继承</span></span><br><span class="line">    <span class="keyword">inline</span> ~LightRefBase() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt; mCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>incStrong</code> 的实现很简单，由于引用计数 <code>mCount</code> 不跟其他数据具有依赖关系，这里直接用 <code>memory_order_relaxed</code> 就可以了。</p><p><code>decStrong</code> 里，<code>fetch_sub</code> 在给 <code>mCount</code> 减 1 的同时返回了原来的值，如果旧值是 1，说明我们是最后一个引用对象的人，接下来就改删除对象了。<code>if</code> 语句里的 <code>atomic_thread_fence</code> 和 <code>fetch_sub</code> 构成了一个 <em>Atomic-fence synchronization</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo : public LightRefBase &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Thread A                                Thread B</span><br><span class="line">---------                               -----------</span><br><span class="line">do with Foo*                            do with Foo*</span><br><span class="line">fetch_sub(1, memory_order_release)</span><br><span class="line">  =&gt; mCount = 1</span><br><span class="line">                                        fetch_sub(1, memory_order_release)</span><br><span class="line">                                        atomic_thread_fense(memory_order_acquire)</span><br><span class="line">                                        delete Foo*</span><br></pre></td></tr></table></figure><p>假定存在这么一个对象 Foo*，它同时被线程 A、B 引用。线程 A 使用完以后，先执行了 <code>decStrong</code>；在线程 B <code>decStrong</code> 的时候，检查到 <code>mCount</code> 的旧值为 1，于是执行 <code>if</code> 语句中的内容。</p><p>所谓的 <em>Atomic-fense synchronization</em> 就是，在线程 A 中，do with Foo* 比 fetch_sub 先执行；线程 A 的 fetch_sub 比 线程 B 的 fetch_sub 先执行；线程 B 的 atomic_thread_fense 保证了 fetch_sub 比 delete Foo* 先执行。所以，线程 B 删除对象的引用的时候，线程 A 的 do with Foo* 一定以及执行完了。如果没有这个 fense，那么 delete Foo* 就可以在 fetch_sub 前面执行，而此时可能其他线程还在使用该对象。</p><p>原因 momory order 和 atomic_thread_fense 的更多信息，读者可以参考 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">memory_order</a> 和 <a href="https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence" target="_blank" rel="noopener">atomic_thread_fence</a>。</p><p>说了这么多，你可能就会想问，有没有其他更简单的方法来实现 <code>decStrong</code> 呢？有的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCount.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acq_rel) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于，<code>if</code> 语句的条件只在最后一个持有引用的人执行时才会为 <code>true</code>；这种情况下，我们才需要一个 <code>acquire operation</code>。这是通过性能换取代码复杂性的一个例子。</p><h2 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h2><p>智能指针的实现是 <code>sp</code>，这里我们只看最关键的几个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/StrongPointer.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    sp(T* other);  <span class="comment">// NOLINT(implicit)</span></span><br><span class="line">    ~sp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> T&amp;       <span class="keyword">operator</span>* () <span class="keyword">const</span>     &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">    <span class="keyword">inline</span> T*       <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span>    &#123; <span class="keyword">return</span> m_ptr;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T*       <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span>            </span>&#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr != <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    T* m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接通过指针来构造 sp 的情况很简单，如果传入的指针非空，就调用 <code>incStrong</code> 增加一个引用计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt;::sp(T* other)</span><br><span class="line">        : m_ptr(other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other)</span><br><span class="line">        other-&gt;incStrong(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构的时候，调用 <code>decStrong</code>，如果引用计数降为 0，<code>decStrong</code> 将会删除 <code>m_ptr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt;::~sp() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr)</span><br><span class="line">        m_ptr-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LightRefBase-设计问题"><a href="#LightRefBase-设计问题" class="headerlink" title="LightRefBase 设计问题"></a>LightRefBase 设计问题</h2><p>不得不说，轻量级指针除了 decStrong 的原子操作比较费解外，其他实现都是非常直观的。但如果我们留心观察，还是能够找到一些闪光点的。</p><h3 id="为什么要让被管理对象继承-LightRefBase"><a href="#为什么要让被管理对象继承-LightRefBase" class="headerlink" title="为什么要让被管理对象继承 LightRefBase"></a>为什么要让被管理对象继承 LightRefBase</h3><p>从易用性的角度考虑，如果被管理对象（如前面例子里的 Foo）不需要继承 <code>LightRefBase</code>，无疑用起来会更加的方便。在考虑这个问题的时候，不妨看一看 <code>LightRefBase</code> 都有什么成员变量。可以看到，我们把引用计数存放在了 <code>LightRefBase</code> 里。这样一来，在堆上创建对象的时候，我们只需要分配一次内存。</p><p>如果不这样做，我们将不得不在堆上分配多一个对象，用来保存引用的计数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotSoLightSP</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  NotSoLightSP(T* ptr)</span><br><span class="line">      : count_&#123;<span class="keyword">new</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>&#125;&#125;, ptr_&#123;ptr&#125; &#123;&#125;</span><br><span class="line">  NotSoLightSP(<span class="keyword">const</span> NotSoLightSP&lt;T&gt;&amp; other)</span><br><span class="line">      : count_&#123;other.count_&#125;, ptr_&#123;other.ptr_&#125; &#123;</span><br><span class="line">    count_-&gt;fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~NotSoLightSP() &#123;</span><br><span class="line">    <span class="keyword">if</span> (count_-&gt;fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release) == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">      <span class="keyword">delete</span> count_;</span><br><span class="line">      <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">RefCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count_-&gt;load(<span class="built_in">std</span>::memory_order_relaxed); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;* count_;</span><br><span class="line">  T* ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Foo() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Foo() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Foo()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NotSoLightSP&lt;Foo&gt; sp&#123;<span class="keyword">new</span> Foo&#125;;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp2 = sp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count = "</span> &lt;&lt; sp2.RefCount() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count = "</span> &lt;&lt; sp.RefCount() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo()</span><br><span class="line">ref count = 2</span><br><span class="line">ref count = 1</span><br><span class="line">~Foo()</span><br></pre></td></tr></table></figure><p>最后，我们再参考 C++ 标准库的 <code>shared_ptr</code> 来讲一讲。对 <code>shared_ptr</code> 来说，一般情况下它也是需要在堆上分配对一个对象用于保存引用计数的；不那么一般的情况是，<code>make_shared</code>，这个时候它可以分配一个大的内存块，然后使用 placement new 来构造这两个对象（待管理对象和引用计数都放在这个内存块中）。</p><h3 id="为什么-LightRefBase-是一个类模板（而-RefBase-却不是）"><a href="#为什么-LightRefBase-是一个类模板（而-RefBase-却不是）" class="headerlink" title="为什么 LightRefBase 是一个类模板（而 RefBase 却不是）"></a>为什么 LightRefBase 是一个类模板（而 RefBase 却不是）</h3><p>如果读者还没了解过 <code>RefBase</code>，可以在我发完下一篇文章的时候再回来看这一小节。</p><p>细心的读者应该留意到，我们是这样继承 LightRefBase 的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> LightRefBase&lt;Foo&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>而 <code>RefBase</code> 是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> :</span> <span class="keyword">public</span> RefBase &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>要寻找这个问题的答案，可以看看 <code>LightRefBase</code> 用模板参数来做了什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCount.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个类唯一使用了 <code>T</code> 的地方就是这里。由于 <code>LightRefBase</code> 没有虚函数，所以在 delete this 指针的时候，需要把它强制转换为真正的类型 <code>T*</code>，否则将不会执行 <code>T::~T()</code>。另一方面，<code>RefBase::~Refbase()</code> 是一个虚函数，所以 <code>RefBase</code> 不需要把 this 强转回真正的类型就能够 delete this。</p><p><code>LightRefBase</code> 之所以搞得这么麻烦，和前一个问题一样，都是为了性能。如果把析构函数是虚函数，那么每个子类都将多消耗一个指针用于存储函数表，这样就不够“light”(轻量)了。</p>]]></content>
    
    <summary type="html">
    
      作为 Android 源码分析系列文章的第一篇，我们先看 LightRefBase 的源码，热热身。
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
  </entry>
  
  <entry>
    <title>Java 程序员眼里的 Linux 内核 —— wait_event 源码分析</title>
    <link href="https://jekton.github.io/2018/12/15/linux-wait-event/"/>
    <id>https://jekton.github.io/2018/12/15/linux-wait-event/</id>
    <published>2018-12-15T08:30:37.000Z</published>
    <updated>2018-12-21T01:07:29.633Z</updated>
    
    <content type="html"><![CDATA[<p>看 Linux 的 <code>wait_event</code> 源码时，联想到我们平时经常用得比较多的 wait/notify、double-check 和 <code>volatile</code>，突然意识 <code>wait_event</code> 简简单单几行代码的背后，涉及的知识点其实非常丰富。本篇文章我们就一起了来探索它背后的知识，然后尝试着和我们的日常开发关联起来。</p><h1 id="wait-event"><a href="#wait-event" class="headerlink" title="wait_event"></a>wait_event</h1><blockquote><p>这里使用 Linux-2.6.24 版本的源码</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在某些情况下，我们会需要等待某个事件，在这个事件发生前，把进程投入睡眠。比方说，同步写 IO；在发出写磁盘命令后，进程要进入休眠，等等磁盘完成。为了支持这一类场景，Linux 引入了 wait queue；wait queue 从概念上跟我们应用层使用的 condition queue 是一样的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里我们着重讲 <code>wait_event</code> 的实现，一些相关的知识读者可以参考《深入理解LINUX内核》。</p><p>下面我们开始看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/include/linux/wait.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wait_event - sleep until a condition gets true</span></span><br><span class="line"><span class="comment"> * @wq: the waitqueue to wait on</span></span><br><span class="line"><span class="comment"> * @condition: a C expression for the event to wait for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the</span></span><br><span class="line"><span class="comment"> * @condition evaluates to true. The @condition is checked each time</span></span><br><span class="line"><span class="comment"> * the waitqueue @wq is woken up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * wake_up() has to be called after changing any variable that could</span></span><br><span class="line"><span class="comment"> * change the result of the wait condition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event(wq, condition)       \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                    \</span><br><span class="line">    <span class="keyword">if</span> (condition)                      \</span><br><span class="line">        <span class="keyword">break</span>;                          \</span><br><span class="line">    __wait_event(wq, condition);        \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里只是先检测一遍条件，然后直接又调用 <code>__wait_event</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/include/linux/wait.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __wait_event(wq, condition)                             \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                            \</span><br><span class="line">    DEFINE_WAIT(__wait);                                        \</span><br><span class="line">                                                                \</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                                  \</span><br><span class="line">        prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE);    \</span><br><span class="line">        <span class="keyword">if</span> (condition)                                          \</span><br><span class="line">            <span class="keyword">break</span>;                                              \</span><br><span class="line">        <span class="comment">// schedule 使用调度器调度另一个线程去执行。当前线程被重新      \</span></span><br><span class="line">        <span class="comment">// 调度时，schedule 函数才会返回                            \</span></span><br><span class="line">        schedule();                                             \</span><br><span class="line">    &#125;                                                           \</span><br><span class="line">    finish_wait(&amp;wq, &amp;__wait);                                  \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>DEFINE_WAIT</code> 宏用于定义局部变量 <code>__wait</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/include/linux/wait.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_WAIT(name)                                   \</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> name = &#123;                                   \</span><br><span class="line">        .<span class="keyword">private</span>    = current,                              \</span><br><span class="line">        .func       = autoremove_wake_function,             \</span><br><span class="line">        .task_list  = LIST_HEAD_INIT((name).task_list),     \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>prepare_to_wait</code> 和 <code>finish_wait</code> 源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/kernel/wait.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: we use "set_current_state()" _after_ the wait-queue add,</span></span><br><span class="line"><span class="comment"> * because we need a memory barrier there on SMP, so that any</span></span><br><span class="line"><span class="comment"> * wake-function that tests for the wait-queue being active</span></span><br><span class="line"><span class="comment"> * will be guaranteed to see waitqueue addition _or_ subsequent</span></span><br><span class="line"><span class="comment"> * tests in this thread will see the wakeup having taken place.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The spin_unlock() itself is semi-permeable and only protects</span></span><br><span class="line"><span class="comment"> * one way (it only protects stuff inside the critical region and</span></span><br><span class="line"><span class="comment"> * stops them from bleeding out - it would still allow subsequent</span></span><br><span class="line"><span class="comment"> * loads to move into the critical region).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> fastcall</span><br><span class="line">prepare_to_wait(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait, <span class="keyword">int</span> state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非独占等待（可以同时唤醒多个进程）</span></span><br><span class="line">    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    <span class="comment">// wait 不存在于某个等待队列时，才把它加入 q</span></span><br><span class="line">    <span class="comment">// wait 是我们新定义的，list_empty 将会返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (list_empty(&amp;wait-&gt;task_list))</span><br><span class="line">        __add_wait_queue(q, wait);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * don't alter the task state if this is just going to</span></span><br><span class="line"><span class="comment">     * queue an async wait queue callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 根据 wait 的定义，is_sync_wait() 这里会返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (is_sync_wait(wait))</span><br><span class="line">        <span class="comment">// 前面注释说使用 set_current_state() 作为屏障，对此不理解的读者可以暂时忽略，</span></span><br><span class="line">        <span class="comment">// 后面我们会举例说明相关的用法</span></span><br><span class="line">        set_current_state(state);</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Used to distinguish between sync and async io wait context:</span></span><br><span class="line"><span class="comment"> * sync i/o typically specifies a NULL wait queue entry or a wait</span></span><br><span class="line"><span class="comment"> * queue entry bound to a task (current task) to wake up.</span></span><br><span class="line"><span class="comment"> * aio specifies a wait queue entry with an async notification</span></span><br><span class="line"><span class="comment"> * callback routine, not associated with any task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> is_sync_wait(wait)    (!(wait) || ((wait)-&gt;private))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> fastcall <span class="title">finish_wait</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can check for list emptiness outside the lock</span></span><br><span class="line"><span class="comment">     * IFF:</span></span><br><span class="line"><span class="comment">     *  - we use the "careful" check that verifies both</span></span><br><span class="line"><span class="comment">     *    the next and prev pointers, so that there cannot</span></span><br><span class="line"><span class="comment">     *    be any half-pending updates in progress on other</span></span><br><span class="line"><span class="comment">     *    CPU's that we haven't seen yet (and that might</span></span><br><span class="line"><span class="comment">     *    still change the stack area.</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *  - all other users take the lock (ie we can only</span></span><br><span class="line"><span class="comment">     *    have _one_ other CPU that looks at or modifies</span></span><br><span class="line"><span class="comment">     *    the list).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty_careful(&amp;wait-&gt;task_list)) &#123;</span><br><span class="line">        spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">        list_del_init(&amp;wait-&gt;task_list);</span><br><span class="line">        spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括来讲，<code>prepare_to_wait</code> 把自己加入等待队列，<code>finish_wait</code> 则把自己从队列里移除。但由于 <code>prepare_to_wait</code> 可能会被调用多次，如果判断 <code>wait</code> 已经处于某个队列中，则不会重复添加。</p><h1 id="条件、条件队列和锁"><a href="#条件、条件队列和锁" class="headerlink" title="条件、条件队列和锁"></a>条件、条件队列和锁</h1><p>对于像我一样平时使用 Java 比较多的读者，对下面这一段代码一定不会觉得陌生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do your stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们不禁要问，应用层的代码可以这样简洁，为什么内核的就不行？这里我们先来大概了解一下条件队列，然后再回答这个问题。</p><p>所谓的条件队列/等待队列，一般由 3 个成分组成：</p><ol><li>一个队列，用于存放等待条件/事件的线程。在应用层，一般我们叫他条件队列（condition queue），LINUX 内核叫他 wait queue</li><li>一个锁，用于保护这个队列</li><li>一个谓词（它的计算结果为 bool 值）用作条件，即前面示例代码的 <code>condition</code>。</li></ol><p>Java 程序员们在这里需要特别注意的是，我说的<strong>锁的作用是保护条件队列</strong>。回顾我们常写的 Java 代码，一般这个锁也用来保护谓词，但这个不是必须的。Java 要求我们在调用 <code>wait</code> 的时候必须持有锁的原因之一是，<code>wait</code> 的内部会把当前线程加入条件队列；修改列表必须持有锁（另一个原因是，<code>wait</code> 的语义之一便是执行后会释放锁，如果都不持有，何来的释放呢）。</p><p>但在另一面，唤醒条件队列上的线程却不一定需要持有锁，虽然 Java 要求我们必须持有锁才能调用 <code>notify</code>。持有锁调用 <code>notify</code> 的好处在于，notify 后条件不会改变。同时，如果持有锁的话，这个操作里也可以把相关线程从条件队列里删除。不好的地方在于，调用 notify 的线程在执行唤醒操作的时候还持有锁，被唤醒线程这个时候如果被内核调度，他的获取锁的操作将失败（会导致该线程又进入睡眠状态）。这种实现方式性能上可能差一点，但代码更安全。</p><p>不要求调用 notify 时持有锁的一个例子是 pthread。这种方式的问题在于，在 notify 还没执行完的时候，条件可能就发生了变化。可能的实现是，只设置线程为可执行状态，等线程获得锁后自己把自己从队列里面移除。</p><p>了解了相关的数据结构后，不难猜想 Java 里 <code>wait</code> 的实现。考虑一种应用层 wait 的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    add_to_condition_queue();</span><br><span class="line">    unlock();</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 <code>wait</code> 方法做一下内联（inlining）处理，可以得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">    add_to_condition_queue();</span><br><span class="line">    unlock();</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do your stuff</span></span><br></pre></td></tr></table></figure><p>对比一下内核的 <code>wait_event</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">our_wait_event</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果你喜欢，换成 condition_queue 也可以</span></span><br><span class="line">        add_to_wait_queue_if_not_added_yet();</span><br><span class="line">        <span class="keyword">if</span> (condition)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    remove_from_wait_queue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，内核把代码写得更复杂的好处在于，它在切换进程前可以再检查一次条件，如果条件已经满足，就不需要执行 <code>schedule</code> 了。切换进程需要保存当前进程的上下文，同时会导致 TLB、Cache 等一系列缓存时效，因此内核总是尽量避免不必要的线程切换，而代价就是更复杂的代码。</p><h1 id="double-check"><a href="#double-check" class="headerlink" title="double-check"></a>double-check</h1><p>首先，如果你也和我一样觉得 <code>our_wait_event</code> 里面两个 <code>if</code> 有点难看，我们不妨试着来给他改一改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">our_wait_event2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">        add_to_wait_queue_if_not_added_yet();</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    remove_from_wait_queue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咋一看好像没什么问题，都是一样的检测条件，在条件不满足的情况下加入等待队列，调用 <code>schedule</code>。重要的是，上面这段代码更简洁，更易读。那么，他正确吗？</p><p>不消说，肯定是有问题的，不然那班内核程序员不会不知道该这么写。那问题究竟出在哪里呢？</p><p>考虑下面两个执行流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread1                              thread2</span><br><span class="line">-----------------------           --------------</span><br><span class="line">check condition =&gt; false</span><br><span class="line">add_to_wait_queue()</span><br><span class="line"></span><br><span class="line">                                  alter_condition()</span><br><span class="line">                                  notify_all()</span><br><span class="line"></span><br><span class="line">state = TASK_UNINTERRUPTABLE</span><br><span class="line">schedule()</span><br></pre></td></tr></table></figure><p>thread1 在把自己加入等待队列后，schedule 前，thread2 就更改了条件并且调用 notify。在这种情况下，如果没有其他线程再次调用 notify，thread1 将会永远休眠（而 thread2 认为自己已经 noitfy 过 thread1 了）。</p><p>为了防止发生这种情况，在添加到等待队列后，thread1 还应该再检查一次条件，如果条件满足，直接把自己从队列里移除就可以了。</p><p>为了方便读者把 <code>wait_event</code> 和 double-check 联系起来，下面我们看一段使用 double-check 实现的 Java 的单例的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SomeClass <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SomeClass.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sInstance = <span class="keyword">new</span> SomeClass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者的共同点都是先检测一遍条件是否成立，然后设置一个“安全阀”。在持有这个安全阀时，再一次检测条件是否满足。double-check 的多线程安全性都源于这个安全阀。就 wait_event 来说，当我们把自己加入等待队列后，就可以保证不会丢失另一个线程的 notify。而创建单例时，加锁保证了第二次判断后不会有另一个线程同时创建对象。（可能说得有点抽象，如果读者不明白，直接跳过就好。只要读者能够完成下面的小测验，那就是懂得 double-check 的）。</p><h2 id="double-check-小测验"><a href="#double-check-小测验" class="headerlink" title="double-check 小测验"></a>double-check 小测验</h2><p>假设有这样一个方法，他可以用来下载文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DownloadCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(File file)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String url, DownloadCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们又假设，可能同时有多个客户会调用这个接口下载同一个文件。为了避免同时下载同一个文件，我们可以在下载时判断一下当前是否已经有任务在下载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DownloadCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(File file)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> </span>&#123;</span><br><span class="line">    <span class="comment">// guarded by itself</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;DownloadCallback&gt; mCallbacks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadTask</span><span class="params">(String url, DownloadCallback callback)</span> </span>&#123;</span><br><span class="line">        mCallbacks.add(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// downloading ...</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"downloaded-file"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bonus: 为什么需要拷贝 callback 列表？</span></span><br><span class="line">        List&lt;DownloadCallback&gt; copy;</span><br><span class="line">        <span class="keyword">synchronized</span> (mCallbacks) &#123;</span><br><span class="line">            copy = <span class="keyword">new</span> ArrayList&lt;&gt;(mCallbacks);</span><br><span class="line">            mCallbacks.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (DownloadCallback callback : copy) &#123;</span><br><span class="line">            callback.onSuccess(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(DownloadCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mCallbacks) &#123;</span><br><span class="line">            mCallbacks.add(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, DownloadTask&gt; mTasks = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String url, DownloadCallback callback)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(getDestFilePath(url));</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        <span class="comment">// 已经存在则不需要下载了</span></span><br><span class="line">        callback.onSuccess(file);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DownloadTask task = <span class="keyword">new</span> DownloadTask(url, callback);</span><br><span class="line">    DownloadTask downloadingTask = mTasks.putIfAbsent(url, task);</span><br><span class="line">    <span class="keyword">if</span> (downloadingTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有正在下载的任务时才需要下载</span></span><br><span class="line">        task.download();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入正在下载的任务的 callback 列表，</span></span><br><span class="line">    downloadingTask.addCallback(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDestFilePath</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"url-to-file-path..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了检验读者是否真正理解 <code>wait_event</code>，你可以尝试着解决上面代码里存在的竞争条件。如果一时没能发现其中的问题，建议读者再从头读一遍文章。为了鼓励读者独立思考、与他人交流，这里我就顺势偷个懒不公布答案了。毕竟，在实际工作中，可不是总会有人告诉你你的代码写得是否正确。</p><h1 id="内存屏障一瞥"><a href="#内存屏障一瞥" class="headerlink" title="内存屏障一瞥"></a>内存屏障一瞥</h1><p>所谓的内存屏障，主要分为 3 种：</p><ol><li>read memory barrier（rmb），保证屏障前的读发生在屏障后的读操作之前</li><li>write memory barrier（wmb），保证屏障前的写发生在屏障后的写操作之前</li><li>full memory barrier（mb），保证屏障前的读写操作发生在屏障后的读写操作之前</li></ol><p>前面 <code>prepare_to_wait</code> 有这么一段注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: we use "set_current_state()" _after_ the wait-queue add,</span></span><br><span class="line"><span class="comment"> * because we need a memory barrier there on SMP, so that any</span></span><br><span class="line"><span class="comment"> * wake-function that tests for the wait-queue being active</span></span><br><span class="line"><span class="comment"> * will be guaranteed to see waitqueue addition _or_ subsequent</span></span><br><span class="line"><span class="comment"> * tests in this thread will see the wakeup having taken place.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The spin_unlock() itself is semi-permeable and only protects</span></span><br><span class="line"><span class="comment"> * one way (it only protects stuff inside the critical region and</span></span><br><span class="line"><span class="comment"> * stops them from bleeding out - it would still allow subsequent</span></span><br><span class="line"><span class="comment"> * loads to move into the critical region).</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这段注释一开始我也是看得云里雾里，直到我找到了他们解决一个内核 bug 的<a href="http://lkml.iu.edu/hypermail/linux/kernel/0312.1/1497.html" target="_blank" rel="noopener">邮件</a>（Google 大法好）。</p><p>这里面的 tests for the wait-queue being active 可以根据 <code>waitqueue_active</code> 来理解，其实指的就是等待队列不为空。spin-lock 虽然可以防止数据竞争，但如果别人在检查的时候不去获取锁呢？（<code>waitqueue_active</code> 就没有加锁）。当然，不加锁可以获得更好的性能。<br>j</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">waitqueue_active</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;q-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set_current_state</code> 使用 <code>set_mb</code> 来设置当前进程的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * set_current_state() includes a barrier so that the write of current-&gt;state</span></span><br><span class="line"><span class="comment"> * is correctly serialised wrt the caller's subsequent test of whether to</span></span><br><span class="line"><span class="comment"> * actually sleep:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    set_current_state(TASK_UNINTERRUPTIBLE);</span></span><br><span class="line"><span class="comment"> *    if (do_i_need_to_sleep())</span></span><br><span class="line"><span class="comment"> *        schedule();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the caller does not need such serialisation then use __set_current_state()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __set_current_state(state_value)                \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; current-&gt;state = (state_value); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_current_state(state_value)        \</span></span><br><span class="line">    set_mb(current-&gt;state, (state_value))</span><br></pre></td></tr></table></figure><p>下面是文档对 <code>set_mb</code> 的描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(*) set_mb(var, value)</span><br><span class="line"></span><br><span class="line">    This assigns the value to the variable and then inserts a full memory</span><br><span class="line">    barrier after it, depending on the function.  It isn&apos;t guaranteed to</span><br><span class="line">    insert anything more than a compiler barrier in a UP compilation.</span><br></pre></td></tr></table></figure><p><code>set_current_state</code> 在设置当前进程的状态后，会插入一个 mb。前面我们了解到，这将禁止 CPU 将 <code>set_current_state</code> 后面的 load/store 提前。</p><p>为了理解完全理解这里 <code>set_mb</code> 的使用，我们还需要再参考一下 <code>wake_up</code> 函数。但由于篇幅关系，这里我只是简单介绍它的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for_each_process_in_wait_queue_without_lock:</span><br><span class="line">    if process.state is sleeping:</span><br><span class="line">        wake it up</span><br><span class="line">        remove it from wait-queue</span><br></pre></td></tr></table></figure><p>假设在 <code>prepare_to_wait</code> 里面我使用的是平凡的 <code>__set_current_state</code>，那么 CPU 就可以把 <code>prepare_to_wait</code> 函数返回后我们所执行的对条件的判断提前到设置进程状态前。这种情况下，如果发生以下的执行序列，CPU2 将会丢失一个 wake-up，他有可能会永远休眠。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CPU0                    CPU1</span><br><span class="line">----------------        ------------------</span><br><span class="line">                        check_condition() =&gt; false</span><br><span class="line">condition = true</span><br><span class="line">wake_up()</span><br><span class="line">                        __set_current_state()</span><br><span class="line">                        schedule()</span><br></pre></td></tr></table></figure><p>解决办法就是引入一个 <code>mb</code>。在下面的例子中，如果 <code>__set_current_state()</code> 在 <code>wake_up()</code> 后执行，CPU1 上的这个线程将不会被唤醒，但随后的 <code>check_condition()</code> 会正确返回 <code>true</code>。反过来，如果 <code>__set_current_state()</code> 在 <code>wake_up()</code> 前执行，<code>check_condition()</code> 可能返回 <code>true</code> 也可能返回 <code>false</code>，但无论如何，他都不会丢失随后的 <code>wake_up()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CPU0                    CPU1</span><br><span class="line">----------------        ------------------</span><br><span class="line">condition = true</span><br><span class="line">wake_up()</span><br><span class="line">                        __set_current_state()</span><br><span class="line">                        mb();</span><br><span class="line">                        check_condition() =&gt; true</span><br></pre></td></tr></table></figure><p>还记得吗，<code>set_current_state</code> 就是在设置进程状态后插入一个内存屏障，所以 <code>prepare_to_wait</code> 直接使用 <code>set_current_state</code> 就可以了。</p><p>现在，我们终于可以说自己完全理解 <code>wait_event</code> 了。也许读者是第一次接触内存屏障，但我敢保证，很多 Java 程序员在不知不觉中使用过一定形式上的屏障。下面我们看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSomeData;          <span class="comment">// guarded by mDataSet</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSomeOtherData;     <span class="comment">// guarded by mDataSet</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mDataSet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDataSet) &#123;</span><br><span class="line">        <span class="comment">// you can now use mSomeData, mSomeOtherData</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSomeData = <span class="number">1</span>;</span><br><span class="line">    mSomeOtherData = <span class="number">2</span>;</span><br><span class="line">    mDataSet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一定开发经验的读者很可能看过类似的代码。虽然我们没有在 <code>mSomeData</code> 和 <code>mSomeOtherData</code> 的读写上做显式的同步，但只要仔细编写代码，利用一个 <code>volatile</code> 变量 <code>mDataSet</code>，这段代码也可以是线程安全的。</p><p>为了避免引入内存屏障这个比较复杂的概念（并且提供更好的移植性），Java 使用一个 happens-before 来描述相关的概念。关于 <code>volatile</code> 有这么一条描述：</p><blockquote><p>A write to a <code>volatile</code> field happens-before every subsequent read of that field.</p></blockquote><p>另外，对于同一个线程，有：</p><blockquote><p>If x and y are actions of the same thread and x comes before y in program order, then x happen before y.</p></blockquote><p>同时，happens-before 具有传递性（x -&gt; y, y -&gt; z, x -&gt; z），所以就有了下面这个结论：</p><p>对 <code>mSomeData, mSomeOtherData</code> 的写操作在 <code>mDataSet = true</code> 之前；<code>mDataSet = true</code> 在随后另一个线程对他的读操作之前；所以 <code>mSomeData, mSomeOtherData</code> 的写操作在随后对 <code>mDataSet</code> 的读操作之前。</p><p>直白一点说，只要一个线程看到 <code>mDataSet</code> 为 <code>true</code>，那他就一定能够正确读取到 <code>mSomeData, mSomeOtherData</code> 的值。</p><p>如果显式使用内存屏障，上面的代码就相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSomeData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSomeOtherData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mDataSet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDataSet) &#123;</span><br><span class="line">        <span class="comment">// 这个读内存屏障保证我们读到 mDataSet 后，也能读到 mSomeData/mSomeOtherData</span></span><br><span class="line">        <span class="comment">// 的最新值</span></span><br><span class="line">        rmb();</span><br><span class="line">        <span class="comment">// you can now use mSomeData, mSomeOtherData</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSomeData = <span class="number">1</span>;</span><br><span class="line">    mSomeOtherData = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 写内存屏障保证对 mSomeData/mSomeOtherData 的写在 mDataSet = true 之前执行</span></span><br><span class="line">    wmb();</span><br><span class="line">    mDataSet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，墙裂推荐一本并行编程的神书《Is Parallel Programming Hard, And, If So, What Can You Do About It?》（可以免费获取），书里有关于内存屏障的最好的描述。</p>]]></content>
    
    <summary type="html">
    
      看 Linux 的 wait_event 源码时，联想到我们平时经常用得比较多的 wait/notify、double-check 和 volatile，突然意识 wait_event 简简单单几行代码的背后，涉及的知识非常丰富。本篇文章我们就一起了来探索它背后的知识，然后尝试着和我们的日常开发关联起来。
    
    </summary>
    
      <category term="Linux" scheme="https://jekton.github.io/categories/Linux/"/>
    
    
      <category term="Java" scheme="https://jekton.github.io/tags/Java/"/>
    
      <category term="parallel-programming" scheme="https://jekton.github.io/tags/parallel-programming/"/>
    
      <category term="Linux" scheme="https://jekton.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核页表的创建</title>
    <link href="https://jekton.github.io/2018/11/18/linux-page-table-setup/"/>
    <id>https://jekton.github.io/2018/11/18/linux-page-table-setup/</id>
    <published>2018-11-18T10:49:38.000Z</published>
    <updated>2018-11-25T03:35:50.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>源码使用 Linux 2.6.24，基于 x86 平台；参考书是《深入理解 LINUX 内核》第三版</p></blockquote><p>内核跟普通的应用一样，为了使用虚拟内存，也需要一个给 CPU 设置一个页表。在这篇文章中，我们就一起来了解 Linux 是如何为内核创建页表的。需要注意的是，这里我并不打算详细讲解页表的方方面面，硬件相关的基础知识，读者可以参考《深入理解LINUX内核》第3版第2章。本文的目的在于，作为该书的补充，基于真实的源码来讲解这一过程。</p><h1 id="临时内核页表的构造"><a href="#临时内核页表的构造" class="headerlink" title="临时内核页表的构造"></a>临时内核页表的构造</h1><p>x86 系统刚刚启动时候运行在实模式下，这个时候线性地址就是物理地址。为了进入 32 位保护模式，首先就要启用分页（paging）。这就要求我们构建一个页表；这张页表把线性地址映射转换为物理地址。由于不同的计算机的配置不一样，他们需要的页表大小、页表个数也都不一样，所以需要在运行时动态分配页表，这就要求我们具有动态内存分配能力。</p><p>为了解决构造页表时候的鸡生蛋蛋生鸡问题，Linux 使用了一个临时的内核页表。它只有两个页表（这里的页表指的是用来索引页框的最后一级页表）。在不启用 PAE (Page Addression Extension) 和 PSE（Page Size Extension）的情况下，一个页表可以指向 <code>10^2 = 1024</code> 个内存页，一个内存页 4K，所以两个页表允许我们索引 8M 的内存。</p><p>顶层的页目录（page directory）使用全局变量 <code>swapper_pg_dir</code> 定义，下面是它的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/include/asm-x86/pgtable_32.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// empty_zero_page 在后面也会用到，这里就一并列出来了</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> empty_zero_page[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pgd_t</span> swapper_pg_dir[<span class="number">1024</span>];</span><br></pre></td></tr></table></figure><p>他在 <code>head_32.S</code> 里面定义的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># $&#123;linux_source&#125;/arch/x86/kernel/head_32.S</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * BSS section</span><br><span class="line"> */</span><br><span class="line">.section &quot;.bss.page_aligned&quot;,&quot;wa&quot;</span><br><span class="line">.align PAGE_SIZE_asm</span><br><span class="line">ENTRY(swapper_pg_dir)</span><br><span class="line">.fill 1024,4,0</span><br><span class="line">ENTRY(swapper_pg_pmd)</span><br><span class="line">.fill 1024,4,0</span><br><span class="line">ENTRY(empty_zero_page)</span><br><span class="line">.fill 4096,1,0</span><br></pre></td></tr></table></figure><p>这里的 <code>.fill 1024,4,0</code> 的意思是用 0 填充 1024 个 4 byte 长度的内存（一个页目录项（page table entry）的大小是 32 bit）。</p><p>接下来是变量 <code>pg0</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/include/asm-x86/pgtable_32.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The boot page tables (all created as a single array) */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pg0[];</span><br></pre></td></tr></table></figure><p><code>pg0</code> 通过指示链接器，放在了 bss 段的后面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /* 前面那些都略去了 */</span><br><span class="line"></span><br><span class="line">  .bss : AT(ADDR(.bss) - LOAD_OFFSET) &#123;</span><br><span class="line">__init_end = .;</span><br><span class="line">__bss_start = .;/* BSS */</span><br><span class="line">*(.bss.page_aligned)</span><br><span class="line">*(.bss)</span><br><span class="line">. = ALIGN(4);</span><br><span class="line">__bss_stop = .;</span><br><span class="line">  _end = . ;</span><br><span class="line">/* This is where the kernel creates the early boot page tables */</span><br><span class="line">. = ALIGN(4096);</span><br><span class="line">pg0 = . ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 <code>swapper_pg_dir</code> 和 <code>pg0</code> 后，接下来的工作就是对它们进行初始化。此时还处于实模式下，这部分工作是由汇编代码完成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># $&#123;linux_source&#125;/arch/x86/kernel/head_32.S</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Initialize page tables.  This creates a PDE and a set of page</span><br><span class="line"> * tables, which are located immediately beyond _end.  The variable</span><br><span class="line"> * init_pg_tables_end is set up to point to the first &quot;safe&quot; location.</span><br><span class="line"> * Mappings are created both at virtual address 0 (identity mapping)</span><br><span class="line"> * and PAGE_OFFSET for up to _end+sizeof(page tables)+INIT_MAP_BEYOND_END.</span><br><span class="line"> *</span><br><span class="line"> * Warning: don&apos;t use %esi or the stack in this code.  However, %esp</span><br><span class="line"> * can be used as a GPR if you really need it...</span><br><span class="line"> */</span><br><span class="line"># __PAGE_OFFSET 是 0xc000 0000，所以 page_pde_offset 是 0xc00</span><br><span class="line">page_pde_offset = (__PAGE_OFFSET &gt;&gt; 20);</span><br><span class="line"></span><br><span class="line">default_entry:</span><br><span class="line"># __PAGE_OFFSET 是 3G，pg0 是虚拟地址，减去 __PAGE_OFFSET 后就得到了</span><br><span class="line"># pg0 的物理地址。我们把 pg0 的物理地址放在了 edi 寄存器里</span><br><span class="line">movl $(pg0 - __PAGE_OFFSET), %edi</span><br><span class="line"># 同理，这里把 swapper_pg_dir 的物理地址放在 edx</span><br><span class="line">movl $(swapper_pg_dir - __PAGE_OFFSET), %edx</span><br><span class="line"># page directory/table entry 的低 12 位都是一些标志物，各个位代表的含义</span><br><span class="line"># 读者可以参考 https://wiki.osdev.org/Paging 或者书中的第 52 页</span><br><span class="line">movl $0x007, %eax/* 0x007 = PRESENT+RW+USER */</span><br><span class="line">10:</span><br><span class="line"># 下面这两行代码对熟悉 C 语言的读者可能会造成一定的困扰。如果从 C 语言的角度</span><br><span class="line"># 来看，它们是把地址 &amp;pg0 + 7 放到了 swapper_pg_dir 的第一项；但问题在于，</span><br><span class="line"># 为什么要 +7？</span><br><span class="line"># 其实这里的 7 和前面那个 7 一样，指的是页目录项的标志物 PRESENT+RW+USER，</span><br><span class="line"># pg0 的地址是 4K 对齐的，这意味着他的地址的低 12 位都为 0，加上 7 以后，刚</span><br><span class="line"># 好就是我们所需要的页目录项的值。</span><br><span class="line">leal 0x007(%edi),%ecx/* Create PDE entry */</span><br><span class="line">movl %ecx,(%edx)/* Store identity PDE entry */</span><br><span class="line"># 书里有说明，我们要把 0x0000 0000 ~ 0x007f ffff 和 0xc000 0000 ~ 0xc07f ffff</span><br><span class="line"># 都映射到物理地址 0x0000 0000 ~ 0x007f ffff，下面这一行设置的 0xc000 0000</span><br><span class="line"># 对应的页目录项。</span><br><span class="line"># 这里的问题在于，按照书里的说明，我们应该设置的是第 0x300 项，这里是加上的却是 0xc00。</span><br><span class="line"># 这里需要提一下平时用 C 语言时编译器帮我们做的事。当我们写下 int *p = NULL; p+2</span><br><span class="line"># 的时候，编译器知道 int 是 4 个字节，所以 p+2 会汇编代码里面是 +8。</span><br><span class="line"># 一个 PDE 也是 32 位，所以真正的偏移量是 0x300 &lt;&lt; 2 = 0xc00</span><br><span class="line">movl %ecx,page_pde_offset(%edx)/* Store kernel PDE entry */</span><br><span class="line"># edx + 4 以后，就是下一个页目录项了，下个循环将会继续初始化（一共两个页目录项）</span><br><span class="line">addl $4,%edx</span><br><span class="line"># 一个页表有 1024 个页表项，这里初始化一个在接下来的循环里面用到的计数器</span><br><span class="line">movl $1024, %ecx</span><br><span class="line">11:</span><br><span class="line"># stosl 把 %eax 的内容复制到物理地址 ES:EDI，也就是 pg0 处；并且 %edi + 4</span><br><span class="line">stosl</span><br><span class="line"># 加上 0x1000 后，%eax 指向下一个页</span><br><span class="line">addl $0x1000,%eax</span><br><span class="line"># %ecx -= 1，如果 %ecx 不为 0，跳转到 11 处。这里总共会循环 1024 次，初始化 1024 个页表项。</span><br><span class="line">loop 11b</span><br><span class="line">/* End condition: we must map up to and including INIT_MAP_BEYOND_END */</span><br><span class="line">/* bytes beyond the end of our own page tables; the +0x007 is the attribute bits */</span><br><span class="line">leal (INIT_MAP_BEYOND_END+0x007)(%edi),%ebp</span><br><span class="line">cmpl %ebp,%eax</span><br><span class="line">jb 10b</span><br><span class="line"># 到这里的时候，%edi 的值是我们映射的最后一个页表项的地址，这里我们把它存到变量</span><br><span class="line"># init_pg_tables_end 里。init_pg_tables_end 在 setup_32.c 里定义</span><br><span class="line">movl %edi,(init_pg_tables_end - __PAGE_OFFSET)</span><br><span class="line"></span><br><span class="line"># 下面是固定映射的，这部分就先不看了</span><br><span class="line">/* Do an early initialization of the fixmap area */</span><br><span class="line">movl $(swapper_pg_dir - __PAGE_OFFSET), %edx</span><br><span class="line">movl $(swapper_pg_pmd - __PAGE_OFFSET), %eax</span><br><span class="line">addl $0x67, %eax/* 0x67 == _PAGE_TABLE */</span><br><span class="line">movl %eax, 4092(%edx)</span><br><span class="line"></span><br><span class="line">xorl %ebx,%ebx/* This is the boot CPU (BSP) */</span><br><span class="line">jmp 3f</span><br></pre></td></tr></table></figure><p>前面代码的最后一行是一个 <code>jmp 3f</code>，下面，我们就看看这个 <code>3</code> 处的代码。</p><h1 id="启用分页"><a href="#启用分页" class="headerlink" title="启用分页"></a>启用分页</h1><p>构建好临时内核页表后，接下来就该启用分页了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># $&#123;linux_source&#125;/arch/x86/kernel/head_32.S</span><br><span class="line"></span><br><span class="line">3:</span><br><span class="line">/*</span><br><span class="line"> * Enable paging</span><br><span class="line"> */</span><br><span class="line">movl $swapper_pg_dir-__PAGE_OFFSET,%eax</span><br><span class="line"># %cr3 寄存器存放的是页表的地址</span><br><span class="line">movl %eax,%cr3/* set the page table pointer.. */</span><br><span class="line">movl %cr0,%eax</span><br><span class="line"># cr0 的最高位是 Paging 位，置 1 后启用分页</span><br><span class="line"># 关于 cr0，参考 https://en.wikipedia.org/wiki/Control_register#CR0</span><br><span class="line">orl $0x80000000,%eax</span><br><span class="line">movl %eax,%cr0/* ..and set paging (PG) bit */</span><br></pre></td></tr></table></figure><p>CPU 的分页机制现在已经启用了，但是我们的页表还是不完整的，剩下部分将会使用 C 语言来完成。</p><h1 id="构建线性地址的内核页表"><a href="#构建线性地址的内核页表" class="headerlink" title="构建线性地址的内核页表"></a>构建线性地址的内核页表</h1><p>完整的页表构建是从函数 <code>pagetable_init</code> 开始的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/arch/x86/mm/init_32.S</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">pagetable_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vaddr, end;</span><br><span class="line"><span class="keyword">pgd_t</span> *pgd_base = swapper_pg_dir;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable PSE if available */</span></span><br><span class="line"><span class="keyword">if</span> (cpu_has_pse)</span><br><span class="line">set_in_cr4(X86_CR4_PSE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable PGE if available */</span></span><br><span class="line"><span class="keyword">if</span> (cpu_has_pge) &#123;</span><br><span class="line">set_in_cr4(X86_CR4_PGE);</span><br><span class="line">__PAGE_KERNEL |= _PAGE_GLOBAL;</span><br><span class="line">__PAGE_KERNEL_EXEC |= _PAGE_GLOBAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kernel_physical_mapping_init(pgd_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是固定映射相关的内容，这里就先忽略了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的页表构建是在函数 <code>kernel_physical_mapping_init</code> 完成的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/arch/x86/mm/init_32.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This maps the physical memory to kernel virtual address space, a total </span></span><br><span class="line"><span class="comment"> * of max_low_pfn pages, by creating page tables starting from address </span></span><br><span class="line"><span class="comment"> * PAGE_OFFSET.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">kernel_physical_mapping_init</span><span class="params">(<span class="keyword">pgd_t</span> *pgd_base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pfn;</span><br><span class="line"><span class="keyword">pgd_t</span> *pgd;</span><br><span class="line"><span class="keyword">pmd_t</span> *pmd;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="keyword">int</span> pgd_idx, pmd_idx, pte_ofs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PAGE_OFFSET 是 0xc000 0000，这里拿的内核虚拟地址第一项对应的 pgd 的 index</span></span><br><span class="line">pgd_idx = pgd_index(PAGE_OFFSET);</span><br><span class="line">pgd = pgd_base + pgd_idx;</span><br><span class="line">pfn = <span class="number">0</span>;<span class="comment">// pfn 代表 page frame number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 pgd。pgd 的项数由 PTRS_PER_PGD 定义，在最普通的情况下，它是 1024。</span></span><br><span class="line"><span class="comment">// 如果启用了 PAE，则等于 4</span></span><br><span class="line"><span class="keyword">for</span> (; pgd_idx &lt; PTRS_PER_PGD; pgd++, pgd_idx++) &#123;</span><br><span class="line"><span class="comment">// 32 位的系统一般是 2 级页表结构（为什么说它是一般，读者后面就会知道了）</span></span><br><span class="line"><span class="comment">// 每个 pgd 项都指向一个 pmd，one_md_table_init 初始化一个 pmd。</span></span><br><span class="line"><span class="comment">// 建议读者这里先跳过本函数后面部分，看完 one_md_table_init 再回过头来继续往下看</span></span><br><span class="line">pmd = one_md_table_init(pgd);</span><br><span class="line"><span class="comment">// max_low_pfn 是被内核直接映射的最后一个页框的页框号，参考书中第 72 页</span></span><br><span class="line"><span class="keyword">if</span> (pfn &gt;= max_low_pfn)</span><br><span class="line"><span class="comment">// 超过 max_low_pfn 的 pte 可以不初始化，但 pmd 必须初始化，所以用 continue</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 对不启用 PAE 的系统来说，这里的 pmd 就是 pgd，PTRS_PER_PMD 等于 1。</span></span><br><span class="line"><span class="comment">// 如果启用 PAE，PTRS_PER_PMD 等于 512。</span></span><br><span class="line"><span class="comment">// 这里的 pmd 相当于页目录（Page Directory）,下面的循环里初始化每个页目录项（每个页目录项</span></span><br><span class="line"><span class="comment">// 指向一个页表项）</span></span><br><span class="line"><span class="keyword">for</span> (pmd_idx = <span class="number">0</span>; pmd_idx &lt; PTRS_PER_PMD &amp;&amp; pfn &lt; max_low_pfn; pmd++, pmd_idx++) &#123;</span><br><span class="line"><span class="comment">// address 是当前（物理）页框开头对应的虚拟地址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> address = pfn * PAGE_SIZE + PAGE_OFFSET;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Map with big pages if possible, otherwise create normal page tables. */</span></span><br><span class="line"><span class="keyword">if</span> (cpu_has_pse) &#123;</span><br><span class="line"><span class="comment">// pfn + PTRS_PER_PTE - 1 是当前 pmd 能够索引的最大的页框号</span></span><br><span class="line"><span class="comment">// * PAGE_SIZE + PAGE_OFFSET + (PAGE_SIZE-1) 就是当前 pmd 做能够指向的最大的</span></span><br><span class="line"><span class="comment">// 地址。也就是说，pmd 的地址范围是 [address, address2]</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> address2 = (pfn + PTRS_PER_PTE - <span class="number">1</span>) * PAGE_SIZE + PAGE_OFFSET + PAGE_SIZE<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (is_kernel_text(address) || is_kernel_text(address2))</span><br><span class="line"><span class="comment">// pmd 包含了内核的 text 段，所以加上了 exec 标记</span></span><br><span class="line">set_pmd(pmd, pfn_pmd(pfn, PAGE_KERNEL_LARGE_EXEC));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">set_pmd(pmd, pfn_pmd(pfn, PAGE_KERNEL_LARGE));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用 PSE 后就不需要 pte 了。</span></span><br><span class="line"><span class="comment">// 对于启用了 PAE 的机器来说，一页是 2^(9+12) = 2M</span></span><br><span class="line"><span class="comment">// 没有 PAE 则是 2^(10+12) = 4M</span></span><br><span class="line">pfn += PTRS_PER_PTE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pte = one_page_table_init(pmd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (pte_ofs = <span class="number">0</span>;</span><br><span class="line">     pte_ofs &lt; PTRS_PER_PTE &amp;&amp; pfn &lt; max_low_pfn;</span><br><span class="line">     pte++, pfn++, pte_ofs++, address += PAGE_SIZE) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_kernel_text(address))</span><br><span class="line">set_pte(pte, pfn_pte(pfn, PAGE_KERNEL_EXEC));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">set_pte(pte, pfn_pte(pfn, PAGE_KERNEL));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Creates a middle page table and puts a pointer to it in the</span></span><br><span class="line"><span class="comment"> * given global directory entry. This only returns the gd entry</span></span><br><span class="line"><span class="comment"> * in non-PAE compilation mode, since the middle layer is folded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pmd_t</span> * __<span class="function">init <span class="title">one_md_table_init</span><span class="params">(<span class="keyword">pgd_t</span> *pgd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pud_t</span> *pud;</span><br><span class="line"><span class="keyword">pmd_t</span> *pmd_table;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_PAE</span></span><br><span class="line"><span class="keyword">if</span> (!(pgd_val(*pgd) &amp; _PAGE_PRESENT)) &#123;</span><br><span class="line"><span class="comment">// 启用 PAE 的情况下，32 bit 的虚拟地址分为 2 9 9 12，pgd 有</span></span><br><span class="line"><span class="comment">// 2^2 = 4 项；pmd 是 2^9 = 512 项；然后是 pte 2^9 = 512 项；</span></span><br><span class="line"><span class="comment">// pte 在 kernel_physical_mapping_init 中初始化。</span></span><br><span class="line"><span class="comment">// PAE 相关知识参考书上第 56 页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bootmem 相关的后面昨晚单独的一篇文章来讲述，这里假装内存被</span></span><br><span class="line"><span class="comment">// 神奇地分配出来就好</span></span><br><span class="line">pmd_table = (<span class="keyword">pmd_t</span> *) alloc_bootmem_low_pages(PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟化相关的东西，忽略就好</span></span><br><span class="line">paravirt_alloc_pd(__pa(pmd_table) &gt;&gt; PAGE_SHIFT);</span><br><span class="line">set_pgd(pgd, __pgd(__pa(pmd_table) | _PAGE_PRESENT));</span><br><span class="line">pud = pud_offset(pgd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pmd_table != pmd_offset(pud, <span class="number">0</span>))</span><br><span class="line">BUG();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 在不启用 PAE 的情况下，下面返回的 pmd_table 其实就是 pgd（也就是</span></span><br><span class="line"><span class="comment">// 直接从 pgd 到 pte，两者都是 2^10 = 1024 项）</span></span><br><span class="line">pud = pud_offset(pgd, <span class="number">0</span>);</span><br><span class="line">pmd_table = pmd_offset(pud, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> pmd_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数就比较平凡了，没有什么好说的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a page table and place a pointer to it in a middle page</span></span><br><span class="line"><span class="comment"> * directory entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pte_t</span> * __<span class="function">init <span class="title">one_page_table_init</span><span class="params">(<span class="keyword">pmd_t</span> *pmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(pmd_val(*pmd) &amp; _PAGE_PRESENT)) &#123;</span><br><span class="line"><span class="keyword">pte_t</span> *page_table = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PAGEALLOC</span></span><br><span class="line">page_table = (<span class="keyword">pte_t</span> *) alloc_bootmem_pages(PAGE_SIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (!page_table)</span><br><span class="line">page_table =</span><br><span class="line">(<span class="keyword">pte_t</span> *)alloc_bootmem_low_pages(PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">paravirt_alloc_pt(&amp;init_mm, __pa(page_table) &gt;&gt; PAGE_SHIFT);</span><br><span class="line">set_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));</span><br><span class="line">BUG_ON(page_table != pte_offset_kernel(pmd, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pte_offset_kernel(pmd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码其实有 4 中情况：有 PAE 和没有 PAE两种，这两种又分别有 PSE 启不启用两种情况。读者可以分情况一个一个看，分情况弄清楚后，再合并一起看。</p><h1 id="固定映射的线性地址、非连续内存区的线性地址"><a href="#固定映射的线性地址、非连续内存区的线性地址" class="headerlink" title="固定映射的线性地址、非连续内存区的线性地址"></a>固定映射的线性地址、非连续内存区的线性地址</h1><p>处于篇幅和学习目的考虑，固定映射、非连续内存的处理在这里就先略去了，以后有机会再单独开一篇文章补上。内核页表的创建相关的代码我们就先看到这里。</p>]]></content>
    
    <summary type="html">
    
      内核跟普通的应用一样，为了使用虚拟内存，也需要一个给 CPU 设置一个页表。在这篇文章中，我们就一起来了解 Linux 是如何为内核创建页表的。
    
    </summary>
    
      <category term="Linux" scheme="https://jekton.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jekton.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解 LINUX 内核》读书笔记 - 临时内核页表</title>
    <link href="https://jekton.github.io/2018/11/18/note-x86-provisional-kernel-page-table-setup/"/>
    <id>https://jekton.github.io/2018/11/18/note-x86-provisional-kernel-page-table-setup/</id>
    <published>2018-11-18T04:04:22.000Z</published>
    <updated>2018-11-18T10:36:02.826Z</updated>
    
    <content type="html"><![CDATA[<p>x86 在启动的时候，CPU 处于实模式；而在保护模式下，为了将线性（内存）地址转换为物理内存地址，我们需要给 CPU 设置页表。本篇文件主要给《深入理解 LINUX 内核》临时内核页表一节（P74）中作者描述不太详细的部分添加更多的解释，并不打算把书中相关的知识点都搬上来，相关知识读者可以参考书中的描述。</p><blockquote><p>本文基于 <code>Linux 2.6.24</code>，x86 平台</p></blockquote><p>在使用分页（paging）的时候，需要构造相应的页表。对于使用一级页表的 x86 系统来说，页目录是必须的。但是这 1024 个页目录项并不需要都指向具体的页表，按需分配就行。看到“分配”这个词，读者就要注意了，它意味着动态内存分配。啊！我们连页表都没有，怎么动态分配内存！！没关系，我们弄个临时页表就可以解决这个鸡蛋和鸡的问题了。</p><p>内核临时页面的设置由 <code>startup_32()</code> 函数完成，这个函数是用汇编语言实现的，位于 <code>arch/x86/kernel/head_32.S</code>。</p><p>我们需要特别留意的是文中提到的，“在这个阶段PAE支持并未激活”。PAE 未激活，意味着此时使用的是二级页表接口，一个页表项 32 bits，DIRECTORY 字段 10 bits，TABLE 字段 10 bits 和 OFFSET 12 bits（参考第 52 页图 2-7）。</p><p>OFFSET 12 bits，所有一个 page 的大小是 <code>2^12 = 4K</code>。TABLE 字段有 10 bits，所以一个页目录项可以指向的页大小为 <code>2^10 * 4K = 4M</code>。我们需要映射 <code>8M</code> 的内存，所以<strong>两个</strong>页目录项就足够了。</p><p>接下来我们需要明白的是，内核映像是加载在物理地址的低端的（P73 图 2-13）。而内核在链接（link）的时候，起始地址却是 <code>0xc000 0000</code>。在实模式，线性地址直接翻译为物理地址；而在保护模式，线性地址需要经过页表的转换后才是物理地址。当我们把线性 <code>0x0000 0000 ~ 0x007f ffff</code> 和 <code>0xc000 0000 ~ 0xc07f ffff</code> 都映射到物理地址 <code>0x0000 0000 ~ 0x007f ffff</code> 时，内核代码就不需要区分当前使用的是线性地址还是物理地址了（直接使用物理地址，经过页表转换后的值是一样的）。</p><p>注意，这里 <code>0x0000 0000 ~ 0x007f ffff</code> 的大小就刚好是 <code>8M</code>。</p><p>确定了需要映射的内存范围后，便可以开始构造页表项。我们设置 <code>swapper_pg_dir</code> 的第 0、1 项的目的很明显（前面我们说了，8M 的内存，共需要 2 个页目录项），它们就对应着线性地址 <code>0x0000 0000 ~ 0x007f ffff</code>。这样一来，第 768、769 项应该就对应着内存 <code>0xc000 0000 ~ 0xc07f ffff</code> 了。这里我们关心都是，768 是怎么出来的？</p><p>我们知道，DIRECTORY 字段有 10 bits，共 <code>2^10 = 1024</code> 个目录项。<code>0xc000 0000</code> 刚好在 4G 内存的 3/4 处。利用这个信息，我们就能够计算 <code>0xc000 0000</code> 对应的页表项为 <code>1024 * (3/4) = 768</code>。另一种更直接的方法是，按照 MMU 转换线性地址时的方法，取 <code>0xc000 0000</code> 的前 10 个位，即得到 <code>0x300</code>。</p><p>在最后，我们来看启用分页的一小段汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl $swapper_pg_dir-__PAGE_OFFSET,%eax</span><br><span class="line">movl %eax,%cr3/* set the page table pointer.. */</span><br><span class="line">movl %cr0,%eax</span><br><span class="line">orl $0x80000000,%eax</span><br><span class="line">movl %eax,%cr0/* ..and set paging (PG) bit */</span><br></pre></td></tr></table></figure><p><code>swapper_pg_dir</code> 就是我们构造的临时页表，问题在于，为什么需要减去 <code>__PAGE_OFFSET</code>（其实就是 <code>0xc0000000</code>）呢？答案在前面我们其实已经说过了，内核在链接（link）的时候，起始地址是 <code>0xc000 0000</code>。也就是说，从内核的视角来看，他以为自己是从 <code>0xc0000000</code> 开始的。<code>$swapper_pg_dir - __PAGE_OFFSET</code> 后，才是 <code>swapper_pg_dir</code> 真正的内存地址（在执行这一行代码的时候，CPU 还处于实模式，这个模式下，线性地址就是物理地址）。</p><p><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;x86 在启动的时候，CPU 处于实模式；而在保护模式下，为了将线性（内存）地址转换为物理内存地址，我们需要给 CPU 设置页表。本篇文件主要给《深入理解 LINUX 内核》临时内核页表一节（P74）中作者描述不太详细的部分添加更多的解释，并不打算把书中相关的知识点都搬上来
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://jekton.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://jekton.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://jekton.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（5）- 插件的使用、开发和发布</title>
    <link href="https://jekton.github.io/2018/09/16/flutter-plugin-dev/"/>
    <id>https://jekton.github.io/2018/09/16/flutter-plugin-dev/</id>
    <published>2018-09-16T01:34:02.000Z</published>
    <updated>2018-09-18T12:17:10.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>本篇文章我们先一起学习 Flutter 插件的使用，然后通过开发一个 toast 插件来学习它的开发，最后发布到 Pub 上。</p><h1 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h1><p>Flutter 的库是以 package 的方式来管理。Package 分为两种，Dart package（也叫 library package） 和 plugin package。当我们说 Fluter 包的时候，指的其实也是 Dart 包，它只能使用 Dart 和 Flutter 提供的 API；而当我们说 Flutter 插件时指的是后者，也就是 plugin package。Flutter 插件通常会包含平台特定的代码。对包的使用者来说，两者没有区别。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>为了使用一个库，我们首先在 pubspec.yaml 里声明一个依赖：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  shared_preferences:</span> <span class="string">^0.4.2</span></span><br></pre></td></tr></table></figure><p><code>^0.4.2</code> 表示与 <code>0.4.2</code> 兼容的版本。我们也可以指定依赖库的为特定的版本：</p><ul><li>any：任意版本</li><li>1.2.3：特定的版本</li><li>&lt;1.2.3：小于 1.2.3 的版本，此外还有 &lt;=、&gt;、&gt;= 可以使用</li><li>‘&gt;=1.2.3 &lt;2.0.0’：指定一个范围</li></ul><p>接下来，在项目的根目录执行 <code>flutter packages get</code>。如果你使用 Android Studio 进行开发，也可以直接在 pubspec.yaml 的编辑页面上面点击 Packages get 按钮。</p><p>上面例子的是发布在 <code>https://pub.dartlang.org/</code> 上的库，除此之外，我们也可以使用其他的源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  transmogrify:</span></span><br><span class="line"><span class="attr">    hosted:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">transmogrify</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://your-package-server.com</span></span><br><span class="line"><span class="attr">    version:</span> <span class="string">^1.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  kittens:</span></span><br><span class="line"><span class="attr">    git:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">git://github.com/munificent/cats.git</span></span><br><span class="line"><span class="attr">      ref:</span> <span class="string">some-branch</span>  <span class="comment"># 可选的</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  kittens:</span></span><br><span class="line"><span class="attr">    git:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">git://github.com/munificent/cats.git</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">path/to/kittens</span>  <span class="comment"># 指定路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 甚至可以指定一个本地路径</span></span><br><span class="line"><span class="attr">    transmogrify:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/Users/me/transmogrify</span></span><br></pre></td></tr></table></figure><p>如果你看过 Flutter 的 pubspec，应该会注意到 flutter 是这样声明的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  flutter:</span></span><br><span class="line"><span class="attr">    sdk:</span> <span class="string">flutter</span></span><br></pre></td></tr></table></figure><p>sdk 用于导入随 Flutter 一起发布的包，目前只有 flutter。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>导入相关的包后，我们就可以使用它的 API 了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:shared_preferences/shared_preferences.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> prefs = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">  <span class="keyword">var</span> used = prefs.getBool(<span class="string">'used'</span>);</span><br><span class="line">  <span class="keyword">if</span> (!used) &#123;</span><br><span class="line">    prefs.setBool(<span class="string">'used'</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种导入方式的问题在于，他把库里所有的符号到导入到了全局的命名空间里面（比方说，在上面的例子里，我们可以直接使用 <code>SharedPreferences</code>）。有时为了防止命名空间的污染，我们可以使用 <code>as</code> 给导入的库一个名字（当然，对 SharedPreferences 其实没有必要使用限定名就是了）：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> prefs = <span class="keyword">await</span> sp.SharedPreferences.getInstance();</span><br><span class="line">  <span class="keyword">var</span> used = prefs.getBool(<span class="string">'used'</span>);</span><br><span class="line">  <span class="keyword">if</span> (!used) &#123;</span><br><span class="line">    prefs.setBool(<span class="string">'used'</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了 Flutter 包的使用后，下面我们自己来开发一个 flutter 插件。</p><h1 id="开发一个插件"><a href="#开发一个插件" class="headerlink" title="开发一个插件"></a>开发一个插件</h1><p>学习 Flutter 的过程中，不知道是你是否注意到 Flutter 并没有提供一个 Toast API。为了弥补这个遗憾，在这一节里我们就来开发一个插件，让它支持 Toast。</p><p>在开始开发前，我们先来了解一下 Flutter 如何跟平台相关的代码进行通信。</p><h2 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h2><p>Flutter 跟平台相关代码可以通过 <code>MethodChannel</code> 进行通信。客户端通过 <code>MethodChannel</code> 将方法调用和参数发生给服务端，服务端也通过 <code>MethodChannel</code> 接收相关的数据。</p><p><img src="/2018/09/16/flutter-plugin-dev/PlatformChannels.png" alt="PlatformChannels"></p><p>需要注意的是，上图中的箭头是双向的。也就是说，我们不仅可以从 Flutter 调用 Android/iOS 的代码，也可以从 Android/iOS 调用 Flutter。调用时相关的参数对应如下：</p><table><thead><tr><th>Dart</th><th>Android</th><th>iOS</th></tr></thead><tbody><tr><td>null</td><td>null</td><td>nil (NSNull when nested)</td></tr><tr><td>bool</td><td>java.lang.Boolean</td><td>NSNumber numberWithBool:</td></tr><tr><td>int</td><td>java.lang.Integer</td><td>NSNumber numberWithInt:</td></tr><tr><td>int, if 32 bits not enough</td><td>java.lang.Long</td><td>NSNumber numberWithLong:</td></tr><tr><td>double</td><td>java.lang.Double</td><td>NSNumber numberWithDouble:</td></tr><tr><td>String</td><td>java.lang.String</td><td>NSString</td></tr><tr><td>Uint8List</td><td>byte[]</td><td>FlutterStandardTypedData typedDataWithBytes:</td></tr><tr><td>Int32List</td><td>int[]</td><td>FlutterStandardTypedData typedDataWithInt32:</td></tr><tr><td>Int64List</td><td>long[]</td><td>FlutterStandardTypedData typedDataWithInt64:</td></tr><tr><td>Float64List</td><td>double[]</td><td>FlutterStandardTypedData typedDataWithFloat64:</td></tr><tr><td>List</td><td>java.util.ArrayList</td><td>NSArray</td></tr><tr><td>Map</td><td>java.util.HashMap</td><td>NSDictionary</td></tr></tbody></table><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>这里假设读者使用 Android Studio 开发。</p><ol><li>在菜单上选择 File -&gt; New -&gt; New Flutter Project</li><li>在弹出的面板里选择 Flutter Plugin，点击 next</li><li>Project name 我们填入 flutter_toast2018，其他信息读者根据自身需要填写</li></ol><p>之所以叫 flutter_toast2018 是因为 Pub 上已经有一个 flutter_toast，所以加上 2018 防止名字冲突。</p><p>生成的项目有 4 个主要的目录：</p><ul><li>android：插件本地代码的 Android 端实现</li><li>ios：iOS 端的实现</li><li>lib：Dart 代码。插件的客户将会使用这里实现的接口</li><li>example：插件的使用示例</li></ul><h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><h3 id="Android-端代码实现"><a href="#Android-端代码实现" class="headerlink" title="Android 端代码实现"></a>Android 端代码实现</h3><p>其实在上一步我们生成项目的时候，项目里就已经包含了一个实现了 <code>platformVersion</code> 的 Flutter 插件 demo，有兴趣的读者可以看看学习一下。下面，我们来开发自己的 Toast 插件（注意，我们的实现只支持 Android）。</p><p>首先我们来了解一下接口 <code>MethodCallHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口用于处理 Flutter 的本地方法调用请求。也就是说，我们需要实现这个接口，当 Flutter 调用我们的时候，弹出一个 toast。</p><p>实现这个接口的是 <code>FlutterToast2018Plugin</code>（位于 android 目录下）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterToast2018Plugin</span> <span class="keyword">implements</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// "example.com/flutter_toast2018" 是我们 method channel 的名字，Dart 代码里还需要用到它。</span></span><br><span class="line">    <span class="comment">// 为了防止命名冲突，可以在它的前面加上域名</span></span><br><span class="line">    <span class="keyword">final</span> channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), <span class="string">"example.com/flutter_toast2018"</span>);</span><br><span class="line">    channel.setMethodCallHandler(<span class="keyword">new</span> FlutterToast2018Plugin());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了弹出 Toast，我们给 <code>FlutterToast2018Plugin</code> 的构造函数添加一个 <code>Context</code> 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterToast2018Plugin</span> <span class="keyword">implements</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FlutterToast2018Plugin</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册 MethodCallHandler</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), <span class="string">"example.com/flutter_toast2018"</span>);</span><br><span class="line">    <span class="comment">// context 可以从 Registrar 拿到</span></span><br><span class="line">    channel.setMethodCallHandler(<span class="keyword">new</span> FlutterToast2018Plugin(registrar.context());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，实现 <code>onMethodCall</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterToast2018Plugin</span> <span class="keyword">implements</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// call.method 是方法名，这里我们就叫它 toast</span></span><br><span class="line">    <span class="keyword">if</span> (call.method.equals(<span class="string">"toast"</span>)) &#123;</span><br><span class="line">      <span class="comment">// 调用本地代码的时候，只能传递一个参数。为了传递多个，可以把参数放在一个 map 里面。</span></span><br><span class="line">      <span class="comment">// call.arguemnt() 方法支持 Map 和 JSONObject</span></span><br><span class="line">      String content = call.argument(<span class="string">"content"</span>);</span><br><span class="line">      String duration = call.argument(<span class="string">"duration"</span>);</span><br><span class="line">      Toast.makeText(mContext, content,</span><br><span class="line">                     <span class="string">"short"</span>.equals(duration) ? Toast.LENGTH_SHORT : Toast.LENGTH_LONG)</span><br><span class="line">              .show();</span><br><span class="line">      <span class="comment">// 执行成功</span></span><br><span class="line">      result.success(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.notImplemented();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flutter-端"><a href="#Flutter-端" class="headerlink" title="Flutter 端"></a>Flutter 端</h3><p>Flutter 端需要做的，就是生成一个 <code>MethodChannel</code>，然后通过这个 <code>MethodChannel</code> 调用 <code>toast</code> 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ToastDuration &#123;</span><br><span class="line">  short, long</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterToast</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的名字要跟 Java 端的对应</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> MethodChannel _channel =</span><br><span class="line">      <span class="keyword">const</span> MethodChannel(<span class="string">'example.com/flutter_toast2018'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Future&lt;<span class="built_in">bool</span>&gt; toast(<span class="built_in">String</span> msg, ToastDuration duration) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> argument = &#123;</span><br><span class="line">      <span class="string">'content'</span>: msg,</span><br><span class="line">      <span class="string">'duration'</span>: duration.toString()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 本地方法是一个异步调用。'toast' 对应我们在前面 Java 代码的 onMethodCall</span></span><br><span class="line">    <span class="comment">// 方法里面处理的方法名</span></span><br><span class="line">    <span class="keyword">var</span> success = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">'toast'</span>, argument);</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>在这一节我们修改工程里 example 目录下的示例，用它来演示插件的使用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先导入我们的包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_toast2018/flutter_toast2018.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      home: <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          title: <span class="keyword">const</span> Text(<span class="string">'Plugin example app'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="keyword">new</span> Center(</span><br><span class="line">          child: RaisedButton(</span><br><span class="line">            child: Text(<span class="string">'toast'</span>),</span><br><span class="line">            <span class="comment">// 插件的使用跟其他库没有什么区别，直接调用即可</span></span><br><span class="line">            onPressed: () =&gt; FlutterToast2018.toast(</span><br><span class="line">              <span class="string">'Toast from Flutter'</span>, ToastDuration.short</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h1><p>前面我们说过，pubspec 支持通过本地路径和 Git 导入依赖，但为了更好的管理版本依赖，还是推荐发布插件到 <a href="https://pub.dartlang.org/" target="_blank" rel="noopener">https://pub.dartlang.org/</a>。在这一节，我们就把前面开发的 toast 插件发布到 Pub 上。</p><p>需要注意的是，由于某些众所周知的原因，pub.dartlang.org 需要一把梯子才能上去。虽然我们也可以通过 flutter-io.cn 来发布，但上传的时候需要登录 Google 账号，梯子还是少不了的。</p><h2 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h2><p>首先是 pubspec.yaml。对 Flutter 插件来说，pubspec 里除了插件的依赖，还包含一些元信息，读者可以根据需要，把这些补上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">flutter_toast2018</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">new</span> <span class="string">Flutter</span> <span class="string">plugin</span> <span class="string">for</span> <span class="string">Android</span> <span class="string">Toast.</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Jekton</span> <span class="string">&lt;ljtong64@gmail.com&gt;</span></span><br><span class="line"><span class="attr">homepage:</span> <span class="attr">https://jekton.github.io/</span></span><br></pre></td></tr></table></figure><p>另外，发布到 Pub 上的包需要包含一个 LICENSE，关于 LICENSE 文件，最简单的方法就是在 GitHub 创建仓库的时候选中一个。</p><h2 id="检查插件"><a href="#检查插件" class="headerlink" title="检查插件"></a>检查插件</h2><p>现在，我们在工程的根目录执行以下命令，检测一下插件有没有什么问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub publish --dry-run</span><br></pre></td></tr></table></figure><p>如果一切正常，将会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">Package has 0 warnings.</span><br></pre></td></tr></table></figure><h2 id="发布插件-1"><a href="#发布插件-1" class="headerlink" title="发布插件"></a>发布插件</h2><p>发布插件和上一步一样，只是少了 –dry-run 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub publish</span><br></pre></td></tr></table></figure><p>如果是第一次发布，会提示验证 Google 账号。授权后便可以继续上传，如果成功的话，会提示“Successful uploaded package”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looks great! Are you ready to upload your package (y/n)? y</span><br><span class="line">Pub needs your authorization to upload packages on your behalf.</span><br><span class="line">In a web browser, go to https://accounts.google.com/o/oauth2/auth?access_type=offline&amp;approval_prompt=force&amp;response_type=code&amp;client_id=xxxxxxxxxxxxxx-8grd2eg9tj9f38os6f1urbcvsq399u8n.apps.googleusercontent.com&amp;redirect_uri=http%3A%2F%2Flocalhost%3A52589&amp;scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email</span><br><span class="line">Then click &quot;Allow access&quot;.</span><br><span class="line"></span><br><span class="line">Waiting for your authorization...</span><br><span class="line">Successfully authorized.</span><br><span class="line">Uploading...</span><br><span class="line">Successful uploaded package.</span><br></pre></td></tr></table></figure><p>前面我们发布的包可以在 <a href="https://pub.dartlang.org/packages/flutter_toast2018" target="_blank" rel="noopener">https://pub.dartlang.org/packages/flutter_toast2018</a> 或 <a href="https://pub.flutter-io.cn/packages/flutter_toast2018" target="_blank" rel="noopener">https://pub.flutter-io.cn/packages/flutter_toast2018</a> 找到。</p><p>相关的代码则是放到了 GitHub 上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_toast2018.git</span><br></pre></td></tr></table></figure><p>最后再提一提我们没有讲到的 Flutter package。为了开发一个 Flutter 包，我们在创建项目的时候可以选择 Flutter package。它和 Flutter 插件唯一的区别是Flutter package 不能包含平台特定的代码（只能使用 Dart 和 Flutter API）。除此之外，开发、发布和使用都跟 Flutter 插件没有什么区别。</p>]]></content>
    
    <summary type="html">
    
      本篇文章我们先一起学习 Flutter 插件的使用，然后通过开发一个 toast 插件来学习它的开发，最后发布到 Pub 上。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语言入门</title>
    <link href="https://jekton.github.io/2018/09/04/dart-tutorial/"/>
    <id>https://jekton.github.io/2018/09/04/dart-tutorial/</id>
    <published>2018-09-04T01:49:17.000Z</published>
    <updated>2018-09-18T12:15:54.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>本篇文章假定读者有一定的编程经验。通过快速浏览 Dart 的一些基础特性，让读者具备使用它进行开发的基本能力。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> done = <span class="keyword">true</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">double</span> x = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">bool</span> visible = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> amount = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">double</span> y = <span class="number">2.7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">bool</span> debug = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> sum = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> z = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure><p>跟常用的其他语言不同，Dart 没有 <code>byte</code>、<code>char</code> 和 <code>float</code>，<code>int</code>、<code>double</code> 都是 64 位。<code>final</code> 跟 Java 里的 final 一样，表示一个运行时常量（在程序运行的时候赋值，赋值后值不再改变）。<code>const</code> 表示一个编译时常量，在程序编译的时候它的值就确定了。</p><p>如果你觉得每次写变量类型太麻烦，你应该会喜欢 Dart 的类型推断功能：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> visible = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">final</span> amount = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">final</span> y = <span class="number">2.7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> sum = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> z = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure><p>Dart 里所有的东西都是对象，包括 <code>int</code>、函数。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">' foo'</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = str.toUpperCase();</span><br><span class="line"><span class="keyword">var</span> str3 = str.trim();</span><br><span class="line"><span class="keyword">assert</span>(str == str2);</span><br><span class="line"><span class="keyword">assert</span>(!identical(str, str2));</span><br></pre></td></tr></table></figure><p>Dart 里的 <code>String</code> 跟 Java 中的一样，是不可变对象；不同的是，检测两个 <code>String</code> 的内容是否一样事，我们使用 <code>==</code> 进行比较；如果要测试两个对象是否是同一个对象（indentity test），使用 <code>identical</code> 函数。</p><h2 id="List、Map-和-Set"><a href="#List、Map-和-Set" class="headerlink" title="List、Map 和 Set"></a>List、Map 和 Set</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数创建对象</span></span><br><span class="line"><span class="comment">// 跟 var list = new List&lt;int&gt;(); 一样</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字面量创建对象，list 的泛型参数可以从变量定义推断出来。</span></span><br><span class="line"><span class="comment">// 推荐使用字面量方式创建对象</span></span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 没有元素，显式指定泛型参数为 int</span></span><br><span class="line"><span class="keyword">var</span> list3 = &lt;<span class="built_in">int</span>&gt;[];</span><br><span class="line">list3.add(<span class="number">1</span>);</span><br><span class="line">list3.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list4 = <span class="keyword">const</span>[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// list4 指向的是一个常量，我们不能给它添加元素（不能修改它）</span></span><br><span class="line">list4.add(<span class="number">3</span>);       <span class="comment">// error</span></span><br><span class="line"><span class="comment">// list4 本身不是一个常量，所以它可以指向另一个对象</span></span><br><span class="line">list4 = [<span class="number">4</span>, <span class="number">5</span>];     <span class="comment">// it's fine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list5 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 相当于 const list5 = const[1, 2];</span></span><br><span class="line">list5.add(<span class="number">3</span>);       <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dart 同样提供了 for-in 循环。</span></span><br><span class="line"><span class="comment">// 因为语音设计时就考虑到了这个需求，in 在 Dart 里是一个关键字</span></span><br><span class="line"><span class="keyword">var</span> list6 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">in</span> list6) &#123;</span><br><span class="line">  <span class="built_in">print</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Dart 2 里，创建对象时可以省略 <code>new</code> 关键字，也推荐省略 <code>new</code>。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"><span class="keyword">set</span>.add(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">set</span>.add(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="keyword">set</span>.contains(<span class="string">'foo'</span>));</span><br></pre></td></tr></table></figure><p>我们只能通过 <code>Set</code> 的构造函数创建实例。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">map[<span class="string">'foo'</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="string">'bar'</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">map[<span class="string">'foo'</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 对应的 key 不存在时，返回 null</span></span><br><span class="line"><span class="keyword">if</span> (map[<span class="string">'foobar'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'map does not contain foobar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map2 = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">'foo'</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">'bar'</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> map3 = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="dynamic-和-Object"><a href="#dynamic-和-Object" class="headerlink" title="dynamic 和 Object"></a>dynamic 和 Object</h2><p>前面我们说过，Dart 里所有东西都是对象。所有这些对象的父类就是 <code>Object</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> o = <span class="string">'string'</span>;</span><br><span class="line">o = <span class="number">42</span>;</span><br><span class="line">o.toString();   <span class="comment">// 我们只能调用 Object 支持的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic</span> obj = <span class="string">'string'</span>;</span><br><span class="line">obj[<span class="string">'foo'</span>] = <span class="number">4</span>;  <span class="comment">// 可以编译通过，但在运行时会抛出 NoSuchMethodError</span></span><br></pre></td></tr></table></figure><p><code>Object</code> 和 <code>dynamic</code> 都使得我们可以接收任意类型的参数，但两者的区别非常的大。</p><p>使用 <code>Object</code> 时，我们只是在说接受任意类型，我们需要的是一个 <code>Object</code>。类型系统会保证其类型安全。</p><p>使用 <code>dynamic</code> 则是告诉编译器，我们知道自己在做什么，<strong>不用做类型检测</strong>。当我们调用一个不存在的方法时，会执行 <code>noSuchMethod()</code> 方法，默认情况下（在 <code>Object</code> 里实现）它会抛出 <code>NoSuchMethodError</code>。</p><p>为了在运行时检测进行类型检测，Dart 提供了一个关键字 <code>is</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> obj = &lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;) &#123;</span><br><span class="line">  <span class="comment">// 进过类型判断后，Dart 知道 obj 是一个 Map&lt;String, int&gt;，</span></span><br><span class="line">  <span class="comment">// 所以这里不用强制转换 obj 的类型，即使我们声明 obj 为 Object。</span></span><br><span class="line">  obj[<span class="string">'foo'</span>] = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然 Dart 也提供了 as 让我们进行类型的强制转换，但为了进来更安全</span></span><br><span class="line"><span class="comment">// 的转换，更推荐使用 is</span></span><br><span class="line"><span class="keyword">var</span> map = obj <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;;</span><br></pre></td></tr></table></figure><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> success = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (success) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'done'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'fail'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  sum += j;</span><br><span class="line">  ++j;</span><br><span class="line">&#125; <span class="keyword">while</span> (j &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (sum-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> type = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的 <code>if/else</code>，<code>do while</code>，<code>while</code> 和 <code>switch</code> 在 Dart 里面都支持。<code>switch</code> 也支持 <code>String</code> 和 <code>enum</code>。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>最普通的函数看起来跟 Java 里的一样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> foo(<span class="built_in">int</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 也支持可选参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(foo(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> foo(<span class="built_in">int</span> x, [<span class="built_in">int</span> y]) &#123;</span><br><span class="line">  <span class="comment">// 是的，int 也可以是 null</span></span><br><span class="line">  <span class="keyword">if</span> (y != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>默认参数也是支持的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> foo(<span class="built_in">int</span> x, [<span class="built_in">int</span> y = <span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还能用具名参数（named parameters）：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo(x: <span class="number">1</span>, y: <span class="number">2</span>));</span><br><span class="line">  <span class="comment">// 具名参数的顺序可以是任意的</span></span><br><span class="line">  <span class="built_in">print</span>(foo(y: <span class="number">3</span>, x: <span class="number">4</span>));</span><br><span class="line">  <span class="comment">// 所有的具名参数都是可选的，这个调用是合法的，但它会导致 foo() 在运行时抛异常</span></span><br><span class="line">  <span class="built_in">print</span>(foo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> foo(&#123;<span class="built_in">int</span> x, <span class="built_in">int</span> y&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具名参数也可以有默认参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo(x: <span class="number">1</span>, y: <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(foo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> foo(&#123;<span class="built_in">int</span> x = <span class="number">0</span>, <span class="built_in">int</span> y = <span class="number">0</span>&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想告诉用户某个具名参数是必须的，可以使用注解 <code>@required</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> foo(&#123;<span class="meta">@required</span> <span class="built_in">int</span> x, <span class="meta">@required</span> <span class="built_in">int</span> y&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@required</code> 是 <code>meta</code> 包里提供的 API，更多的信息读者可以查看 <a href="https://pub.dartlang.org/packages/meta" target="_blank" rel="noopener">https://pub.dartlang.org/packages/meta</a>。</p><p>函数还可以在函数的内部定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typedef 在 Dart 里面用于定义函数类型的别名</span></span><br><span class="line"><span class="keyword">typedef</span> Adder = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">Adder makeAdder(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="built_in">int</span> adder(<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + extra;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> adder = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>像上面这样简单的函数，我们还可以使用 lambda：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Adder = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">Adder makeAdder(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + extra;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 如果只有一个语句，我们可以使用下面这种更为简洁的形式</span></span><br><span class="line">  <span class="comment">// return (int x, int y) =&gt; x + y + extra;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> adder = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 里面不仅变量支持类型推断，lambda 的参数也支持自动推断。上面的代码还可以进一步简化为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Adder = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">Adder makeAdder(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="comment">// 我们要返回的类型是 Adder，所以 Dart 知道 x, y 都是 int</span></span><br><span class="line">  <span class="keyword">return</span> (x, y) =&gt; x + y + extra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> adder = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>美中不足的是，Dart 不支持函数的重载。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>抛出异常：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> Exception(<span class="string">'put your error message here'</span>);</span><br></pre></td></tr></table></figure><p>捕获异常：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 捕获特定类型的异常</span></span><br><span class="line">&#125; on FormatException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 捕获特定类型的异常，但不需要这个对象</span></span><br><span class="line">&#125; on Exception &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line"><span class="comment">// 捕获所有异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 Java 不同的是，Dart 可以抛出任意类型的对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>定义一个类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> someConst = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="comment">// 成员变量也可以是 final 的</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point2D(<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这种初始化方式很常见，Dart 提供了更简洁的方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point2d</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  point2d(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还可以使用初始化列表（initializer list）对对象进行初始化：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于是在 initializer list 中，Dart 知道第一个 x 是 this.x，</span></span><br><span class="line">  <span class="comment">// 第二个 x 是构造函数的参数</span></span><br><span class="line">  Point2D(<span class="built_in">int</span> x, <span class="built_in">int</span> y) : x = x, y = y &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initializer list 会在构造函数的函数体运行前执行。</p><p>Dart 具有垃圾收集功能，对象的使用跟 Java 里几乎是一样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point2D(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  point.x = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">print</span>(point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">  Point2D(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有的类都继承自 Object，toString() 是 Object 中的方法</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="comment">// 在字符串的内部可以通过 $&#123;expression&#125; 的方式插入值，如果</span></span><br><span class="line">    <span class="comment">// expression 是一个变量，可以省略花括号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Point2D&#123;x=$x, y=$y&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// Point2D&#123;x=4, y=2&#125;</span></span><br></pre></td></tr></table></figure><p>Dart 使用 package 的概念来管理源码和可见性。它没有 <code>public</code>、<code>private</code> 之类的访问权限控制符，默认情况下，所有的符号都是公开的。如果我们不想某个变量对包的外部可见，可以使用下划线开头来给变量命名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们使用 Dart 的访问控制，实现一个带偏移量的 Point：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OffsetPoint</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _x;</span><br><span class="line">  <span class="built_in">int</span> _y;</span><br><span class="line">  <span class="built_in">int</span> offset;</span><br><span class="line"></span><br><span class="line">  OffsetPoint(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> offset)</span><br><span class="line">      : _x = x, _y = y, offset = offset &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义一个 getter</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> x =&gt; _x + offset;</span><br><span class="line">  <span class="comment">// getter 不能有参数，连括号都省掉了</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> y &#123;</span><br><span class="line">    <span class="keyword">return</span> _y + offset;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义 setter</span></span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">set</span> x (<span class="built_in">int</span> x) =&gt; _x = x;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">set</span> y (<span class="built_in">int</span> y) =&gt; _y = y;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"OffsetPoint&#123;x=$x, y=$y&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = OffsetPoint(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="comment">// 使用 getter/setter 时，就像它是一个普通的成员变量</span></span><br><span class="line">  <span class="built_in">print</span>(point.x)</span><br><span class="line">  <span class="built_in">print</span>(point);</span><br><span class="line">  point.x = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">print</span>(point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// OffsetPoint&#123;x=11, y=12&#125;</span></span><br><span class="line"><span class="comment">// OffsetPoint&#123;x=14, y=12&#125;</span></span><br></pre></td></tr></table></figure><p>在 Dart 里继承对象也很简单：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">  Point2D(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> <span class="keyword">extends</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> z;</span><br><span class="line">  <span class="comment">// 父类的构造函数只能在 initializer list 里调用</span></span><br><span class="line">  Point3D(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> z): z = z, <span class="keyword">super</span>(x, y) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对象构造时它跟 Java、C++ 都不太一样：</p><ol><li>先执行子类 initializer list，但只初始化自己的成员变量</li><li>初始化父类的成员变量</li><li>执行父类构造函数的函数体</li><li>执行之类构造函数的函数体</li></ol><p>基于这个初始化顺序，推荐是把 <code>super()</code> 放在 initializer list 的最后。此外，在 initializer list 里不能访问 <code>this</code>（也就是说，只能调用静态方法）。</p><p>虽然 Dart 是单继承的，但它也提供了一定程度的多重继承支持：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bark</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> bark() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'woof'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> <span class="keyword">extends</span> <span class="title">Point2D</span> <span class="title">with</span> <span class="title">Bark</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> z;</span><br><span class="line">  <span class="comment">// 父类的构造函数只能在 initializer list 里调用</span></span><br><span class="line">  Point3D(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> z): z = z, <span class="keyword">super</span>(x, y) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有其他类需要继承，所以直接 extends Bark 就可以了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bark</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = Point3D(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  p.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 把支持多重继承的类叫做 mixin。更详细的介绍，读者可以参考<a href="https://www.dartlang.org/articles/language/mixins" target="_blank" rel="noopener">https://www.dartlang.org/articles/language/mixins</a>。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  S first;</span><br><span class="line">  T second;</span><br><span class="line">  Pair(<span class="keyword">this</span>.first, <span class="keyword">this</span>.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = Pair(<span class="string">'hello'</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(p <span class="keyword">is</span> Pair&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;);</span><br><span class="line">  <span class="comment">// is! 也是 Dart 的运算符，下面的语句跟 !(p is Pair&lt;int, int&gt;) 是一样的，</span></span><br><span class="line">  <span class="comment">// 但 is! 读起来跟像英语</span></span><br><span class="line">  <span class="built_in">print</span>(p <span class="keyword">is</span>! Pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;);</span><br><span class="line">  <span class="built_in">print</span>(p <span class="keyword">is</span> Pair);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>跟 Java 不同，Dart 的泛型参数类型在运行时是保留的。</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Dart 是单线程的，主线程由一个事件循环来执行（类似 Android 的主线程）。对于异步代码，我们通过 <code>Future</code> 来获取结果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import 语句用于导入一个包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  file.exists()</span><br><span class="line">      .then((exists) =&gt; <span class="built_in">print</span>(<span class="string">'file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>))</span><br><span class="line">      .catchError((e) =&gt; <span class="built_in">print</span>(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 2 提供了 async 函数，用来简化这种编程范式。下面这段代码的效果跟上面是一样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意，上面两段代码并不是完全一样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  foo();</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> bar() &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  file.exists()</span><br><span class="line">      .then((exists) =&gt; <span class="built_in">print</span>(<span class="string">'bar: file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>))</span><br><span class="line">      .catchError((e) =&gt; <span class="built_in">print</span>(e));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'bar: after file.exists() returned'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'bar: file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'bar: after file.exists() returned'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种可能的结果：</span></span><br><span class="line"><span class="comment">// bar: after file.exists() returned</span></span><br><span class="line"><span class="comment">// foo: file not exists</span></span><br><span class="line"><span class="comment">// foo: after file.exists() returned</span></span><br><span class="line"><span class="comment">// bar: file not exists</span></span><br></pre></td></tr></table></figure><p>这里的关键在于，bar 函数里面，<code>file.exists()...</code> 执行完后，会马上执行下面的语句；而 foo 则会等待结果，然后才继续执行。关于 Future 的更多的细节，<strong>强烈建议</strong>读者阅读<a href="https://webdev.dartlang.org/articles/performance/event-loop" target="_blank" rel="noopener">https://webdev.dartlang.org/articles/performance/event-loop</a>。</p><p>最后需要说明的是，Dart 的生成器、<code>Stream</code> 在这里我们并没有介绍，读者可以参考 <a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">https://www.dartlang.org/guides/language/language-tour</a>。此外，Dart 官网还有许多资源等待读者去发掘。</p>]]></content>
    
    <summary type="html">
    
      本篇文章假定读者有一定的编程经验。通过快速浏览 Dart 的一些基础特性，让读者具备使用它进行开发的基本能力。
    
    </summary>
    
      <category term="Dart" scheme="https://jekton.github.io/categories/Dart/"/>
    
    
      <category term="Dart" scheme="https://jekton.github.io/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（4）- 文件、存储和网络</title>
    <link href="https://jekton.github.io/2018/09/01/flutter-io-basic/"/>
    <id>https://jekton.github.io/2018/09/01/flutter-io-basic/</id>
    <published>2018-08-31T23:29:39.000Z</published>
    <updated>2018-09-18T12:16:58.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>本篇文章我们先学习 Flutter IO 相关的基础知识，然后在<a href="2018/08/29/flutter-ux-basic">Flutter 开发（3）- 交互、动画、手势和事件处理</a>的基础上，继续开发一个 echo 客户端。由于日常开发中 HTTP 比 socket 更常见，我们的 echo 客户端将会使用 HTTP 协议跟服务端通信。Echo 服务器也会使用 Dart 来实现。</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>为了执行文件操作，我们可以使用 Dart 的 io 包：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br></pre></td></tr></table></figure><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>在 Dart 里，我们通过类 <code>File</code> 来执行文件操作：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filepath = <span class="string">"path to your file"</span>;</span><br><span class="line">  <span class="keyword">var</span> file = File(filepath);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">    <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">      <span class="keyword">await</span> file.create();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于 CPU，IO 总是很慢的，所以大部分文件操作都返回一个 <code>Future</code>，并在出错的时候抛出一个异常。如果你需要，也可以使用同步版本，这些方法都带一个后缀 Sync：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">  <span class="keyword">const</span> filepath = <span class="string">"path to your file"</span>;</span><br><span class="line">  <span class="keyword">var</span> file = File(filepath);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> exists = file.existsSync();</span><br><span class="line">    <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">      file.createSync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async 方法使得我们可以像写同步方法一样写异步代码，同步版本的 io 方法已经没有太多使用的必要了（Dart 1 不支持 async 函数，所以同步版本的方法的存在是有必要的）。</p><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>写 <code>String</code> 时我们可以使用 <code>writeAsString</code> 和 <code>writeAsBytes</code> 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filepath = <span class="string">"path to your file"</span>;</span><br><span class="line"><span class="keyword">var</span> file = File(filepath);</span><br><span class="line"><span class="keyword">await</span> file.writeAsString(<span class="string">'Hello, Dart IO'</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; toBeWritten = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">await</span> file.writeAsBytes(toBeWritten);</span><br></pre></td></tr></table></figure><p>如果只是为了写文件，还可以使用 <code>openWrite</code> 打开一个 <code>IOSink</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filepath = <span class="string">"path to your file"</span>;</span><br><span class="line">  <span class="keyword">var</span> file = File(filepath);</span><br><span class="line">  IOSink sink;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    sink = file.openWrite();</span><br><span class="line">    <span class="comment">// 默认的写文件操作会覆盖原有内容；如果要追究内容，用 append 模式</span></span><br><span class="line">    <span class="comment">// sink = file.openWrite(mode: FileMode.append);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// write() 的参数是一个 Object，他会执行 obj.toString() 把转换后</span></span><br><span class="line">    <span class="comment">// 的 String 写入文件</span></span><br><span class="line">    sink.write(<span class="string">'Hello, Dart'</span>);</span><br><span class="line">    <span class="keyword">await</span> sink.flush();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    sink?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>读写原始的 bytes 也是相当简单的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">await</span> file.readAsString();</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; content = <span class="keyword">await</span> file.readAsBytes();</span><br></pre></td></tr></table></figure><p>和写文件类似，它还有一个 <code>openRead</code> 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream 是 async 包里的类</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="comment">// utf8、LineSplitter 属于 convert 包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filepath = <span class="string">"path to your file"</span>;</span><br><span class="line">  <span class="keyword">var</span> file = File(filepath);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Stream&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; stream = file.openRead();</span><br><span class="line">    <span class="keyword">var</span> lines = stream</span><br><span class="line">        <span class="comment">// 把内容用 utf-8 解码</span></span><br><span class="line">        .transform(utf8.decoder)</span><br><span class="line">        <span class="comment">// 每次返回一行</span></span><br><span class="line">        .transform(LineSplitter());</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> line <span class="keyword">in</span> lines) &#123;</span><br><span class="line">      <span class="built_in">print</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后需要注意的是，我们读写 bytes 的时候，使用的对象是 <code>List&lt;int&gt;</code>，而一个 <code>int</code> 在 Dart 里面有 64 位。Dart 一开始设计就是用于 Web，这部分的效率也就不那么高了。</p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON 相关的 API 放在了 convert 包里面：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br></pre></td></tr></table></figure><h2 id="把对象转换为-JSON"><a href="#把对象转换为-JSON" class="headerlink" title="把对象转换为 JSON"></a>把对象转换为 JSON</h2><p>假设我们有这样一个对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">  <span class="built_in">String</span> description;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了把他转换为 JSON，我们给他定义一个 <code>toJson</code> 方法（注意，不能改变他的方法签名）：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，我们的方法只有一个语句，这个语句定义了一个 map。</span></span><br><span class="line">  <span class="comment">// 使用这种语法的时候，Dart 会自动把这个 map 当做方法的返回值</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; toJson() =&gt; &#123;</span><br><span class="line">    <span class="string">'x'</span>: x,</span><br><span class="line">    <span class="string">'y'</span>: y,</span><br><span class="line">    <span class="string">'desc'</span>: description</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们调用 <code>json.encode</code> 方法把对象转换为 JSON：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point(<span class="number">2</span>, <span class="number">12</span>, <span class="string">'Some point'</span>);</span><br><span class="line">  <span class="keyword">var</span> pointJson = json.encode(point);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'pointJson = $pointJson'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// List, Map 都是支持的</span></span><br><span class="line">  <span class="keyword">var</span> points = [point, point];</span><br><span class="line">  <span class="keyword">var</span> pointsJson = json.encode(points);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'pointsJson = $pointsJson'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行后打印出：</span></span><br><span class="line"><span class="comment">// pointJson = &#123;"x":2,"y":12,"desc":"Some point"&#125;</span></span><br><span class="line"><span class="comment">// pointsJson = [&#123;"x":2,"y":12,"desc":"Some point"&#125;,&#123;"x":2,"y":12,"desc":"Some point"&#125;]</span></span><br></pre></td></tr></table></figure><h2 id="把-JSON-转换为对象"><a href="#把-JSON-转换为对象" class="headerlink" title="把 JSON 转换为对象"></a>把 JSON 转换为对象</h2><p>首先，我们给 <code>Point</code> 类再加多一个构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; map)</span><br><span class="line">      : x = map[<span class="string">'x'</span>], y = map[<span class="string">'y'</span>], description = map[<span class="string">'desc'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了方便后面演示，也加入一个 toString</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Point&#123;x=$x, y=$y, desc=$description&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解析 JSON 字符串，我们可以用 <code>json.decode</code> 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> obj = json.decode(jsonString);</span><br></pre></td></tr></table></figure><p>返回一个 <code>dynamic</code> 的原因在于，Dart 不知道传进去的 JSON 是什么。如果是一个 JSON 对象，返回值将是一个 <code>Map&lt;String, dynamic&gt;</code>；如果是 JSON 数组，则会返回 <code>List&lt;dynamic&gt;</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point(<span class="number">2</span>, <span class="number">12</span>, <span class="string">'Some point'</span>);</span><br><span class="line">  <span class="keyword">var</span> pointJson = json.encode(point);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'pointJson = $pointJson'</span>);</span><br><span class="line">  <span class="keyword">var</span> points = [point, point];</span><br><span class="line">  <span class="keyword">var</span> pointsJson = json.encode(points);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'pointsJson = $pointsJson'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> decoded = json.decode(pointJson);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'decoded.runtimeType = <span class="subst">$&#123;decoded.runtimeType&#125;</span>'</span>);</span><br><span class="line">  <span class="keyword">var</span> point2 = Point.fromJson(decoded);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'point2 = $point2'</span>);</span><br><span class="line"></span><br><span class="line">  decoded = json.decode(pointsJson);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'decoded.runtimeType = <span class="subst">$&#123;decoded.runtimeType&#125;</span>'</span>);</span><br><span class="line">  <span class="keyword">var</span> points2 = &lt;Point&gt;[];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> map <span class="keyword">in</span> decoded) &#123;</span><br><span class="line">    points2.add(Point.fromJson(map));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'points2 = $points2'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pointJson = &#123;&quot;x&quot;:2,&quot;y&quot;:12,&quot;desc&quot;:&quot;Some point&quot;&#125;</span><br><span class="line">pointsJson = [&#123;&quot;x&quot;:2,&quot;y&quot;:12,&quot;desc&quot;:&quot;Some point&quot;&#125;,&#123;&quot;x&quot;:2,&quot;y&quot;:12,&quot;desc&quot;:&quot;Some point&quot;&#125;]</span><br><span class="line"></span><br><span class="line">decoded.runtimeType = _InternalLinkedHashMap&lt;String, dynamic&gt;</span><br><span class="line">point2 = Point&#123;x=2, y=12, desc=Some point&#125;</span><br><span class="line">decoded.runtimeType = List&lt;dynamic&gt;</span><br><span class="line">points2 = [Point&#123;x=2, y=12, desc=Some point&#125;, Point&#123;x=2, y=12, desc=Some point&#125;]</span><br></pre></td></tr></table></figure><p>需要说明的是，我们把 <code>Map&lt;String, dynamic&gt;</code> 转化为对象时使用时定义了一个构造函数，但这个是任意的，使用静态方法、Dart 工厂方法等都是可行的。之所以限定 <code>toJson</code> 方法的原型，是因为 <code>json.encode</code> 只支持 Map、List、String、int 等内置类型。当它遇到不认识的类型时，如果没有给它设置参数 toEncodable，就会调用对象的 <code>toJson</code> 方法（所以方法的原型不能改变）。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>为了向服务器发送 HTTP 请求，我们可以使用 io 包里面的 <code>HttpClient</code>。但它实在不是那么好用，于是就有人弄出了一个 http 包。为了使用 http 包，需要修改 pubspec.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pubspec.yaml</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  http:</span> <span class="string">^0.11.3+17</span></span><br></pre></td></tr></table></figure><p>http 包的使用非常直接，为了发出一个 GET，可以使用 <code>http.get</code> 方法；对应的，还有 <code>post</code>、<code>put</code> 等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:http/http.dart'</span> <span class="keyword">as</span> http;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getMessage() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> response = <span class="keyword">await</span> http.<span class="keyword">get</span>(<span class="string">'http://www.xxx.com/yyy/zzz'</span>);</span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.body;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'getMessage: $e'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTTP POST 的例子我们在下面实现 echo 客户端的时候再看。</p><h1 id="使用-SQLite-数据库"><a href="#使用-SQLite-数据库" class="headerlink" title="使用 SQLite 数据库"></a>使用 SQLite 数据库</h1><p>包 sqflite 可以让我们使用 SQLite：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  sqflite:</span> <span class="string">any</span></span><br></pre></td></tr></table></figure><p>sqflite 的 API 跟 Android 的那些非常像，下面我们直接用一个例子来演示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:sqflite/sqflite.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnId = <span class="string">'id'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnTitle = <span class="string">'title'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnContent = <span class="string">'content'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> id;</span><br><span class="line">  <span class="built_in">String</span> title;</span><br><span class="line">  <span class="built_in">String</span> content;</span><br><span class="line"></span><br><span class="line">  Todo(<span class="keyword">this</span>.title, <span class="keyword">this</span>.content, [<span class="keyword">this</span>.id]);</span><br><span class="line"></span><br><span class="line">  Todo.fromMap(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; map)</span><br><span class="line">      : id = map[columnId], title = map[columnTitle], content = map[columnContent];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; toMap() =&gt; &#123;</span><br><span class="line">    columnTitle: title,</span><br><span class="line">    columnContent: content,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Todo&#123;id=$id, title=$title, content=$content&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> table = <span class="string">'Todo'</span>;</span><br><span class="line">  <span class="comment">// getDatabasesPath() 的 sqflite 提供的函数</span></span><br><span class="line">  <span class="keyword">var</span> path = <span class="keyword">await</span> getDatabasesPath() + <span class="string">'/demo.db'</span>;</span><br><span class="line">  <span class="comment">// 使用 openDatabase 打开数据库</span></span><br><span class="line">  <span class="keyword">var</span> database = <span class="keyword">await</span> openDatabase(</span><br><span class="line">      path,</span><br><span class="line">      version: <span class="number">1</span>,</span><br><span class="line">      onCreate: (db, version) <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sql =<span class="string">'''</span></span><br><span class="line"><span class="string">            CREATE TABLE $table ('</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;Todo.columnId&#125;</span> INTEGER PRIMARY KEY,'</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;Todo.columnTitle&#125;</span> TEXT,'</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;Todo.columnContent&#125;</span> TEXT'</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">            '''</span>;</span><br><span class="line">        <span class="comment">// execute 方法可以执行任意的 SQL</span></span><br><span class="line">        <span class="keyword">await</span> db.execute(sql);</span><br><span class="line">      &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 为了让每次运行的结果都一样，先把数据清掉</span></span><br><span class="line">  <span class="keyword">await</span> database.delete(table);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> todo1 = Todo(<span class="string">'Flutter'</span>, <span class="string">'Learn Flutter widgets.'</span>);</span><br><span class="line">  <span class="keyword">var</span> todo2 = Todo(<span class="string">'Flutter'</span>, <span class="string">'Learn how to to IO in Flutter.'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入数据</span></span><br><span class="line">  <span class="keyword">await</span> database.insert(table, todo1.toMap());</span><br><span class="line">  <span class="keyword">await</span> database.insert(table, todo2.toMap());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">Map</span>&gt; list = <span class="keyword">await</span> database.query(table);</span><br><span class="line">  <span class="comment">// 重新赋值，这样 todo.id 才不会为 0</span></span><br><span class="line">  todo1 = Todo.fromMap(list[<span class="number">0</span>]);</span><br><span class="line">  todo2 = Todo.fromMap(list[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'query: todo1 = $todo1'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'query: todo2 = $todo2'</span>);</span><br><span class="line"></span><br><span class="line">  todo1.content += <span class="string">' Come on!'</span>;</span><br><span class="line">  todo2.content += <span class="string">' I\'m tired'</span>;</span><br><span class="line">  <span class="comment">// 使用事务</span></span><br><span class="line">  <span class="keyword">await</span> database.transaction((txn) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 注意，这里面只能用 txn。直接使用 database 将导致死锁</span></span><br><span class="line">    <span class="keyword">await</span> txn.update(table, todo1.toMap(),</span><br><span class="line">        <span class="comment">// where 的参数里，我们可以使用 ? 作为占位符，对应的值按顺序放在 whereArgs</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，whereArgs 的参数类型是 List，这里不能写成 todo1.id.toString()。</span></span><br><span class="line">        <span class="comment">// 不然就变成了用 String 和 int 比较，这样一来就匹配不到待更新的那一行了</span></span><br><span class="line">        where: <span class="string">'<span class="subst">$&#123;Todo.columnId&#125;</span> = ?'</span>, whereArgs: [todo1.id]);</span><br><span class="line">    <span class="keyword">await</span> txn.update(table, todo2.toMap(),</span><br><span class="line">        where: <span class="string">'<span class="subst">$&#123;Todo.columnId&#125;</span> = ?'</span>, whereArgs: [todo2.id]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  list = <span class="keyword">await</span> database.query(table);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> map <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="keyword">var</span> todo = Todo.fromMap(map);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'updated: todo = $todo'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后，别忘了关闭数据库</span></span><br><span class="line">  <span class="keyword">await</span> database.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query: todo1 = Todo&#123;id=1, title=Flutter, content=Learn Flutter widgets&#125;</span><br><span class="line">query: todo2 = Todo&#123;id=2, title=Flutter, content=Learn how to to IO in Flutter&#125;</span><br><span class="line">updated: todo = Todo&#123;id=1, title=Flutter, content=Learn Flutter widgets. Come on!&#125;</span><br><span class="line">updated: todo = Todo&#123;id=2, title=Flutter, content=Learn how to to IO in Flutter. I&apos;m tired&#125;</span><br></pre></td></tr></table></figure><p>有 Android 经验的读者会发现，使用 Dart 编写数据库相关代码的时候舒服很多。如果读者对数据库不太熟悉，可以参考《SQL必知必会》。本篇的主要知识点到这里的就讲完了，作为练习，下面我们就一起来实现 echo 客户端的后端。</p><h1 id="echo-客户端"><a href="#echo-客户端" class="headerlink" title="echo 客户端"></a>echo 客户端</h1><h2 id="HTTP-服务端"><a href="#HTTP-服务端" class="headerlink" title="HTTP 服务端"></a>HTTP 服务端</h2><p>在开始之前，你可以在 GitHub 上找到上篇文章的代码，我们将在它的基础上进行开发。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ux-basic</span><br></pre></td></tr></table></figure><h3 id="服务端架构"><a href="#服务端架构" class="headerlink" title="服务端架构"></a>服务端架构</h3><p>首先我们来看看服务端的架构（说是架构，但其实非常的简单，或者说很简陋）：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> port;</span><br><span class="line">  HttpServer httpServer;</span><br><span class="line">  <span class="comment">// 在 Dart 里面，函数也是 first class object，所以我们可以直接把</span></span><br><span class="line">  <span class="comment">// 函数放到 Map 里面</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">void</span> <span class="built_in">Function</span>(HttpRequest)&gt; routes;</span><br><span class="line"></span><br><span class="line">  HttpEchoServer(<span class="keyword">this</span>.port) &#123;</span><br><span class="line">    _initRoutes();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _initRoutes() &#123;</span><br><span class="line">    routes = &#123;</span><br><span class="line">      <span class="comment">// 我们只支持 path 为 '/history' 和 '/echo' 的请求。</span></span><br><span class="line">      <span class="comment">// history 用于获取历史记录；</span></span><br><span class="line">      <span class="comment">// echo 则提供 echo 服务。</span></span><br><span class="line">      <span class="string">'/history'</span>: _history,</span><br><span class="line">      <span class="string">'/echo'</span>: _echo,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个 Future，这样客户端就能够在 start 完成后做一些事</span></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 HttpServer</span></span><br><span class="line">    httpServer = <span class="keyword">await</span> HttpServer.bind(InternetAddress.loopbackIPv4, port);</span><br><span class="line">    <span class="comment">// 2. 开始监听客户请求</span></span><br><span class="line">    <span class="keyword">return</span> httpServer.listen((request) &#123;</span><br><span class="line">      <span class="keyword">final</span> path = request.uri.path;</span><br><span class="line">      <span class="keyword">final</span> handler = routes[path];</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler(request);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 给客户返回一个 404</span></span><br><span class="line">        request.response.statusCode = HttpStatus.notFound;</span><br><span class="line">        request.response.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _history(HttpRequest request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> close() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> server = httpServer;</span><br><span class="line">    httpServer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">await</span> server?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端框架里，我们把支持的所有路径都加到 routes 里面，当收到客户请求的时候，只需要直接从 routes 里取出对应的处理函数，把请求分发给他就可以了。如果读者对服务端编程没有太大兴趣或不太了解，这部分可以不用太关注。</p><h3 id="将对象序列化为-JSON"><a href="#将对象序列化为-JSON" class="headerlink" title="将对象序列化为 JSON"></a>将对象序列化为 JSON</h3><p>为了把 Message 对象序列化为 JSON，这里我们对 Message 做一些小修改：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> timestamp;</span><br><span class="line"></span><br><span class="line">  Message(<span class="keyword">this</span>.msg, <span class="keyword">this</span>.timestamp);</span><br><span class="line">  Message.create(<span class="built_in">String</span> msg)</span><br><span class="line">      : msg = msg, timestamp = <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; toJson() =&gt; &#123;</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">"$msg"</span>,</span><br><span class="line">    <span class="string">"timestamp"</span>: timestamp</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Message&#123;msg: $msg, timestamp: $timestamp&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们加入一个 toJson 方法。下面是服务端的 _echo 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> GET = <span class="string">'GET'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> POST = <span class="string">'POST'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  _unsupportedMethod(HttpRequest request) &#123;</span><br><span class="line">    request.response.statusCode = HttpStatus.methodNotAllowed;</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.method != POST) &#123;</span><br><span class="line">      _unsupportedMethod(request);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取从客户端 POST 请求的 body，更多的知识，参考</span></span><br><span class="line">    <span class="comment">// https://www.dartlang.org/tutorials/dart-vm/httpserver</span></span><br><span class="line">    <span class="built_in">String</span> body = <span class="keyword">await</span> request.transform(utf8.decoder).join();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> message = Message.create(body);</span><br><span class="line">      messages.add(message);</span><br><span class="line">      request.response.statusCode = HttpStatus.ok;</span><br><span class="line">      <span class="comment">// json 是 convert 包里的对象，encode 方法还有第二个参数 toEncodable。当遇到对象不是</span></span><br><span class="line">      <span class="comment">// Dart 的内置对象时，如果提供这个参数，就会调用它对对象进行序列化；这里我们没有提供，</span></span><br><span class="line">      <span class="comment">// 所以 encode 方法会调用对象的 toJson 方法，这个方法在前面我们已经定义了</span></span><br><span class="line">      <span class="keyword">var</span> data = json.encode(message);</span><br><span class="line">      <span class="comment">// 把响应写回给客户端</span></span><br><span class="line">      request.response.write(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      request.response.statusCode = HttpStatus.badRequest;</span><br><span class="line">    &#125;</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h2><p>我们的 echo 服务器使用了 dart:io 包里面 HttpServer 来开发。对应的，我们也可以使用这个包里的 HttpRequest 来执行 HTTP 请求，但这里我们并不打算这么做。第三方库 http 提供了更简单易用的接口。</p><p>首先把依赖添加到 pubspec 里：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pubspec.yaml</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  http:</span> <span class="string">^0.11.3+17</span></span><br></pre></td></tr></table></figure><p>客户端实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:http/http.dart'</span> <span class="keyword">as</span> http;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> port;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> host;</span><br><span class="line"></span><br><span class="line">  HttpEchoClient(<span class="keyword">this</span>.port): host = <span class="string">'http://localhost:$port'</span>;</span><br><span class="line"></span><br><span class="line">  Future&lt;Message&gt; send(<span class="built_in">String</span> msg) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// http.post 用来执行一个 HTTP POST 请求。</span></span><br><span class="line">    <span class="comment">// 它的 body 参数是一个 dynamic，可以支持不同类型的 body，这里我们</span></span><br><span class="line">    <span class="comment">// 只是直接把客户输入的消息发给服务端就可以了。由于 msg 是一个 String，</span></span><br><span class="line">    <span class="comment">// post 方法会自动设置 HTTP 的 Content-Type 为 text/plain</span></span><br><span class="line">    <span class="keyword">final</span> response = <span class="keyword">await</span> http.post(host + <span class="string">'/echo'</span>, body: msg);</span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; msgJson = json.decode(response.body);</span><br><span class="line">      <span class="comment">// Dart 并不知道我们的 Message 长什么样，我们需要自己通过</span></span><br><span class="line">      <span class="comment">// Map&lt;String, dynamic&gt; 来构造对象</span></span><br><span class="line">      <span class="keyword">var</span> message = Message.fromJson(msgJson);</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> timestamp;</span><br><span class="line"></span><br><span class="line">  Message.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; json)</span><br><span class="line">    : msg = json[<span class="string">'msg'</span>], timestamp = json[<span class="string">'timestamp'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们把他们和上一节的 UI 结合到一起。首先启动服务器，然后创建客户端：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HttpEchoServer _server;</span><br><span class="line">HttpEchoClient _client;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> port = <span class="number">6060</span>;</span><br><span class="line">    _server = HttpEchoServer(port);</span><br><span class="line">    <span class="comment">// initState 不是一个 async 函数，这里我们不能直接 await _server.start(),</span></span><br><span class="line">    <span class="comment">// future.then(...) 跟 await 是等价的</span></span><br><span class="line">    _server.start().then((_) &#123;</span><br><span class="line">      <span class="comment">// 等服务器启动后才创建客户端</span></span><br><span class="line">      _client = HttpEchoClient(port);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">          );</span><br><span class="line">          <span class="comment">// 以下是修改了的地方</span></span><br><span class="line">          <span class="keyword">if</span> (_client == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 现在，我们不是直接构造一个 Message，而是通过 _client 把消息</span></span><br><span class="line">          <span class="comment">// 发送给服务器</span></span><br><span class="line">          <span class="keyword">var</span> msg = <span class="keyword">await</span> _client.send(result);</span><br><span class="line">          <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            messageListKey.currentState.addMessage(msg);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            debugPrint(<span class="string">'fail to send $result'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成，在做了这么多工作以后，我们的应用现在是真正的 echo 客户端了，虽然看起来跟之前没什么两样。接下来，我们就做一些跟之前不一样的——把历史记录保存下来。</p><h2 id="历史记录存储、恢复"><a href="#历史记录存储、恢复" class="headerlink" title="历史记录存储、恢复"></a>历史记录存储、恢复</h2><h3 id="获取应用的存储路径"><a href="#获取应用的存储路径" class="headerlink" title="获取应用的存储路径"></a>获取应用的存储路径</h3><p>为了获得应用的文件存储路径，我们引入多一个库：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pubspec.yaml</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  path_provider:</span> <span class="string">^0.4.1</span></span><br></pre></td></tr></table></figure><p>通过它我们可以拿到应用的 file、cache 和 external storage 的路径：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:path_provider/path_provider.dart'</span> <span class="keyword">as</span> path_provider;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> historyFilepath;</span><br><span class="line"></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    historyFilepath = <span class="keyword">await</span> _historyPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; _historyPath() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 获取应用私有的文件目录</span></span><br><span class="line">    <span class="keyword">final</span> directory = <span class="keyword">await</span> path_provider.getApplicationDocumentsDirectory();</span><br><span class="line">    <span class="keyword">return</span> directory.path + <span class="string">'/messages.json'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保存历史记录"><a href="#保存历史记录" class="headerlink" title="保存历史记录"></a>保存历史记录</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原谅我，为了简单，我们就多存几次吧</span></span><br><span class="line">    _storeMessages();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; _storeMessages() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// json.encode 支持 List、Map</span></span><br><span class="line">      <span class="keyword">final</span> data = json.encode(messages);</span><br><span class="line">      <span class="comment">// File 是 dart:io 里的类</span></span><br><span class="line">      <span class="keyword">final</span> file = File(historyFilepath);</span><br><span class="line">      <span class="keyword">final</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">      <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">        <span class="keyword">await</span> file.create();</span><br><span class="line">      &#125;</span><br><span class="line">      file.writeAsString(data);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 虽然文件操作方法都是异步的，我们仍然可以通过这种方式 catch 到</span></span><br><span class="line">    <span class="comment">// 他们抛出的异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'_storeMessages: $e'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载历史记录"><a href="#加载历史记录" class="headerlink" title="加载历史记录"></a>加载历史记录</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    historyFilepath = <span class="keyword">await</span> _historyPath();</span><br><span class="line">    <span class="comment">// 在启动服务器前先加载历史记录</span></span><br><span class="line">    <span class="keyword">await</span> _loadMessages();</span><br><span class="line">    httpServer = <span class="keyword">await</span> HttpServer.bind(InternetAddress.loopbackIPv4, port);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future _loadMessages() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> file = File(historyFilepath);</span><br><span class="line">      <span class="keyword">var</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">      <span class="keyword">if</span> (!exists) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> content = <span class="keyword">await</span> file.readAsString();</span><br><span class="line">      <span class="keyword">var</span> list = json.decode(content);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> msg <span class="keyword">in</span> list) &#123;</span><br><span class="line">        <span class="keyword">var</span> message = Message.fromJson(msg);</span><br><span class="line">        messages.add(message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'_loadMessages: $e'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们来实现 _history 函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _history(HttpRequest request) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.method != GET) &#123;</span><br><span class="line">      _unsupportedMethod(request);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> historyData = json.encode(messages);</span><br><span class="line">    request.response.write(historyData);</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_history 的实现很直接，我们只是把 messages 全都返回给客户端。</p><p>接下来是客户端部分：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;Message&gt;&gt; getHistory() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// http 包的 get 方法用来执行 HTTP GET 请求</span></span><br><span class="line">      <span class="keyword">final</span> response = <span class="keyword">await</span> http.<span class="keyword">get</span>(host + <span class="string">'/history'</span>);</span><br><span class="line">      <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _decodeHistory(response.body);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'getHistory: $e'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;Message&gt; _decodeHistory(<span class="built_in">String</span> response) &#123;</span><br><span class="line">    <span class="comment">// JSON 数组 decode 出来是一个 &lt;Map&lt;String, dynamic&gt;&gt;[]</span></span><br><span class="line">    <span class="keyword">var</span> messages = json.decode(response);</span><br><span class="line">    <span class="keyword">var</span> list = &lt;Message&gt;[];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> msgJson <span class="keyword">in</span> messages) &#123;</span><br><span class="line">      list.add(Message.fromJson(msgJson));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> port = <span class="number">6060</span>;</span><br><span class="line">    _server = HttpEchoServer(port);</span><br><span class="line">    _server.start().then((_) &#123;</span><br><span class="line">      <span class="comment">// 我们等服务器启动后才创建客户端</span></span><br><span class="line">      _client = HttpEchoClient(port);</span><br><span class="line">      <span class="comment">// 创建客户端后马上拉取历史记录</span></span><br><span class="line">      _client.getHistory().then((list) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          messages.addAll(list);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>最后需要做的是，在 APP 退出后关闭服务器。这就要求我们能够收到应用生命周期变化的通知。为了达到这个目的，Flutter 为我们提供了 WidgetsBinding 类（虽然没有 Android 的 Lifecycle 那么好用就是啦）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了使用 WidgetsBinding，我们继承 WidgetsBindingObserver 然后覆盖相应的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    _server.start().then((_) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册生命周期回调</span></span><br><span class="line">      WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == AppLifecycleState.paused) &#123;</span><br><span class="line">      <span class="keyword">var</span> server = _server;</span><br><span class="line">      _server = <span class="keyword">null</span>;</span><br><span class="line">      server?.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们的应用是这个样子的：<br><img src="/2018/09/01/flutter-io-basic/flutter-echo-demo.gif" alt="flutter-echo-demo"></p><p>所有的代码可以在 GitHub 上找到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout io-basic</span><br></pre></td></tr></table></figure><h2 id="使用-SQLite-数据库-1"><a href="#使用-SQLite-数据库-1" class="headerlink" title="使用 SQLite 数据库"></a>使用 SQLite 数据库</h2><p>前面的实现中我们把 echo 服务器的数据存放在了文件里。这一节我们改一改，把数据存到 SQLite 中。</p><p>别忘了添加依赖：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  sqflite:</span> <span class="string">any</span></span><br></pre></td></tr></table></figure><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:sqflite/sqflite.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> tableName = <span class="string">'History'</span>;</span><br><span class="line">  <span class="comment">// 这部分常量最好是放到 Message 的定义里。为了方便阅读，就暂且放这里吧</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnId = <span class="string">'id'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnMsg = <span class="string">'msg'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnTimestamp = <span class="string">'timestamp'</span>;</span><br><span class="line"></span><br><span class="line">  Database database;</span><br><span class="line"></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> _initDatabase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future _initDatabase() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> path = <span class="keyword">await</span> getDatabasesPath() + <span class="string">'/history.db'</span>;</span><br><span class="line">    database = <span class="keyword">await</span> openDatabase(</span><br><span class="line">      path,</span><br><span class="line">      version: <span class="number">1</span>,</span><br><span class="line">      onCreate: (db, version) <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sql = <span class="string">'''</span></span><br><span class="line"><span class="string">            CREATE TABLE $tableName (</span></span><br><span class="line"><span class="string">            $columnId INTEGER PRIMARY KEY,</span></span><br><span class="line"><span class="string">            $columnMsg TEXT,</span></span><br><span class="line"><span class="string">            $columnTimestamp INTEGER</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">            '''</span>;</span><br><span class="line">        <span class="keyword">await</span> db.execute(sql);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载历史记录-1"><a href="#加载历史记录-1" class="headerlink" title="加载历史记录"></a>加载历史记录</h3><p>加载历史记录的相关代码在 <code>_loadMessages</code> 方法中，这里我们修改原有的实现，让它从数据库加载数据：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Future _loadMessages() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">await</span> database.query(</span><br><span class="line">      tableName,</span><br><span class="line">      columns: [columnMsg, columnTimestamp],</span><br><span class="line">      orderBy: columnId,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list) &#123;</span><br><span class="line">      <span class="comment">// fromJson 也适用于使用数据库的场景</span></span><br><span class="line">      <span class="keyword">var</span> message = Message.fromJson(item);</span><br><span class="line">      messages.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上改为使用数据库来存储后，我们并不需要把所有的消息都存放在内存中（也就是这里的 <code>_loadMessage</code>是不必要的）。客户请求历史记录时，我们再按需从数据库读取数据即可。为了避免修改到程序的逻辑，这里还是继续保持一份数据在内存中。有兴趣的读者可以对程序作出相应的修改。</p><h3 id="保存记录"><a href="#保存记录" class="headerlink" title="保存记录"></a>保存记录</h3><p>记录的保存很简单，一行代码就可以搞定了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  _storeMessage(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _storeMessage(Message msg) &#123;</span><br><span class="line">  database.insert(tableName, msg.toJson());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 JSON 的版本，我们每次都需要把所有的数据都保存一遍。对数据库来说，只要把收到的这一条信息存进去即可。读者也应该能够感受到，就我们的需求来说，使用 SQLite 的版本实现起来更简单，也更高效。</p><h3 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h3><p><code>close</code> 方法也要做相应的修改：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> close() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> db = database;</span><br><span class="line">  database = <span class="keyword">null</span>;</span><br><span class="line">  db?.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码可以查看 tag echo-db：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout echo-db</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本篇文章我们先学习 Flutter IO 相关的基础知识，然后在 flutter-ux-basic 一文的基础上，继续开发一个 echo 客户端。由于日常开发中 HTTP 比 socket 更常见，我们的 echo 客户端将会使用 HTTP 协议跟服务端通信。Echo 服务器也会使用 Dart 来实现。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（3）- 交互、动画、手势和事件处理</title>
    <link href="https://jekton.github.io/2018/08/29/flutter-ux-basic/"/>
    <id>https://jekton.github.io/2018/08/29/flutter-ux-basic/</id>
    <published>2018-08-29T01:06:41.000Z</published>
    <updated>2018-09-18T12:17:25.137Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>在这一篇文章中，我们首先介绍手势事件的处理和页面跳转的基础知识，然后通过实现一个 echo 客户端的前端页面来加强学习；最后我们再学习内置的动画 Widget 以及如何自定义动画效果。</p><h1 id="手势处理"><a href="#手势处理" class="headerlink" title="手势处理"></a>手势处理</h1><h2 id="按钮点击"><a href="#按钮点击" class="headerlink" title="按钮点击"></a>按钮点击</h2><p>为了获取按钮的点击事件，只需要设置 <code>onPressed</code> 参数就可以了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      child: Text(<span class="string">'click'</span>),</span><br><span class="line">      onPressed: () =&gt; debugPrint(<span class="string">'clicked'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任意控件的手势事件"><a href="#任意控件的手势事件" class="headerlink" title="任意控件的手势事件"></a>任意控件的手势事件</h2><p>跟 button 不同，大多数的控件没有手势事件监听函数可以设置，为了监听这些控件上的手势事件，我们需要使用另一个控件——<code>GestureDetector</code>（没错，它也是一个控件）：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      child: Text(<span class="string">'text'</span>),</span><br><span class="line">      onTap: () =&gt; debugPrint(<span class="string">'clicked'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面代码使用到的 <code>onTap</code>，<code>GestureDetector</code> 还支持许多其他事件：</p><ul><li>onTapDown：按下</li><li>onTap：点击动作</li><li>onTapUp：抬起</li><li>onTapCancel：前面触发了 onTapDown，但并没有完成一个 onTap 动作</li><li>onDoubleTap：双击</li><li>onLongPress：长按</li><li>onScaleStart, onScaleUpdate, onScaleEnd：缩放</li><li>onVerticalDragDown, onVerticalDragStart, onVerticalDragUpdate, onVerticalDragEnd, onVerticalDragCancel, onVerticalDragUpdate：在竖直方向上移动</li><li>onHorizontalDragDown, onHorizontalDragStart, onHorizontalDragUpdate, onHorizontalDragEnd, onHorizontalDragCancel, onHorizontalDragUpdate：在水平方向上移动</li><li>onPanDown, onPanStart, onPanUpdate, onPanEnd, onPanCancel：拖曳（水平、竖直方向上移动）</li></ul><p>如果同时设置了 onVerticalXXX 和 onHorizontalXXX，在一个手势里，只有一个会触发（如果用户首先在水平方向移动，则整个过程只触发 onHorizontalUpdate；竖直方向的类似）</p><p>这里要说明的是，onVerticalXXX/onHorizontalXXX 和 onPanXXX 不能同时设置。如果同时需要水平、竖直方向的移动，使用 onPanXXX。</p><p>如果读者希望在用户点击的时候能够有个水波纹效果，可以使用 <code>InkWell</code>，它的用法跟 <code>GestureDetector</code> 类似，只是少了拖动相关的手势（毕竟，这个水波纹效果只有在点击的时候才有意义）。</p><h2 id="原始手势事件监听"><a href="#原始手势事件监听" class="headerlink" title="原始手势事件监听"></a>原始手势事件监听</h2><p><code>GestureDetector</code> 在绝大部分时候都能够满足我们的需求，如果真的满足不了，我们还可以使用最原始的 <code>Listener</code> 控件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Listener(</span><br><span class="line">      child: Text(<span class="string">'text'</span>),</span><br><span class="line">      onPointerDown: (event) =&gt; <span class="built_in">print</span>(<span class="string">'onPointerDown'</span>),</span><br><span class="line">      onPointerUp: (event) =&gt; <span class="built_in">print</span>(<span class="string">'onPointerUp'</span>),</span><br><span class="line">      onPointerMove: (event) =&gt; <span class="built_in">print</span>(<span class="string">'onPointerMove'</span>),</span><br><span class="line">      onPointerCancel: (event) =&gt; <span class="built_in">print</span>(<span class="string">'onPointerCancel'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在页面间跳转"><a href="#在页面间跳转" class="headerlink" title="在页面间跳转"></a>在页面间跳转</h1><p>Flutter 里所有的东西都是 <code>widget</code>，所以，一个页面，也是 <code>widget</code>。为了调整到新的页面，我们可以 push 一个 route 到 <code>Navigator</code> 管理的栈中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">  context,</span><br><span class="line">  MaterialPageRoute(builder: (_) =&gt; SecondScreen())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>需要返回的话，pop 掉就可以了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pop(context);</span><br></pre></td></tr></table></figure><p>下面是完整的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter navigation'</span>,</span><br><span class="line">      home: FirstScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _FirstScreenState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FirstScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FirstScreen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Navigation deme'</span>),),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          child: Text(<span class="string">'First screen'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; SecondScreen())</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _SecondScreenState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_SecondScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">SecondScreen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Navigation deme'</span>),),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">            child: Text(<span class="string">'Second screen'</span>),</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              Navigator.pop(context);</span><br><span class="line">            &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了打开一个页面，Flutter 也支持从页面返回数据：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pop(context, <span class="string">'message from second screen'</span>);</span><br></pre></td></tr></table></figure><p>由于打开页面是异步的，页面的结果通过一个 <code>Future</code> 来返回：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// Navigator.push 会返回一个 Future&lt;T&gt;，如果你对这里使用的 await不太熟悉，可以参考</span></span><br><span class="line">  <span class="comment">// https://www.dartlang.org/guides/language/language-tour#asynchrony-support</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    MaterialPageRoute(builder: (_) =&gt; SecondScreen())</span><br><span class="line">  );</span><br><span class="line">  debugPrint(<span class="string">'msg = $msg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以在 <code>MaterialApp</code> 里设置好每个 route 对应的页面，然后使用 <code>Navigator.pushNamed(context, routeName)</code> 来打开它们：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  <span class="comment">// 从名字叫做 '/' 的 route 开始（也就是 home）</span></span><br><span class="line">  initialRoute: <span class="string">'/'</span>,</span><br><span class="line">  routes: &#123;</span><br><span class="line">    <span class="string">'/'</span>: (context) =&gt; HomeScreen(),</span><br><span class="line">    <span class="string">'/about'</span>: (context) =&gt; AboutScreen(),</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来，我们通过实现一个 echo 客户端的前端页面来综合运用前面所学的知识（逻辑部分我们留到下一篇文章再补充）。</p><h1 id="echo-客户端"><a href="#echo-客户端" class="headerlink" title="echo 客户端"></a>echo 客户端</h1><h2 id="消息输入页"><a href="#消息输入页" class="headerlink" title="消息输入页"></a>消息输入页</h2><p>这一节我们来实现一个用户输入的页面。UI 很简单，就是一个文本框和一个按钮。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageForm</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _MessageFormState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageForm</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> editController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象被从 widget 树里永久移除的时候调用 dispose 方法（可以理解为对象要销毁了）</span></span><br><span class="line">  <span class="comment">// 这里我们需要主动再调用 editController.dispose() 以释放资源</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    editController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Padding(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">      child: Row(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// 我们让输入框占满一行里除按钮外的所有空间</span></span><br><span class="line">          Expanded(</span><br><span class="line">            child: Container(</span><br><span class="line">              margin: EdgeInsets.only(right: <span class="number">8.0</span>),</span><br><span class="line">              child: TextField(</span><br><span class="line">                decoration: InputDecoration(</span><br><span class="line">                  hintText: <span class="string">'Input message'</span>,</span><br><span class="line">                  contentPadding: EdgeInsets.all(<span class="number">0.0</span>),</span><br><span class="line">                ),</span><br><span class="line">                style: TextStyle(</span><br><span class="line">                  fontSize: <span class="number">22.0</span>,</span><br><span class="line">                  color: Colors.black54</span><br><span class="line">                ),</span><br><span class="line">                controller: editController,</span><br><span class="line">                <span class="comment">// 自动获取焦点。这样在页面打开时就会自动弹出输入法</span></span><br><span class="line">                autofocus: <span class="keyword">true</span>,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          InkWell(</span><br><span class="line">            onTap: () =&gt; debugPrint(<span class="string">'send: <span class="subst">$&#123;editController.text&#125;</span>'</span>),</span><br><span class="line">            onDoubleTap: () =&gt; debugPrint(<span class="string">'double tapped'</span>),</span><br><span class="line">            onLongPress: () =&gt; debugPrint(<span class="string">'long pressed'</span>),</span><br><span class="line">            child: Container(</span><br><span class="line">              padding: EdgeInsets.symmetric(vertical: <span class="number">10.0</span>, horizontal: <span class="number">16.0</span>),</span><br><span class="line">              decoration: BoxDecoration(</span><br><span class="line">                color: Colors.black12,</span><br><span class="line">                borderRadius: BorderRadius.circular(<span class="number">5.0</span>)</span><br><span class="line">              ),</span><br><span class="line">              child: Text(<span class="string">'Send'</span>),</span><br><span class="line">            ),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UX demo'</span>,</span><br><span class="line">      home: AddMessageScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMessageScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Add message'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: MessageForm(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的按钮本应该使用 <code>RaisedButton</code> 或 <code>FlatButton</code>。为了演示如何监听手势事件，我们这里故意自己用 <code>Container</code> 做了一个按钮，然后通过 <code>InkWell</code> 监听手势事件。<code>InkWell</code> 除了上面展示的几个事件外，还带有一个水波纹效果。如果不需要这个水波纹效果，读者也可以使用 <code>GestureDetector</code>。</p><h2 id="消息列表页面"><a href="#消息列表页面" class="headerlink" title="消息列表页面"></a>消息列表页面</h2><p>我们的 echo 客户端共有两个页面，一个用于展示所有的消息，另一个页面用户输入消息，后者在上一小节我们已经写好了。下面，我们来实现用于展示消息的页面。</p><h3 id="页面间跳转"><a href="#页面间跳转" class="headerlink" title="页面间跳转"></a>页面间跳转</h3><p>我们的页面包含一个列表和一个按钮，列表用于展示信息，按钮则用来打开上一节我们所实现的 <code>AddMessageScreen</code>。这里我们先添加一个按钮并实现页面间的跳转。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是我们的消息展示页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Echo client'</span>),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="comment">// push 一个新的 route 到 Navigator 管理的栈中，以此来打开一个页面</span></span><br><span class="line">          Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: <span class="string">'Add message'</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消息的输入页面，我们点击 Send 按钮后就返回：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onTap: () &#123;</span><br><span class="line">  debugPrint(<span class="string">'send: <span class="subst">$&#123;editController.text&#125;</span>'</span>);</span><br><span class="line">  Navigator.pop(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们加入一些骨架代码，实现一个完整的应用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UX demo'</span>,</span><br><span class="line">      home: MessageListScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，上面代码所提供的功能还不够，我们需要从 <code>AddMessageScreen</code> 中返回一个消息。</p><p>首先我们对数据建模：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> timestamp;</span><br><span class="line"></span><br><span class="line">  Message(<span class="keyword">this</span>.msg, <span class="keyword">this</span>.timestamp);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Message&#123;msg: $msg, timestamp: $timestamp&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是返回数据和接收数据的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">onTap: () &#123;</span><br><span class="line">  debugPrint(<span class="string">'send: <span class="subst">$&#123;editController.text&#125;</span>'</span>);</span><br><span class="line">  <span class="keyword">final</span> msg = Message(</span><br><span class="line">    editController.text,</span><br><span class="line">    <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch</span><br><span class="line">  );</span><br><span class="line">  Navigator.pop(context, msg);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">floatingActionButton: FloatingActionButton(</span><br><span class="line">  onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">        context,</span><br><span class="line">        MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">    );</span><br><span class="line">    debugPrint(<span class="string">'result = $result'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="把数据展示到-ListView"><a href="#把数据展示到-ListView" class="headerlink" title="把数据展示到 ListView"></a>把数据展示到 ListView</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageList</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先忽略这里的参数 key，后面我们就会看到他的作用了</span></span><br><span class="line">  MessageList(&#123;Key key&#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _MessageListState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemCount: messages.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">final</span> msg = messages[index];</span><br><span class="line">        <span class="keyword">final</span> subtitle = <span class="built_in">DateTime</span>.fromMillisecondsSinceEpoch(msg.timestamp)</span><br><span class="line">            .toLocal().toIso8601String();</span><br><span class="line">        <span class="keyword">return</span> ListTile(</span><br><span class="line">          title: Text(msg.msg),</span><br><span class="line">          subtitle: Text(subtitle),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> addMessage(Message msg) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      messages.add(msg);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里唯一的新知识就是给 <code>MessageList</code> 的 <code>key</code> 参数，我们下面先看看如何使用他，然后再说明它的作用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> messageListKey = GlobalKey&lt;_MessageListState&gt;(debugLabel: <span class="string">'messageListKey'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Echo client'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: MessageList(key: messageListKey),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">          );</span><br><span class="line">          debugPrint(<span class="string">'result = $result'</span>);</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">is</span> Message) &#123;</span><br><span class="line">            messageListKey.currentState.addMessage(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: <span class="string">'Add message'</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入一个 <code>GlobalKey</code> 的原因在于，<code>MessageListScreen</code> 需要把从 <code>AddMessageScreen</code> 返回的数据放到 <code>_MessageListState</code> 中，而我们无法从 <code>MessageList</code> 拿到这个 state。</p><p><code>GlobalKey</code> 的是应用全局唯一的 key，把这个 key 设置给 <code>MessageList</code> 后，我们就能够通过这个 key 拿到对应的 <code>statefulWidget</code> 的 <code>state</code>。</p><p>现在，整体的效果是这个样子的：<br><img src="/2018/08/29/flutter-ux-basic/message-list.gif" alt="message-list"></p><p>如果你遇到了麻烦，在 Github 上找到所有的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ux-basic</span><br></pre></td></tr></table></figure><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>Flutter 动画的核心是 <code>Animation&lt;T&gt;</code>，<code>Animation</code> 接受一个时钟信号（<code>vsync</code>），转换为 <code>T</code> 值输出。它控制着动画的进度和状态，但不参与图像的绘制。最基本的 <code>Animation</code> 是 <code>AnimationController</code>，它输出 [0, 1] 之间的值。</p><h2 id="使用内置的-Widget-完成动画"><a href="#使用内置的-Widget-完成动画" class="headerlink" title="使用内置的 Widget 完成动画"></a>使用内置的 Widget 完成动画</h2><p>为了使用动画，我们可以用 Flutter 提供的 <code>AnimatedContainer</code>、<code>FadeTransition</code>、<code>ScaleTransition</code> 和 <code>RotationTransition</code> 等 Widget 来完成。</p><p>下面我们就来演示如何使用 <code>ScaleTransition</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'animation'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(<span class="string">'animation'</span>),),</span><br><span class="line">        body: AnimWidget(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画是有状态的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnimWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> controller;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    controller = AnimationController(</span><br><span class="line">      <span class="comment">// 动画的时长</span></span><br><span class="line">      duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">5000</span>),</span><br><span class="line">      <span class="comment">// 提供 vsync 最简单的方式，就是直接继承 SingleTickerProviderStateMixin</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 调用 forward 方法开始动画</span></span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ScaleTransition(</span><br><span class="line">      child: FlutterLogo(size: <span class="number">200.0</span>),</span><br><span class="line">      scale: controller,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnimationController</code> 的输出是线性的。非线性的效果可以使用 <code>CurveAnimation</code> 来实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  AnimationController controller;</span><br><span class="line">  CurvedAnimation curve;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    controller = AnimationController(</span><br><span class="line">      <span class="comment">// 动画的时长</span></span><br><span class="line">      duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">5000</span>),</span><br><span class="line">      <span class="comment">// 提供 vsync 最简单的方式，就是直接继承 SingleTickerProviderStateMixin</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line">    curve = CurvedAnimation(</span><br><span class="line">      parent: controller,</span><br><span class="line">      <span class="comment">// 更多的效果，参考 https://docs.flutter.io/flutter/animation/Curves-class.html</span></span><br><span class="line">      curve: Curves.easeInOut,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 调用 forward 方法开始动画</span></span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ScaleTransition(</span><br><span class="line">      child: FlutterLogo(size: <span class="number">200.0</span>),</span><br><span class="line">      <span class="comment">// 注意，这里我们把原先的 controller 改为了 curve</span></span><br><span class="line">      scale: curve,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们还可以组合不同的动画：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> scaled = ScaleTransition(</span><br><span class="line">      child: FlutterLogo(size: <span class="number">200.0</span>),</span><br><span class="line">      scale: curve,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> FadeTransition(</span><br><span class="line">      child: scaled,</span><br><span class="line">      opacity: curve,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的动画控件，读者可以参考 <a href="https://flutter.io/widgets/animation/" target="_blank" rel="noopener">https://flutter.io/widgets/animation/</a>。</p><h2 id="自定义动画效果"><a href="#自定义动画效果" class="headerlink" title="自定义动画效果"></a>自定义动画效果</h2><p>上一节我们使用 Flutter 内置的 <code>Widget</code> 来实现动画。他们虽然能够完成日常开发的大部分需求，但总有一些时候不太适用。这时我们就得自己实现动画效果了。</p><p>前面我们说，<code>AnimationController</code> 的输出在 [0, 1] 之间，这往往对我们需要实现的动画效果不太方便。为了将数值从 [0, 1] 映射到目标空间，可以使用 <code>Tween</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">animationValue = Tween(begin: <span class="number">0.0</span>, end: <span class="number">200.0</span>).animate(controller)</span><br><span class="line">    <span class="comment">// 每一帧都会触发 listener 回调</span></span><br><span class="line">    ..addListener(() &#123;</span><br><span class="line">      <span class="comment">// animationValue.value 随着动画的进行不断地变化。我们利用这个值来实现</span></span><br><span class="line">      <span class="comment">// 动画效果</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'value = <span class="subst">$&#123;animationValue.value&#125;</span>'</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>下面我们来画一个小圆点，让它往复不断地在正弦曲线上运动。</p><p><img src="/2018/08/29/flutter-ux-basic/sin-curve.gif" alt=""></p><p>先来实现小圆点沿着曲线运动的效果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span> <span class="keyword">as</span> math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/animation.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimationDemoView</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnimationState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoView</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> padding = <span class="number">16.0</span>;</span><br><span class="line"></span><br><span class="line">  AnimationController controller;</span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; left;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 只有在 initState 执行完，我们才能通过 MediaQuery.of(context) 获取</span></span><br><span class="line">    <span class="comment">// mediaQueryData。这里通过创建一个 Future 从而在 Dart 事件队列里插入</span></span><br><span class="line">    <span class="comment">// 一个事件，以达到延后执行的目的（类似于在 Android 里 post 一个 Runnable）</span></span><br><span class="line">    <span class="comment">// 关于 Dart 的事件队列，读者可以参考 https://webdev.dartlang.org/articles/performance/event-loop</span></span><br><span class="line">    Future(_initState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _initState() &#123;</span><br><span class="line">    controller = AnimationController(</span><br><span class="line">        duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>),</span><br><span class="line">        <span class="comment">// 注意类定义的 with SingleTickerProviderStateMixin，提供 vsync 最简单的方法</span></span><br><span class="line">        <span class="comment">// 就是继承一个 SingleTickerProviderStateMixin。这里的 vsync 跟 Android 里</span></span><br><span class="line">        <span class="comment">// 的 vsync 类似，用来提供时针滴答，触发动画的更新。</span></span><br><span class="line">        vsync: <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们通过 MediaQuery 获取屏幕宽度</span></span><br><span class="line">    <span class="keyword">final</span> mediaQueryData = MediaQuery.of(context);</span><br><span class="line">    <span class="keyword">final</span> displayWidth = mediaQueryData.size.width;</span><br><span class="line">    debugPrint(<span class="string">'width = $displayWidth'</span>);</span><br><span class="line">    left = Tween(begin: padding, end: displayWidth - padding).animate(controller)</span><br><span class="line">      ..addListener(() &#123;</span><br><span class="line">        <span class="comment">// 调用 setState 触发他重新 build 一个 Widget。在 build 方法里，我们根据</span></span><br><span class="line">        <span class="comment">// Animatable&lt;T&gt; 的当前值来创建 Widget，达到动画的效果（类似 Android 的属性动画）。</span></span><br><span class="line">        setState(() &#123;</span><br><span class="line">          <span class="comment">// have nothing to do</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 监听动画状态变化</span></span><br><span class="line">      ..addStatusListener((status) &#123;</span><br><span class="line">        <span class="comment">// 这里我们让动画往复不断执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次动画完成</span></span><br><span class="line">        <span class="keyword">if</span> (status == AnimationStatus.completed) &#123;</span><br><span class="line">          <span class="comment">// 我们让动画反正执行一遍</span></span><br><span class="line">          controller.reverse();</span><br><span class="line">        <span class="comment">// 反着执行的动画结束</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AnimationStatus.dismissed) &#123;</span><br><span class="line">          <span class="comment">// 正着重新开始</span></span><br><span class="line">          controller.forward();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 假定一个单位是 24</span></span><br><span class="line">    <span class="keyword">final</span> unit = <span class="number">24.0</span>;</span><br><span class="line">    <span class="keyword">final</span> marginLeft = left == <span class="keyword">null</span> ? padding : left.value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 marginLeft 单位化</span></span><br><span class="line">    <span class="keyword">final</span> unitizedLeft = (marginLeft - padding) / unit;</span><br><span class="line">    <span class="keyword">final</span> unitizedTop = math.sin(unitizedLeft);</span><br><span class="line">    <span class="comment">// unitizedTop + 1 是了把 [-1, 1] 之间的值映射到 [0, 2]</span></span><br><span class="line">    <span class="comment">// (unitizedTop+1) * unit 后把单位化的值转回来</span></span><br><span class="line">    <span class="keyword">final</span> marginTop = (unitizedTop + <span class="number">1</span>) * unit + padding;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// 我们根据动画的进度设置圆点的位置</span></span><br><span class="line">      margin: EdgeInsets.only(left: marginLeft, top: marginTop),</span><br><span class="line">      <span class="comment">// 画一个小红点</span></span><br><span class="line">      child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            color: Colors.red, borderRadius: BorderRadius.circular(<span class="number">7.5</span>)),</span><br><span class="line">        width: <span class="number">15.0</span>,</span><br><span class="line">        height: <span class="number">15.0</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    controller.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter animation demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(<span class="string">'Animation demo'</span>)),</span><br><span class="line">        body: AnimationDemoView(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的动画中，我们只是对位置做出了改变，下面我们将在位置变化的同时，也让小圆点从红到蓝进行颜色的变化。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoView</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Animation&lt;Color&gt; color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _initState() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    color = ColorTween(begin: Colors.red, end: Colors.blue).animate(controller);</span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> color = <span class="keyword">this</span>.color == <span class="keyword">null</span> ? Colors.red : <span class="keyword">this</span>.color.value;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// 我们根据动画的进度设置圆点的位置</span></span><br><span class="line">      margin: EdgeInsets.only(left: marginLeft, top: marginTop),</span><br><span class="line">      <span class="comment">// 画一个小圆点</span></span><br><span class="line">      child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            color: color, borderRadius: BorderRadius.circular(<span class="number">7.5</span>)),</span><br><span class="line">        width: <span class="number">15.0</span>,</span><br><span class="line">        height: <span class="number">15.0</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 GitHub 上，可以找到所有的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout sin-curve</span><br></pre></td></tr></table></figure><p>在这个例子中，我们还可以加多一些效果，比方说让小圆点在运动的过程中大小也不断变化、使用 <code>CurveAnimation</code> 改变它运动的速度，这些就留给读者作为练习吧。</p>]]></content>
    
    <summary type="html">
    
      在这一篇文章中，我们首先介绍手势事件的处理和页面跳转的基础知识，然后通过实现一个 echo 客户端的前端页面来加强学习；最后我们再学习内置的动画 Widget 以及如何自定义动画效果。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（2）- UI控件和布局</title>
    <link href="https://jekton.github.io/2018/08/26/flutter-ui-basic/"/>
    <id>https://jekton.github.io/2018/08/26/flutter-ui-basic/</id>
    <published>2018-08-26T07:33:41.000Z</published>
    <updated>2018-09-18T12:17:18.177Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>本篇文章我们先介绍 Flutter 里一些常用的 UI 控件，然后借助官网提供的两个 demo 把所学的控件知识实际使用起来。</p><h1 id="基本控件"><a href="#基本控件" class="headerlink" title="基本控件"></a>基本控件</h1><h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>在 Flutter 里，UI 控件就是所谓的 Widget。通过组合不同的 Widget，来实现我们用户交互界面。</p><p>Widget 分为两种，一种是无状态的，叫 <code>StatelessWidget</code>，它只能用来展示信息，不能有动作（用户交互）；另一种是有状态的，叫 <code>StatefulWidget</code>，这种 Widget 可以通过改变状态使得 UI 发生变化，它可以包含用户交互。</p><p><code>StatelessWidget</code> 的使用非常简单，我们只需要继承 <code>StatelessWidget</code>，然后实现 <code>build</code> 方法就可以了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>build</code> 方法的实现，在后面我们学习具体的控件时读者就会了解的，这里暂时忽略掉。</p><p><code>StatefulWidget</code> 用起来麻烦一些，他还需要一个 <code>State</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _BarWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BarWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BarWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看起来可能有些绕，<code>BarWidget</code> 依赖了 <code>_BarWidgetState</code>，而 <code>_BarWidgetState</code> 又继承了 <code>State&lt;BarWidget&gt;</code>。如果读者不太理解，其实也没有什么关系，这只是一个样板代码，照着写就行了。</p><p>从 <code>BarWidget</code> 的实现来看，好像跟前面使用 <code>StatelessWidget</code> 没有什么区别，都是在 <code>build</code> 方法里面返回一个 <code>Widget</code>，只是 stateful widget 把这个方法挪到了 <code>State</code> 里面。实际上，两者的区别非常大。stateless widget 整个生命周期里都不会改变，所以 <code>build</code> 方法只会执行一次。而 stateful widget 只要状态改变，就会调用 <code>build</code> 方法重新创建 UI。</p><p>为了触发 UI 的重建，我们可以调用 <code>setState</code> 方法。下面的代码读者留意一下即可，在后面我们学习了相关的控件后再回过头来看。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _BarWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BarWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BarWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'i = $i'</span>),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            setState(() &#123;</span><br><span class="line">              ++i;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">          child: Text(<span class="string">'click'</span>),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们开始学习一些具体的控件。</p><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>为了展示文本，我们使用 <code>Text</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">"Put your text here"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是最简单的文本了，它使用的是默认的样式。很多情况下，我们都需要对文本的样式进行修改，这个时候，可以使用 <code>TextStyle</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(</span><br><span class="line">      <span class="string">"Put your text here"</span>,</span><br><span class="line">      style: TextStyle(</span><br><span class="line">        color: Colors.blue,</span><br><span class="line">        fontSize: <span class="number">16.0</span>,</span><br><span class="line">        fontWeight: FontWeight.bold</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用 <code>Image</code>，可以让我们向用户展示一张图片。图片的来源可以是网络、文件、资源和内存，它们对应的构造函数分别是：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Image.asset(name);</span><br><span class="line">Image.file(file);</span><br><span class="line">Image.memory(bytes);</span><br><span class="line">Image.network(src);</span><br></pre></td></tr></table></figure><p>比方说，为了展示一张来自网络的图片，我们可以这样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Image.network(</span><br><span class="line">      <span class="string">"http://www.example.com/xxx.png"</span>,</span><br><span class="line">      width: <span class="number">200.0</span>,</span><br><span class="line">      height: <span class="number">150.0</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><p>Flutter 提供了两个基本的按钮控件：<code>FlatButton</code> 和 <code>RaisedButton</code>，它们的使用方法是类似的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> flatBtn = FlatButton(</span><br><span class="line">      onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'FlatButton pressed'</span>),</span><br><span class="line">      child: Text(<span class="string">'BUTTON'</span>),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> raisedButton = RaisedButton(</span><br><span class="line">      onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'RaisedButton pressed'</span>),</span><br><span class="line">      child: Text(<span class="string">'BUTTON'</span>),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> raisedButton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过设置 <code>onPressed</code> 回调，我们可以在按钮被点击的时候得到回调。<code>child</code> 参数用于设置按钮的内容。虽然我们给 <code>child</code> 传递的是 <code>Text</code>，但这不是必需的，它可以接受任意的 <code>Widget</code>，比方说，<code>Image</code>。</p><p>注意，由于我们只是在按钮点击的时候打印一个字符串，这里使用 <code>StatelessWidget</code> 是没有问题的。但如果有其他 UI 动作（比如弹出一个 dialog，则必须使用 <code>StatefulWidget</code>）。</p><p>它们的区别只是样式不同而已的：</p><p><code>FlatButton</code>：<br><img src="/2018/08/26/flutter-ui-basic/flat-button.png" alt=""></p><p><code>RaiseButton</code>：<br><img src="/2018/08/26/flutter-ui-basic/raised-button.png" alt=""></p><h2 id="文本输入框"><a href="#文本输入框" class="headerlink" title="文本输入框"></a>文本输入框</h2><p>Flutter 的文本输入框叫 <code>TextField</code>。为了获取用户输入的文本，我们需要给他设置一个 controller。通过这个 controller，就可以拿到文本框里的内容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageForm</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _MessageFormState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageForm</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> editController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// Row、Expand 都是用于布局的控件，这里可以先忽略它们</span></span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Expanded(</span><br><span class="line">          child: TextField(</span><br><span class="line">            controller: editController,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">"click"</span>),</span><br><span class="line">          onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'text inputted: <span class="subst">$&#123;editController.text&#125;</span>'</span>),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    <span class="comment">// 手动调用 controller 的 dispose 方法以释放资源</span></span><br><span class="line">    editController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示弹框"><a href="#显示弹框" class="headerlink" title="显示弹框"></a>显示弹框</h2><p>在前面的 <code>TextField</code> 例子中，我们只是把用户的输入通过 <code>print</code> 打印出来，这未免也太无趣了。在这一小节，我们要把它显示在 dialog 里。为了弹出一个 dialog，我们需要调用 <code>showDialog</code> 方法并传递一个 builder：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageForm</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> editController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Expanded(</span><br><span class="line">          child: TextField(</span><br><span class="line">            controller: editController,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">"click"</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            showDialog(</span><br><span class="line">                <span class="comment">// 第一个 context 是参数名，第二个 context 是 State 的成员变量</span></span><br><span class="line">                context: context,</span><br><span class="line">                builder: (_) &#123;</span><br><span class="line">                  <span class="keyword">return</span> AlertDialog(</span><br><span class="line">                    <span class="comment">// dialog 的内容</span></span><br><span class="line">                    content: Text(editController.text),</span><br><span class="line">                    <span class="comment">// actions 设置 dialog 的按钮</span></span><br><span class="line">                    actions: &lt;Widget&gt;[</span><br><span class="line">                      FlatButton(</span><br><span class="line">                        child: Text(<span class="string">'OK'</span>),</span><br><span class="line">                        <span class="comment">// 用户点击按钮后，关闭弹框</span></span><br><span class="line">                        onPressed: () =&gt; Navigator.pop(context),</span><br><span class="line">                      )</span><br><span class="line">                    ],</span><br><span class="line">                  );</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    editController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最简单的布局——Container、Padding-和-Center："><a href="#最简单的布局——Container、Padding-和-Center：" class="headerlink" title="最简单的布局——Container、Padding 和 Center："></a>最简单的布局——Container、Padding 和 Center：</h2><p>我们经常说，Flutter 里面所有的东西都是 Widget，所以，布局也是 Widget。</p><p>控件 <code>Container</code> 可以让我们设置一个控件的尺寸、背景、margin 等：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Text(<span class="string">'text'</span>),</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      margin: EdgeInsets.all(<span class="number">4.0</span>),</span><br><span class="line">      width: <span class="number">80.0</span>,</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        <span class="comment">// 背景色</span></span><br><span class="line">        color: Colors.grey,</span><br><span class="line">        <span class="comment">// 圆角</span></span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">5.0</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们只需要 padding，可以使用控件 <code>Padding</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Padding(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      child: Text(<span class="string">'text'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Center</code> 就跟它的名字一样，把一个控件放在中间：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      margin: EdgeInsets.all(<span class="number">4.0</span>),</span><br><span class="line">      width: <span class="number">200.0</span>,</span><br><span class="line">      height: <span class="number">200.0</span>,</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        <span class="comment">// 背景色</span></span><br><span class="line">        color: Colors.grey,</span><br><span class="line">        <span class="comment">// 圆角</span></span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">5.0</span>),</span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把文本放在 Container 的中间</span></span><br><span class="line">      child: Center(</span><br><span class="line">        child: Text(<span class="string">'text'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水平、竖直布局和-Expand"><a href="#水平、竖直布局和-Expand" class="headerlink" title="水平、竖直布局和 Expand"></a>水平、竖直布局和 Expand</h2><p>我们经常说，Flutter 里面所有的东西都是 <code>Widget</code>，所以，布局也是 <code>Widget</code>。水平布局我们可以使用 <code>Row</code>，竖直布局使用 <code>Column</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      <span class="comment">// 只有一个子元素的 widget，一般使用 child 参数来设置；Row 可以包含多个子控件，</span></span><br><span class="line">      <span class="comment">// 对应的则是 children。</span></span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'text1'</span>),</span><br><span class="line">        Text(<span class="string">'text2'</span>),</span><br><span class="line">        Text(<span class="string">'text3'</span>),</span><br><span class="line">        Text(<span class="string">'text4'</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Column</code> 的使用是一样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'text1'</span>),</span><br><span class="line">        Text(<span class="string">'text2'</span>),</span><br><span class="line">        Text(<span class="string">'text3'</span>),</span><br><span class="line">        Text(<span class="string">'text4'</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>Expand</code> 控件，我们来看看 <code>TextField</code> 的那个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageForm</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _MessageFormState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageForm</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> editController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        <span class="comment">// 占满一行里除 RaisedButton 外的所有空间</span></span><br><span class="line">        Expanded(</span><br><span class="line">          child: TextField(</span><br><span class="line">            controller: editController,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">"click"</span>),</span><br><span class="line">          onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'text inputted: <span class="subst">$&#123;editController.text&#125;</span>'</span>),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    editController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过使用 <code>Expand</code>，<code>TextField</code> 才能够占满一行里除按钮外的所有空间。此外，当一行/列里有多个 <code>Expand</code> 时，我们还可以通过设置它的 <code>flex</code> 参数，在多个 <code>Expand</code> 之间按比例划分可用空间。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Expanded(</span><br><span class="line">          <span class="comment">// 占一行的 2/3</span></span><br><span class="line">          flex: <span class="number">2</span>,</span><br><span class="line">          child: RaisedButton(child: Text(<span class="string">'btn1'</span>),),</span><br><span class="line">        ),</span><br><span class="line">        Expanded(</span><br><span class="line">          <span class="comment">// 占一行的 1/3</span></span><br><span class="line">          flex: <span class="number">1</span>,</span><br><span class="line">          child: RaisedButton(child: Text(<span class="string">'btn2'</span>),),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stack-布局"><a href="#Stack-布局" class="headerlink" title="Stack 布局"></a>Stack 布局</h2><p>有些时候，我们可能会希望一个控件叠在另一个控件的上面。于是，<code>Stack</code> 应运而生：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'foobar'</span>),</span><br><span class="line">        Text(<span class="string">'barfoo'</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，子控件都按 <code>Stack</code> 的左上角对齐，于是，上面的两个文本完全一上一下堆叠在一起。我们还可以通过设置 <code>alignment</code> 参数来改变这个对齐的位置：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      <span class="comment">// Aligment 的取值范围为 [-1, 1]，Stack 中心为 (0, 0)，</span></span><br><span class="line">      <span class="comment">// 这里设置为 (-0.5, -0.5) 后，可以让文本对齐到 Container 的 1/4 处</span></span><br><span class="line">      alignment: <span class="keyword">const</span> Alignment(<span class="number">-0.5</span>, <span class="number">-0.5</span>),</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(</span><br><span class="line">          width: <span class="number">200.0</span>,</span><br><span class="line">          height: <span class="number">200.0</span>,</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        Text(<span class="string">'foobar'</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/26/flutter-ui-basic/screenshot-stack.png" alt="screenshot-stack"></p><p>通过组合 Row/Column 和 Stack，已经能够完成绝大部分的布局了，所以 Flutter 里没有相对布局之类的东西。更多的 Flutter 控件，读者可以参考 <a href="https://flutter.io/widgets/" target="_blank" rel="noopener">https://flutter.io/widgets/</a>。</p><h1 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h1><p>在这一节里，我们综合前面所学的知识，来实现下面这个界面。</p><p><img src="/2018/08/26/flutter-ui-basic/lakes-diagram.png" alt="lakes-diagram"></p><h2 id="展示图片"><a href="#展示图片" class="headerlink" title="展示图片"></a>展示图片</h2><ol><li><p>把图片 <a href="lake.png">lake</a> 放到项目根目录的 <code>images</code> 文件夹下（如果没有，你需要自己创建一个）</p></li><li><p>修改 <code>pubspec.yaml</code>，找到下面这个地方，然后把图片加进来</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line"></span><br><span class="line">  # The following line ensures that the Material Icons font is</span><br><span class="line">  # included with your application, so that you can use the icons in</span><br><span class="line">  # the material Icons class.</span><br><span class="line">  uses-material-design: true</span><br><span class="line"></span><br><span class="line">  # To add assets to your application, add an assets section, like this:</span><br><span class="line">  # assets:</span><br><span class="line">  #  - images/a_dot_burr.jpeg</span><br><span class="line">  #  - images/a_dot_ham.jpeg</span><br></pre></td></tr></table></figure><p> 修改后如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line"></span><br><span class="line">  # The following line ensures that the Material Icons font is</span><br><span class="line">  # included with your application, so that you can use the icons in</span><br><span class="line">  # the material Icons class.</span><br><span class="line">  uses-material-design: true</span><br><span class="line"></span><br><span class="line">  # To add assets to your application, add an assets section, like this:</span><br><span class="line">  assets:</span><br><span class="line">    - images/lake.jpg</span><br></pre></td></tr></table></figure></li><li><p>现在，我们可以把这张图片展示出来了：</p> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UI basic 1'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Top Lakes'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Image.asset(</span><br><span class="line">          <span class="string">'images/lake.jpg'</span>,</span><br><span class="line">          width: <span class="number">600.0</span>,</span><br><span class="line">          height: <span class="number">240.0</span>,</span><br><span class="line">          <span class="comment">// cover 类似于 Android 开发中的 centerCrop，其他一些类型，读者可以查看</span></span><br><span class="line">          <span class="comment">// https://docs.flutter.io/flutter/painting/BoxFit-class.html</span></span><br><span class="line">          fit: BoxFit.cover,</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果读者是初学 Flutter，<strong>强烈建议</strong>在遇到不熟悉的 API 时翻一翻文档，并在文档中找到 demo 所使用的 API。我们的例子不可能覆盖所有的 API，通过这种方式熟悉文档后，读者就可以根据文档实现出自己想要的效果。不妨就从 <code>Image</code> 开始吧，在 <a href="https://docs.flutter.io/flutter/widgets/Image/Image.asset.html" target="_blank" rel="noopener">https://docs.flutter.io/flutter/widgets/Image/Image.asset.html</a> 找出上面我们使用的 <code>Image.asset</code> 构造函数的几个参数的含义，还有 <code>BoxFit</code> 的其他几个枚举值。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>在这一小节，我们来实现图片下方的标题区域。</p><p><img src="/2018/08/26/flutter-ui-basic/title-section-diagram.png" alt=""></p><p>我们直接来看代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TitleSection</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> subtitle;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> starCount;</span><br><span class="line"></span><br><span class="line">  _TitleSection(<span class="keyword">this</span>.title, <span class="keyword">this</span>.subtitle, <span class="keyword">this</span>.starCount);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 为了给 title section 加上 padding，这里我们给内容套一个 Container</span></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// 设置上下左右的 padding 都是 32。类似的还有 EdgeInsets.only/symmetric 等</span></span><br><span class="line">      padding: EdgeInsets.all(<span class="number">32.0</span>),</span><br><span class="line">      child: Row(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// 这里为了让标题占满屏幕宽度的剩余空间，用 Expanded 把标题包了起来</span></span><br><span class="line">          Expanded(</span><br><span class="line">            <span class="comment">// 再次提醒读者，Expanded 只能包含一个子元素，使用的参数名是 child。接下来，</span></span><br><span class="line">            <span class="comment">// 为了在竖直方向放两个标题，加入一个 Column。</span></span><br><span class="line">            child: Column(</span><br><span class="line">              <span class="comment">// Column 是竖直方向的，cross 为交叉的意思，也就是说，这里设置的是水平方向</span></span><br><span class="line">              <span class="comment">// 的对齐。在水平方向，我们让文本对齐到 start（读者可以修改为 end 看看效果）</span></span><br><span class="line">              crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                <span class="comment">// 聪明的你，这个时候肯定知道为什么突然加入一个 Container 了。</span></span><br><span class="line">                <span class="comment">// 跟前面一样，只是为了设置一个 padding</span></span><br><span class="line">                Container(</span><br><span class="line">                  padding: <span class="keyword">const</span> EdgeInsets.only(bottom: <span class="number">8.0</span>),</span><br><span class="line">                  child: Text(</span><br><span class="line">                    title,</span><br><span class="line">                    style: TextStyle(fontWeight: FontWeight.bold),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">                Text(</span><br><span class="line">                  subtitle,</span><br><span class="line">                  style: TextStyle(color: Colors.grey[<span class="number">500</span>]),</span><br><span class="line">                )</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这里是 Row 的第二个子元素，下面这两个就没用太多值得说的东西了。</span></span><br><span class="line">          Icon(</span><br><span class="line">            Icons.star,</span><br><span class="line">            color: Colors.red[<span class="number">500</span>],</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          Text(starCount.toString())</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><p>接下来我们要做的这一部分在布局上所用到的知识，基本知识在上一小节我们都已经学习了。这里唯一的区别在于，三个按钮是水平分布的。</p><p><img src="/2018/08/26/flutter-ui-basic/button-section-diagram.png" alt=""></p><p>实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildButtonColumn(BuildContext context, IconData icon, <span class="built_in">String</span> label) &#123;</span><br><span class="line">  <span class="keyword">final</span> color = Theme.of(context).primaryColor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Column(</span><br><span class="line">    <span class="comment">// main axis 跟我们前面提到的 cross axis 相对应，对 Column 来说，指的就是竖直方向。</span></span><br><span class="line">    <span class="comment">// 在放置完子控件后，屏幕上可能还会有一些剩余的空间（free space），min 表示尽量少占用</span></span><br><span class="line">    <span class="comment">// free space；类似于 Android 的 wrap_content。</span></span><br><span class="line">    <span class="comment">// 对应的，还有 MainAxisSize.max</span></span><br><span class="line">    mainAxisSize: MainAxisSize.min,</span><br><span class="line">    <span class="comment">// 沿着 main axis 居中放置</span></span><br><span class="line">    mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line"></span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Icon(icon, color: color),</span><br><span class="line">      Container(</span><br><span class="line">        margin: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">8.0</span>),</span><br><span class="line">        child: Text(</span><br><span class="line">          label,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">            fontSize: <span class="number">12.0</span>,</span><br><span class="line">            fontWeight: FontWeight.w400,</span><br><span class="line">            color: color,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      )</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    Widget buttonSection = Container(</span><br><span class="line">      child: Row(</span><br><span class="line">        <span class="comment">// 沿水平方向平均放置</span></span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">        children: [</span><br><span class="line">          _buildButtonColumn(context, Icons.call, <span class="string">'CALL'</span>),</span><br><span class="line">          _buildButtonColumn(context, Icons.near_me, <span class="string">'ROUTE'</span>),</span><br><span class="line">          _buildButtonColumn(context, Icons.share, <span class="string">'SHARE'</span>),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 cross/main axis，看看下面这两个图就很清楚了：<br><img src="/2018/08/26/flutter-ui-basic/column-diagram.png" alt=""><br><img src="/2018/08/26/flutter-ui-basic/row-diagram.png" alt=""></p><p><code>MainAxisAlignment</code> 的更多的信息，可以查看 <a href="https://docs.flutter.io/flutter/rendering/MainAxisAlignment-class.html" target="_blank" rel="noopener">https://docs.flutter.io/flutter/rendering/MainAxisAlignment-class.html</a>。</p><h2 id="全部放到一起"><a href="#全部放到一起" class="headerlink" title="全部放到一起"></a>全部放到一起</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> titleSection = _TitleSection(</span><br><span class="line">        <span class="string">'Oeschinen Lake Campground'</span>, <span class="string">'Kandersteg, Switzerland'</span>, <span class="number">41</span>);</span><br><span class="line">    <span class="keyword">final</span> buttonSection = ...;</span><br><span class="line">    <span class="keyword">final</span> textSection = Container(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">32.0</span>),</span><br><span class="line">        child: Text(</span><br><span class="line">          <span class="string">'''</span></span><br><span class="line"><span class="string">Lake Oeschinen lies at the foot of the Blüemlisalp in the Bernese Alps. Situated 1,578 meters above sea level, it is one of the larger Alpine Lakes. A gondola ride from Kandersteg, followed by a half-hour walk through pastures and pine forest, leads you to the lake, which warms to 20 degrees Celsius in the summer. Activities enjoyed here include rowing, and riding the summer toboggan run.</span></span><br><span class="line"><span class="string">          '''</span>,</span><br><span class="line">          softWrap: <span class="keyword">true</span>,</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UI basic 1'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Top Lakes'</span>),</span><br><span class="line">          ),</span><br><span class="line">          <span class="comment">// 由于我们的内容可能会超出屏幕的长度，这里把内容都放到 ListView 里。</span></span><br><span class="line">          <span class="comment">// 除了这种用法，ListView 也可以像我们在 Android 原生开发中使用 ListView 那样，</span></span><br><span class="line">          <span class="comment">// 根据数据动态生成一个个 item。这个我们在下一节再来学习</span></span><br><span class="line">          body: ListView(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Image.asset(</span><br><span class="line">                <span class="string">'images/lake.jpg'</span>,</span><br><span class="line">                width: <span class="number">600.0</span>,</span><br><span class="line">                height: <span class="number">240.0</span>,</span><br><span class="line">                <span class="comment">// cover 类似于 Android 开发中的 centerCrop，其他一些类型，读者可以查看</span></span><br><span class="line">                <span class="comment">// https://docs.flutter.io/flutter/painting/BoxFit-class.html</span></span><br><span class="line">                fit: BoxFit.cover,</span><br><span class="line">              ),</span><br><span class="line"></span><br><span class="line">              titleSection,</span><br><span class="line">              buttonSection,</span><br><span class="line">              textSection</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果没有出错的话，运行后应该就可以看到下面这个页面。<br><img src="/2018/08/26/flutter-ui-basic/Screenshot_20180826-172022.png" alt=""></p><p>如果你遇到了麻烦，可以在这里找到所有的源码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ui-basic1</span><br></pre></td></tr></table></figure><p>更多的布局知识，读者还可以参考 <a href="https://flutter.io/tutorials/layout/" target="_blank" rel="noopener">https://flutter.io/tutorials/layout/</a>。</p><h1 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h1><p>在这一小节我们来实现一个 list view。</p><p><img src="/2018/08/26/flutter-ui-basic/listview.png" alt=""></p><p>这里我们采用的还是官网提供的例子，但是换一种方式来实现，让它跟我们平时使用 Java 时更像一些。</p><p>首先给数据建模：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BuildingType &#123; theater, restaurant &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> BuildingType type;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> address;</span><br><span class="line"></span><br><span class="line">  Building(<span class="keyword">this</span>.type, <span class="keyword">this</span>.title, <span class="keyword">this</span>.address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现每个 item 的 UI：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> position;</span><br><span class="line">  <span class="keyword">final</span> Building building;</span><br><span class="line"></span><br><span class="line">  ItemView(<span class="keyword">this</span>.position, <span class="keyword">this</span>.building);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> icon = Icon(</span><br><span class="line">        building.type == BuildingType.restaurant</span><br><span class="line">            ? Icons.restaurant</span><br><span class="line">            : Icons.theaters,</span><br><span class="line">        color: Colors.blue[<span class="number">500</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> widget = Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">          child: icon,</span><br><span class="line">        ),</span><br><span class="line">        Expanded(</span><br><span class="line">          child: Column(</span><br><span class="line">            crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(</span><br><span class="line">                building.title,</span><br><span class="line">                style: TextStyle(</span><br><span class="line">                  fontSize: <span class="number">20.0</span>,</span><br><span class="line">                  fontWeight: FontWeight.w500,</span><br><span class="line">                )</span><br><span class="line">              ),</span><br><span class="line">              Text(building.address)</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> widget;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是 ListView。由于渲染机制不同，这里没必要弄个 adapter 来管理 widget：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildingListView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Building&gt; buildings;</span><br><span class="line"></span><br><span class="line">  BuildingListView(<span class="keyword">this</span>.buildings);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// ListView.builder 可以按需生成子控件</span></span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemCount: buildings.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ItemView(index, buildings[index]);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们来给 item 加上点击事件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个回调接口</span></span><br><span class="line"><span class="keyword">typedef</span> OnItemClickListener = <span class="keyword">void</span> <span class="built_in">Function</span>(<span class="built_in">int</span> position);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> position;</span><br><span class="line">  <span class="keyword">final</span> Building building;</span><br><span class="line">  <span class="keyword">final</span> OnItemClickListener listener;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的 listener 会从 ListView 那边传过来</span></span><br><span class="line">  ItemView(<span class="keyword">this</span>.position, <span class="keyword">this</span>.building, <span class="keyword">this</span>.listener);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> widget = ...;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般来说，为了监听手势事件，我们使用 GestureDetector。但这里为了在点击的时候有个</span></span><br><span class="line">    <span class="comment">// 水波纹效果，使用的是 InkWell。</span></span><br><span class="line">    <span class="keyword">return</span> InkWell(</span><br><span class="line">      onTap: () =&gt; listener(position),</span><br><span class="line">      child: widget</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildingListView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Building&gt; buildings;</span><br><span class="line">  <span class="keyword">final</span> OnItemClickListener listener;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是对外接口。外部通过构造函数传入数据和 listener</span></span><br><span class="line">  BuildingListView(<span class="keyword">this</span>.buildings, <span class="keyword">this</span>.listener);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemCount: buildings.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ItemView(index, buildings[index], listener);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后加上一些脚手架代码，我们的列表就能够跑起来了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> buildings = [</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'CineArts at the Empire'</span>, <span class="string">'85 W Portal Ave'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'The Castro Theater'</span>, <span class="string">'429 Castro St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Alamo Drafthouse Cinema'</span>, <span class="string">'2550 Mission St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Roxie Theater'</span>, <span class="string">'3117 16th St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'United Artists Stonestown Twin'</span>, <span class="string">'501 Buckingham Way'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'AMC Metreon 16'</span>, <span class="string">'135 4th St #3000'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'K\'s Kitchen'</span>, <span class="string">'1923 Ocean Ave'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'Chaiya Thai Restaurant'</span>, <span class="string">'72 Claremont Blvd'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'La Ciccia'</span>, <span class="string">'291 30th St'</span>),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// double 一下</span></span><br><span class="line">      Building(BuildingType.theater, <span class="string">'CineArts at the Empire'</span>, <span class="string">'85 W Portal Ave'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'The Castro Theater'</span>, <span class="string">'429 Castro St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Alamo Drafthouse Cinema'</span>, <span class="string">'2550 Mission St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Roxie Theater'</span>, <span class="string">'3117 16th St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'United Artists Stonestown Twin'</span>, <span class="string">'501 Buckingham Way'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'AMC Metreon 16'</span>, <span class="string">'135 4th St #3000'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'K\'s Kitchen'</span>, <span class="string">'1923 Ocean Ave'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'Chaiya Thai Restaurant'</span>, <span class="string">'72 Claremont Blvd'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'La Ciccia'</span>, <span class="string">'291 30th St'</span>),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'ListView demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Buildings'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: BuildingListView(buildings, (index) =&gt; debugPrint(<span class="string">'item $index clicked'</span>))</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候你应该可以看到像这样的界面了：<br><img src="/2018/08/26/flutter-ui-basic/screenshot-listview.png" alt=""></p><p>如果你遇到了什么麻烦，可以查看 tag ui-basic2 的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ui-basic2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本篇文章我们先介绍 Flutter 里一些常用的 UI 控件，然后借助官网提供的两个 demo 把所学的控件知识实际使用起来。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（1）- 开发框架、流程、编译打包、调试</title>
    <link href="https://jekton.github.io/2018/08/26/flutter-first-app/"/>
    <id>https://jekton.github.io/2018/08/26/flutter-first-app/</id>
    <published>2018-08-26T01:41:42.000Z</published>
    <updated>2018-09-18T12:16:48.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>Flutter 是 Google 推出的移动端跨平台开发框架，使用的编程语言是 Dart。从 React Native 到 Flutter，开发者对跨平台解决方案的探索从未停止，毕竟，它可以让我们节省移动端一半的人力。本篇文章中，我们就通过编写一个简单的 Flutter 来了解他的开发流程。</p><p>这里我们要开发的 demo 很简单，只是在屏幕中间放一个按钮，点击的时候，模拟摇两个骰子并弹窗显示结果。我们撸起袖子开干吧。</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>我们这里假定读者已经安装好 Flutter，并且使用安装了 Flutter 插件的 Android Studio 进行开发。如果你还没有配置好开发环境，可以参考 <a href="https://mp.weixin.qq.com/s/6lmhHNBRcmoNqkMHaCBx8A" target="_blank" rel="noopener">这篇文章</a>。</p><p>下面我们开始创建项目：</p><ol><li>选择 File &gt; New &gt; New Flutter project…</li><li>在接下来弹出的选择面板里，选择 Flutter Application</li><li>这里填应用的基本信息。Project name 我们就写 flutter_demo 好了。这里要注意的是，Project name 必须是一个合法的 Dart 包名（小写+下划线，可以有数字）。填好以后点击 next，然后 finish。</li></ol><p>第一次创建项目时，由于要下载 gradle，时间会稍微长一些。</p><h1 id="编写代码（1）"><a href="#编写代码（1）" class="headerlink" title="编写代码（1）"></a>编写代码（1）</h1><p>在上一小节里我们所创建的项目，已经有了一些代码，感兴趣的读者可以跑到自己手机上看一看，相关的代码在 <code>lib/main.dart</code> 里面。</p><p>为了体验从头开发一个应用的过程，这里我们先把 <code>lib/main.dart</code> 里的内容都删除。</p><p>首先，我们创建一个 <code>main</code> 函数。跟其他语言一样，<code>main</code> 函数是应用的入口：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们编写一个 <code>Widget</code> 作为我们的 app。在 Flutter 里，所有的东西都是 <code>Widget</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 创建一个 MyApp</span></span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这个 widget 作用这个应用的顶层 widget.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 这个 widget 是无状态的，所以我们继承的是 [StatelessWidget].</span></span><br><span class="line"><span class="comment">/// 对应的，有状态的 widget 可以继承 [StatefulWidget]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 创建内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以进入正题，进入一个按钮，在点击的时候弹框显示结果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">// 我们想使用 material 风格的应用，所以这里用 MaterialApp</span></span><br><span class="line">  <span class="keyword">return</span> MaterialApp(</span><br><span class="line">    <span class="comment">// 移动设备使用这个 title 来表示我们的应用。具体一点说，在 Android 设备里，我们点击</span></span><br><span class="line">    <span class="comment">// recent 按钮打开最近应用列表的时候，显示的就是这个 title。</span></span><br><span class="line">    title: <span class="string">'Our first Flutter app'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用的“主页”</span></span><br><span class="line">    home: Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Flutter rolling demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 我们知道，Flutter 里所有的东西都是 widget。为了把按钮放在屏幕的中央，</span></span><br><span class="line">      <span class="comment">// 这里使用了 Center（它是一个 widget）。</span></span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          <span class="comment">// 用户点击时候调用</span></span><br><span class="line">          onPressed: _onPressed,</span><br><span class="line">          child: Text(<span class="string">'roll'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="安装、调试（1）"><a href="#安装、调试（1）" class="headerlink" title="安装、调试（1）"></a>安装、调试（1）</h1><p>现在，点击 Run，把我们的第一个 Flutter 应用跑起来吧。没有意外的话，你会看到下面这个页面：<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-pic1.png" alt="Screenshot with a button in the center"></p><p>如果你遇到了什么困难，可以查看 tag <code>first_app_step1</code> 的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout first_app_step1</span><br></pre></td></tr></table></figure><p>由于是第一次写 Flutter 应用，我们对上面的代码是否能够按照预期执行还不是那么有信心，所以我们先打个 log 确认一下，点击按钮后是不是真的会执行 <code>onPress</code>。</p><p>打 log 可以使用 Dart 提供的 <code>print</code>，但在日志比较多的时候，<code>print</code> 的输出可能会被 Android 丢弃，这个时候 <code>debugPrint</code> 会是更好的选择。对应的日志信息可以在 <code>Dart Console</code> 里查看（View -&gt; Tool Windows -&gt; Run 或者 Mac 上使用 Command+4 打开）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">  debugPrint(<span class="string">'_onPressed'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后（会自动 Hot Reload）后，我们再次点击按钮，在我的设备上，打印出了下面这样的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (11297): _onPressed</span><br><span class="line">V/AudioManager(11297): playSoundEffect   effectType: 0</span><br><span class="line">V/AudioManager(11297): querySoundEffectsEnabled...</span><br></pre></td></tr></table></figure><p>这里的第一行，就是我们打印的。现在我们有足够的自信说，点击按钮后，会执行 <code>_onPressed</code> 方法。</p><h1 id="编写代码（2）"><a href="#编写代码（2）" class="headerlink" title="编写代码（2）"></a>编写代码（2）</h1><p>软件开发通常是一个螺旋式上升的过程，不可能通过一次编码、调试就完成。现在，开始第二轮迭代过程。</p><p>接下来我们要做的，便是在 <code>_onPressed</code> 里面弹一个框：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context 这里使用的是 MyApp.build 的参数</span></span><br><span class="line"><span class="keyword">void</span> _onPressed(BuildContext context) &#123;</span><br><span class="line">  debugPrint(<span class="string">'_onPressed'</span>);</span><br><span class="line"></span><br><span class="line">  showDialog(</span><br><span class="line">    context: context,</span><br><span class="line">    builder: (_) &#123;</span><br><span class="line">      <span class="keyword">return</span> AlertDialog(</span><br><span class="line">        content: Text(<span class="string">'AlertDialog'</span>),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遗憾的是，这一次并不那么顺利。Dialog 没有弹出来，而且报了下面这问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (11297): Navigator operation requested with a context that does not include a Navigator.</span><br><span class="line">I/flutter (11297): The context used to push or pop routes from the Navigator must be that of a widget that is a</span><br><span class="line">I/flutter (11297): descendant of a Navigator widget.</span><br></pre></td></tr></table></figure><p>原因在于，stateless 的 widget 只能用于显示信息，而不能有其他动作。所以，该让 <code>StatefulWidget</code> 上场了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RollingButton</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// StatefulWidget 需要实现这个方法，返回一个 State</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _RollingState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能看起来有点恶心，这里的泛型参数居然是 RollingButton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RollingState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RollingButton</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      child: Text(<span class="string">'Roll'</span>),</span><br><span class="line">      onPressed: _onPressed,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">    debugPrint(<span class="string">'_RollingState._onPressed'</span>);</span><br><span class="line">    showDialog(</span><br><span class="line">        <span class="comment">// 第一个 context 是参数名，第二个 context 是 State 的成员变量</span></span><br><span class="line">        context: context,</span><br><span class="line">        builder: (_) &#123;</span><br><span class="line">          <span class="keyword">return</span> AlertDialog(</span><br><span class="line">            content: Text(<span class="string">'AlertDialog'</span>),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现一个 stateful 的 widget，需要继承 <code>StatefulWidget</code> 并在 <code>createState</code> 方法中返回一个 <code>State</code>。除了这一部分，上面的代码跟我们之前写的并没有太大的区别。</p><p>剩下的，就是替换 <code>MyApp</code> 里面使用的按钮，修改后的代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Our first Flutter app'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Flutter rolling demo'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: RollingButton(),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，点击按钮后，我们将看到梦寐以求的 dialog。<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-pic2.png" alt="Screenshot with a dialog"></p><p>如果你遇到了麻烦，可以查看 tag <code>first_app_step2</code> 的代码。</p><p>最后，我们来实现“roll”：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RollingState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RollingButton</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> _random = Random();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; _roll() &#123;</span><br><span class="line">    <span class="keyword">final</span> roll1 = _random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> roll2 = _random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> [roll1, roll1];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">    debugPrint(<span class="string">'_RollingState._onPressed'</span>);</span><br><span class="line">    <span class="keyword">final</span> rollResults = _roll();</span><br><span class="line">    showDialog(</span><br><span class="line">        <span class="comment">// 第一个 context 是参数名，第二个 context 是 State 的成员变量</span></span><br><span class="line">        context: context,</span><br><span class="line">        builder: (_) &#123;</span><br><span class="line">          <span class="keyword">return</span> AlertDialog(</span><br><span class="line">            content: Text(<span class="string">'Roll result: (<span class="subst">$&#123;rollResults[<span class="number">0</span>]&#125;</span>, <span class="subst">$&#123;rollResults[<span class="number">1</span>]&#125;</span>)'</span>),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="安装、调试（2）"><a href="#安装、调试（2）" class="headerlink" title="安装、调试（2）"></a>安装、调试（2）</h1><p>还是一样，重新运行后，我们就能够看到每次点击按钮的结果随机地出现 <code>[1, 6]</code> 中的数……慢着，怎么弹出的消息里的两个号码总是一样的！好吧，肯定是哪里出错了。</p><p>这次，我们不采用打 log 的方法，改用 debugger 来调试。</p><ol><li>在 <code>final rollResults = _roll();</code> 这一行打个断点</li><li>然后点击 Debug main.dart 开始调试</li><li>点击 APP 里的 Roll 按钮</li></ol><p>现在，应用停在了我们所打的断点处：<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-debug1.png" alt="debug step1"></p><p>接下来：</p><ol><li>Step Into 进入 <code>_roll</code> 方法</li><li>进入 <code>_roll</code> 后，Step Over 一行执行。<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-debug2.png" alt="debug step2"><br>这里我们看到，两次 random 确实产生了不同的结果。我们继续：</li><li>继续 Step Over，这个时候 <code>_roll</code> 就返回了</li><li>切换到 Variables 这个选项卡，查看 <code>rollResults</code> 的值<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-debug3.png" alt="debug step3"></li></ol><p>可以发现，两个结果居然变成一样的了。再往回查看一下代码，我们竟然 <code>return [roll1, roll1]</code>。修改后一个为 <code>roll2</code>，我们就程序就能够按预期的正常执行了。</p><p>最终的代码，可以看 tag <code>first_app_done</code>。</p><h2 id="调试总结"><a href="#调试总结" class="headerlink" title="调试总结"></a>调试总结</h2><p>本篇文章其实介绍了两种调试方法：打 log 和 debugger。虽然现在 Flutter 提供的 log 工具比较简陋，可以预期未来还会进一步完善。</p><p>使用打 log 的方式，好处在于不会对执行流程产生较大的影响，在多线程环境尤为有用。它的速度也比较快，不需要我们去单步执行。不足之处在于，如果原先没有对应的 log，我们只能修改代码重新运行，才能查看相应的状态。对于线上的应用，我们也只能够通过分析 log 来定位问题。</p><p>debugger 跟打 log 方式是互补的。使用 debugger 时，我们可以随意查看我们需要知道的变量的值，一步一步近距离观察代码的运行状态。坏处当然就是太慢了。在什么时候使用什么方法，需要一些经验；但有时候就全凭个人喜好了，没有优劣之分。</p><p>更多的调试方法，读者可以根据需要查看<a href="https://flutter.io/debugging/" target="_blank" rel="noopener">https://flutter.io/debugging/</a>进一步学习。</p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>编写完应用后，是时候打包 apk 分发给用户使用了。在这一小节，我们就来看看怎么给 Flutter 项目打包。</p><p>在我们项目的根目录，有一个 android 文件夹，下面我们将主要对这个目录的文件进行修改。</p><ol><li><p>查看 <code>AndroidManifest.xml</code>。这是一个按模板生成的文件，有些东西可能需要修改一下</p></li><li><p><code>build.gradle</code>，这里面也可能有你需要修改的地方。对我们的应用来说，目前都先维持原样</p></li><li><p>如果有需要，更新 <code>res/mipmap</code> 里的应用启动图标。这里我们不改</p></li><li><p>签名</p><ol><li><p>生成签名的 key（如果你已经有了，跳过这一步）,<code>keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key</code>。为了让读者也可以编译，这里我把 key 也放到了项目中。</p></li><li><p>添加一个 <code>android/key.properties</code>，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storePassword=123456</span><br><span class="line">keyPassword=123456</span><br><span class="line">keyAlias=key</span><br><span class="line">storeFile=../key.jks</span><br></pre></td></tr></table></figure></li><li><p>更新 build.gradle 里的签名配置</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> keystorePropertiesFile = rootProject.<span class="keyword">file</span>(<span class="string">"key.properties"</span>)</span><br><span class="line"><span class="keyword">def</span> keystoreProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">keystoreProperties.load(<span class="keyword">new</span> FileInputStream(keystorePropertiesFile))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            keyAlias keystoreProperties[<span class="string">'keyAlias'</span>]</span><br><span class="line">            keyPassword keystoreProperties[<span class="string">'keyPassword'</span>]</span><br><span class="line">            storeFile <span class="keyword">file</span>(keystoreProperties[<span class="string">'storeFile'</span>])</span><br><span class="line">            storePassword keystoreProperties[<span class="string">'storePassword'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line"></span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            useProguard <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// proguard 文件我们在下一步添加</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>添加 <code>/android/app/proguard-rules.pro</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#Flutter Wrapper</span><br><span class="line">-keep class io.flutter.app.** &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.plugin.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.util.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.view.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.plugins.**  &#123; *; &#125;</span><br></pre></td></tr></table></figure></li><li><p>编译 apk。在项目的根目录，执行 <code>flutter build apk</code>， 编译后的应用在 <code>build/app/outputs/apk/release/app-release.apk</code>。</p></li><li><p>还是在根目录下，执行 <code>flutter install</code> 就可以安装这个 apk 了。</p></li></ol><br>对于 iOS，读者可以看[https://flutter.io/ios-release/](https://flutter.io/ios-release/)，这里就不再演示了。 查看最终的项目，可以 checkout 到 tag `first_app_signing`。恭喜你，第一个 Flutter 应用完成啦。]]></content>
    
    <summary type="html">
    
      Flutter 是 Google 推出的移动端跨平台开发框架，使用的编程语言是 Dart。从 React Native 到 Flutter，开发者对跨平台解决方案的探索从未停止，毕竟，它可以让我们节省移动端一半的人力。本篇文章中，我们就通过编写一个简单的 Flutter 来了解他的开发流程。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>JDK 源码分析（1）- FutureTask</title>
    <link href="https://jekton.github.io/2018/07/25/jdk-FutureTask/"/>
    <id>https://jekton.github.io/2018/07/25/jdk-FutureTask/</id>
    <published>2018-07-25T05:27:45.000Z</published>
    <updated>2018-08-18T12:47:22.691Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是 JDK 源码分析的第一篇，主要关注 <code>FutureTask</code> 的实现。我们所分析的源码使用的是 Java10，因此也假设了读者了解 <code>VarHandle</code>（Java9 新增的 API），不了解的读者可以看我翻译的<a href="https://jekton.github.io/2018/07/22/java-translation-jep-193-Variable-Handles/">JEP 193</a>。</p><a id="more"></a><h2 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h2><p>这里我们不准备详细讲 <code>FutureTask</code> 的用法，只是简单提一下，帮组读者回忆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首先我们构造一个 `FutureTask`</span></span><br><span class="line">FutureTask&lt;Foo&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 然后我们把这个实例放在后台线程执行，比方说 executor：</span></span><br><span class="line">executor.execute(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 最后，我们获取执行的结果</span></span><br><span class="line">Foo foo = task.get();</span><br></pre></td></tr></table></figure><p>如果读者对 <code>FutureTask</code> 的用法不是很熟悉，等看完源码就会非常清楚了。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The run state of this task, initially NEW.  The run state</span></span><br><span class="line"><span class="comment">     * transitions to a terminal state only in methods set,</span></span><br><span class="line"><span class="comment">     * setException, and cancel.  During completion, state may take on</span></span><br><span class="line"><span class="comment">     * transient values of COMPLETING (while outcome is being set) or</span></span><br><span class="line"><span class="comment">     * INTERRUPTING (only while interrupting the runner to satisfy a</span></span><br><span class="line"><span class="comment">     * cancel(true)). Transitions from these intermediate to final</span></span><br><span class="line"><span class="comment">     * states use cheaper ordered/lazy writes because values are unique</span></span><br><span class="line"><span class="comment">     * and cannot be further modified.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Possible state transitions:</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">// this.state 是 volatile，对 volatile 字段的写入，存在一个 happen-before</span></span><br><span class="line">        <span class="comment">// 关系；也就是说，`this.state = NEW` 执行完毕时，`this.callable = callable`</span></span><br><span class="line">        <span class="comment">// 也保证已经写入</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为标准库的实现，在性能上我们锱铢必较。这里利用 <code>volatile</code> 的特性，可以不需要设置 <code>callable</code> 为 <code>volatile</code>。</p><h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>创建了 <code>FutureTask</code> 实例后，我们就可以执行他了。这个由 <code>run()</code> 方法来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            <span class="comment">// 这是一个原子操作</span></span><br><span class="line">            !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="comment">// 假设有两个线程竞争执行这个 futureTask，线程1 执行了</span></span><br><span class="line">            <span class="comment">// state != NEW 后，轮到线程2，同样执行成功；接着线程2</span></span><br><span class="line">            <span class="comment">// 继续执行到方法结束并设置 runner 回 null；再后面，线</span></span><br><span class="line">            <span class="comment">// 程1 重新被调度，来到了下面这个 if 语句。此时其实已经</span></span><br><span class="line">            <span class="comment">// 执行完成，所以这里要再判断一次</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 情况1：发生异常</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    <span class="comment">// 情况2：执行成功</span></span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 情况3：任务被取消</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VarHandle mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MethodHandles.Lookup l = MethodHandles.lookup();</span><br><span class="line">            STATE = l.findVarHandle(FutureTask.class, <span class="string">"state"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">            RUNNER = l.findVarHandle(FutureTask.class, <span class="string">"runner"</span>, Thread.class);</span><br><span class="line">            WAITERS = l.findVarHandle(FutureTask.class, <span class="string">"waiters"</span>, WaitNode.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reduce the risk of rare disastrous classloading in first call to</span></span><br><span class="line">        <span class="comment">// LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span></span><br><span class="line">        Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们分 3 种情况来看代码。</p><h3 id="情况1：发生异常"><a href="#情况1：发生异常" class="headerlink" title="情况1：发生异常"></a>情况1：发生异常</h3><p>如果执行的过程发生了异常，会调用 <code>setException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可能客户会调用 cancel 方法取消任务，所以这里要用原子操作</span></span><br><span class="line">        <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">            outcome = t;</span><br><span class="line">            STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VarHandle</code> 的 <code>setRelease</code> 有这样一句注释：</p><blockquote><p>Sets the value of a variable to the {@code newValue}, and ensures that prior loads and stores are not reordered after this access.</p></blockquote><p>所以（如果 <code>compareAndSet</code> 执行成功），当我们把 <code>state</code> 设置为 <code>EXCEPTIONAL</code> 前，能够保证 <code>outcome = t</code> 已经执行完成。</p><p><code>finishCompletion</code> 我们留到后面再看。</p><h3 id="情况2：执行成功"><a href="#情况2：执行成功" class="headerlink" title="情况2：执行成功"></a>情况2：执行成功</h3><p>执行成功时调用 <code>set</code> 方法，它的实现跟 <code>setException</code> 差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况3：任务被取消"><a href="#情况3：任务被取消" class="headerlink" title="情况3：任务被取消"></a>情况3：任务被取消</h3><p>如果需要取消任务，可以调用 <code>FutureTask</code> 的 <code>cancel</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">              (<span class="keyword">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="comment">// 如果当前状态不是 NEW 并且不能成功将其设置为 INTERRUPTING/CANCELLED</span></span><br><span class="line">            <span class="comment">// 表示任务已经执行完，所以 cancel 失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="comment">// 如果 t == null，要么是这个任务还没开始执行，要么已经执行</span></span><br><span class="line">                    <span class="comment">// 到了 run 方法里的 finally 块</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    STATE.setRelease(<span class="keyword">this</span>, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>mayInterruptIfRunning == false</code>，那就直接尝试把状态设置为 <code>CANCELLED</code>；否则需要 interrupt 线程。下面是 <code>run</code> 方法最后的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">final</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 对应 mayInterruptIfRunning == true 的情况</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensures that any interrupt from a possible cancel(true) is only</span></span><br><span class="line"><span class="comment">     * delivered to a task while in run or runAndReset.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">        <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></span><br><span class="line">        <span class="comment">// 注意，第一个比较的是参数 s，s 可能是 `INTERRUPTED`</span></span><br><span class="line">        <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">            <span class="comment">// state 是 volatile，保证我们这里每次都能够读到最新的值</span></span><br><span class="line">            <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">                Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// assert state == INTERRUPTED;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We want to clear any interrupt we may have received from</span></span><br><span class="line">        <span class="comment">// cancel(true).  However, it is permissible to use interrupts</span></span><br><span class="line">        <span class="comment">// as an independent mechanism for a task to communicate with</span></span><br><span class="line">        <span class="comment">// its caller, and there is no way to clear only the</span></span><br><span class="line">        <span class="comment">// cancellation interrupt.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Thread.interrupted();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有 3 种情况，最后都会调用 <code>finishCompletion</code> 方法，这部分我们下一节继续看。</p><h2 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h2><p>在 <code>finishCompletion</code> 的内部，会唤醒等待结果的线程。这里我们先不看 <code>finishCompletion</code>，而是看看 <code>get</code> 方法，这样会更容易理解一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">// awaitDone 会返回结束时的状态</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            <span class="comment">// timeout 后还没有结束</span></span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分的重点在于 <code>awaitDone</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class="line"><span class="comment">     * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class="line"><span class="comment">     * for more detailed explanation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Awaits completion or aborts on interrupt or timeout.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timed true if use timed waits</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanos time to wait, if timed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> state upon completion or at timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// The code below is very delicate, to achieve these goals:</span></span><br><span class="line">        <span class="comment">// - call nanoTime exactly once for each call to park</span></span><br><span class="line">        <span class="comment">// - if nanos &lt;= 0L, return promptly without allocation or nanoTime</span></span><br><span class="line">        <span class="comment">// - if nanos == Long.MIN_VALUE, don't underflow</span></span><br><span class="line">        <span class="comment">// - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic</span></span><br><span class="line">        <span class="comment">//   and we suffer a spurious wakeup, we will do no worse than</span></span><br><span class="line">        <span class="comment">//   to park-spin for a while</span></span><br><span class="line">        <span class="keyword">long</span> startTime = <span class="number">0L</span>;    <span class="comment">// Special value 0L means not yet parked</span></span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 任务完成或被取消</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">                <span class="comment">// 到 COMPLETING 状态了的话，预期很快就会结束，所以 yield 一下</span></span><br><span class="line">                <span class="comment">// 就够了</span></span><br><span class="line">                <span class="comment">// We may have already promised (via isDone) that we are done</span></span><br><span class="line">                <span class="comment">// so never return empty-handed or throw InterruptedException</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">// removeWaiter 把节点从 waiters 列表里移除</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一个循环，q == null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用 get 方法时传入时间为 0 或负值，可以轮询任务；</span></span><br><span class="line">                <span class="comment">// 默认版本的 get 传入的 timed == false，会无限等待</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> s;</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// queued 初始为 false</span></span><br><span class="line">            <span class="comment">// 第二个循环会执行下面这个语句，把 q 入队。</span></span><br><span class="line">            <span class="comment">// （上一步成功的情况下）第三个循环才会开始执行再往下的休眠操作</span></span><br><span class="line">            <span class="comment">// 注意：每个循环都会检查 state</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                <span class="comment">// 这里我们先把队头 waiters 赋值给 q.next，赋值语句的返回值还是</span></span><br><span class="line">                <span class="comment">// waiters。执行这个语句的时候，我们期待 waiter 的当前值是 waiters</span></span><br><span class="line">                <span class="comment">// 并且将它设置为 q。</span></span><br><span class="line">                <span class="comment">// 因为可能有多个线程同时执行这个方法，这个语句还是有可能会执行</span></span><br><span class="line">                <span class="comment">// 失败的。如果失败，在接下来的循环里会重试</span></span><br><span class="line">                <span class="comment">// weakCompareAndSet 就姑且当做原子的 compareAndSet 吧</span></span><br><span class="line">                queued = WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> parkNanos;</span><br><span class="line">                <span class="keyword">if</span> (startTime == <span class="number">0L</span>) &#123; <span class="comment">// first time</span></span><br><span class="line">                    startTime = System.nanoTime();</span><br><span class="line">                    <span class="keyword">if</span> (startTime == <span class="number">0L</span>)</span><br><span class="line">                        startTime = <span class="number">1L</span>;</span><br><span class="line">                    parkNanos = nanos;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class="line">                    <span class="keyword">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class="line">                        removeWaiter(q);</span><br><span class="line">                        <span class="keyword">return</span> state;</span><br><span class="line">                    &#125;</span><br><span class="line">                    parkNanos = nanos - elapsed;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// nanoTime may be slow; recheck before parking</span></span><br><span class="line">                <span class="keyword">if</span> (state &lt; COMPLETING)</span><br><span class="line">                    <span class="comment">// 把线程投入休眠</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, parkNanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们继续看 <code>removeWaiter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to unlink a timed-out or interrupted wait node to avoid</span></span><br><span class="line"><span class="comment"> * accumulating garbage.  Internal nodes are simply unspliced</span></span><br><span class="line"><span class="comment"> * without CAS since it is harmless if they are traversed anyway</span></span><br><span class="line"><span class="comment"> * by releasers.  To avoid effects of unsplicing from already</span></span><br><span class="line"><span class="comment"> * removed nodes, the list is retraversed in case of an apparent</span></span><br><span class="line"><span class="comment"> * race.  This is slow when there are a lot of nodes, but we don't</span></span><br><span class="line"><span class="comment"> * expect lists to be long enough to outweigh higher-overhead</span></span><br><span class="line"><span class="comment"> * schemes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 为了能够重新开始整个循环，包裹了一层 for 循环</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">            <span class="comment">// 遍历 waiters</span></span><br><span class="line">            <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="comment">// 下面两种情况对应 q.thread == null，也就是说，q 是待删除的节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// next 字段是 volatile，所以这里可以直接赋值。把 prev.next</span></span><br><span class="line">                    <span class="comment">// 指向 s （q.next）后就删除了 q。</span></span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                        <span class="comment">// 很倒霉的，prev 也要被删除（或已经被删除）</span></span><br><span class="line">                        <span class="comment">// 这里有三种可能：</span></span><br><span class="line">                        <span class="comment">// 1. prev.node 刚被设置为 null，但这个节点还在列表里，</span></span><br><span class="line">                        <span class="comment">//    prev.next = s 成功把 q 从列表里删除</span></span><br><span class="line">                        <span class="comment">// 2. 节点已经被删除</span></span><br><span class="line">                        <span class="comment">//    2.1 prev 是头节点（这将会执行下面那个else if 子句），</span></span><br><span class="line">                        <span class="comment">//        q 被设置为队头，q.next 仍旧指向 s；</span></span><br><span class="line">                        <span class="comment">//    2.2 prev 不是头结点，prev.prev.next 指向了 q；</span></span><br><span class="line">                        <span class="comment">//    这两种情况下，q 还留在列表里</span></span><br><span class="line">                        <span class="comment">// 所有这3种情况下，数据结构都是正常的。如果 q 还在列表里，</span></span><br><span class="line">                        <span class="comment">// 重新开始循环后总会删除它。如果已经被删除，遍历完列表后</span></span><br><span class="line">                        <span class="comment">// 也会退出。</span></span><br><span class="line">                        <span class="comment">// q 已经被删除的情况下，即使下个循环里我们把别人要删除的</span></span><br><span class="line">                        <span class="comment">// 节点给删除了也没关系。</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// q 在队头，所要把 waiters 设置为 s</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!WAITERS.compareAndSet(<span class="keyword">this</span>, q, s))</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得 <code>removeWaiter</code> 难以理解，建议多看几遍（我自己也是研究了很久），使用原子操作来实现并发访问是会带来比较大的复杂度的。</p><p>最后，我们来看个简单的 <code>finishCompletion</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 把 waiters 设置为 null 后相当于取出所有的 waiter</span></span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 遍历 waiters</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 唤醒线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>FutureTask</code> 到这里我们就看完了。虽然代码量不多，但还是比预料中的复杂。除了上面代码里明确使用的 volatile 和原子操作，<code>FutureTask</code> 对 <code>state</code> 的定义也是很讲究的。通过增序定义 state 常量，在某些情况下我们可以直接通过比较常量值来判断状态是否处于某些状态集。比方说，是否被中断使用的是 <code>state &gt;= INTERRUPTING</code>；如果不这么做，我们就需要 <code>state == INTERRUPTING || state == INTERRUPTED</code>，毫无疑问，前者会执行得更快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是 JDK 源码分析的第一篇，主要关注 &lt;code&gt;FutureTask&lt;/code&gt; 的实现。我们所分析的源码使用的是 Java10，因此也假设了读者了解 &lt;code&gt;VarHandle&lt;/code&gt;（Java9 新增的 API），不了解的读者可以看我翻译的&lt;a href=&quot;https://jekton.github.io/2018/07/22/java-translation-jep-193-Variable-Handles/&quot;&gt;JEP 193&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jekton.github.io/categories/Java/"/>
    
    
      <category term="JDK" scheme="https://jekton.github.io/tags/JDK/"/>
    
  </entry>
  
</feed>
