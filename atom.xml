<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>初级程序员虾饺</title>
  
  <subtitle>Learning for fun</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jekton.github.io/"/>
  <updated>2019-03-20T12:23:26.622Z</updated>
  <id>https://jekton.github.io/</id>
  
  <author>
    <name>Jekton</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android P 源码分析 4 - logd 的初始化</title>
    <link href="https://jekton.github.io/2019/03/19/android9-logd-init/"/>
    <id>https://jekton.github.io/2019/03/19/android9-logd-init/</id>
    <published>2019-03-19T11:45:44.000Z</published>
    <updated>2019-03-20T12:23:26.622Z</updated>
    
    <content type="html"><![CDATA[<p>为了跟老罗的书保持一个相对一致的步伐，这一篇开始我们来看 logd 的实现。当然，这个 logd 不是老罗书里讲的 log 驱动，而是在应用层实现的一个守护进程。</p><a id="more"></a><p>在进入正题之前先说明一下，logd 虽然是用 C++ 写的，但由于比较接近系统，需要读者对系统编程有一定的了解。不熟悉的读者可以通过《Linux系统编程》快速入个门，《UNIX环境高级程序设计》则是关于这一主题最好的书籍。</p><h2 id="logd-的启动"><a href="#logd-的启动" class="headerlink" title="logd 的启动"></a>logd 的启动</h2><p>通过查看 logd 源码目录，我们可以看到这样一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// system/core/logd/logd.rc</span><br><span class="line">service logd /system/bin/logd</span><br><span class="line">    socket logd stream 0666 logd logd</span><br><span class="line">    socket logdr seqpacket 0666 logd logd</span><br><span class="line">    socket logdw dgram+passcred 0222 logd logd</span><br><span class="line">    file /proc/kmsg r</span><br><span class="line">    file /dev/kmsg w</span><br><span class="line">    user logd</span><br><span class="line">    group logd system package_info readproc</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line"></span><br><span class="line">service logd-reinit /system/bin/logd --reinit</span><br><span class="line">    oneshot</span><br><span class="line">    disabled</span><br><span class="line">    user logd</span><br><span class="line">    group logd</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    write /dev/event-log-tags &quot;# content owned by logd</span><br><span class="line">&quot;</span><br><span class="line">    chown logd logd /dev/event-log-tags</span><br><span class="line">    chmod 0644 /dev/event-log-tags</span><br></pre></td></tr></table></figure></p><p>init 进程是在 post-fs 阶段启动 logd 的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// system/core/rootdir/init.rc</span><br><span class="line">on post-fs</span><br><span class="line">    # Load properties from</span><br><span class="line">    #     /system/build.prop,</span><br><span class="line">    #     /odm/build.prop,</span><br><span class="line">    #     /vendor/build.prop and</span><br><span class="line">    #     /factory/factory.prop</span><br><span class="line">    load_system_props</span><br><span class="line">    # start essential services</span><br><span class="line">    start logd</span><br><span class="line">    start servicemanager</span><br><span class="line">    start hwservicemanager</span><br><span class="line">    start vndservicemanage</span><br></pre></td></tr></table></figure></p><p>从这里我们可以得出几个信息：</p><ol><li>logd 是经由 init 进程启动的</li><li>init 进程为 logd 创建了 3 个（UNIX 域）socket，分别是 <code>/dev/socket/logd, /dev/socket/logdr, /dev/socket/logdw</code></li><li>init 进程为 logd 打开了两个文件 <code>/proc/kmsg, /dev/kmsg</code></li><li>把 logd 的 uid 设置为 logd，gid 设置为 logd、system、package_info 和 readproc</li><li>把 logd 进程的 pid 写到文件 /dev/cpuset/system-background/tasks</li></ol><p>关于 socket 的相关知识，读者可以参考《UNIX 网络编程，卷1》。</p><p>logd-reinit 用来触发 logd 的重新初始化，同样执行的是 logd 程序，只是多了一个参数 <code>--init</code>。后面我们讲 logd 的控制命令时再详细说。</p><p>至于 init 进程如何解析 init.rc，以后有机会写 init 进程相关文章的时候再讨论。</p><h2 id="logd-的初始化"><a href="#logd-的初始化" class="headerlink" title="logd 的初始化"></a>logd 的初始化</h2><p>init 进程启动 logd 后，接下来执行的自然是 logd 的 <code>main</code> 函数。这个函数有点长，这里先把代码放上来，后面再一点点慢慢看。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Foreground waits for exit of the main persistent threads</span></span><br><span class="line"><span class="comment">// that are started here. The threads are created to manage</span></span><br><span class="line"><span class="comment">// UNIX domain client sockets for writing, reading and</span></span><br><span class="line"><span class="comment">// controlling the user space logger, and for any additional</span></span><br><span class="line"><span class="comment">// logging plugins like auditd and restart control. Additional</span></span><br><span class="line"><span class="comment">// transitory per-client threads are created for each reader.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// logd is written under the assumption that the timezone is UTC.</span></span><br><span class="line">    <span class="comment">// If TZ is not set, persist.sys.timezone is looked up in some time utility</span></span><br><span class="line">    <span class="comment">// libc functions, including mktime. It confuses the logd time handling,</span></span><br><span class="line">    <span class="comment">// so here explicitly set TZ to UTC, which overrides the property.</span></span><br><span class="line">    setenv(<span class="string">"TZ"</span>, <span class="string">"UTC"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// issue reinit command. KISS argument parsing.</span></span><br><span class="line">    <span class="keyword">if</span> ((argc &gt; <span class="number">1</span>) &amp;&amp; argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--reinit"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> issueReinit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> dev_kmsg[] = <span class="string">"/dev/kmsg"</span>;</span><br><span class="line">    fdDmesg = android_get_control_file(dev_kmsg);</span><br><span class="line">    <span class="keyword">if</span> (fdDmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fdDmesg = TEMP_FAILURE_RETRY(open(dev_kmsg, O_WRONLY | O_CLOEXEC));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fdPmesg = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> klogd = __android_logger_property_get_bool(</span><br><span class="line">        <span class="string">"ro.logd.kernel"</span>,</span><br><span class="line">        BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_ENG | BOOL_DEFAULT_FLAG_SVELTE);</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> proc_kmsg[] = <span class="string">"/proc/kmsg"</span>;</span><br><span class="line">        fdPmesg = android_get_control_file(proc_kmsg);</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fdPmesg = TEMP_FAILURE_RETRY(</span><br><span class="line">                open(proc_kmsg, O_RDONLY | O_NDELAY | O_CLOEXEC));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) android::prdebug(<span class="string">"Failed to open %s\n"</span>, proc_kmsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reinit Thread</span></span><br><span class="line">    sem_init(&amp;reinit, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;uidName, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_name, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">if</span> (!pthread_attr_init(&amp;attr)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(param));</span><br><span class="line">        pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line">        pthread_attr_setschedpolicy(&amp;attr, SCHED_BATCH);</span><br><span class="line">        <span class="keyword">if</span> (!pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED)) &#123;</span><br><span class="line">            <span class="keyword">pthread_t</span> thread;</span><br><span class="line">            reinit_running = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (pthread_create(&amp;thread, &amp;attr, reinit_thread_start, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">                reinit_running = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> auditd =</span><br><span class="line">        __android_logger_property_get_bool(<span class="string">"ro.logd.auditd"</span>, BOOL_DEFAULT_TRUE);</span><br><span class="line">    <span class="keyword">if</span> (drop_privs(klogd, auditd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serves the purpose of managing the last logs times read on a</span></span><br><span class="line">    <span class="comment">// socket connection, and as a reader lock on a range of log</span></span><br><span class="line">    <span class="comment">// entries.</span></span><br><span class="line"></span><br><span class="line">    LastLogTimes* times = <span class="keyword">new</span> LastLogTimes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogBuffer is the object which is responsible for holding all</span></span><br><span class="line">    <span class="comment">// log entries.</span></span><br><span class="line"></span><br><span class="line">    logBuf = <span class="keyword">new</span> LogBuffer(times);</span><br><span class="line"></span><br><span class="line">    signal(SIGHUP, reinit_signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__android_logger_property_get_bool(</span><br><span class="line">            <span class="string">"logd.statistics"</span>, BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_PERSIST |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_ENG |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_SVELTE)) &#123;</span><br><span class="line">        logBuf-&gt;enableStatistics();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogReader listens on /dev/socket/logdr. When a client</span></span><br><span class="line">    <span class="comment">// connects, log entries in the LogBuffer are written to the client.</span></span><br><span class="line"></span><br><span class="line">    LogReader* reader = <span class="keyword">new</span> LogReader(logBuf);</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogListener listens on /dev/socket/logdw for client</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogListener* swl = <span class="keyword">new</span> LogListener(logBuf, reader);</span><br><span class="line">    <span class="comment">// Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value</span></span><br><span class="line">    <span class="keyword">if</span> (swl-&gt;startListener(<span class="number">600</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Command listener listens on /dev/socket/logd for incoming logd</span></span><br><span class="line">    <span class="comment">// administrative commands.</span></span><br><span class="line"></span><br><span class="line">    CommandListener* cl = <span class="keyword">new</span> CommandListener(logBuf, reader, swl);</span><br><span class="line">    <span class="keyword">if</span> (cl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogAudit listens on NETLINK_AUDIT socket for selinux</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogAudit* al = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (auditd) &#123;</span><br><span class="line">        al = <span class="keyword">new</span> LogAudit(logBuf, reader,</span><br><span class="line">                          __android_logger_property_get_bool(</span><br><span class="line">                              <span class="string">"ro.logd.auditd.dmesg"</span>, BOOL_DEFAULT_TRUE)</span><br><span class="line">                              ? fdDmesg</span><br><span class="line">                              : <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogKlog* kl = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        kl = <span class="keyword">new</span> LogKlog(logBuf, reader, fdDmesg, fdPmesg, al != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readDmesg(al, kl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// failure is an option ... messages are in dmesg (required by standard)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kl &amp;&amp; kl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> kl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (al &amp;&amp; al-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> al;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TEMP_FAILURE_RETRY(pause());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="打开-dev-kmsg"><a href="#打开-dev-kmsg" class="headerlink" title="打开 /dev/kmsg"></a>打开 /dev/kmsg</h3><p>前面我们看 init.rc 的时候已经知道，init 进程会为我们打开设备文件 <code>/dev/kmsg</code>，所以这里我们只要找到他对应的文件描述符就可以了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fdDmesg = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> dev_kmsg[] = <span class="string">"/dev/kmsg"</span>;</span><br><span class="line">    fdDmesg = android_get_control_file(dev_kmsg);</span><br><span class="line">    <span class="keyword">if</span> (fdDmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fdDmesg = TEMP_FAILURE_RETRY(open(dev_kmsg, O_WRONLY | O_CLOEXEC));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子进程想要使用父进程为其打开的文件，一般情况下有这么几种方法：</p><ol><li>约定好对应的描述符是多少（比方说，使用 shell 对输入输出进行重定向，就是在 0 1 2 上打开文件）</li><li>通过命令行参数告诉子进程（如，<code>--kmsg 1</code>）</li><li>通过环境变量。这个是 init 进程采用的方法</li></ol><p>下面我们就来看看 <code>android_get_control_file</code> 是如何实现的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libcutils/android_get_control_file.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_FILE_ENV_PREFIX <span class="meta-string">"ANDROID_FILE_"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libcutils/android_get_control_file.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">android_get_control_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = __android_get_control_from_env(ANDROID_FILE_ENV_PREFIX, path);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__)</span></span><br><span class="line">    <span class="comment">// Find file path from /proc and make sure it is correct</span></span><br><span class="line">    <span class="keyword">char</span> *proc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (asprintf(&amp;proc, <span class="string">"/proc/self/fd/%d"</span>, fd) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!proc) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="comment">// readlink() does not guarantee a nul byte, len+2 so we catch truncation.</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(<span class="built_in">calloc</span>(<span class="number">1</span>, len + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">        <span class="built_in">free</span>(proc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">ssize_t</span> ret = TEMP_FAILURE_RETRY(readlink(proc, buf, len + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(proc);</span><br><span class="line">    <span class="keyword">int</span> cmp = (len != <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(ret)) || <span class="built_in">strcmp</span>(buf, path);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmp != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// It is what we think it is</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bionic/libc/include/unistd.h</span></span><br><span class="line"><span class="comment">/* Used to retry syscalls that can return EINTR. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_FAILURE_RETRY(exp) (&#123;         \</span></span><br><span class="line">    __typeof__(<span class="built_in">exp</span>) _rc;                   \</span><br><span class="line">    <span class="keyword">do</span> &#123;                                   \</span><br><span class="line">        _rc = (<span class="built_in">exp</span>);                       \</span><br><span class="line">    &#125; <span class="keyword">while</span> (_rc == <span class="number">-1</span> &amp;&amp; errno == EINTR); \</span><br><span class="line">    _rc; &#125;)</span><br></pre></td></tr></table></figure></p><p><code>__android_get_control_from_env</code> 拿到这个 <code>fd</code> 后，如果运行的系统是 Linux，就执行后面的一些检查。具体来说就是读符号链接 <code>/proc/self/fd/#fd_num</code> 的内容，如果这个内容跟 <code>path</code> 相等，就认为这个描述符确实是我们所需要的。</p><p><code>TEMP_FAILURE_RETRY</code> 在系统的源码里出现的频率很高，主要用来处理系统调动被信号中断的情况。<code>__typeof__</code> 是编译器提供的运算符，类似于 C++ 的 <code>decltype</code>。</p><p>下面我们看看 <code>__android_get_control_from_env</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libcutils/android_get_control_file.cpp</span></span><br><span class="line">LIBCUTILS_HIDDEN <span class="keyword">int</span> __android_get_control_from_env(<span class="keyword">const</span> <span class="keyword">char</span>* prefix,</span><br><span class="line">                                                    <span class="keyword">const</span> <span class="keyword">char</span>* name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prefix || !name) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *key = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (asprintf(&amp;key, <span class="string">"%s%s"</span>, prefix, name) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *cp = key;</span><br><span class="line">    <span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(*cp)) *cp = <span class="string">'_'</span>;</span><br><span class="line">        ++cp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* val = getenv(key);</span><br><span class="line">    <span class="built_in">free</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (!val) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> fd = strtol(val, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (errno) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// validity checking</span></span><br><span class="line">    <span class="keyword">if</span> ((fd &lt; <span class="number">0</span>) || (fd &gt; INT_MAX)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since we are inheriting an fd, it could legitimately exceed _SC_OPEN_MAX</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Still open?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(F_GETFD) <span class="comment">// Lowest overhead</span></span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(fcntl(fd, F_GETFD)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(F_GETFL) <span class="comment">// Alternate lowest overhead</span></span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// Hail Mary pass</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(fstat(fd, &amp;s)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面我们传入的的 <code>ANDROID_FILE_</code> 和 <code>/dev/kmsg</code>，这里我们把他们拼接起来得到 <code>ANDROID_FILE_/dev/kmsg</code>。随后的循环把不是字母、数字的字符换成 <code>_</code>，最后这个 key 是 <code>ANDROID_FILE__dev_kmsg</code>。</p><p>我们拿这个 key 去 <code>getenv</code>，如果存在这个环境变量，就调用 <code>strtol</code> 将其转换为 <code>long</code>。所谓的文件描述符，其实仅仅是一个数字。这里将 <code>val</code> 转换为 <code>long</code>，我们也就拿到了文件对应的 fd。</p><p>拿到这个 fd 后，还要验证一下它是不是还打开着。这里使用的方法是用 <code>fcntl</code> 去获取一下 fd flag。如果成功，文件自然是打开着的。</p><p>获取 fd flag 一般只需要访问文件表，所以是最快的；获取 file flag 要通过文件表去拿 file 对象，这个慢一点；而  file stat 则需要再通过 file 对象拿到 inode 节点的数据，这个是最慢的。</p><p>我们直接通过环境变量取得描述符，这并不能保证它就是我们所期望的文件（比方说，可以先关掉这个 fd，然后再打开任意一个文件，新打开的文件 fd 的数值将会和我们刚刚关闭的那个一样），所以在 <code>android_get_control_file</code> 里还要用 <code>/proc/self/fd/##</code> 验证多一次。</p><p><code>/dev/kmsg</code> 设备文件是用来读写内核 log 的，有兴趣的读者可以参考文档 <a href="https://www.kernel.org/doc/Documentation/ABI/testing/dev-kmsg" target="_blank" rel="noopener">dev-kmsg</a>。logd 本身提供的就是 log 机制，但在自己还没启动完成或者出错的时候，如果需要写 log，就只能写到内核的 log 去了。</p><h3 id="打开-proc-kmsg"><a href="#打开-proc-kmsg" class="headerlink" title="打开 /proc/kmsg"></a>打开 /proc/kmsg</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fdPmesg = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> klogd = __android_logger_property_get_bool(</span><br><span class="line">        <span class="string">"ro.logd.kernel"</span>,</span><br><span class="line">        BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_ENG | BOOL_DEFAULT_FLAG_SVELTE);</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> proc_kmsg[] = <span class="string">"/proc/kmsg"</span>;</span><br><span class="line">        fdPmesg = android_get_control_file(proc_kmsg);</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fdPmesg = TEMP_FAILURE_RETRY(</span><br><span class="line">                open(proc_kmsg, O_RDONLY | O_NDELAY | O_CLOEXEC));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) android::prdebug(<span class="string">"Failed to open %s\n"</span>, proc_kmsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开 <code>/proc/kmsg</code> 是为了读内核的日志，但这个是可选的，这里我们通过读系统属性来判断是否需要读内核的日志。</p><h3 id="启动-reinit-线程"><a href="#启动-reinit-线程" class="headerlink" title="启动 reinit 线程"></a>启动 reinit 线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line">    <span class="comment">// open /proc/kmsg</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reinit Thread</span></span><br><span class="line">    sem_init(&amp;reinit, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;uidName, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_name, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">if</span> (!pthread_attr_init(&amp;attr)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(param));</span><br><span class="line">        pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line">        pthread_attr_setschedpolicy(&amp;attr, SCHED_BATCH);</span><br><span class="line">        <span class="keyword">if</span> (!pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED)) &#123;</span><br><span class="line">            <span class="keyword">pthread_t</span> thread;</span><br><span class="line">            reinit_running = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (pthread_create(&amp;thread, &amp;attr, reinit_thread_start, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">                reinit_running = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reinit 线程主要处理最开始时前面我们提到了 reinit 命令。另外，logd 还使用这个线程做 uid 转 name 的工作。关于他的实现，后面我们讲 logd 的管理接口时再看。</p><h3 id="设置运行时优先级、权限"><a href="#设置运行时优先级、权限" class="headerlink" title="设置运行时优先级、权限"></a>设置运行时优先级、权限</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line">    <span class="comment">// open /proc/kmsg</span></span><br><span class="line">    <span class="comment">// 启动 Reinit Thread</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> auditd =</span><br><span class="line">        __android_logger_property_get_bool(<span class="string">"ro.logd.auditd"</span>, BOOL_DEFAULT_TRUE);</span><br><span class="line">    <span class="keyword">if</span> (drop_privs(klogd, auditd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分代码跟平台相关性比较大，普通的应用开发一般不会使用到这些。这部分我们这里先略过，后面用单独的一篇文章来讲。</p><h3 id="启动各个-log-监听器"><a href="#启动各个-log-监听器" class="headerlink" title="启动各个 log 监听器"></a>启动各个 log 监听器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line">    <span class="comment">// open /proc/kmsg</span></span><br><span class="line">    <span class="comment">// 启动 Reinit Thread</span></span><br><span class="line">    <span class="comment">// 设置运行时优先级、权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serves the purpose of managing the last logs times read on a</span></span><br><span class="line">    <span class="comment">// socket connection, and as a reader lock on a range of log</span></span><br><span class="line">    <span class="comment">// entries.</span></span><br><span class="line"></span><br><span class="line">    LastLogTimes* times = <span class="keyword">new</span> LastLogTimes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogBuffer is the object which is responsible for holding all</span></span><br><span class="line">    <span class="comment">// log entries.</span></span><br><span class="line"></span><br><span class="line">    logBuf = <span class="keyword">new</span> LogBuffer(times);</span><br><span class="line"></span><br><span class="line">    signal(SIGHUP, reinit_signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__android_logger_property_get_bool(</span><br><span class="line">            <span class="string">"logd.statistics"</span>, BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_PERSIST |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_ENG |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_SVELTE)) &#123;</span><br><span class="line">        logBuf-&gt;enableStatistics();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogReader listens on /dev/socket/logdr. When a client</span></span><br><span class="line">    <span class="comment">// connects, log entries in the LogBuffer are written to the client.</span></span><br><span class="line"></span><br><span class="line">    LogReader* reader = <span class="keyword">new</span> LogReader(logBuf);</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogListener listens on /dev/socket/logdw for client</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogListener* swl = <span class="keyword">new</span> LogListener(logBuf, reader);</span><br><span class="line">    <span class="comment">// Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value</span></span><br><span class="line">    <span class="keyword">if</span> (swl-&gt;startListener(<span class="number">600</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Command listener listens on /dev/socket/logd for incoming logd</span></span><br><span class="line">    <span class="comment">// administrative commands.</span></span><br><span class="line"></span><br><span class="line">    CommandListener* cl = <span class="keyword">new</span> CommandListener(logBuf, reader, swl);</span><br><span class="line">    <span class="keyword">if</span> (cl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogAudit listens on NETLINK_AUDIT socket for selinux</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogAudit* al = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (auditd) &#123;</span><br><span class="line">        al = <span class="keyword">new</span> LogAudit(logBuf, reader,</span><br><span class="line">                          __android_logger_property_get_bool(</span><br><span class="line">                              <span class="string">"ro.logd.auditd.dmesg"</span>, BOOL_DEFAULT_TRUE)</span><br><span class="line">                              ? fdDmesg</span><br><span class="line">                              : <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogKlog* kl = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        kl = <span class="keyword">new</span> LogKlog(logBuf, reader, fdDmesg, fdPmesg, al != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readDmesg(al, kl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// failure is an option ... messages are in dmesg (required by standard)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kl &amp;&amp; kl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> kl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (al &amp;&amp; al-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> al;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TEMP_FAILURE_RETRY(pause());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的这些代码实现上算是非常直观的，各个类的作用也都通过注释写得很清楚。<code>LogAudit</code> 读的是 selinux 的 log，<code>LogKlog</code> 读的是内核的 log，<code>readDmsg</code> 用 <code>klogctl</code> 把内核的 log 读出来以后，又把数据通过 <code>LogAudit</code> 和 <code>LogKlog</code> 写到由 logd 管理的 <code>LogBuffer</code> 里面。这两个我都不太熟悉，后面我们先就直接忽略他了。哪天补上了相关知识点，有机会再来写多两篇。</p><p>到目前为止，我们算是了解了 logd 的骨架，后面我们再分 4 篇文章，分别写 Linux 的权限控制、logd 命令控制、读 log 写 log。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了跟老罗的书保持一个相对一致的步伐，这一篇开始我们来看 logd 的实现。当然，这个 logd 不是老罗书里讲的 log 驱动，而是在应用层实现的一个守护进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
  </entry>
  
  <entry>
    <title>Android P 源码分析 3 - SharedPreferences 源码分析</title>
    <link href="https://jekton.github.io/2019/03/19/android9-sp/"/>
    <id>https://jekton.github.io/2019/03/19/android9-sp/</id>
    <published>2019-03-19T11:30:50.000Z</published>
    <updated>2019-03-19T02:14:55.836Z</updated>
    
    <content type="html"><![CDATA[<p>本来按顺序这一篇应该是 logd，但突然有点好奇 SP 在保存数据的时候是怎么同步的，就还是先看 SP 吧，当做在开始啃 logd 这个硬骨头前轻松一下（虽然这么说，SP 还是有很多值得我们学习的地方的）。</p><a id="more"></a><h2 id="获取-SP-实例"><a href="#获取-SP-实例" class="headerlink" title="获取 SP 实例"></a>获取 SP 实例</h2><p>我们通过调用 <code>Context.getSharedPreferences</code> 获取一个 SharedPreferences 实例的时候，真正的实现在 <code>ContextImpl</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(String name, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// At least one application in the world actually passes in a null</span></span><br><span class="line">    <span class="comment">// name.  This happened to work because when we generated the file name</span></span><br><span class="line">    <span class="comment">// we would stringify it to "null.xml".  Nice.</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">            Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = <span class="string">"null"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File file;</span><br><span class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSharedPrefsPaths == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSharedPrefsPaths = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        file = mSharedPrefsPaths.get(name);</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">            file = getSharedPreferencesPath(name);</span><br><span class="line">            mSharedPrefsPaths.put(name, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(File file, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">        sp = cache.get(file);</span><br><span class="line">        <span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkMode(mode);</span><br><span class="line">            <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isCredentialProtectedStorage()</span><br><span class="line">                        &amp;&amp; !getSystemService(UserManager.class)</span><br><span class="line">                                .isUserUnlockingOrUnlocked(UserHandle.myUserId())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"SharedPreferences in credential encrypted "</span></span><br><span class="line">                            + <span class="string">"storage are not available until after user is unlocked"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sp = <span class="keyword">new</span> SharedPreferencesImpl(file, mode);</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="comment">// If somebody else (some other process) changed the prefs</span></span><br><span class="line">        <span class="comment">// file behind our back, we reload it.  This has been the</span></span><br><span class="line">        <span class="comment">// historical (if undocumented) behavior.</span></span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map from package name, to preference name, to cached preferences.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"ContextImpl.class"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"ContextImpl.class"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; <span class="title">getSharedPreferencesCacheLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sSharedPrefsCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sSharedPrefsCache = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String packageName = getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);</span><br><span class="line">    <span class="keyword">if</span> (packagePrefs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        packagePrefs = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这三个方法的实现都相当的直观，唯一有趣的是 <code>getSharedPreferencesCacheLocked</code> 里面那个 <code>packageName</code>。我们知道，一个应用的包名并不会改变；在访问内存中数据时，不同进程也不会互相干扰。这样看来，用 packageName 做 key 的这个 <code>sSharedPrefsCache</code> 是否有点多余？</p><p>通过查看 git 提交记录 <code>8e3ddab</code> 可以看到这样一句说明：</p><blockquote><p>Otherwise multiple applications using the same process can end up leaking SharedPreferences instances between the apps</p></blockquote><p>其实 Android 有一个相当不常用的特性——多个应用可以共用同一个进程。在这种情况下，这里用 package name 就能够把各个应用的 SP 区分开。</p><p>这里的实现还隐含了 SP 的一个特性：一旦数据加载到内存，除非我们删除整个 SP，内存中的数据在整个进程的生命周期中都存在。正常情况下，SP 中的数据量是非常小的，这个并不会导致什么问题。</p><h2 id="SP-的初始化"><a href="#SP-的初始化" class="headerlink" title="SP 的初始化"></a>SP 的初始化</h2><p>还是跟前面一样，我们直接看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/core/java/android/app/SharedPreferencesImpl.java</span></span><br><span class="line">SharedPreferencesImpl(File file, <span class="keyword">int</span> mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    mMode = mode;</span><br><span class="line">    mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    mMap = <span class="keyword">null</span>;</span><br><span class="line">    mThrowable = <span class="keyword">null</span>;</span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startLoadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"SharedPreferencesImpl-load"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，SP 一创建就开始在后台加载数据了。利用这个特性，对于比较大的 SP 并且预期很快就要用到，可以提前获取 SP 实例，以触发他的初始化。这样一来，在随后我们真正需要读取里面的数据时，他很可能就已经加载完成，从而避免了第一次读取时的卡顿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLoaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debugging</span></span><br><span class="line">    <span class="keyword">if</span> (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempt to read preferences file "</span> + mFile + <span class="string">" without permission"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">null</span>;</span><br><span class="line">    StructStat stat = <span class="keyword">null</span>;</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        <span class="keyword">if</span> (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                str = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(mFile), <span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">                map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Cannot read "</span> + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">        <span class="comment">// An errno exception means the stat failed. Treat as empty/non-existing by</span></span><br><span class="line">        <span class="comment">// ignoring.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="keyword">true</span>;</span><br><span class="line">        mThrowable = thrown;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It's important that we always signal waiters, even if we'll make</span></span><br><span class="line">        <span class="comment">// them fail with an exception. The try-finally is pretty wide, but</span></span><br><span class="line">        <span class="comment">// better safe than sorry.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (thrown == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mMap = map;</span><br><span class="line">                    <span class="comment">// 文件的最后修改时间</span></span><br><span class="line">                    mStatTimestamp = stat.st_mtim;</span><br><span class="line">                    <span class="comment">// 文件大小</span></span><br><span class="line">                    mStatSize = stat.st_size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// In case of a thrown exception, we retain the old map. That allows</span></span><br><span class="line">            <span class="comment">// any open editors to commit and store updates.</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            mThrowable = t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Os.stat</code> 用来获取文件的元信息，它不是 JDK 提供的 API。关于它的实现，有兴趣的读者可以参考《UNIX 环境高级编程》（APUE）。</p><p>XML 的解析并不是我们关心的东西，只要知道 SP 是用 XML 文件存储的就好。</p><p>加载成功后的 <code>notifyAll</code> 我们要结合 <code>awaitLoadedLocked</code> 来看。在我们准备读、写 SP 的时候，都会先调用 <code>awaitLoadedLocked</code> 等待 <code>loadFromDisk</code>。<code>loadFromDisk</code> 最后的 <code>notifyAll</code> 就是为了唤醒这些等待数据加载完成的线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="comment">// Raise an explicit StrictMode onReadFromDisk for this</span></span><br><span class="line">        <span class="comment">// thread, since the real read will be in a different</span></span><br><span class="line">        <span class="comment">// thread and otherwise ignored by StrictMode.</span></span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mThrowable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(mThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>mThrowable</code> 是在数据加载失败时由 <code>loadFromDisk</code> 设置的。这里相当于把后台的数据加载线程发生的异常转移到了实际需要读写 SP 的线程，有一定的借鉴的意义。</p><h2 id="从-SP-中读取数据"><a href="#从-SP-中读取数据" class="headerlink" title="从 SP 中读取数据"></a>从 SP 中读取数据</h2><p>读数据的情况很简单，只需要等 <code>loadFromDisk</code> 加载完数据，然后直接从 map 里面 get 就可以了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key, @Nullable String defValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.get(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读其他类型的情况类似，这里就不看了。</p><h2 id="向-SP-写入数据"><a href="#向-SP-写入数据" class="headerlink" title="向 SP 写入数据"></a>向 SP 写入数据</h2><p>写数据的时候，我们要先获取一个 <code>Editor</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> remove the need to call awaitLoadedLocked() when</span></span><br><span class="line">    <span class="comment">// requesting an editor.  will require some work on the</span></span><br><span class="line">    <span class="comment">// Editor, but then we should be able to do:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      context.getSharedPreferences(..).edit().putString(..).apply()</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// ... all without blocking.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EditorImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mEditorLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"mEditorLock"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; mModified = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"mEditorLock"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mClear = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Editor <span class="title">putString</span><span class="params">(String key, @Nullable String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            mModified.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Editor <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            mModified.put(key, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Editor <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            mClear = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>EditorImpl</code> 把所有的修改都保存在成员变量 <code>mModified</code> 和 <code>mClear</code> 里，以达到批量修改的目的。下面我们看看他的 <code>apply</code> 方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">        <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        mcr.writtenToDiskLatch.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                        Log.d(TAG, mFile.getName() + <span class="string">":"</span> + mcr.memoryStateGeneration</span><br><span class="line">                                + <span class="string">" applied after "</span> + (System.currentTimeMillis() - startTime)</span><br><span class="line">                                + <span class="string">" ms"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">        Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    awaitCommit.run();</span><br><span class="line">                    QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Okay to notify the listeners before it's hit disk</span></span><br><span class="line">        <span class="comment">// because the listeners should always get the same</span></span><br><span class="line">        <span class="comment">// SharedPreferences instance back, which has the</span></span><br><span class="line">        <span class="comment">// changes reflected in memory.</span></span><br><span class="line">        notifyListeners(mcr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里分是三个步骤：</p><ol><li>把修改写到内存的缓存里</li><li>把修改写到硬盘（文件）</li><li>通知监听者</li></ol><p>下面我们一个一个步骤来看：</p><h3 id="把修改写到内存的缓存里"><a href="#把修改写到内存的缓存里" class="headerlink" title="把修改写到内存的缓存里"></a>把修改写到内存的缓存里</h3><p>这一步是由 <code>commitToMemory</code> 实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true if any changes were made</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MemoryCommitResult <span class="title">commitToMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> memoryStateGeneration;</span><br><span class="line">        List&lt;String&gt; keysModified = <span class="keyword">null</span>;</span><br><span class="line">        Set&lt;OnSharedPreferenceChangeListener&gt; listeners = <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (SharedPreferencesImpl.<span class="keyword">this</span>.mLock) &#123;</span><br><span class="line">            <span class="comment">// We optimistically don't make a deep copy until</span></span><br><span class="line">            <span class="comment">// a memory commit comes in when we're already</span></span><br><span class="line">            <span class="comment">// writing to disk.</span></span><br><span class="line">            <span class="keyword">if</span> (mDiskWritesInFlight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// We can't modify our mMap as a currently</span></span><br><span class="line">                <span class="comment">// in-flight write owns it.  Clone it before</span></span><br><span class="line">                <span class="comment">// modifying it.</span></span><br><span class="line">                <span class="comment">// noinspection unchecked</span></span><br><span class="line">                mMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(mMap);</span><br><span class="line">            &#125;</span><br><span class="line">            mapToWriteToDisk = mMap;</span><br><span class="line">            mDiskWritesInFlight++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> hasListeners = mListeners.size() &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">                keysModified = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                listeners = <span class="keyword">new</span> HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> changesMade = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mClear) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mapToWriteToDisk.isEmpty()) &#123;</span><br><span class="line">                        changesMade = <span class="keyword">true</span>;</span><br><span class="line">                        mapToWriteToDisk.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mClear = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">                    String k = e.getKey();</span><br><span class="line">                    Object v = e.getValue();</span><br><span class="line">                    <span class="comment">// "this" is the magic value for a removal mutation. In addition,</span></span><br><span class="line">                    <span class="comment">// setting a value to "null" for a given key is specified to be</span></span><br><span class="line">                    <span class="comment">// equivalent to calling remove on that key.</span></span><br><span class="line">                    <span class="keyword">if</span> (v == <span class="keyword">this</span> || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mapToWriteToDisk.remove(k);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                            Object existingValue = mapToWriteToDisk.get(k);</span><br><span class="line">                            <span class="keyword">if</span> (existingValue != <span class="keyword">null</span> &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mapToWriteToDisk.put(k, v);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    changesMade = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">                        keysModified.add(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mModified.clear();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (changesMade) &#123;</span><br><span class="line">                    mCurrentMemoryStateGeneration++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                memoryStateGeneration = mCurrentMemoryStateGeneration;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MemoryCommitResult(memoryStateGeneration, keysModified, listeners,</span><br><span class="line">                mapToWriteToDisk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>mDiskWritesInFlight</code> 是 <code>SharedPreferencesImpl</code> 的成员变量，表示当前有多少个正着执行中的硬盘写操作。如果我们不是唯一的写者，表示在前面有某个写操作正把 <code>mMap</code> 的内容写到硬盘。此时我们不能直接修改 <code>mMap</code>，否则硬盘的数据的一致性会有问题（比方说，部分 key 是旧的，部分是新的）。拷贝一份 <code>mMap</code> 后，我们就可以安全地进行修改了。</p><p>SP 提供了一个 <code>registerOnSharedPreferenceChangeListener</code> 方法，通过它我们可以注册监听器，在 SP 修改的时候得到通知。相关的 listener 就放在 <code>mListener</code> 里。</p><p>我们可以把这个方法里的 <code>mapToWriteToDisk</code> 看做是 SP 的一个快照（snapshot）， <code>SharedPreferencesImpl::mCurrentMemoryStateGeneration</code> 用来跟踪这些快照的年龄。当我们往文件里面写入数据的时候，只有年龄最大（数据最新）的那一个快照才需要写到硬盘里（旧的数据即使写了进入，也马上会被覆盖）。关于这一点，在后面我们看 <code>writeToFile</code> 实现的时候就知道了。</p><p>方法最后返回的 <code>MemoryCommitResult</code> 就很简单了，只是一些数据的聚集：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return value from EditorImpl#commitToMemory()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCommitResult</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> memoryStateGeneration;</span><br><span class="line">    <span class="meta">@Nullable</span> <span class="keyword">final</span> List&lt;String&gt; keysModified;</span><br><span class="line">    <span class="meta">@Nullable</span> <span class="keyword">final</span> Set&lt;OnSharedPreferenceChangeListener&gt; listeners;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch writtenToDiskLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"mWritingToDiskLock"</span>)</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> writeToDiskResult = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> wasWritten = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MemoryCommitResult</span><span class="params">(<span class="keyword">long</span> memoryStateGeneration, @Nullable List&lt;String&gt; keysModified,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Set&lt;OnSharedPreferenceChangeListener&gt; listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String, Object&gt; mapToWriteToDisk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memoryStateGeneration = memoryStateGeneration;</span><br><span class="line">        <span class="keyword">this</span>.keysModified = keysModified;</span><br><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br><span class="line">        <span class="keyword">this</span>.mapToWriteToDisk = mapToWriteToDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDiskWriteResult</span><span class="params">(<span class="keyword">boolean</span> wasWritten, <span class="keyword">boolean</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wasWritten = wasWritten;</span><br><span class="line">        writeToDiskResult = result;</span><br><span class="line">        writtenToDiskLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="把修改写到硬盘（文件）"><a href="#把修改写到硬盘（文件）" class="headerlink" title="把修改写到硬盘（文件）"></a>把修改写到硬盘（文件）</h3><p>为了帮助你回忆 <code>apply</code> 的工作，这里我再拷贝一份他的源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay to notify the listeners before it's hit disk</span></span><br><span class="line">    <span class="comment">// because the listeners should always get the same</span></span><br><span class="line">    <span class="comment">// SharedPreferences instance back, which has the</span></span><br><span class="line">    <span class="comment">// changes reflected in memory.</span></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>QueuedWork</code> 是一个全局的工作队列，<code>addFinisher</code> 添加进去的 runnable 不会立即执行，仅仅是放到一个链表里。当某个人想要等待 <code>QueuedWork</code> 所有工作执行完毕时，就调用 <code>QueuedWork.waitToFinish()</code>，在这个方法里面会取出早先所有 <code>addFinisher</code> 的任务，一个一个执行。</p><p>在 <code>awaitCommit</code> 里面，我们调用了 <code>mcr.writtenToDiskLatch.await()</code> 来等待数据写入硬盘，所以这里的把 <code>awaitCommit</code> 放到 <code>QueuedWork</code> 里，就提供了一种机制，让外界等待文件的写入操作。读者可以到 <code>ActivityThread</code> 中搜一下 <code>QueuedWork.waitToFinish</code>，会发现在 activity/service stop 的时候，都会执行这个操作，从而保证在应用退出前 SP 已经写入硬盘。</p><p>接下来的 <code>enqueueDiskWrite</code> 执行真正的写入操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue an already-committed-to-memory result to be written</span></span><br><span class="line"><span class="comment"> * to disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * They will be written to disk one-at-a-time in the order</span></span><br><span class="line"><span class="comment"> * that they're enqueued.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> postWriteRunnable if non-null, we're being called</span></span><br><span class="line"><span class="comment"> *   from apply() and this is the runnable to run after</span></span><br><span class="line"><span class="comment"> *   the write proceeds.  if null (from a regular commit()),</span></span><br><span class="line"><span class="comment"> *   then we're allowed to do this disk write on the main</span></span><br><span class="line"><span class="comment"> *   thread (which in addition to reducing allocations and</span></span><br><span class="line"><span class="comment"> *   creating a background thread, this has the advantage that</span></span><br><span class="line"><span class="comment"> *   we catch them in userdebug StrictMode reports to convert</span></span><br><span class="line"><span class="comment"> *   them where possible to apply() ...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> Runnable postWriteRunnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Typical #commit() path with fewer allocations, doing a write on</span></span><br><span class="line">    <span class="comment">// the current thread.</span></span><br><span class="line">    <span class="keyword">if</span> (isFromSyncCommit) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> wasEmpty = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>isFromSyncCommit</code> 是我们直接调用 <code>editor.commit</code> 的情况，这个时候如果我们是唯一的写者（writter），就直接调用 <code>writeToDiskRunnable.run()</code> 执行写入操作。其他情况下，都放到 <code>QueuedWork</code> 里面执行。</p><p><code>QueuedWork</code> 在内部使用一个 <code>HandlerThread</code> 串行地执行所有的工作，<code>queue()</code> 后的任务都会被 post 到这个线程去执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueuedWork</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queue a work-runnable for processing asynchronously.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> work The new runnable to process</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shouldDelay If the message should be delayed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">(Runnable work, <span class="keyword">boolean</span> shouldDelay)</span> </span>&#123;</span><br><span class="line">        Handler handler = getHandler();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            sWork.add(work);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldDelay &amp;&amp; sCanDelay) &#123;</span><br><span class="line">                handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对 <code>editor.apply()</code> 而言，这里的 <code>shouldDelay</code> 参数为 <code>true</code>，实际的写入操作会延迟 100 毫秒才执行。接下来看完 <code>writeToFile</code> 的实现以后，我们就会发现，这个小小的延迟在频繁 <code>editor.apply</code> 的时候实际上有一定优化作用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mWritingToDiskLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(MemoryCommitResult mcr, <span class="keyword">boolean</span> isFromSyncCommit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> existsTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> backupExistsTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> outputStreamCreateTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> writeTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> fsyncTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> setPermTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> fstatTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> deleteTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> fileExists = mFile.exists();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rename the current file so it may be used as a backup during the next read</span></span><br><span class="line">    <span class="keyword">if</span> (fileExists) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> needsWrite = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only need to write if the disk state is older than this commit</span></span><br><span class="line">        <span class="keyword">if</span> (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFromSyncCommit) &#123;</span><br><span class="line">                needsWrite = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="comment">// No need to persist intermediate states. Just wait for the latest state to</span></span><br><span class="line">                    <span class="comment">// be persisted.</span></span><br><span class="line">                    <span class="keyword">if</span> (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123;</span><br><span class="line">                        needsWrite = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!needsWrite) &#123;</span><br><span class="line">            mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> backupFileExists = mBackupFile.exists();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            backupExistsTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!backupFileExists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Couldn't rename file "</span> + mFile</span><br><span class="line">                      + <span class="string">" to backup file "</span> + mBackupFile);</span><br><span class="line">                mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attempt to write the file, delete the backup and return true as atomically as</span></span><br><span class="line">    <span class="comment">// possible.  If any exception occurs, delete the new file; next time we will restore</span></span><br><span class="line">    <span class="comment">// from the backup.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            outputStreamCreateTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line"></span><br><span class="line">        writeTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        FileUtils.sync(str);</span><br><span class="line"></span><br><span class="line">        fsyncTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        str.close();</span><br><span class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            setPermTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> StructStat stat = Os.stat(mFile.getPath());</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                mStatTimestamp = stat.st_mtim;</span><br><span class="line">                mStatSize = stat.st_size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            fstatTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Writing was successful, delete the backup file if there is one.</span></span><br><span class="line">        mBackupFile.delete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            deleteTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDiskStateGeneration = mcr.memoryStateGeneration;</span><br><span class="line"></span><br><span class="line">        mcr.setDiskWriteResult(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"write: "</span> + (existsTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (backupExistsTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (outputStreamCreateTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (writeTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (fsyncTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (setPermTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (fstatTime - startTime) + <span class="string">"/"</span></span><br><span class="line">                    + (deleteTime - startTime));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> fsyncDuration = fsyncTime - writeTime;</span><br><span class="line">        mSyncTimes.add((<span class="keyword">int</span>) fsyncDuration);</span><br><span class="line">        mNumSync++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG || mNumSync % <span class="number">1024</span> == <span class="number">0</span> || fsyncDuration &gt; MAX_FSYNC_DURATION_MILLIS) &#123;</span><br><span class="line">            mSyncTimes.log(TAG, <span class="string">"Time required to fsync "</span> + mFile + <span class="string">": "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"writeToFile: Got exception:"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up an unsuccessfully written file</span></span><br><span class="line">    <span class="keyword">if</span> (mFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFile.delete()) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Couldn't clean up partially-written file "</span> + mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们看看 <code>needsWrite</code> 中 <code>mCurrentMemoryStateGeneration == mcr.memoryStateGeneration</code> 的情况，这个代码当前的快照是最新的，所以需要写入硬盘。之所以单独拿这个出来说，是为了说明前面 <code>QueuedWork.queue()</code> 里面那个 delay 所起到的作用。由于我们用的是异步的 <code>editor.apply</code>，所以这个延迟是隐含在 API 里的，还在正确的语义范畴里；另一方面，考虑应用频繁 <code>apply</code> 的情况，如果前后的 apply 间隔小于 100 毫秒，那么这个条件判断只在最后的写任务会为 <code>true</code>，从而避免了过多的无用的写硬盘操作。</p><p>最后我们看看 <code>mBackupFile</code> 的作用。在开头的 <code>loadFromDisk</code> 有这么一小段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果备份文件存在，我们就把 <code>mFile</code> 删除，然后读备份文件的数据。</p><p>为了考察这个备份文件的作用，我们先假设 SP 是刚刚创建的，此时备份文件不存在，<code>writeToDisk</code> 先把 <code>mFile</code> 保存一个备份，然后往 <code>mFile</code> 写数据。在写数据成功的情况下，我们再删除前面的那个备份，此时只有 <code>mFile</code> 存在。</p><p>另一种可能性是，我们在写 <code>mFile</code> 的时候失败了，此时 <code>mFile</code> 里面是一些垃圾数据，而备份文件 <code>mBackupFile</code> 是我们在这个失败的写操作之前保存的，虽然它的信息不是最新的，却是完整的数据。在这种情况下，<code>loadFromDisk</code> 会加载备份文件的数据。</p><p>最后一种情况是我们在准备写数据的时候备份文件存在，这种只在前一次写文件失败的时候才会发生。此时 <code>mFile</code> 无疑是错误的，所以我们直接删掉它。</p><h3 id="通知监听者"><a href="#通知监听者" class="headerlink" title="通知监听者"></a>通知监听者</h3><p>虽然文章已经很长，处于完整性考虑，还是把 <code>notifyListeners</code> 的代码也一起放上来。这里的实现很简单，我就不多说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mcr.listeners == <span class="keyword">null</span> || mcr.keysModified == <span class="keyword">null</span> ||</span><br><span class="line">            mcr.keysModified.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mcr.keysModified.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> String key = mcr.keysModified.get(i);</span><br><span class="line">                <span class="keyword">for</span> (OnSharedPreferenceChangeListener listener : mcr.listeners) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.onSharedPreferenceChanged(SharedPreferencesImpl.<span class="keyword">this</span>, key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Run this function on the main thread.</span></span><br><span class="line">            ActivityThread.sMainThreadHandler.post(() -&gt; notifyListeners(mcr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来按顺序这一篇应该是 logd，但突然有点好奇 SP 在保存数据的时候是怎么同步的，就还是先看 SP 吧，当做在开始啃 logd 这个硬骨头前轻松一下（虽然这么说，SP 还是有很多值得我们学习的地方的）。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
  </entry>
  
  <entry>
    <title>Android P 源码分析 2 - 强弱指针的实现</title>
    <link href="https://jekton.github.io/2019/03/12/android9-sp-wp/"/>
    <id>https://jekton.github.io/2019/03/12/android9-sp-wp/</id>
    <published>2019-03-12T01:01:01.000Z</published>
    <updated>2019-03-18T11:38:29.179Z</updated>
    
    <content type="html"><![CDATA[<p>继上篇我们学习了 Android 轻量级指针的实现，是时候来看“重量级”指针的实现了。在 Android 里，“重量级”指针指的是 <code>RefBase</code> 和 <code>sp/wp</code> 配合使用的情况，它提供了完整的强、弱指针的支持。</p><a id="more"></a><p>考虑这样一种情况，A 持有 B，B 持有 A，C 持有 A。如果只使用简单的引用计数，在 C 释放 A 后，A、B 各自的计数值都为 1，永远不会被销毁，也无法再访问。这就是经典的循环引用问题。</p><p>引入弱指针后，我们可以让 A 持有 B 的强指针，而 B 指持有 A 的弱指针。这样一来，在 C 释放 A 后，A 的引用计数将降为 0 从而被销魂；A 销毁的同时，A 所持有的 B 的强指针也会销毁，于是 B 的引用计数也降为 0，B 被销毁。</p><p>了解了这些基础知识后，下面我们就来看看 <code>RefBase</code> 的源码</p><h2 id="RefBase"><a href="#RefBase" class="headerlink" title="RefBase"></a>RefBase</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>这里我先把 <code>RefBase</code> 的定义摆上来，后面我们捡最重要的几个看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/RefBase.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">forceIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//! DEBUGGING ONLY: Get current strong ref count.</span></span><br><span class="line">            <span class="keyword">int32_t</span>         getStrongCount() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">weakref_type</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">RefBase*            <span class="title">refBase</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">incWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">decWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquires a strong reference if there is already one.</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquires a weak reference if there is already one.</span></span><br><span class="line">        <span class="comment">// This is not always safe. see ProcessState.cpp and BpBinder.cpp</span></span><br><span class="line">        <span class="comment">// for proper use.</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! DEBUGGING ONLY: Get current weak ref count.</span></span><br><span class="line">        <span class="keyword">int32_t</span>             getWeakCount() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! DEBUGGING ONLY: Print references held on object.</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! DEBUGGING ONLY: Enable tracking for this object.</span></span><br><span class="line">        <span class="comment">// enable -- enable/disable tracking</span></span><br><span class="line">        <span class="comment">// retain -- when tracking is enable, if true, then we save a stack trace</span></span><br><span class="line">        <span class="comment">//           for each reference and dereference; when retain == false, we</span></span><br><span class="line">        <span class="comment">//           match up references and dereferences and keep only the</span></span><br><span class="line">        <span class="comment">//           outstanding ones.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span> enable, <span class="keyword">bool</span> retain)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">weakref_type*   <span class="title">createWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="function">weakref_type*   <span class="title">getWeakRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//! DEBUGGING ONLY: Print references held on object.</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  <span class="keyword">void</span>            <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; getWeakRefs()-&gt;printRefs(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//! DEBUGGING ONLY: Enable tracking of object.</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  <span class="keyword">void</span>            <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span> enable, <span class="keyword">bool</span> retain)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        getWeakRefs()-&gt;trackMe(enable, retain); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RefBase basetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">                            RefBase();</span><br><span class="line">    <span class="keyword">virtual</span>                 ~RefBase();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">        OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">extendObjectLifetime</span><span class="params">(<span class="keyword">int32_t</span> mode)</span></span>;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//! Flags for onIncStrongAttempted()</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        FIRST_INC_STRONG = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Invoked after creation of initial strong pointer/reference.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Invoked when either the last strong reference goes away, or we need to undo</span></span><br><span class="line">    <span class="comment">// the effect of an unnecessary onIncStrongAttempted.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="comment">// Only called in OBJECT_LIFETIME_WEAK case.  Returns true if OK to promote to</span></span><br><span class="line">    <span class="comment">// strong reference. May have side effects if it returns true.</span></span><br><span class="line">    <span class="comment">// The first flags argument is always FIRST_INC_STRONG.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Remove initial flag argument.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(<span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="comment">// Invoked in the OBJECT_LIFETIME_WEAK case when the last reference of either</span></span><br><span class="line">    <span class="comment">// kind goes away.  Unused.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Remove.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">weakref_type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">weakref_impl</span>;</span></span><br><span class="line">    </span><br><span class="line">                            RefBase(<span class="keyword">const</span> RefBase&amp; o);</span><br><span class="line">            RefBase&amp;        <span class="keyword">operator</span>=(<span class="keyword">const</span> RefBase&amp; o);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        weakref_impl* <span class="keyword">const</span> mRefs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在看他的函数的实现前，我们先对比一下 <code>LightRefBase</code>，看看他们两个有什么不同。首先最明显的是，<code>RefBase</code> 不是一个类模板，这个我们在上篇已经提到了；也因此 <code>RefBase::~RefBase</code> 是一个虚函数。其次，<code>RefBase</code> 还定义了一个 <code>weakref_type</code>，他的真正实现是 <code>weakref_impl</code>，所有的引用计数都记录在 <code>weakref_impl</code> 里。</p><p>好事者这个时候就要问了，为什么 <code>RefBase</code> 不像 <code>LightRefBase</code> 把引用计数直接用成员变量来存储？（人家这么写，肯定是有理由的呀）这里的关键就在弱指针上。当用户持有弱指针的时候，需要提供一种途径，让他尝试转换成强指针。如果把引用计数等信息都存放在 <code>RefBase</code> 里，当对象已经销毁但有弱指针指向它的时候，弱指针就没有信息可以判断是否能够升级为强指针了。现在我们把引用计数都放在 <code>weakref_impl</code> 里，<code>RefBase</code> 对象可以先销毁；只要有 <code>weakref_imp</code> 在，<code>wp</code> 就能够根据 <code>weakref_impl</code> 中的信息判断是否能够提升为 <code>sp</code>。</p><p>接下来我们看看 <code>weakref_impl</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/RefBase.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIAL_STRONG_VALUE (1&lt;&lt;28)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefBase</span>:</span>:weakref_impl : <span class="keyword">public</span> RefBase::weakref_type</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt;    mStrong;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt;    mWeak;</span><br><span class="line">    RefBase* <span class="keyword">const</span>          mBase;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt;    mFlags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_REFS</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">weakref_impl</span><span class="params">(RefBase* base)</span></span></span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renameStrongRefId</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*old_id*/</span>, <span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*new_id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renameWeakRefId</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*old_id*/</span>, <span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*new_id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span>, <span class="keyword">bool</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>weakref_impl</code> 继承了 <code>weakref_type</code>，在非 debug 模式下，他的另外一些成员函数都是空实现，我们直接忽略。<code>mFlags</code> 的取值是 <code>RefBase</code> 中定义的 <code>enum</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">    OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">    OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>创建 <code>weakref_impl</code> 时，使用的是默认的 lifetime <code>OBJECT_LIFETIME_STRONG</code>。</p><p>有了总体的认识后，接下来我们开始看源码，探究一些小细节。</p><h2 id="强指针的实现"><a href="#强指针的实现" class="headerlink" title="强指针的实现"></a>强指针的实现</h2><p>在这一小节我们先来看强指针的实现，弱指针留到后面。上一节我们讲 <code>LightRefBase</code> 的时候已经知道，<code>sp</code> 在创建的时候会调用对象的 <code>incStrong</code>，销毁的时候调用 <code>decStrong</code>。下面我们就来看看 <code>RefBase</code> 这两个函数的实现。</p><p>首先是对象的创建：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/RefBase.cpp</span></span><br><span class="line">RefBase::RefBase()</span><br><span class="line">    : mRefs(<span class="keyword">new</span> weakref_impl(<span class="keyword">this</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>嗯，是比较单调无趣。下面我们看看 <code>incStrong</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/RefBase.cpp</span></span><br><span class="line"><span class="keyword">void</span> RefBase::incStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;incWeak(id);</span><br><span class="line">    </span><br><span class="line">    refs-&gt;addStrongRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = refs-&gt;mStrong.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    ALOG_ASSERT(c &gt; <span class="number">0</span>, <span class="string">"incStrong() called on %p after last strong ref"</span>, refs);</span><br><span class="line">    <span class="keyword">if</span> (c != INITIAL_STRONG_VALUE)  &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> old __unused = refs-&gt;mStrong.fetch_sub(INITIAL_STRONG_VALUE, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// A decStrong() must still happen after us.</span></span><br><span class="line">    ALOG_ASSERT(old &gt; INITIAL_STRONG_VALUE, <span class="string">"0x%x too small"</span>, old);</span><br><span class="line">    refs-&gt;mBase-&gt;onFirstRef();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>weakref_impl</code> 没有定义 <code>incWeak</code> 函数，这里实际调用的是他的父类 <code>weakref_type</code> 的 <code>incWeak</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::weakref_type::incWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    impl-&gt;addWeakRef(id);  <span class="comment">// 空实现</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c __unused = impl-&gt;mWeak.fetch_add(<span class="number">1</span>,</span><br><span class="line">            <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    ALOG_ASSERT(c &gt;= <span class="number">0</span>, <span class="string">"incWeak called on %p after last weak ref"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为实际的实现就是 <code>weakref_impl</code>，所以这里的强制类型转换不会出错。跟 <code>LightRefBase</code> 的情况一样，由于计数值跟其他的数据没有什么依赖，这里用 <code>memory_order_relaxed</code> 就可以了。</p><p>总的来说，<code>incStrong</code> 所做的就是给 <code>weakref_impl</code> 的 <code>mStrong</code> 和 <code>mWeak</code> 都加 1。</p><p>接下来我们看看 <code>decStrong</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/RefBase.cpp</span></span><br><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);  <span class="comment">// 空实现</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = refs-&gt;mStrong.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(BAD_STRONG(c), <span class="string">"decStrong() called on %p too many times"</span>,</span><br><span class="line">            refs);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">int32_t</span> flags = refs-&gt;mFlags.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// The destructor does not delete refs in this case.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note that even with only strong reference operations, the thread</span></span><br><span class="line">    <span class="comment">// deallocating this may not be the same as the thread deallocating refs.</span></span><br><span class="line">    <span class="comment">// That's OK: all accesses to this happen before its deletion here,</span></span><br><span class="line">    <span class="comment">// and all accesses to refs happen before its deletion in the final decWeak.</span></span><br><span class="line">    <span class="comment">// The destructor can safely access mRefs because either it's deleting</span></span><br><span class="line">    <span class="comment">// mRefs itself, or it's running entirely before the final mWeak decrement.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Since we're doing atomic loads of `flags`, the static analyzer assumes</span></span><br><span class="line">    <span class="comment">// they can change between `delete this;` and `refs-&gt;decWeak(id);`. This is</span></span><br><span class="line">    <span class="comment">// not the case. The analyzer may become more okay with this patten when</span></span><br><span class="line">    <span class="comment">// https://bugs.llvm.org/show_bug.cgi?id=34365 gets resolved. NOLINTNEXTLINE</span></span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就直接了当地多了，直接修改 <code>weakref_impl</code> 的成员变量。</p><p>根据上篇文章我们对 <code>sp</code> 的了解，只有在准备销魂对象的时候才会调用 <code>decStrong</code>。这里 <code>fetch_sub</code> 使用 <code>memory_order_release</code> 就保证了接下来我们要销毁对象时，前面对对象的操作都已经执行完（release 操作相当于在前面放了一个内存屏障，确保前面的操作不会被重排序到 <code>fetch_sub</code> 的后面）。</p><p>如果 <code>c == 1</code>，说明我们是最后一个引用对象的人，接下来就可以准备删除对象了。这里 <code>atomic_thread_fense</code> 的使用跟前面 <code>LightRefBase</code> 的用法是一样的。</p><p>如果 <code>mFlag</code> 是 <code>OBJECT_LIFETIME_STRONG</code>，表示对象的生命周期由强指针控制，当强引用计数值降为 0 的时候，就需要删除对象。</p><p>由于我们在 <code>incStrong</code> 里增加了弱引用计数，这里也要 <code>decWeak</code>。</p><h2 id="弱指针的实现"><a href="#弱指针的实现" class="headerlink" title="弱指针的实现"></a>弱指针的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/RefBase.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> RefBase::weakref_type weakref_type;</span><br><span class="line"></span><br><span class="line">    wp(<span class="keyword">const</span> wp&lt;T&gt;&amp; other);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">wp</span><span class="params">(<span class="keyword">const</span> sp&lt;T&gt;&amp; other)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~wp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// promotion to sp</span></span><br><span class="line">    sp&lt;T&gt; promote() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略去了跟我们关注的主题不相关的其他一大堆函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">sp</span>;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">wp</span>;</span></span><br><span class="line"></span><br><span class="line">    T*              m_ptr;</span><br><span class="line">    weakref_type*   m_refs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>wp</code> 的 <code>m_ptr</code> 指向真正的对象，但这个对象可能已经被销毁了；在使用的时候需要先调用 <code>promote()</code> 提升到 <code>sp</code>，以确保对象不被销毁。<code>m_refs</code> 指针一定是有效的。</p><h3 id="弱指针的创建"><a href="#弱指针的创建" class="headerlink" title="弱指针的创建"></a>弱指针的创建</h3><p>创建 <code>wp</code> 的代码很简单，就是把 <code>weakref_impl</code> 的 <code>mWeak</code> 计数加 1：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">wp&lt;T&gt;::wp(<span class="keyword">const</span> wp&lt;T&gt;&amp; other)</span><br><span class="line">    : m_ptr(other.m_ptr), m_refs(other.m_refs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_refs-&gt;incWeak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">wp&lt;T&gt;::wp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other)</span><br><span class="line">    : m_ptr(other.m_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) &#123;</span><br><span class="line">        m_refs = m_ptr-&gt;createWeak(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="从弱指针提升至强指针"><a href="#从弱指针提升至强指针" class="headerlink" title="从弱指针提升至强指针"></a>从弱指针提升至强指针</h3><p>下面我们看从 <code>wp</code> 转 <code>sp</code> 的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt; wp&lt;T&gt;::promote() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;T&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr &amp;&amp; m_refs-&gt;attemptIncStrong(&amp;result)) &#123;</span><br><span class="line">        result.set_pointer(m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码并没有做太多事，关键的实现还是在 <code>m_refs-&gt;attemptIncStrong()</code>。<code>m_refs</code> 是一个 <code>RefBase::weakref_type*</code>，执行的是下面这段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RefBase::weakref_type::attemptIncStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    incWeak(id);</span><br><span class="line">    </span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">int32_t</span> curCount = impl-&gt;mStrong.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    ALOG_ASSERT(curCount &gt;= <span class="number">0</span>,</span><br><span class="line">            <span class="string">"attemptIncStrong called on %p after underflow"</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount != INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        <span class="comment">// 情况1：</span></span><br><span class="line">        <span class="comment">// we're in the easy/common case of promoting a weak-reference</span></span><br><span class="line">        <span class="comment">// from an existing strong reference.</span></span><br><span class="line">        <span class="keyword">if</span> (impl-&gt;mStrong.compare_exchange_weak(curCount, curCount+<span class="number">1</span>,</span><br><span class="line">                <span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">        <span class="comment">// situation. curCount was updated by compare_exchange_weak.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span> || curCount == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        <span class="comment">// we're now in the harder case of either:</span></span><br><span class="line">        <span class="comment">// - there never was a strong reference on us</span></span><br><span class="line">        <span class="comment">// - or, all strong references have been released</span></span><br><span class="line">        <span class="keyword">int32_t</span> flags = impl-&gt;mFlags.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="comment">// this object has a "normal" life-time, i.e.: it gets destroyed</span></span><br><span class="line">            <span class="comment">// when the last strong reference goes away</span></span><br><span class="line">            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 情况2：</span></span><br><span class="line">                <span class="comment">// the last strong-reference got released, the object cannot</span></span><br><span class="line">                <span class="comment">// be revived.</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况3：</span></span><br><span class="line">            <span class="comment">// here, curCount == INITIAL_STRONG_VALUE, which means</span></span><br><span class="line">            <span class="comment">// there never was a strong-reference, so we can try to</span></span><br><span class="line">            <span class="comment">// promote this object; we need to do that atomically.</span></span><br><span class="line">            <span class="keyword">while</span> (curCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (impl-&gt;mStrong.compare_exchange_weak(curCount, curCount+<span class="number">1</span>,</span><br><span class="line">                        <span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">                <span class="comment">// situation (e.g.: another thread has inc/decStrong'ed us)</span></span><br><span class="line">                <span class="comment">// curCount has been updated.</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// promote() failed, some other thread destroyed us in the</span></span><br><span class="line">                <span class="comment">// meantime (i.e.: strong count reached zero).</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情况4： </span></span><br><span class="line">            <span class="comment">// this object has an "extended" life-time, i.e.: it can be</span></span><br><span class="line">            <span class="comment">// revived from a weak-reference only.</span></span><br><span class="line">            <span class="comment">// Ask the object's implementation if it agrees to be revived</span></span><br><span class="line">            <span class="keyword">if</span> (!impl-&gt;mBase-&gt;onIncStrongAttempted(FIRST_INC_STRONG, id)) &#123;</span><br><span class="line">                <span class="comment">// it didn't so give-up.</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// grab a strong-reference, which is always safe due to the</span></span><br><span class="line">            <span class="comment">// extended life-time.</span></span><br><span class="line">            curCount = impl-&gt;mStrong.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">            <span class="comment">// If the strong reference count has already been incremented by</span></span><br><span class="line">            <span class="comment">// someone else, the implementor of onIncStrongAttempted() is holding</span></span><br><span class="line">            <span class="comment">// an unneeded reference.  So call onLastStrongRef() here to remove it.</span></span><br><span class="line">            <span class="comment">// (No, this is not pretty.)  Note that we MUST NOT do this if we</span></span><br><span class="line">            <span class="comment">// are in fact acquiring the first reference.</span></span><br><span class="line">            <span class="keyword">if</span> (curCount != <span class="number">0</span> &amp;&amp; curCount != INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">                impl-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    impl-&gt;addStrongRef(id);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PRINT_REFS</span></span><br><span class="line">    ALOGD(<span class="string">"attemptIncStrong of %p from %p: cnt=%d\n"</span>, <span class="keyword">this</span>, id, curCount);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// curCount is the value of mStrong before we incremented it.</span></span><br><span class="line">    <span class="comment">// Now we need to fix-up the count if it was INITIAL_STRONG_VALUE.</span></span><br><span class="line">    <span class="comment">// This must be done safely, i.e.: handle the case where several threads</span></span><br><span class="line">    <span class="comment">// were here in attemptIncStrong().</span></span><br><span class="line">    <span class="comment">// curCount &gt; INITIAL_STRONG_VALUE is OK, and can happen if we're doing</span></span><br><span class="line">    <span class="comment">// this in the middle of another incStrong.  The subtraction is handled</span></span><br><span class="line">    <span class="comment">// by the thread that started with INITIAL_STRONG_VALUE.</span></span><br><span class="line">    <span class="keyword">if</span> (curCount == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        impl-&gt;mStrong.fetch_sub(INITIAL_STRONG_VALUE,</span><br><span class="line">                <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每次增加强引用计数前，都要先递增一个弱引用计数。由于我们是通过弱指针来执行这个操作，<code>incWeak</code> 总是有效的，这里直接执行就可以。</p><p>前面我们说过，<code>weakref_type</code> 的实际实现是 <code>weakref_impl</code>，所以接下来的强制类型转换也是合法的。后面的操作我们分几种情况来考虑。</p><ol><li>有强指针指向这个对象。此时 <code>curCount &gt; 0 &amp;&amp; curCount != INITIAL_STRONG_VALUE</code>，我们在接下来的循环里尝试递增一个强引用计数。之所以要用 compare exchange，是因为在我们准备给 <code>mStrong</code> 加 1 的同时，其他线程可能要给他减 1。<br>按照 C++ 文档的描述，相对于 <code>compare_exchange_strong</code>，<code>compare_exchange_weak</code> 偶尔会发生假性的（spurious）失败，但它能够在弱一致性保证的机器上提供更好的性能（由于我们是在一个循环里面执行，所以即使发生了假性失败，也会重新执行）。为了更好的性能，这里使用的是后者。</li><li><code>curCount &lt; 0</code>。在这种情况下，如果对象的生命周期是 <code>OBJECT_LIFETIME_STRONG</code>，说明对象受强引用计数控制，此时对象已经销毁。</li><li><code>curCount == INITIAL_STRONG_VALUE</code>，对象创建以后还没有被强指针引用过，说明对象还存活着，此时我们在一个 <code>while</code> 循环里尝试递增 <code>mStrong</code></li><li>这种情况下，<code>mFlags == OBJECT_LIFETIME_WEAK</code>，对象的生命周期受弱引用计数控制。既然我们准备将一个弱引用提升为强引用，此时对象的弱引用计数肯定是不为 0 的。这个时候如果对象允许（<code>onIncStrongAttempted</code> 默认的实现就是返回 <code>true</code>），我们直接递增强引用计数就可以了。</li></ol><h3 id="弱指针的销毁"><a href="#弱指针的销毁" class="headerlink" title="弱指针的销毁"></a>弱指针的销毁</h3><p>回顾一下强指针的内容，我们知道，<code>sp</code> 销毁的时候，会调用对象的 <code>decStrong</code>。<code>RefBase::decStrong</code> 我们在前面已经看过他的实现了，总结起来就是：</p><ol><li>如果对象受强引用计数控制（<code>OBJECT_LIFETIME_STRONG</code>），<code>decStrong</code> 在强引用计数为 0 的时候销毁 <code>this</code>（不销毁 <code>weakref_impl</code>）</li><li>如果受弱引用计数控制，在强引用计数为 0 的时候不直接销毁对象。</li></ol><p>对强指针来说，无论是上面的哪一种情况，最后都会执行 <code>decWeak</code>（强指针会使 <code>mStrong</code>、<code>mWeak</code> 都加 1）。对弱指针来说，他只会递增弱引用计数 <code>mWeak</code>，所以在销毁的时候只需要执行 <code>decWeak</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/RefBase.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">wp&lt;T&gt;::~wp()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们看看 <code>decWeak</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/RefBase.cpp</span></span><br><span class="line"><span class="keyword">void</span> RefBase::weakref_type::decWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    impl-&gt;removeWeakRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = impl-&gt;mWeak.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(BAD_WEAK(c), <span class="string">"decWeak called on %p too many times"</span>,</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> flags = impl-&gt;mFlags.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">        <span class="comment">// This is the regular lifetime case. The object is destroyed</span></span><br><span class="line">        <span class="comment">// when the last strong reference goes away. Since weakref_impl</span></span><br><span class="line">        <span class="comment">// outlives the object, it is not destroyed in the dtor, and</span></span><br><span class="line">        <span class="comment">// we'll have to do it here.</span></span><br><span class="line">        <span class="keyword">if</span> (impl-&gt;mStrong.load(<span class="built_in">std</span>::memory_order_relaxed)</span><br><span class="line">                == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">            <span class="comment">// Decrementing a weak count to zero when object never had a strong</span></span><br><span class="line">            <span class="comment">// reference.  We assume it acquired a weak reference early, e.g.</span></span><br><span class="line">            <span class="comment">// in the constructor, and will eventually be properly destroyed,</span></span><br><span class="line">            <span class="comment">// usually via incrementing and decrementing the strong count.</span></span><br><span class="line">            <span class="comment">// Thus we no longer do anything here.  We log this case, since it</span></span><br><span class="line">            <span class="comment">// seems to be extremely rare, and should not normally occur. We</span></span><br><span class="line">            <span class="comment">// used to deallocate mBase here, so this may now indicate a leak.</span></span><br><span class="line">            ALOGW(<span class="string">"RefBase: Object at %p lost last weak reference "</span></span><br><span class="line">                    <span class="string">"before it had a strong reference"</span>, impl-&gt;mBase);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ALOGV("Freeing refs %p of old RefBase %p\n", this, impl-&gt;mBase);</span></span><br><span class="line">            <span class="keyword">delete</span> impl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is the OBJECT_LIFETIME_WEAK case. The last weak-reference</span></span><br><span class="line">        <span class="comment">// is gone, we can destroy the object.</span></span><br><span class="line">        impl-&gt;mBase-&gt;onLastWeakRef(id);</span><br><span class="line">        <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里 <code>atomic_thread_fense</code> 的用法跟 <code>decStrong</code> 里是一样的。在弱引用计数降为 0 的时候，分 3 中情况处理：</p><ol><li><code>OBJECT_LIFETIME_STRONG</code>，但是没有强指针引用过这个对象。这个只有在我们使用弱指针引用对象但却从没把弱指针提升到强指针（也就是说，我们根本没使用过这个对象）的情况下才会发生。由于很可能是个错误，这个写了个 warning 日志。</li><li><code>OBJECT_LIFETIME_STRONG</code>，有强指针引用过这个对象，这是最正常的情况。此时不存在任何的强、弱指针指向对象，所以把 <code>weakref_impl</code> 也删掉。</li><li><code>OBJECT_LIFETIME_WEAK</code>，由于对象受弱引用计数控制而此时弱引用计数为 0，所以需要删除对象（<code>delete impl-&gt;mBase</code>）。</li></ol><p>无论是 <code>decStrong</code> 还是 <code>decWeak</code>，删除对象后，最终都会执行到 <code>RefBase::~RefBase</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RefBase::~RefBase()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> flags = mRefs-&gt;mFlags.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// Life-time of this object is extended to WEAK, in</span></span><br><span class="line">    <span class="comment">// which case weakref_impl doesn't out-live the object and we</span></span><br><span class="line">    <span class="comment">// can free it now.</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) &#123;</span><br><span class="line">        <span class="comment">// It's possible that the weak count is not 0 if the object</span></span><br><span class="line">        <span class="comment">// re-acquired a weak reference in its destructor</span></span><br><span class="line">        <span class="keyword">if</span> (mRefs-&gt;mWeak.load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> mRefs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mRefs-&gt;mStrong.load(<span class="built_in">std</span>::memory_order_relaxed)</span><br><span class="line">            == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        <span class="comment">// We never acquired a strong reference on this object.</span></span><br><span class="line">        LOG_ALWAYS_FATAL_IF(mRefs-&gt;mWeak.load() != <span class="number">0</span>,</span><br><span class="line">                <span class="string">"RefBase: Explicit destruction with non-zero weak "</span></span><br><span class="line">                <span class="string">"reference count"</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Always report if we get here. Currently MediaMetadataRetriever</span></span><br><span class="line">        <span class="comment">// C++ objects are inconsistently managed and sometimes get here.</span></span><br><span class="line">        <span class="comment">// There may be other cases, but we believe they should all be fixed.</span></span><br><span class="line">        <span class="keyword">delete</span> mRefs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For debugging purposes, clear mRefs.  Ineffective against outstanding wp's.</span></span><br><span class="line">    <span class="keyword">const_cast</span>&lt;weakref_impl*&amp;&gt;(mRefs) = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果对象受弱引用计数控制，在 <code>decWeak</code> 中我们删除对象，而后 <code>weakref_impl</code> 在 <code>~RefBase</code> 中删除。</p><p>前面 <code>decWeak</code> 的第一种情况下，我们只是写了个日志然后什么也没做。如果受强引用计数控制但却没有被强指针引用过，并且执行了 <code>~RefBase</code>，说明对象要么是被手动 <code>delete</code>，要么是在栈上分配的。不管哪种情况，此时都应该释放 <code>mRefs</code>，否则将会有内存泄漏。</p><p>最后做个总结。在正常的情况下，</p><ol><li>如果对象的生命周期是 <code>OBJECT_LIFETIME_STRONG</code>，这也是默认的情况。在 <code>decStrong</code> 中，如果强引用计数为 0，将删除对象；在 <code>decWeak</code> 中，如果弱引用计数为 0，将删除 <code>weakref_impl</code></li><li>如果对象的生命周期是 <code>OBJECT_LIFETIME_WEAK</code>，对象将在 <code>decWeak</code> 中删除，<code>weakref_impl</code> 则是在 <code>~RefBase</code> 中回收的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继上篇我们学习了 Android 轻量级指针的实现，是时候来看“重量级”指针的实现了。在 Android 里，“重量级”指针指的是 &lt;code&gt;RefBase&lt;/code&gt; 和 &lt;code&gt;sp/wp&lt;/code&gt; 配合使用的情况，它提供了完整的强、弱指针的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
  </entry>
  
  <entry>
    <title>Android P 源码分析 1 - 轻量级智能指针的实现</title>
    <link href="https://jekton.github.io/2019/03/06/android9-light-sp/"/>
    <id>https://jekton.github.io/2019/03/06/android9-light-sp/</id>
    <published>2019-03-06T11:23:28.000Z</published>
    <updated>2019-03-09T13:09:44.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇词"><a href="#开篇词" class="headerlink" title="开篇词"></a>开篇词</h2><p>去年（2018）二季度写过几篇 Android 源码相关的文章，后来由于太懒中断了，一晃眼一整年什么也没干成。经过几个月的迷茫，终于在年底开始发奋学习。慢慢把一些基础捡回来后，兜兜转转，看源码的时机又来了。文章标题里的那个“1”显然表示此刻的我雄心勃勃，也希望自己能够坚持下去，改掉虎头蛇尾的毛病。</p><p>分析 Android 源码的书籍中，最厚重的无疑是老罗的《Android 源代码情景分析》，目前我也是使用它作为主要的参考书。前期的写作基本会按照老罗书中的脉络进行，如果有幸坚持下来，再另外找话题继续探索。跟老罗书中不同的是，喜新厌旧的我将会基于 Android P（<code>pie-release</code>分支）来讲解，不然就太没意思了。</p><p>由于作者水平有限，没办法在文章把涉及的知识点给大家一一罗列，只能在相关地方推荐几本参考书。如果大家对某个知识点有疑惑，可以是找个安静的时间，慢慢享受一本纸质书。</p><p>下面我们进入正题，先拿 Android 的轻量级指针来热热身。</p><h2 id="关于智能指针的一点点背景知识"><a href="#关于智能指针的一点点背景知识" class="headerlink" title="关于智能指针的一点点背景知识"></a>关于智能指针的一点点背景知识</h2><p>文章假设你有一定的 C++ 基础，不熟悉的读者可以参考《C++ Primer》。也希望读者可以下载一份源码，毕竟在网页上没法在代码直接进行跳转，整体性也差一点。如果你想了解更多智能指针的知识，《More Effective C++》将会是一本很棒的书，很值得一读。</p><p>标准的 C++ 并支持垃圾收集，这就需要用户手动释放内存资源。当多个模块通过一个指针共享对象实例时，对象的所有权往往非常地模糊，这就很容易让用户在什么时候删除对象这个问题上产生疑惑。幸运的时候，利用 RAII(Resource Acquisition Is Initialization，参考《The C++ Programming Language》，不了解也没关系)，我们可以系统地、自动地管理对象的生命周期。</p><p>所谓的智能指针，就是在对象的内部维持一个计数；我们在类的构造函数里对计数增加 1，并在析构函数减 1。如果当前我们是最后一个人引用这个对象，那么计数值在析构函数里减 1 后就应该等于 0，此时对象可以被安全地删除。</p><h2 id="轻量级指针的用法"><a href="#轻量级指针的用法" class="headerlink" title="轻量级指针的用法"></a>轻量级指针的用法</h2><p>先了解一下 API，对我们阅读源码是非常有帮助的，这里我们先看看一个小例子，学一学怎么使用轻量级指针。</p><p>首先，对应希望被智能指针引用的类应该继承 <code>LightRefBase</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> LightRefBase&lt;Foo&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来，我们通过 <code>sp</code> 来引用它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 sp，sp 指 strong pointer，它是一个智能指针，用来管理我们的 Foo 对象</span></span><br><span class="line">  sp&lt;Foo&gt; p&#123;<span class="keyword">new</span> Foo&#125;;   <span class="comment">// 此时计数值为 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> p2 = p;    <span class="comment">// 计数值 = 2</span></span><br><span class="line">    p2-&gt;foo();</span><br><span class="line">  &#125; <span class="comment">// p2 销毁，计数值 = 1</span></span><br><span class="line">  p-&gt;foo();</span><br><span class="line">&#125;   <span class="comment">// p 销毁，计数值 = 0，Foo 对象也销毁</span></span><br></pre></td></tr></table></figure></p><p>下面我们一起来看看它的源码。</p><h2 id="计数器-LightRefBase-的实现"><a href="#计数器-LightRefBase-的实现" class="headerlink" title="计数器 LightRefBase 的实现"></a>计数器 LightRefBase 的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/LightRefBase.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LightRefBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    inline LightRefBase() : mCount(0) &#123; &#125;</span><br><span class="line">    inline void incStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">        mCount.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCount.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! DEBUGGING ONLY: Get current strong ref count.</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> int32_t <span class="title">getStrongCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mCount.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> LightRefBase&lt;T&gt; basetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 注意，析构函数是 protected，这就限定了 LightRefBase 只能被继承</span></span><br><span class="line">    <span class="keyword">inline</span> ~LightRefBase() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt; mCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>incStrong</code> 的实现很简单，由于引用计数 <code>mCount</code> 不跟其他数据具有依赖关系，这里直接用 <code>memory_order_relaxed</code> 就可以了。</p><p><code>decStrong</code> 里，<code>fetch_sub</code> 在给 <code>mCount</code> 减 1 的同时返回了原来的值，如果旧值是 1，说明我们是最后一个引用对象的人，接下来就改删除对象了。<code>if</code> 语句里的 <code>atomic_thread_fence</code> 和 <code>fetch_sub</code> 构成了一个 <em>Atomic-fence synchronization</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo : public LightRefBase &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Thread A                                Thread B</span><br><span class="line">---------                               -----------</span><br><span class="line">do with Foo*                            do with Foo*</span><br><span class="line">fetch_sub(1, memory_order_release)</span><br><span class="line">  =&gt; mCount = 1</span><br><span class="line">                                        fetch_sub(1, memory_order_release)</span><br><span class="line">                                        atomic_thread_fense(memory_order_acquire)</span><br><span class="line">                                        delete Foo*</span><br></pre></td></tr></table></figure></p><p>假定存在这么一个对象 Foo*，它同时被线程 A、B 引用。线程 A 使用完以后，先执行了 <code>decStrong</code>；在线程 B <code>decStrong</code> 的时候，检查到 <code>mCount</code> 的旧值为 1，于是执行 <code>if</code> 语句中的内容。</p><p>所谓的 <em>Atomic-fense synchronization</em> 就是，在线程 A 中，do with Foo<em> 比 fetch_sub 先执行；线程 A 的 fetch_sub 比 线程 B 的 fetch_sub 先执行；线程 B 的 atomic_thread_fense 保证了 fetch_sub 比 delete Foo</em> 先执行。所以，线程 B 删除对象的引用的时候，线程 A 的 do with Foo<em> 一定以及执行完了。如果没有这个 fense，那么 delete Foo</em> 就可以在 fetch_sub 前面执行，而此时可能其他线程还在使用该对象。</p><p>原因 momory order 和 atomic_thread_fense 的更多信息，读者可以参考 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">memory_order</a> 和 <a href="https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence" target="_blank" rel="noopener">atomic_thread_fence</a>。</p><p>说了这么多，你可能就会想问，有没有其他更简单的方法来实现 <code>decStrong</code> 呢？有的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCount.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acq_rel) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题在于，<code>if</code> 语句的条件只在最后一个持有引用的人执行时才会为 <code>true</code>；这种情况下，我们才需要一个 <code>acquire operation</code>。这是通过性能换取代码复杂性的一个例子。</p><h2 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h2><p>智能指针的实现是 <code>sp</code>，这里我们只看最关键的几个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/StrongPointer.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    sp(T* other);  <span class="comment">// NOLINT(implicit)</span></span><br><span class="line">    ~sp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> T&amp;       <span class="keyword">operator</span>* () <span class="keyword">const</span>     &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">    <span class="keyword">inline</span> T*       <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span>    &#123; <span class="keyword">return</span> m_ptr;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T*       <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span>            </span>&#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr != <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    T* m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>直接通过指针来构造 sp 的情况很简单，如果传入的指针非空，就调用 <code>incStrong</code> 增加一个引用计数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt;::sp(T* other)</span><br><span class="line">        : m_ptr(other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other)</span><br><span class="line">        other-&gt;incStrong(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>析构的时候，调用 <code>decStrong</code>，如果引用计数降为 0，<code>decStrong</code> 将会删除 <code>m_ptr</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt;::~sp() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr)</span><br><span class="line">        m_ptr-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LightRefBase-设计问题"><a href="#LightRefBase-设计问题" class="headerlink" title="LightRefBase 设计问题"></a>LightRefBase 设计问题</h2><p>不得不说，轻量级指针除了 decStrong 的原子操作比较费解外，其他实现都是非常直观的。但如果我们留心观察，还是能够找到一些闪光点的。</p><h3 id="为什么要让被管理对象继承-LightRefBase"><a href="#为什么要让被管理对象继承-LightRefBase" class="headerlink" title="为什么要让被管理对象继承 LightRefBase"></a>为什么要让被管理对象继承 LightRefBase</h3><p>从易用性的角度考虑，如果被管理对象（如前面例子里的 Foo）不需要继承 <code>LightRefBase</code>，无疑用起来会更加的方便。在考虑这个问题的时候，不妨看一看 <code>LightRefBase</code> 都有什么成员变量。可以看到，我们把引用计数存放在了 <code>LightRefBase</code> 里。这样一来，在堆上创建对象的时候，我们只需要分配一次内存。</p><p>如果不这样做，我们将不得不在堆上分配多一个对象，用来保存引用的计数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotSoLightSP</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  NotSoLightSP(T* ptr)</span><br><span class="line">      : count_&#123;<span class="keyword">new</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>&#125;&#125;, ptr_&#123;ptr&#125; &#123;&#125;</span><br><span class="line">  NotSoLightSP(<span class="keyword">const</span> NotSoLightSP&lt;T&gt;&amp; other)</span><br><span class="line">      : count_&#123;other.count_&#125;, ptr_&#123;other.ptr_&#125; &#123;</span><br><span class="line">    count_-&gt;fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~NotSoLightSP() &#123;</span><br><span class="line">    <span class="keyword">if</span> (count_-&gt;fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release) == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">      <span class="keyword">delete</span> count_;</span><br><span class="line">      <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">RefCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count_-&gt;load(<span class="built_in">std</span>::memory_order_relaxed); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;* count_;</span><br><span class="line">  T* ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Foo() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Foo() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Foo()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NotSoLightSP&lt;Foo&gt; sp&#123;<span class="keyword">new</span> Foo&#125;;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp2 = sp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count = "</span> &lt;&lt; sp2.RefCount() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count = "</span> &lt;&lt; sp.RefCount() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo()</span><br><span class="line">ref count = 2</span><br><span class="line">ref count = 1</span><br><span class="line">~Foo()</span><br></pre></td></tr></table></figure></p><p>最后，我们再参考 C++ 标准库的 <code>shared_ptr</code> 来讲一讲。对 <code>shared_ptr</code> 来说，一般情况下它也是需要在堆上分配对一个对象用于保存引用计数的；不那么一般的情况是，<code>make_shared</code>，这个时候它可以分配一个大的内存块，然后使用 placement new 来构造这两个对象（待管理对象和引用计数都放在这个内存块中）。</p><h3 id="为什么-LightRefBase-是一个类模板（而-RefBase-却不是）"><a href="#为什么-LightRefBase-是一个类模板（而-RefBase-却不是）" class="headerlink" title="为什么 LightRefBase 是一个类模板（而 RefBase 却不是）"></a>为什么 LightRefBase 是一个类模板（而 RefBase 却不是）</h3><p>如果读者还没了解过 <code>RefBase</code>，可以在我发完下一篇文章的时候再回来看这一小节。</p><p>细心的读者应该留意到，我们是这样继承 LightRefBase 的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> LightRefBase&lt;Foo&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>而 <code>RefBase</code> 是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> :</span> <span class="keyword">public</span> RefBase &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>要寻找这个问题的答案，可以看看 <code>LightRefBase</code> 用模板参数来做了什么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCount.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，整个类唯一使用了 <code>T</code> 的地方就是这里。由于 <code>LightRefBase</code> 没有虚函数，所以在 delete this 指针的时候，需要把它强制转换为真正的类型 <code>T*</code>，否则将不会执行 <code>T::~T()</code>。另一方面，<code>RefBase::~Refbase()</code> 是一个虚函数，所以 <code>RefBase</code> 不需要把 this 强转回真正的类型就能够 delete this。</p><p><code>LightRefBase</code> 之所以搞得这么麻烦，和前一个问题一样，都是为了性能。如果把析构函数是虚函数，那么每个子类都将多消耗一个指针用于存储函数表，这样就不够“light”(轻量)了。</p>]]></content>
    
    <summary type="html">
    
      作为 Android 源码分析系列文章的第一篇，我们先看 LightRefBase 的源码，热热身。
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
  </entry>
  
  <entry>
    <title>Java 程序员眼里的 Linux 内核 —— wait_event 源码分析</title>
    <link href="https://jekton.github.io/2018/12/15/linux-wait-event/"/>
    <id>https://jekton.github.io/2018/12/15/linux-wait-event/</id>
    <published>2018-12-15T08:30:37.000Z</published>
    <updated>2018-12-21T01:07:29.633Z</updated>
    
    <content type="html"><![CDATA[<p>看 Linux 的 <code>wait_event</code> 源码时，联想到我们平时经常用得比较多的 wait/notify、double-check 和 <code>volatile</code>，突然意识 <code>wait_event</code> 简简单单几行代码的背后，涉及的知识点其实非常丰富。本篇文章我们就一起了来探索它背后的知识，然后尝试着和我们的日常开发关联起来。</p><h1 id="wait-event"><a href="#wait-event" class="headerlink" title="wait_event"></a>wait_event</h1><blockquote><p>这里使用 Linux-2.6.24 版本的源码</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在某些情况下，我们会需要等待某个事件，在这个事件发生前，把进程投入睡眠。比方说，同步写 IO；在发出写磁盘命令后，进程要进入休眠，等等磁盘完成。为了支持这一类场景，Linux 引入了 wait queue；wait queue 从概念上跟我们应用层使用的 condition queue 是一样的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里我们着重讲 <code>wait_event</code> 的实现，一些相关的知识读者可以参考《深入理解LINUX内核》。</p><p>下面我们开始看代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/include/linux/wait.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wait_event - sleep until a condition gets true</span></span><br><span class="line"><span class="comment"> * @wq: the waitqueue to wait on</span></span><br><span class="line"><span class="comment"> * @condition: a C expression for the event to wait for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the</span></span><br><span class="line"><span class="comment"> * @condition evaluates to true. The @condition is checked each time</span></span><br><span class="line"><span class="comment"> * the waitqueue @wq is woken up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * wake_up() has to be called after changing any variable that could</span></span><br><span class="line"><span class="comment"> * change the result of the wait condition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event(wq, condition)       \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                    \</span><br><span class="line">    <span class="keyword">if</span> (condition)                      \</span><br><span class="line">        <span class="keyword">break</span>;                          \</span><br><span class="line">    __wait_event(wq, condition);        \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>这里只是先检测一遍条件，然后直接又调用 <code>__wait_event</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/include/linux/wait.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __wait_event(wq, condition)                             \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                            \</span><br><span class="line">    DEFINE_WAIT(__wait);                                        \</span><br><span class="line">                                                                \</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                                  \</span><br><span class="line">        prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE);    \</span><br><span class="line">        <span class="keyword">if</span> (condition)                                          \</span><br><span class="line">            <span class="keyword">break</span>;                                              \</span><br><span class="line">        <span class="comment">// schedule 使用调度器调度另一个线程去执行。当前线程被重新      \</span></span><br><span class="line">        <span class="comment">// 调度时，schedule 函数才会返回                            \</span></span><br><span class="line">        schedule();                                             \</span><br><span class="line">    &#125;                                                           \</span><br><span class="line">    finish_wait(&amp;wq, &amp;__wait);                                  \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p><code>DEFINE_WAIT</code> 宏用于定义局部变量 <code>__wait</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/include/linux/wait.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_WAIT(name)                                   \</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> name = &#123;                                   \</span><br><span class="line">        .<span class="keyword">private</span>    = current,                              \</span><br><span class="line">        .func       = autoremove_wake_function,             \</span><br><span class="line">        .task_list  = LIST_HEAD_INIT((name).task_list),     \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>prepare_to_wait</code> 和 <code>finish_wait</code> 源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/kernel/wait.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: we use "set_current_state()" _after_ the wait-queue add,</span></span><br><span class="line"><span class="comment"> * because we need a memory barrier there on SMP, so that any</span></span><br><span class="line"><span class="comment"> * wake-function that tests for the wait-queue being active</span></span><br><span class="line"><span class="comment"> * will be guaranteed to see waitqueue addition _or_ subsequent</span></span><br><span class="line"><span class="comment"> * tests in this thread will see the wakeup having taken place.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The spin_unlock() itself is semi-permeable and only protects</span></span><br><span class="line"><span class="comment"> * one way (it only protects stuff inside the critical region and</span></span><br><span class="line"><span class="comment"> * stops them from bleeding out - it would still allow subsequent</span></span><br><span class="line"><span class="comment"> * loads to move into the critical region).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> fastcall</span><br><span class="line">prepare_to_wait(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait, <span class="keyword">int</span> state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非独占等待（可以同时唤醒多个进程）</span></span><br><span class="line">    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    <span class="comment">// wait 不存在于某个等待队列时，才把它加入 q</span></span><br><span class="line">    <span class="comment">// wait 是我们新定义的，list_empty 将会返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (list_empty(&amp;wait-&gt;task_list))</span><br><span class="line">        __add_wait_queue(q, wait);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * don't alter the task state if this is just going to</span></span><br><span class="line"><span class="comment">     * queue an async wait queue callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 根据 wait 的定义，is_sync_wait() 这里会返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (is_sync_wait(wait))</span><br><span class="line">        <span class="comment">// 前面注释说使用 set_current_state() 作为屏障，对此不理解的读者可以暂时忽略，</span></span><br><span class="line">        <span class="comment">// 后面我们会举例说明相关的用法</span></span><br><span class="line">        set_current_state(state);</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Used to distinguish between sync and async io wait context:</span></span><br><span class="line"><span class="comment"> * sync i/o typically specifies a NULL wait queue entry or a wait</span></span><br><span class="line"><span class="comment"> * queue entry bound to a task (current task) to wake up.</span></span><br><span class="line"><span class="comment"> * aio specifies a wait queue entry with an async notification</span></span><br><span class="line"><span class="comment"> * callback routine, not associated with any task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> is_sync_wait(wait)    (!(wait) || ((wait)-&gt;private))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> fastcall <span class="title">finish_wait</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can check for list emptiness outside the lock</span></span><br><span class="line"><span class="comment">     * IFF:</span></span><br><span class="line"><span class="comment">     *  - we use the "careful" check that verifies both</span></span><br><span class="line"><span class="comment">     *    the next and prev pointers, so that there cannot</span></span><br><span class="line"><span class="comment">     *    be any half-pending updates in progress on other</span></span><br><span class="line"><span class="comment">     *    CPU's that we haven't seen yet (and that might</span></span><br><span class="line"><span class="comment">     *    still change the stack area.</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *  - all other users take the lock (ie we can only</span></span><br><span class="line"><span class="comment">     *    have _one_ other CPU that looks at or modifies</span></span><br><span class="line"><span class="comment">     *    the list).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty_careful(&amp;wait-&gt;task_list)) &#123;</span><br><span class="line">        spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">        list_del_init(&amp;wait-&gt;task_list);</span><br><span class="line">        spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>概括来讲，<code>prepare_to_wait</code> 把自己加入等待队列，<code>finish_wait</code> 则把自己从队列里移除。但由于 <code>prepare_to_wait</code> 可能会被调用多次，如果判断 <code>wait</code> 已经处于某个队列中，则不会重复添加。</p><h1 id="条件、条件队列和锁"><a href="#条件、条件队列和锁" class="headerlink" title="条件、条件队列和锁"></a>条件、条件队列和锁</h1><p>对于像我一样平时使用 Java 比较多的读者，对下面这一段代码一定不会觉得陌生：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do your stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们不禁要问，应用层的代码可以这样简洁，为什么内核的就不行？这里我们先来大概了解一下条件队列，然后再回答这个问题。</p><p>所谓的条件队列/等待队列，一般由 3 个成分组成：</p><ol><li>一个队列，用于存放等待条件/事件的线程。在应用层，一般我们叫他条件队列（condition queue），LINUX 内核叫他 wait queue</li><li>一个锁，用于保护这个队列</li><li>一个谓词（它的计算结果为 bool 值）用作条件，即前面示例代码的 <code>condition</code>。</li></ol><p>Java 程序员们在这里需要特别注意的是，我说的<strong>锁的作用是保护条件队列</strong>。回顾我们常写的 Java 代码，一般这个锁也用来保护谓词，但这个不是必须的。Java 要求我们在调用 <code>wait</code> 的时候必须持有锁的原因之一是，<code>wait</code> 的内部会把当前线程加入条件队列；修改列表必须持有锁（另一个原因是，<code>wait</code> 的语义之一便是执行后会释放锁，如果都不持有，何来的释放呢）。</p><p>但在另一面，唤醒条件队列上的线程却不一定需要持有锁，虽然 Java 要求我们必须持有锁才能调用 <code>notify</code>。持有锁调用 <code>notify</code> 的好处在于，notify 后条件不会改变。同时，如果持有锁的话，这个操作里也可以把相关线程从条件队列里删除。不好的地方在于，调用 notify 的线程在执行唤醒操作的时候还持有锁，被唤醒线程这个时候如果被内核调度，他的获取锁的操作将失败（会导致该线程又进入睡眠状态）。这种实现方式性能上可能差一点，但代码更安全。</p><p>不要求调用 notify 时持有锁的一个例子是 pthread。这种方式的问题在于，在 notify 还没执行完的时候，条件可能就发生了变化。可能的实现是，只设置线程为可执行状态，等线程获得锁后自己把自己从队列里面移除。</p><p>了解了相关的数据结构后，不难猜想 Java 里 <code>wait</code> 的实现。考虑一种应用层 wait 的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    add_to_condition_queue();</span><br><span class="line">    unlock();</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把 <code>wait</code> 方法做一下内联（inlining）处理，可以得到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">    add_to_condition_queue();</span><br><span class="line">    unlock();</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do your stuff</span></span><br></pre></td></tr></table></figure></p><p>对比一下内核的 <code>wait_event</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">our_wait_event</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果你喜欢，换成 condition_queue 也可以</span></span><br><span class="line">        add_to_wait_queue_if_not_added_yet();</span><br><span class="line">        <span class="keyword">if</span> (condition)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    remove_from_wait_queue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，内核把代码写得更复杂的好处在于，它在切换进程前可以再检查一次条件，如果条件已经满足，就不需要执行 <code>schedule</code> 了。切换进程需要保存当前进程的上下文，同时会导致 TLB、Cache 等一系列缓存时效，因此内核总是尽量避免不必要的线程切换，而代价就是更复杂的代码。</p><h1 id="double-check"><a href="#double-check" class="headerlink" title="double-check"></a>double-check</h1><p>首先，如果你也和我一样觉得 <code>our_wait_event</code> 里面两个 <code>if</code> 有点难看，我们不妨试着来给他改一改：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">our_wait_event2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">        add_to_wait_queue_if_not_added_yet();</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    remove_from_wait_queue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>咋一看好像没什么问题，都是一样的检测条件，在条件不满足的情况下加入等待队列，调用 <code>schedule</code>。重要的是，上面这段代码更简洁，更易读。那么，他正确吗？</p><p>不消说，肯定是有问题的，不然那班内核程序员不会不知道该这么写。那问题究竟出在哪里呢？</p><p>考虑下面两个执行流：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread1                              thread2</span><br><span class="line">-----------------------           --------------</span><br><span class="line">check condition =&gt; false</span><br><span class="line">add_to_wait_queue()</span><br><span class="line"></span><br><span class="line">                                  alter_condition()</span><br><span class="line">                                  notify_all()</span><br><span class="line"></span><br><span class="line">state = TASK_UNINTERRUPTABLE</span><br><span class="line">schedule()</span><br></pre></td></tr></table></figure></p><p>thread1 在把自己加入等待队列后，schedule 前，thread2 就更改了条件并且调用 notify。在这种情况下，如果没有其他线程再次调用 notify，thread1 将会永远休眠（而 thread2 认为自己已经 noitfy 过 thread1 了）。</p><p>为了防止发生这种情况，在添加到等待队列后，thread1 还应该再检查一次条件，如果条件满足，直接把自己从队列里移除就可以了。</p><p>为了方便读者把 <code>wait_event</code> 和 double-check 联系起来，下面我们看一段使用 double-check 实现的 Java 的单例的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SomeClass <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SomeClass.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sInstance = <span class="keyword">new</span> SomeClass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两者的共同点都是先检测一遍条件是否成立，然后设置一个“安全阀”。在持有这个安全阀时，再一次检测条件是否满足。double-check 的多线程安全性都源于这个安全阀。就 wait_event 来说，当我们把自己加入等待队列后，就可以保证不会丢失另一个线程的 notify。而创建单例时，加锁保证了第二次判断后不会有另一个线程同时创建对象。（可能说得有点抽象，如果读者不明白，直接跳过就好。只要读者能够完成下面的小测验，那就是懂得 double-check 的）。</p><h2 id="double-check-小测验"><a href="#double-check-小测验" class="headerlink" title="double-check 小测验"></a>double-check 小测验</h2><p>假设有这样一个方法，他可以用来下载文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DownloadCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(File file)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String url, DownloadCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们又假设，可能同时有多个客户会调用这个接口下载同一个文件。为了避免同时下载同一个文件，我们可以在下载时判断一下当前是否已经有任务在下载：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DownloadCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(File file)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> </span>&#123;</span><br><span class="line">    <span class="comment">// guarded by itself</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;DownloadCallback&gt; mCallbacks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadTask</span><span class="params">(String url, DownloadCallback callback)</span> </span>&#123;</span><br><span class="line">        mCallbacks.add(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// downloading ...</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"downloaded-file"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bonus: 为什么需要拷贝 callback 列表？</span></span><br><span class="line">        List&lt;DownloadCallback&gt; copy;</span><br><span class="line">        <span class="keyword">synchronized</span> (mCallbacks) &#123;</span><br><span class="line">            copy = <span class="keyword">new</span> ArrayList&lt;&gt;(mCallbacks);</span><br><span class="line">            mCallbacks.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (DownloadCallback callback : copy) &#123;</span><br><span class="line">            callback.onSuccess(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(DownloadCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mCallbacks) &#123;</span><br><span class="line">            mCallbacks.add(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, DownloadTask&gt; mTasks = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String url, DownloadCallback callback)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(getDestFilePath(url));</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        <span class="comment">// 已经存在则不需要下载了</span></span><br><span class="line">        callback.onSuccess(file);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DownloadTask task = <span class="keyword">new</span> DownloadTask(url, callback);</span><br><span class="line">    DownloadTask downloadingTask = mTasks.putIfAbsent(url, task);</span><br><span class="line">    <span class="keyword">if</span> (downloadingTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有正在下载的任务时才需要下载</span></span><br><span class="line">        task.download();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入正在下载的任务的 callback 列表，</span></span><br><span class="line">    downloadingTask.addCallback(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDestFilePath</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"url-to-file-path..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了检验读者是否真正理解 <code>wait_event</code>，你可以尝试着解决上面代码里存在的竞争条件。如果一时没能发现其中的问题，建议读者再从头读一遍文章。为了鼓励读者独立思考、与他人交流，这里我就顺势偷个懒不公布答案了。毕竟，在实际工作中，可不是总会有人告诉你你的代码写得是否正确。</p><h1 id="内存屏障一瞥"><a href="#内存屏障一瞥" class="headerlink" title="内存屏障一瞥"></a>内存屏障一瞥</h1><p>所谓的内存屏障，主要分为 3 种：</p><ol><li>read memory barrier（rmb），保证屏障前的读发生在屏障后的读操作之前</li><li>write memory barrier（wmb），保证屏障前的写发生在屏障后的写操作之前</li><li>full memory barrier（mb），保证屏障前的读写操作发生在屏障后的读写操作之前</li></ol><p>前面 <code>prepare_to_wait</code> 有这么一段注释：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: we use "set_current_state()" _after_ the wait-queue add,</span></span><br><span class="line"><span class="comment"> * because we need a memory barrier there on SMP, so that any</span></span><br><span class="line"><span class="comment"> * wake-function that tests for the wait-queue being active</span></span><br><span class="line"><span class="comment"> * will be guaranteed to see waitqueue addition _or_ subsequent</span></span><br><span class="line"><span class="comment"> * tests in this thread will see the wakeup having taken place.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The spin_unlock() itself is semi-permeable and only protects</span></span><br><span class="line"><span class="comment"> * one way (it only protects stuff inside the critical region and</span></span><br><span class="line"><span class="comment"> * stops them from bleeding out - it would still allow subsequent</span></span><br><span class="line"><span class="comment"> * loads to move into the critical region).</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>这段注释一开始我也是看得云里雾里，直到我找到了他们解决一个内核 bug 的<a href="http://lkml.iu.edu/hypermail/linux/kernel/0312.1/1497.html" target="_blank" rel="noopener">邮件</a>（Google 大法好）。</p><p>这里面的 tests for the wait-queue being active 可以根据 <code>waitqueue_active</code> 来理解，其实指的就是等待队列不为空。spin-lock 虽然可以防止数据竞争，但如果别人在检查的时候不去获取锁呢？（<code>waitqueue_active</code> 就没有加锁）。当然，不加锁可以获得更好的性能。<br>j<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">waitqueue_active</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;q-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>set_current_state</code> 使用 <code>set_mb</code> 来设置当前进程的状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * set_current_state() includes a barrier so that the write of current-&gt;state</span></span><br><span class="line"><span class="comment"> * is correctly serialised wrt the caller's subsequent test of whether to</span></span><br><span class="line"><span class="comment"> * actually sleep:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    set_current_state(TASK_UNINTERRUPTIBLE);</span></span><br><span class="line"><span class="comment"> *    if (do_i_need_to_sleep())</span></span><br><span class="line"><span class="comment"> *        schedule();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the caller does not need such serialisation then use __set_current_state()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __set_current_state(state_value)                \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; current-&gt;state = (state_value); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_current_state(state_value)        \</span></span><br><span class="line">    set_mb(current-&gt;state, (state_value))</span><br></pre></td></tr></table></figure></p><p>下面是文档对 <code>set_mb</code> 的描述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(*) set_mb(var, value)</span><br><span class="line"></span><br><span class="line">    This assigns the value to the variable and then inserts a full memory</span><br><span class="line">    barrier after it, depending on the function.  It isn&apos;t guaranteed to</span><br><span class="line">    insert anything more than a compiler barrier in a UP compilation.</span><br></pre></td></tr></table></figure></p><p><code>set_current_state</code> 在设置当前进程的状态后，会插入一个 mb。前面我们了解到，这将禁止 CPU 将 <code>set_current_state</code> 后面的 load/store 提前。</p><p>为了理解完全理解这里 <code>set_mb</code> 的使用，我们还需要再参考一下 <code>wake_up</code> 函数。但由于篇幅关系，这里我只是简单介绍它的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for_each_process_in_wait_queue_without_lock:</span><br><span class="line">    if process.state is sleeping:</span><br><span class="line">        wake it up</span><br><span class="line">        remove it from wait-queue</span><br></pre></td></tr></table></figure></p><p>假设在 <code>prepare_to_wait</code> 里面我使用的是平凡的 <code>__set_current_state</code>，那么 CPU 就可以把 <code>prepare_to_wait</code> 函数返回后我们所执行的对条件的判断提前到设置进程状态前。这种情况下，如果发生以下的执行序列，CPU2 将会丢失一个 wake-up，他有可能会永远休眠。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CPU0                    CPU1</span><br><span class="line">----------------        ------------------</span><br><span class="line">                        check_condition() =&gt; false</span><br><span class="line">condition = true</span><br><span class="line">wake_up()</span><br><span class="line">                        __set_current_state()</span><br><span class="line">                        schedule()</span><br></pre></td></tr></table></figure></p><p>解决办法就是引入一个 <code>mb</code>。在下面的例子中，如果 <code>__set_current_state()</code> 在 <code>wake_up()</code> 后执行，CPU1 上的这个线程将不会被唤醒，但随后的 <code>check_condition()</code> 会正确返回 <code>true</code>。反过来，如果 <code>__set_current_state()</code> 在 <code>wake_up()</code> 前执行，<code>check_condition()</code> 可能返回 <code>true</code> 也可能返回 <code>false</code>，但无论如何，他都不会丢失随后的 <code>wake_up()</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CPU0                    CPU1</span><br><span class="line">----------------        ------------------</span><br><span class="line">condition = true</span><br><span class="line">wake_up()</span><br><span class="line">                        __set_current_state()</span><br><span class="line">                        mb();</span><br><span class="line">                        check_condition() =&gt; true</span><br></pre></td></tr></table></figure></p><p>还记得吗，<code>set_current_state</code> 就是在设置进程状态后插入一个内存屏障，所以 <code>prepare_to_wait</code> 直接使用 <code>set_current_state</code> 就可以了。</p><p>现在，我们终于可以说自己完全理解 <code>wait_event</code> 了。也许读者是第一次接触内存屏障，但我敢保证，很多 Java 程序员在不知不觉中使用过一定形式上的屏障。下面我们看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSomeData;          <span class="comment">// guarded by mDataSet</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSomeOtherData;     <span class="comment">// guarded by mDataSet</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mDataSet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDataSet) &#123;</span><br><span class="line">        <span class="comment">// you can now use mSomeData, mSomeOtherData</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSomeData = <span class="number">1</span>;</span><br><span class="line">    mSomeOtherData = <span class="number">2</span>;</span><br><span class="line">    mDataSet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一定开发经验的读者很可能看过类似的代码。虽然我们没有在 <code>mSomeData</code> 和 <code>mSomeOtherData</code> 的读写上做显式的同步，但只要仔细编写代码，利用一个 <code>volatile</code> 变量 <code>mDataSet</code>，这段代码也可以是线程安全的。</p><p>为了避免引入内存屏障这个比较复杂的概念（并且提供更好的移植性），Java 使用一个 happens-before 来描述相关的概念。关于 <code>volatile</code> 有这么一条描述：</p><blockquote><p>A write to a <code>volatile</code> field happens-before every subsequent read of that field.</p></blockquote><p>另外，对于同一个线程，有：</p><blockquote><p>If x and y are actions of the same thread and x comes before y in program order, then x happen before y.</p></blockquote><p>同时，happens-before 具有传递性（x -&gt; y, y -&gt; z, x -&gt; z），所以就有了下面这个结论：</p><p>对 <code>mSomeData, mSomeOtherData</code> 的写操作在 <code>mDataSet = true</code> 之前；<code>mDataSet = true</code> 在随后另一个线程对他的读操作之前；所以 <code>mSomeData, mSomeOtherData</code> 的写操作在随后对 <code>mDataSet</code> 的读操作之前。</p><p>直白一点说，只要一个线程看到 <code>mDataSet</code> 为 <code>true</code>，那他就一定能够正确读取到 <code>mSomeData, mSomeOtherData</code> 的值。</p><p>如果显式使用内存屏障，上面的代码就相当于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSomeData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSomeOtherData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mDataSet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDataSet) &#123;</span><br><span class="line">        <span class="comment">// 这个读内存屏障保证我们读到 mDataSet 后，也能读到 mSomeData/mSomeOtherData</span></span><br><span class="line">        <span class="comment">// 的最新值</span></span><br><span class="line">        rmb();</span><br><span class="line">        <span class="comment">// you can now use mSomeData, mSomeOtherData</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSomeData = <span class="number">1</span>;</span><br><span class="line">    mSomeOtherData = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 写内存屏障保证对 mSomeData/mSomeOtherData 的写在 mDataSet = true 之前执行</span></span><br><span class="line">    wmb();</span><br><span class="line">    mDataSet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，墙裂推荐一本并行编程的神书《Is Parallel Programming Hard, And, If So, What Can You Do About It?》（可以免费获取），书里有关于内存屏障的最好的描述。</p>]]></content>
    
    <summary type="html">
    
      看 Linux 的 wait_event 源码时，联想到我们平时经常用得比较多的 wait/notify、double-check 和 volatile，突然意识 wait_event 简简单单几行代码的背后，涉及的知识非常丰富。本篇文章我们就一起了来探索它背后的知识，然后尝试着和我们的日常开发关联起来。
    
    </summary>
    
      <category term="Linux" scheme="https://jekton.github.io/categories/Linux/"/>
    
    
      <category term="Java" scheme="https://jekton.github.io/tags/Java/"/>
    
      <category term="Linux" scheme="https://jekton.github.io/tags/Linux/"/>
    
      <category term="parallel-programming" scheme="https://jekton.github.io/tags/parallel-programming/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核页表的创建</title>
    <link href="https://jekton.github.io/2018/11/18/linux-page-table-setup/"/>
    <id>https://jekton.github.io/2018/11/18/linux-page-table-setup/</id>
    <published>2018-11-18T10:49:38.000Z</published>
    <updated>2018-11-25T03:35:50.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>源码使用 Linux 2.6.24，基于 x86 平台；参考书是《深入理解 LINUX 内核》第三版</p></blockquote><p>内核跟普通的应用一样，为了使用虚拟内存，也需要一个给 CPU 设置一个页表。在这篇文章中，我们就一起来了解 Linux 是如何为内核创建页表的。需要注意的是，这里我并不打算详细讲解页表的方方面面，硬件相关的基础知识，读者可以参考《深入理解LINUX内核》第3版第2章。本文的目的在于，作为该书的补充，基于真实的源码来讲解这一过程。</p><h1 id="临时内核页表的构造"><a href="#临时内核页表的构造" class="headerlink" title="临时内核页表的构造"></a>临时内核页表的构造</h1><p>x86 系统刚刚启动时候运行在实模式下，这个时候线性地址就是物理地址。为了进入 32 位保护模式，首先就要启用分页（paging）。这就要求我们构建一个页表；这张页表把线性地址映射转换为物理地址。由于不同的计算机的配置不一样，他们需要的页表大小、页表个数也都不一样，所以需要在运行时动态分配页表，这就要求我们具有动态内存分配能力。</p><p>为了解决构造页表时候的鸡生蛋蛋生鸡问题，Linux 使用了一个临时的内核页表。它只有两个页表（这里的页表指的是用来索引页框的最后一级页表）。在不启用 PAE (Page Addression Extension) 和 PSE（Page Size Extension）的情况下，一个页表可以指向 <code>10^2 = 1024</code> 个内存页，一个内存页 4K，所以两个页表允许我们索引 8M 的内存。</p><p>顶层的页目录（page directory）使用全局变量 <code>swapper_pg_dir</code> 定义，下面是它的声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/include/asm-x86/pgtable_32.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// empty_zero_page 在后面也会用到，这里就一并列出来了</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> empty_zero_page[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pgd_t</span> swapper_pg_dir[<span class="number">1024</span>];</span><br></pre></td></tr></table></figure></p><p>他在 <code>head_32.S</code> 里面定义的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># $&#123;linux_source&#125;/arch/x86/kernel/head_32.S</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * BSS section</span><br><span class="line"> */</span><br><span class="line">.section &quot;.bss.page_aligned&quot;,&quot;wa&quot;</span><br><span class="line">.align PAGE_SIZE_asm</span><br><span class="line">ENTRY(swapper_pg_dir)</span><br><span class="line">.fill 1024,4,0</span><br><span class="line">ENTRY(swapper_pg_pmd)</span><br><span class="line">.fill 1024,4,0</span><br><span class="line">ENTRY(empty_zero_page)</span><br><span class="line">.fill 4096,1,0</span><br></pre></td></tr></table></figure></p><p>这里的 <code>.fill 1024,4,0</code> 的意思是用 0 填充 1024 个 4 byte 长度的内存（一个页目录项（page table entry）的大小是 32 bit）。</p><p>接下来是变量 <code>pg0</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/include/asm-x86/pgtable_32.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The boot page tables (all created as a single array) */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pg0[];</span><br></pre></td></tr></table></figure></p><p><code>pg0</code> 通过指示链接器，放在了 bss 段的后面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /* 前面那些都略去了 */</span><br><span class="line"></span><br><span class="line">  .bss : AT(ADDR(.bss) - LOAD_OFFSET) &#123;</span><br><span class="line">__init_end = .;</span><br><span class="line">__bss_start = .;/* BSS */</span><br><span class="line">*(.bss.page_aligned)</span><br><span class="line">*(.bss)</span><br><span class="line">. = ALIGN(4);</span><br><span class="line">__bss_stop = .;</span><br><span class="line">  _end = . ;</span><br><span class="line">/* This is where the kernel creates the early boot page tables */</span><br><span class="line">. = ALIGN(4096);</span><br><span class="line">pg0 = . ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了 <code>swapper_pg_dir</code> 和 <code>pg0</code> 后，接下来的工作就是对它们进行初始化。此时还处于实模式下，这部分工作是由汇编代码完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># $&#123;linux_source&#125;/arch/x86/kernel/head_32.S</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Initialize page tables.  This creates a PDE and a set of page</span><br><span class="line"> * tables, which are located immediately beyond _end.  The variable</span><br><span class="line"> * init_pg_tables_end is set up to point to the first &quot;safe&quot; location.</span><br><span class="line"> * Mappings are created both at virtual address 0 (identity mapping)</span><br><span class="line"> * and PAGE_OFFSET for up to _end+sizeof(page tables)+INIT_MAP_BEYOND_END.</span><br><span class="line"> *</span><br><span class="line"> * Warning: don&apos;t use %esi or the stack in this code.  However, %esp</span><br><span class="line"> * can be used as a GPR if you really need it...</span><br><span class="line"> */</span><br><span class="line"># __PAGE_OFFSET 是 0xc000 0000，所以 page_pde_offset 是 0xc00</span><br><span class="line">page_pde_offset = (__PAGE_OFFSET &gt;&gt; 20);</span><br><span class="line"></span><br><span class="line">default_entry:</span><br><span class="line"># __PAGE_OFFSET 是 3G，pg0 是虚拟地址，减去 __PAGE_OFFSET 后就得到了</span><br><span class="line"># pg0 的物理地址。我们把 pg0 的物理地址放在了 edi 寄存器里</span><br><span class="line">movl $(pg0 - __PAGE_OFFSET), %edi</span><br><span class="line"># 同理，这里把 swapper_pg_dir 的物理地址放在 edx</span><br><span class="line">movl $(swapper_pg_dir - __PAGE_OFFSET), %edx</span><br><span class="line"># page directory/table entry 的低 12 位都是一些标志物，各个位代表的含义</span><br><span class="line"># 读者可以参考 https://wiki.osdev.org/Paging 或者书中的第 52 页</span><br><span class="line">movl $0x007, %eax/* 0x007 = PRESENT+RW+USER */</span><br><span class="line">10:</span><br><span class="line"># 下面这两行代码对熟悉 C 语言的读者可能会造成一定的困扰。如果从 C 语言的角度</span><br><span class="line"># 来看，它们是把地址 &amp;pg0 + 7 放到了 swapper_pg_dir 的第一项；但问题在于，</span><br><span class="line"># 为什么要 +7？</span><br><span class="line"># 其实这里的 7 和前面那个 7 一样，指的是页目录项的标志物 PRESENT+RW+USER，</span><br><span class="line"># pg0 的地址是 4K 对齐的，这意味着他的地址的低 12 位都为 0，加上 7 以后，刚</span><br><span class="line"># 好就是我们所需要的页目录项的值。</span><br><span class="line">leal 0x007(%edi),%ecx/* Create PDE entry */</span><br><span class="line">movl %ecx,(%edx)/* Store identity PDE entry */</span><br><span class="line"># 书里有说明，我们要把 0x0000 0000 ~ 0x007f ffff 和 0xc000 0000 ~ 0xc07f ffff</span><br><span class="line"># 都映射到物理地址 0x0000 0000 ~ 0x007f ffff，下面这一行设置的 0xc000 0000</span><br><span class="line"># 对应的页目录项。</span><br><span class="line"># 这里的问题在于，按照书里的说明，我们应该设置的是第 0x300 项，这里是加上的却是 0xc00。</span><br><span class="line"># 这里需要提一下平时用 C 语言时编译器帮我们做的事。当我们写下 int *p = NULL; p+2</span><br><span class="line"># 的时候，编译器知道 int 是 4 个字节，所以 p+2 会汇编代码里面是 +8。</span><br><span class="line"># 一个 PDE 也是 32 位，所以真正的偏移量是 0x300 &lt;&lt; 2 = 0xc00</span><br><span class="line">movl %ecx,page_pde_offset(%edx)/* Store kernel PDE entry */</span><br><span class="line"># edx + 4 以后，就是下一个页目录项了，下个循环将会继续初始化（一共两个页目录项）</span><br><span class="line">addl $4,%edx</span><br><span class="line"># 一个页表有 1024 个页表项，这里初始化一个在接下来的循环里面用到的计数器</span><br><span class="line">movl $1024, %ecx</span><br><span class="line">11:</span><br><span class="line"># stosl 把 %eax 的内容复制到物理地址 ES:EDI，也就是 pg0 处；并且 %edi + 4</span><br><span class="line">stosl</span><br><span class="line"># 加上 0x1000 后，%eax 指向下一个页</span><br><span class="line">addl $0x1000,%eax</span><br><span class="line"># %ecx -= 1，如果 %ecx 不为 0，跳转到 11 处。这里总共会循环 1024 次，初始化 1024 个页表项。</span><br><span class="line">loop 11b</span><br><span class="line">/* End condition: we must map up to and including INIT_MAP_BEYOND_END */</span><br><span class="line">/* bytes beyond the end of our own page tables; the +0x007 is the attribute bits */</span><br><span class="line">leal (INIT_MAP_BEYOND_END+0x007)(%edi),%ebp</span><br><span class="line">cmpl %ebp,%eax</span><br><span class="line">jb 10b</span><br><span class="line"># 到这里的时候，%edi 的值是我们映射的最后一个页表项的地址，这里我们把它存到变量</span><br><span class="line"># init_pg_tables_end 里。init_pg_tables_end 在 setup_32.c 里定义</span><br><span class="line">movl %edi,(init_pg_tables_end - __PAGE_OFFSET)</span><br><span class="line"></span><br><span class="line"># 下面是固定映射的，这部分就先不看了</span><br><span class="line">/* Do an early initialization of the fixmap area */</span><br><span class="line">movl $(swapper_pg_dir - __PAGE_OFFSET), %edx</span><br><span class="line">movl $(swapper_pg_pmd - __PAGE_OFFSET), %eax</span><br><span class="line">addl $0x67, %eax/* 0x67 == _PAGE_TABLE */</span><br><span class="line">movl %eax, 4092(%edx)</span><br><span class="line"></span><br><span class="line">xorl %ebx,%ebx/* This is the boot CPU (BSP) */</span><br><span class="line">jmp 3f</span><br></pre></td></tr></table></figure></p><p>前面代码的最后一行是一个 <code>jmp 3f</code>，下面，我们就看看这个 <code>3</code> 处的代码。</p><h1 id="启用分页"><a href="#启用分页" class="headerlink" title="启用分页"></a>启用分页</h1><p>构建好临时内核页表后，接下来就该启用分页了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># $&#123;linux_source&#125;/arch/x86/kernel/head_32.S</span><br><span class="line"></span><br><span class="line">3:</span><br><span class="line">/*</span><br><span class="line"> * Enable paging</span><br><span class="line"> */</span><br><span class="line">movl $swapper_pg_dir-__PAGE_OFFSET,%eax</span><br><span class="line"># %cr3 寄存器存放的是页表的地址</span><br><span class="line">movl %eax,%cr3/* set the page table pointer.. */</span><br><span class="line">movl %cr0,%eax</span><br><span class="line"># cr0 的最高位是 Paging 位，置 1 后启用分页</span><br><span class="line"># 关于 cr0，参考 https://en.wikipedia.org/wiki/Control_register#CR0</span><br><span class="line">orl $0x80000000,%eax</span><br><span class="line">movl %eax,%cr0/* ..and set paging (PG) bit */</span><br></pre></td></tr></table></figure></p><p>CPU 的分页机制现在已经启用了，但是我们的页表还是不完整的，剩下部分将会使用 C 语言来完成。</p><h1 id="构建线性地址的内核页表"><a href="#构建线性地址的内核页表" class="headerlink" title="构建线性地址的内核页表"></a>构建线性地址的内核页表</h1><p>完整的页表构建是从函数 <code>pagetable_init</code> 开始的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/arch/x86/mm/init_32.S</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">pagetable_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vaddr, end;</span><br><span class="line"><span class="keyword">pgd_t</span> *pgd_base = swapper_pg_dir;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable PSE if available */</span></span><br><span class="line"><span class="keyword">if</span> (cpu_has_pse)</span><br><span class="line">set_in_cr4(X86_CR4_PSE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable PGE if available */</span></span><br><span class="line"><span class="keyword">if</span> (cpu_has_pge) &#123;</span><br><span class="line">set_in_cr4(X86_CR4_PGE);</span><br><span class="line">__PAGE_KERNEL |= _PAGE_GLOBAL;</span><br><span class="line">__PAGE_KERNEL_EXEC |= _PAGE_GLOBAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kernel_physical_mapping_init(pgd_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是固定映射相关的内容，这里就先忽略了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际的页表构建是在函数 <code>kernel_physical_mapping_init</code> 完成的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $&#123;linux_source&#125;/arch/x86/mm/init_32.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This maps the physical memory to kernel virtual address space, a total </span></span><br><span class="line"><span class="comment"> * of max_low_pfn pages, by creating page tables starting from address </span></span><br><span class="line"><span class="comment"> * PAGE_OFFSET.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">kernel_physical_mapping_init</span><span class="params">(<span class="keyword">pgd_t</span> *pgd_base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pfn;</span><br><span class="line"><span class="keyword">pgd_t</span> *pgd;</span><br><span class="line"><span class="keyword">pmd_t</span> *pmd;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="keyword">int</span> pgd_idx, pmd_idx, pte_ofs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PAGE_OFFSET 是 0xc000 0000，这里拿的内核虚拟地址第一项对应的 pgd 的 index</span></span><br><span class="line">pgd_idx = pgd_index(PAGE_OFFSET);</span><br><span class="line">pgd = pgd_base + pgd_idx;</span><br><span class="line">pfn = <span class="number">0</span>;<span class="comment">// pfn 代表 page frame number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 pgd。pgd 的项数由 PTRS_PER_PGD 定义，在最普通的情况下，它是 1024。</span></span><br><span class="line"><span class="comment">// 如果启用了 PAE，则等于 4</span></span><br><span class="line"><span class="keyword">for</span> (; pgd_idx &lt; PTRS_PER_PGD; pgd++, pgd_idx++) &#123;</span><br><span class="line"><span class="comment">// 32 位的系统一般是 2 级页表结构（为什么说它是一般，读者后面就会知道了）</span></span><br><span class="line"><span class="comment">// 每个 pgd 项都指向一个 pmd，one_md_table_init 初始化一个 pmd。</span></span><br><span class="line"><span class="comment">// 建议读者这里先跳过本函数后面部分，看完 one_md_table_init 再回过头来继续往下看</span></span><br><span class="line">pmd = one_md_table_init(pgd);</span><br><span class="line"><span class="comment">// max_low_pfn 是被内核直接映射的最后一个页框的页框号，参考书中第 72 页</span></span><br><span class="line"><span class="keyword">if</span> (pfn &gt;= max_low_pfn)</span><br><span class="line"><span class="comment">// 超过 max_low_pfn 的 pte 可以不初始化，但 pmd 必须初始化，所以用 continue</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 对不启用 PAE 的系统来说，这里的 pmd 就是 pgd，PTRS_PER_PMD 等于 1。</span></span><br><span class="line"><span class="comment">// 如果启用 PAE，PTRS_PER_PMD 等于 512。</span></span><br><span class="line"><span class="comment">// 这里的 pmd 相当于页目录（Page Directory）,下面的循环里初始化每个页目录项（每个页目录项</span></span><br><span class="line"><span class="comment">// 指向一个页表项）</span></span><br><span class="line"><span class="keyword">for</span> (pmd_idx = <span class="number">0</span>; pmd_idx &lt; PTRS_PER_PMD &amp;&amp; pfn &lt; max_low_pfn; pmd++, pmd_idx++) &#123;</span><br><span class="line"><span class="comment">// address 是当前（物理）页框开头对应的虚拟地址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> address = pfn * PAGE_SIZE + PAGE_OFFSET;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Map with big pages if possible, otherwise create normal page tables. */</span></span><br><span class="line"><span class="keyword">if</span> (cpu_has_pse) &#123;</span><br><span class="line"><span class="comment">// pfn + PTRS_PER_PTE - 1 是当前 pmd 能够索引的最大的页框号</span></span><br><span class="line"><span class="comment">// * PAGE_SIZE + PAGE_OFFSET + (PAGE_SIZE-1) 就是当前 pmd 做能够指向的最大的</span></span><br><span class="line"><span class="comment">// 地址。也就是说，pmd 的地址范围是 [address, address2]</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> address2 = (pfn + PTRS_PER_PTE - <span class="number">1</span>) * PAGE_SIZE + PAGE_OFFSET + PAGE_SIZE<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (is_kernel_text(address) || is_kernel_text(address2))</span><br><span class="line"><span class="comment">// pmd 包含了内核的 text 段，所以加上了 exec 标记</span></span><br><span class="line">set_pmd(pmd, pfn_pmd(pfn, PAGE_KERNEL_LARGE_EXEC));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">set_pmd(pmd, pfn_pmd(pfn, PAGE_KERNEL_LARGE));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用 PSE 后就不需要 pte 了。</span></span><br><span class="line"><span class="comment">// 对于启用了 PAE 的机器来说，一页是 2^(9+12) = 2M</span></span><br><span class="line"><span class="comment">// 没有 PAE 则是 2^(10+12) = 4M</span></span><br><span class="line">pfn += PTRS_PER_PTE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pte = one_page_table_init(pmd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (pte_ofs = <span class="number">0</span>;</span><br><span class="line">     pte_ofs &lt; PTRS_PER_PTE &amp;&amp; pfn &lt; max_low_pfn;</span><br><span class="line">     pte++, pfn++, pte_ofs++, address += PAGE_SIZE) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_kernel_text(address))</span><br><span class="line">set_pte(pte, pfn_pte(pfn, PAGE_KERNEL_EXEC));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">set_pte(pte, pfn_pte(pfn, PAGE_KERNEL));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Creates a middle page table and puts a pointer to it in the</span></span><br><span class="line"><span class="comment"> * given global directory entry. This only returns the gd entry</span></span><br><span class="line"><span class="comment"> * in non-PAE compilation mode, since the middle layer is folded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pmd_t</span> * __<span class="function">init <span class="title">one_md_table_init</span><span class="params">(<span class="keyword">pgd_t</span> *pgd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pud_t</span> *pud;</span><br><span class="line"><span class="keyword">pmd_t</span> *pmd_table;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_PAE</span></span><br><span class="line"><span class="keyword">if</span> (!(pgd_val(*pgd) &amp; _PAGE_PRESENT)) &#123;</span><br><span class="line"><span class="comment">// 启用 PAE 的情况下，32 bit 的虚拟地址分为 2 9 9 12，pgd 有</span></span><br><span class="line"><span class="comment">// 2^2 = 4 项；pmd 是 2^9 = 512 项；然后是 pte 2^9 = 512 项；</span></span><br><span class="line"><span class="comment">// pte 在 kernel_physical_mapping_init 中初始化。</span></span><br><span class="line"><span class="comment">// PAE 相关知识参考书上第 56 页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bootmem 相关的后面昨晚单独的一篇文章来讲述，这里假装内存被</span></span><br><span class="line"><span class="comment">// 神奇地分配出来就好</span></span><br><span class="line">pmd_table = (<span class="keyword">pmd_t</span> *) alloc_bootmem_low_pages(PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟化相关的东西，忽略就好</span></span><br><span class="line">paravirt_alloc_pd(__pa(pmd_table) &gt;&gt; PAGE_SHIFT);</span><br><span class="line">set_pgd(pgd, __pgd(__pa(pmd_table) | _PAGE_PRESENT));</span><br><span class="line">pud = pud_offset(pgd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pmd_table != pmd_offset(pud, <span class="number">0</span>))</span><br><span class="line">BUG();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 在不启用 PAE 的情况下，下面返回的 pmd_table 其实就是 pgd（也就是</span></span><br><span class="line"><span class="comment">// 直接从 pgd 到 pte，两者都是 2^10 = 1024 项）</span></span><br><span class="line">pud = pud_offset(pgd, <span class="number">0</span>);</span><br><span class="line">pmd_table = pmd_offset(pud, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> pmd_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数就比较平凡了，没有什么好说的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a page table and place a pointer to it in a middle page</span></span><br><span class="line"><span class="comment"> * directory entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pte_t</span> * __<span class="function">init <span class="title">one_page_table_init</span><span class="params">(<span class="keyword">pmd_t</span> *pmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(pmd_val(*pmd) &amp; _PAGE_PRESENT)) &#123;</span><br><span class="line"><span class="keyword">pte_t</span> *page_table = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PAGEALLOC</span></span><br><span class="line">page_table = (<span class="keyword">pte_t</span> *) alloc_bootmem_pages(PAGE_SIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (!page_table)</span><br><span class="line">page_table =</span><br><span class="line">(<span class="keyword">pte_t</span> *)alloc_bootmem_low_pages(PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">paravirt_alloc_pt(&amp;init_mm, __pa(page_table) &gt;&gt; PAGE_SHIFT);</span><br><span class="line">set_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));</span><br><span class="line">BUG_ON(page_table != pte_offset_kernel(pmd, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pte_offset_kernel(pmd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这部分代码其实有 4 中情况：有 PAE 和没有 PAE两种，这两种又分别有 PSE 启不启用两种情况。读者可以分情况一个一个看，分情况弄清楚后，再合并一起看。</p><h1 id="固定映射的线性地址、非连续内存区的线性地址"><a href="#固定映射的线性地址、非连续内存区的线性地址" class="headerlink" title="固定映射的线性地址、非连续内存区的线性地址"></a>固定映射的线性地址、非连续内存区的线性地址</h1><p>处于篇幅和学习目的考虑，固定映射、非连续内存的处理在这里就先略去了，以后有机会再单独开一篇文章补上。内核页表的创建相关的代码我们就先看到这里。</p>]]></content>
    
    <summary type="html">
    
      内核跟普通的应用一样，为了使用虚拟内存，也需要一个给 CPU 设置一个页表。在这篇文章中，我们就一起来了解 Linux 是如何为内核创建页表的。
    
    </summary>
    
      <category term="Linux" scheme="https://jekton.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://jekton.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解 LINUX 内核》读书笔记 - 临时内核页表</title>
    <link href="https://jekton.github.io/2018/11/18/note-x86-provisional-kernel-page-table-setup/"/>
    <id>https://jekton.github.io/2018/11/18/note-x86-provisional-kernel-page-table-setup/</id>
    <published>2018-11-18T04:04:22.000Z</published>
    <updated>2018-11-18T10:36:02.826Z</updated>
    
    <content type="html"><![CDATA[<p>x86 在启动的时候，CPU 处于实模式；而在保护模式下，为了将线性（内存）地址转换为物理内存地址，我们需要给 CPU 设置页表。本篇文件主要给《深入理解 LINUX 内核》临时内核页表一节（P74）中作者描述不太详细的部分添加更多的解释，并不打算把书中相关的知识点都搬上来，相关知识读者可以参考书中的描述。</p><blockquote><p>本文基于 <code>Linux 2.6.24</code>，x86 平台</p></blockquote><p>在使用分页（paging）的时候，需要构造相应的页表。对于使用一级页表的 x86 系统来说，页目录是必须的。但是这 1024 个页目录项并不需要都指向具体的页表，按需分配就行。看到“分配”这个词，读者就要注意了，它意味着动态内存分配。啊！我们连页表都没有，怎么动态分配内存！！没关系，我们弄个临时页表就可以解决这个鸡蛋和鸡的问题了。</p><p>内核临时页面的设置由 <code>startup_32()</code> 函数完成，这个函数是用汇编语言实现的，位于 <code>arch/x86/kernel/head_32.S</code>。</p><p>我们需要特别留意的是文中提到的，“在这个阶段PAE支持并未激活”。PAE 未激活，意味着此时使用的是二级页表接口，一个页表项 32 bits，DIRECTORY 字段 10 bits，TABLE 字段 10 bits 和 OFFSET 12 bits（参考第 52 页图 2-7）。</p><p>OFFSET 12 bits，所有一个 page 的大小是 <code>2^12 = 4K</code>。TABLE 字段有 10 bits，所以一个页目录项可以指向的页大小为 <code>2^10 * 4K = 4M</code>。我们需要映射 <code>8M</code> 的内存，所以<strong>两个</strong>页目录项就足够了。</p><p>接下来我们需要明白的是，内核映像是加载在物理地址的低端的（P73 图 2-13）。而内核在链接（link）的时候，起始地址却是 <code>0xc000 0000</code>。在实模式，线性地址直接翻译为物理地址；而在保护模式，线性地址需要经过页表的转换后才是物理地址。当我们把线性 <code>0x0000 0000 ~ 0x007f ffff</code> 和 <code>0xc000 0000 ~ 0xc07f ffff</code> 都映射到物理地址 <code>0x0000 0000 ~ 0x007f ffff</code> 时，内核代码就不需要区分当前使用的是线性地址还是物理地址了（直接使用物理地址，经过页表转换后的值是一样的）。</p><p>注意，这里 <code>0x0000 0000 ~ 0x007f ffff</code> 的大小就刚好是 <code>8M</code>。</p><p>确定了需要映射的内存范围后，便可以开始构造页表项。我们设置 <code>swapper_pg_dir</code> 的第 0、1 项的目的很明显（前面我们说了，8M 的内存，共需要 2 个页目录项），它们就对应着线性地址 <code>0x0000 0000 ~ 0x007f ffff</code>。这样一来，第 768、769 项应该就对应着内存 <code>0xc000 0000 ~ 0xc07f ffff</code> 了。这里我们关心都是，768 是怎么出来的？</p><p>我们知道，DIRECTORY 字段有 10 bits，共 <code>2^10 = 1024</code> 个目录项。<code>0xc000 0000</code> 刚好在 4G 内存的 3/4 处。利用这个信息，我们就能够计算 <code>0xc000 0000</code> 对应的页表项为 <code>1024 * (3/4) = 768</code>。另一种更直接的方法是，按照 MMU 转换线性地址时的方法，取 <code>0xc000 0000</code> 的前 10 个位，即得到 <code>0x300</code>。</p><p>在最后，我们来看启用分页的一小段汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl $swapper_pg_dir-__PAGE_OFFSET,%eax</span><br><span class="line">movl %eax,%cr3/* set the page table pointer.. */</span><br><span class="line">movl %cr0,%eax</span><br><span class="line">orl $0x80000000,%eax</span><br><span class="line">movl %eax,%cr0/* ..and set paging (PG) bit */</span><br></pre></td></tr></table></figure><p><code>swapper_pg_dir</code> 就是我们构造的临时页表，问题在于，为什么需要减去 <code>__PAGE_OFFSET</code>（其实就是 <code>0xc0000000</code>）呢？答案在前面我们其实已经说过了，内核在链接（link）的时候，起始地址是 <code>0xc000 0000</code>。也就是说，从内核的视角来看，他以为自己是从 <code>0xc0000000</code> 开始的。<code>$swapper_pg_dir - __PAGE_OFFSET</code> 后，才是 <code>swapper_pg_dir</code> 真正的内存地址（在执行这一行代码的时候，CPU 还处于实模式，这个模式下，线性地址就是物理地址）。</p><p><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;x86 在启动的时候，CPU 处于实模式；而在保护模式下，为了将线性（内存）地址转换为物理内存地址，我们需要给 CPU 设置页表。本篇文件主要给《深入理解 LINUX 内核》临时内核页表一节（P74）中作者描述不太详细的部分添加更多的解释，并不打算把书中相关的知识点都搬上来
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://jekton.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://jekton.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://jekton.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（5）- 插件的使用、开发和发布</title>
    <link href="https://jekton.github.io/2018/09/16/flutter-plugin-dev/"/>
    <id>https://jekton.github.io/2018/09/16/flutter-plugin-dev/</id>
    <published>2018-09-16T01:34:02.000Z</published>
    <updated>2018-09-18T12:17:10.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>本篇文章我们先一起学习 Flutter 插件的使用，然后通过开发一个 toast 插件来学习它的开发，最后发布到 Pub 上。</p><h1 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h1><p>Flutter 的库是以 package 的方式来管理。Package 分为两种，Dart package（也叫 library package） 和 plugin package。当我们说 Fluter 包的时候，指的其实也是 Dart 包，它只能使用 Dart 和 Flutter 提供的 API；而当我们说 Flutter 插件时指的是后者，也就是 plugin package。Flutter 插件通常会包含平台特定的代码。对包的使用者来说，两者没有区别。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>为了使用一个库，我们首先在 pubspec.yaml 里声明一个依赖：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  shared_preferences:</span> <span class="string">^0.4.2</span></span><br></pre></td></tr></table></figure></p><p><code>^0.4.2</code> 表示与 <code>0.4.2</code> 兼容的版本。我们也可以指定依赖库的为特定的版本：</p><ul><li>any：任意版本</li><li>1.2.3：特定的版本</li><li>&lt;1.2.3：小于 1.2.3 的版本，此外还有 &lt;=、&gt;、&gt;= 可以使用</li><li>‘&gt;=1.2.3 &lt;2.0.0’：指定一个范围</li></ul><p>接下来，在项目的根目录执行 <code>flutter packages get</code>。如果你使用 Android Studio 进行开发，也可以直接在 pubspec.yaml 的编辑页面上面点击 Packages get 按钮。</p><p>上面例子的是发布在 <code>https://pub.dartlang.org/</code> 上的库，除此之外，我们也可以使用其他的源：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  transmogrify:</span></span><br><span class="line"><span class="attr">    hosted:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">transmogrify</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://your-package-server.com</span></span><br><span class="line"><span class="attr">    version:</span> <span class="string">^1.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  kittens:</span></span><br><span class="line"><span class="attr">    git:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">git://github.com/munificent/cats.git</span></span><br><span class="line"><span class="attr">      ref:</span> <span class="string">some-branch</span>  <span class="comment"># 可选的</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  kittens:</span></span><br><span class="line"><span class="attr">    git:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">git://github.com/munificent/cats.git</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">path/to/kittens</span>  <span class="comment"># 指定路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 甚至可以指定一个本地路径</span></span><br><span class="line"><span class="attr">    transmogrify:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/Users/me/transmogrify</span></span><br></pre></td></tr></table></figure></p><p>如果你看过 Flutter 的 pubspec，应该会注意到 flutter 是这样声明的：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  flutter:</span></span><br><span class="line"><span class="attr">    sdk:</span> <span class="string">flutter</span></span><br></pre></td></tr></table></figure></p><p>sdk 用于导入随 Flutter 一起发布的包，目前只有 flutter。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>导入相关的包后，我们就可以使用它的 API 了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:shared_preferences/shared_preferences.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> prefs = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">  <span class="keyword">var</span> used = prefs.getBool(<span class="string">'used'</span>);</span><br><span class="line">  <span class="keyword">if</span> (!used) &#123;</span><br><span class="line">    prefs.setBool(<span class="string">'used'</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种导入方式的问题在于，他把库里所有的符号到导入到了全局的命名空间里面（比方说，在上面的例子里，我们可以直接使用 <code>SharedPreferences</code>）。有时为了防止命名空间的污染，我们可以使用 <code>as</code> 给导入的库一个名字（当然，对 SharedPreferences 其实没有必要使用限定名就是了）：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> prefs = <span class="keyword">await</span> sp.SharedPreferences.getInstance();</span><br><span class="line">  <span class="keyword">var</span> used = prefs.getBool(<span class="string">'used'</span>);</span><br><span class="line">  <span class="keyword">if</span> (!used) &#123;</span><br><span class="line">    prefs.setBool(<span class="string">'used'</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>了解了 Flutter 包的使用后，下面我们自己来开发一个 flutter 插件。</p><h1 id="开发一个插件"><a href="#开发一个插件" class="headerlink" title="开发一个插件"></a>开发一个插件</h1><p>学习 Flutter 的过程中，不知道是你是否注意到 Flutter 并没有提供一个 Toast API。为了弥补这个遗憾，在这一节里我们就来开发一个插件，让它支持 Toast。</p><p>在开始开发前，我们先来了解一下 Flutter 如何跟平台相关的代码进行通信。</p><h2 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h2><p>Flutter 跟平台相关代码可以通过 <code>MethodChannel</code> 进行通信。客户端通过 <code>MethodChannel</code> 将方法调用和参数发生给服务端，服务端也通过 <code>MethodChannel</code> 接收相关的数据。</p><p><img src="/2018/09/16/flutter-plugin-dev/PlatformChannels.png" alt="PlatformChannels"></p><p>需要注意的是，上图中的箭头是双向的。也就是说，我们不仅可以从 Flutter 调用 Android/iOS 的代码，也可以从 Android/iOS 调用 Flutter。调用时相关的参数对应如下：</p><table><thead><tr><th>Dart</th><th>Android</th><th>iOS</th></tr></thead><tbody><tr><td>null</td><td>null</td><td>nil (NSNull when nested)</td></tr><tr><td>bool</td><td>java.lang.Boolean</td><td>NSNumber numberWithBool:</td></tr><tr><td>int</td><td>java.lang.Integer</td><td>NSNumber numberWithInt:</td></tr><tr><td>int, if 32 bits not enough</td><td>java.lang.Long</td><td>NSNumber numberWithLong:</td></tr><tr><td>double</td><td>java.lang.Double</td><td>NSNumber numberWithDouble:</td></tr><tr><td>String</td><td>java.lang.String</td><td>NSString</td></tr><tr><td>Uint8List</td><td>byte[]</td><td>FlutterStandardTypedData typedDataWithBytes:</td></tr><tr><td>Int32List</td><td>int[]</td><td>FlutterStandardTypedData typedDataWithInt32:</td></tr><tr><td>Int64List</td><td>long[]</td><td>FlutterStandardTypedData typedDataWithInt64:</td></tr><tr><td>Float64List</td><td>double[]</td><td>FlutterStandardTypedData typedDataWithFloat64:</td></tr><tr><td>List</td><td>java.util.ArrayList</td><td>NSArray</td></tr><tr><td>Map</td><td>java.util.HashMap</td><td>NSDictionary</td></tr></tbody></table><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>这里假设读者使用 Android Studio 开发。</p><ol><li>在菜单上选择 File -&gt; New -&gt; New Flutter Project</li><li>在弹出的面板里选择 Flutter Plugin，点击 next</li><li>Project name 我们填入 flutter_toast2018，其他信息读者根据自身需要填写</li></ol><p>之所以叫 flutter_toast2018 是因为 Pub 上已经有一个 flutter_toast，所以加上 2018 防止名字冲突。</p><p>生成的项目有 4 个主要的目录：</p><ul><li>android：插件本地代码的 Android 端实现</li><li>ios：iOS 端的实现</li><li>lib：Dart 代码。插件的客户将会使用这里实现的接口</li><li>example：插件的使用示例</li></ul><h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><h3 id="Android-端代码实现"><a href="#Android-端代码实现" class="headerlink" title="Android 端代码实现"></a>Android 端代码实现</h3><p>其实在上一步我们生成项目的时候，项目里就已经包含了一个实现了 <code>platformVersion</code> 的 Flutter 插件 demo，有兴趣的读者可以看看学习一下。下面，我们来开发自己的 Toast 插件（注意，我们的实现只支持 Android）。</p><p>首先我们来了解一下接口 <code>MethodCallHandler</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个接口用于处理 Flutter 的本地方法调用请求。也就是说，我们需要实现这个接口，当 Flutter 调用我们的时候，弹出一个 toast。</p><p>实现这个接口的是 <code>FlutterToast2018Plugin</code>（位于 android 目录下）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterToast2018Plugin</span> <span class="keyword">implements</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// "example.com/flutter_toast2018" 是我们 method channel 的名字，Dart 代码里还需要用到它。</span></span><br><span class="line">    <span class="comment">// 为了防止命名冲突，可以在它的前面加上域名</span></span><br><span class="line">    <span class="keyword">final</span> channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), <span class="string">"example.com/flutter_toast2018"</span>);</span><br><span class="line">    channel.setMethodCallHandler(<span class="keyword">new</span> FlutterToast2018Plugin());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了弹出 Toast，我们给 <code>FlutterToast2018Plugin</code> 的构造函数添加一个 <code>Context</code> 参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterToast2018Plugin</span> <span class="keyword">implements</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FlutterToast2018Plugin</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册 MethodCallHandler</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), <span class="string">"example.com/flutter_toast2018"</span>);</span><br><span class="line">    <span class="comment">// context 可以从 Registrar 拿到</span></span><br><span class="line">    channel.setMethodCallHandler(<span class="keyword">new</span> FlutterToast2018Plugin(registrar.context());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，实现 <code>onMethodCall</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterToast2018Plugin</span> <span class="keyword">implements</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// call.method 是方法名，这里我们就叫它 toast</span></span><br><span class="line">    <span class="keyword">if</span> (call.method.equals(<span class="string">"toast"</span>)) &#123;</span><br><span class="line">      <span class="comment">// 调用本地代码的时候，只能传递一个参数。为了传递多个，可以把参数放在一个 map 里面。</span></span><br><span class="line">      <span class="comment">// call.arguemnt() 方法支持 Map 和 JSONObject</span></span><br><span class="line">      String content = call.argument(<span class="string">"content"</span>);</span><br><span class="line">      String duration = call.argument(<span class="string">"duration"</span>);</span><br><span class="line">      Toast.makeText(mContext, content,</span><br><span class="line">                     <span class="string">"short"</span>.equals(duration) ? Toast.LENGTH_SHORT : Toast.LENGTH_LONG)</span><br><span class="line">              .show();</span><br><span class="line">      <span class="comment">// 执行成功</span></span><br><span class="line">      result.success(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.notImplemented();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Flutter-端"><a href="#Flutter-端" class="headerlink" title="Flutter 端"></a>Flutter 端</h3><p>Flutter 端需要做的，就是生成一个 <code>MethodChannel</code>，然后通过这个 <code>MethodChannel</code> 调用 <code>toast</code> 方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ToastDuration &#123;</span><br><span class="line">  short, long</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterToast</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的名字要跟 Java 端的对应</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> MethodChannel _channel =</span><br><span class="line">      <span class="keyword">const</span> MethodChannel(<span class="string">'example.com/flutter_toast2018'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Future&lt;<span class="built_in">bool</span>&gt; toast(<span class="built_in">String</span> msg, ToastDuration duration) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> argument = &#123;</span><br><span class="line">      <span class="string">'content'</span>: msg,</span><br><span class="line">      <span class="string">'duration'</span>: duration.toString()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 本地方法是一个异步调用。'toast' 对应我们在前面 Java 代码的 onMethodCall</span></span><br><span class="line">    <span class="comment">// 方法里面处理的方法名</span></span><br><span class="line">    <span class="keyword">var</span> success = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">'toast'</span>, argument);</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>在这一节我们修改工程里 example 目录下的示例，用它来演示插件的使用：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先导入我们的包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_toast2018/flutter_toast2018.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      home: <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          title: <span class="keyword">const</span> Text(<span class="string">'Plugin example app'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="keyword">new</span> Center(</span><br><span class="line">          child: RaisedButton(</span><br><span class="line">            child: Text(<span class="string">'toast'</span>),</span><br><span class="line">            <span class="comment">// 插件的使用跟其他库没有什么区别，直接调用即可</span></span><br><span class="line">            onPressed: () =&gt; FlutterToast2018.toast(</span><br><span class="line">              <span class="string">'Toast from Flutter'</span>, ToastDuration.short</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h1><p>前面我们说过，pubspec 支持通过本地路径和 Git 导入依赖，但为了更好的管理版本依赖，还是推荐发布插件到 <a href="https://pub.dartlang.org/" target="_blank" rel="noopener">https://pub.dartlang.org/</a>。在这一节，我们就把前面开发的 toast 插件发布到 Pub 上。</p><p>需要注意的是，由于某些众所周知的原因，pub.dartlang.org 需要一把梯子才能上去。虽然我们也可以通过 flutter-io.cn 来发布，但上传的时候需要登录 Google 账号，梯子还是少不了的。</p><h2 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h2><p>首先是 pubspec.yaml。对 Flutter 插件来说，pubspec 里除了插件的依赖，还包含一些元信息，读者可以根据需要，把这些补上：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">flutter_toast2018</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">new</span> <span class="string">Flutter</span> <span class="string">plugin</span> <span class="string">for</span> <span class="string">Android</span> <span class="string">Toast.</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Jekton</span> <span class="string">&lt;ljtong64@gmail.com&gt;</span></span><br><span class="line"><span class="attr">homepage:</span> <span class="attr">https://jekton.github.io/</span></span><br></pre></td></tr></table></figure></p><p>另外，发布到 Pub 上的包需要包含一个 LICENSE，关于 LICENSE 文件，最简单的方法就是在 GitHub 创建仓库的时候选中一个。</p><h2 id="检查插件"><a href="#检查插件" class="headerlink" title="检查插件"></a>检查插件</h2><p>现在，我们在工程的根目录执行以下命令，检测一下插件有没有什么问题：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub publish --dry-run</span><br></pre></td></tr></table></figure></p><p>如果一切正常，将会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">Package has 0 warnings.</span><br></pre></td></tr></table></figure></p><h2 id="发布插件-1"><a href="#发布插件-1" class="headerlink" title="发布插件"></a>发布插件</h2><p>发布插件和上一步一样，只是少了 –dry-run 参数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub publish</span><br></pre></td></tr></table></figure></p><p>如果是第一次发布，会提示验证 Google 账号。授权后便可以继续上传，如果成功的话，会提示“Successful uploaded package”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looks great! Are you ready to upload your package (y/n)? y</span><br><span class="line">Pub needs your authorization to upload packages on your behalf.</span><br><span class="line">In a web browser, go to https://accounts.google.com/o/oauth2/auth?access_type=offline&amp;approval_prompt=force&amp;response_type=code&amp;client_id=xxxxxxxxxxxxxx-8grd2eg9tj9f38os6f1urbcvsq399u8n.apps.googleusercontent.com&amp;redirect_uri=http%3A%2F%2Flocalhost%3A52589&amp;scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email</span><br><span class="line">Then click &quot;Allow access&quot;.</span><br><span class="line"></span><br><span class="line">Waiting for your authorization...</span><br><span class="line">Successfully authorized.</span><br><span class="line">Uploading...</span><br><span class="line">Successful uploaded package.</span><br></pre></td></tr></table></figure></p><p>前面我们发布的包可以在 <a href="https://pub.dartlang.org/packages/flutter_toast2018" target="_blank" rel="noopener">https://pub.dartlang.org/packages/flutter_toast2018</a> 或 <a href="https://pub.flutter-io.cn/packages/flutter_toast2018" target="_blank" rel="noopener">https://pub.flutter-io.cn/packages/flutter_toast2018</a> 找到。</p><p>相关的代码则是放到了 GitHub 上：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_toast2018.git</span><br></pre></td></tr></table></figure></p><p>最后再提一提我们没有讲到的 Flutter package。为了开发一个 Flutter 包，我们在创建项目的时候可以选择 Flutter package。它和 Flutter 插件唯一的区别是Flutter package 不能包含平台特定的代码（只能使用 Dart 和 Flutter API）。除此之外，开发、发布和使用都跟 Flutter 插件没有什么区别。</p>]]></content>
    
    <summary type="html">
    
      本篇文章我们先一起学习 Flutter 插件的使用，然后通过开发一个 toast 插件来学习它的开发，最后发布到 Pub 上。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语言入门</title>
    <link href="https://jekton.github.io/2018/09/04/dart-tutorial/"/>
    <id>https://jekton.github.io/2018/09/04/dart-tutorial/</id>
    <published>2018-09-04T01:49:17.000Z</published>
    <updated>2018-09-18T12:15:54.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>本篇文章假定读者有一定的编程经验。通过快速浏览 Dart 的一些基础特性，让读者具备使用它进行开发的基本能力。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> done = <span class="keyword">true</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">double</span> x = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">bool</span> visible = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> amount = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">double</span> y = <span class="number">2.7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">bool</span> debug = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> sum = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> z = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure><p>跟常用的其他语言不同，Dart 没有 <code>byte</code>、<code>char</code> 和 <code>float</code>，<code>int</code>、<code>double</code> 都是 64 位。<code>final</code> 跟 Java 里的 final 一样，表示一个运行时常量（在程序运行的时候赋值，赋值后值不再改变）。<code>const</code> 表示一个编译时常量，在程序编译的时候它的值就确定了。</p><p>如果你觉得每次写变量类型太麻烦，你应该会喜欢 Dart 的类型推断功能：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> visible = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">final</span> amount = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">final</span> y = <span class="number">2.7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> sum = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> z = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure></p><p>Dart 里所有的东西都是对象，包括 <code>int</code>、函数。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">' foo'</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = str.toUpperCase();</span><br><span class="line"><span class="keyword">var</span> str3 = str.trim();</span><br><span class="line"><span class="keyword">assert</span>(str == str2);</span><br><span class="line"><span class="keyword">assert</span>(!identical(str, str2));</span><br></pre></td></tr></table></figure><p>Dart 里的 <code>String</code> 跟 Java 中的一样，是不可变对象；不同的是，检测两个 <code>String</code> 的内容是否一样事，我们使用 <code>==</code> 进行比较；如果要测试两个对象是否是同一个对象（indentity test），使用 <code>identical</code> 函数。</p><h2 id="List、Map-和-Set"><a href="#List、Map-和-Set" class="headerlink" title="List、Map 和 Set"></a>List、Map 和 Set</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数创建对象</span></span><br><span class="line"><span class="comment">// 跟 var list = new List&lt;int&gt;(); 一样</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字面量创建对象，list 的泛型参数可以从变量定义推断出来。</span></span><br><span class="line"><span class="comment">// 推荐使用字面量方式创建对象</span></span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 没有元素，显式指定泛型参数为 int</span></span><br><span class="line"><span class="keyword">var</span> list3 = &lt;<span class="built_in">int</span>&gt;[];</span><br><span class="line">list3.add(<span class="number">1</span>);</span><br><span class="line">list3.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list4 = <span class="keyword">const</span>[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// list4 指向的是一个常量，我们不能给它添加元素（不能修改它）</span></span><br><span class="line">list4.add(<span class="number">3</span>);       <span class="comment">// error</span></span><br><span class="line"><span class="comment">// list4 本身不是一个常量，所以它可以指向另一个对象</span></span><br><span class="line">list4 = [<span class="number">4</span>, <span class="number">5</span>];     <span class="comment">// it's fine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list5 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 相当于 const list5 = const[1, 2];</span></span><br><span class="line">list5.add(<span class="number">3</span>);       <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dart 同样提供了 for-in 循环。</span></span><br><span class="line"><span class="comment">// 因为语音设计时就考虑到了这个需求，in 在 Dart 里是一个关键字</span></span><br><span class="line"><span class="keyword">var</span> list6 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">in</span> list6) &#123;</span><br><span class="line">  <span class="built_in">print</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Dart 2 里，创建对象时可以省略 <code>new</code> 关键字，也推荐省略 <code>new</code>。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"><span class="keyword">set</span>.add(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">set</span>.add(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="keyword">set</span>.contains(<span class="string">'foo'</span>));</span><br></pre></td></tr></table></figure><p>我们只能通过 <code>Set</code> 的构造函数创建实例。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">map[<span class="string">'foo'</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="string">'bar'</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">map[<span class="string">'foo'</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 对应的 key 不存在时，返回 null</span></span><br><span class="line"><span class="keyword">if</span> (map[<span class="string">'foobar'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'map does not contain foobar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map2 = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">'foo'</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">'bar'</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> map3 = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="dynamic-和-Object"><a href="#dynamic-和-Object" class="headerlink" title="dynamic 和 Object"></a>dynamic 和 Object</h2><p>前面我们说过，Dart 里所有东西都是对象。所有这些对象的父类就是 <code>Object</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> o = <span class="string">'string'</span>;</span><br><span class="line">o = <span class="number">42</span>;</span><br><span class="line">o.toString();   <span class="comment">// 我们只能调用 Object 支持的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic</span> obj = <span class="string">'string'</span>;</span><br><span class="line">obj[<span class="string">'foo'</span>] = <span class="number">4</span>;  <span class="comment">// 可以编译通过，但在运行时会抛出 NoSuchMethodError</span></span><br></pre></td></tr></table></figure><p><code>Object</code> 和 <code>dynamic</code> 都使得我们可以接收任意类型的参数，但两者的区别非常的大。</p><p>使用 <code>Object</code> 时，我们只是在说接受任意类型，我们需要的是一个 <code>Object</code>。类型系统会保证其类型安全。</p><p>使用 <code>dynamic</code> 则是告诉编译器，我们知道自己在做什么，<strong>不用做类型检测</strong>。当我们调用一个不存在的方法时，会执行 <code>noSuchMethod()</code> 方法，默认情况下（在 <code>Object</code> 里实现）它会抛出 <code>NoSuchMethodError</code>。</p><p>为了在运行时检测进行类型检测，Dart 提供了一个关键字 <code>is</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> obj = &lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;) &#123;</span><br><span class="line">  <span class="comment">// 进过类型判断后，Dart 知道 obj 是一个 Map&lt;String, int&gt;，</span></span><br><span class="line">  <span class="comment">// 所以这里不用强制转换 obj 的类型，即使我们声明 obj 为 Object。</span></span><br><span class="line">  obj[<span class="string">'foo'</span>] = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然 Dart 也提供了 as 让我们进行类型的强制转换，但为了进来更安全</span></span><br><span class="line"><span class="comment">// 的转换，更推荐使用 is</span></span><br><span class="line"><span class="keyword">var</span> map = obj <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;;</span><br></pre></td></tr></table></figure></p><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> success = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (success) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'done'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'fail'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  sum += j;</span><br><span class="line">  ++j;</span><br><span class="line">&#125; <span class="keyword">while</span> (j &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (sum-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> type = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的 <code>if/else</code>，<code>do while</code>，<code>while</code> 和 <code>switch</code> 在 Dart 里面都支持。<code>switch</code> 也支持 <code>String</code> 和 <code>enum</code>。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>最普通的函数看起来跟 Java 里的一样：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> foo(<span class="built_in">int</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dart 也支持可选参数：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(foo(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> foo(<span class="built_in">int</span> x, [<span class="built_in">int</span> y]) &#123;</span><br><span class="line">  <span class="comment">// 是的，int 也可以是 null</span></span><br><span class="line">  <span class="keyword">if</span> (y != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>默认参数也是支持的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> foo(<span class="built_in">int</span> x, [<span class="built_in">int</span> y = <span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还能用具名参数（named parameters）：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo(x: <span class="number">1</span>, y: <span class="number">2</span>));</span><br><span class="line">  <span class="comment">// 具名参数的顺序可以是任意的</span></span><br><span class="line">  <span class="built_in">print</span>(foo(y: <span class="number">3</span>, x: <span class="number">4</span>));</span><br><span class="line">  <span class="comment">// 所有的具名参数都是可选的，这个调用是合法的，但它会导致 foo() 在运行时抛异常</span></span><br><span class="line">  <span class="built_in">print</span>(foo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> foo(&#123;<span class="built_in">int</span> x, <span class="built_in">int</span> y&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具名参数也可以有默认参数：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo(x: <span class="number">1</span>, y: <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(foo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> foo(&#123;<span class="built_in">int</span> x = <span class="number">0</span>, <span class="built_in">int</span> y = <span class="number">0</span>&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果想告诉用户某个具名参数是必须的，可以使用注解 <code>@required</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> foo(&#123;<span class="meta">@required</span> <span class="built_in">int</span> x, <span class="meta">@required</span> <span class="built_in">int</span> y&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>@required</code> 是 <code>meta</code> 包里提供的 API，更多的信息读者可以查看 <a href="https://pub.dartlang.org/packages/meta" target="_blank" rel="noopener">https://pub.dartlang.org/packages/meta</a>。</p><p>函数还可以在函数的内部定义：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typedef 在 Dart 里面用于定义函数类型的别名</span></span><br><span class="line"><span class="keyword">typedef</span> Adder = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">Adder makeAdder(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="built_in">int</span> adder(<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + extra;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> adder = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p>像上面这样简单的函数，我们还可以使用 lambda：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Adder = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">Adder makeAdder(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + extra;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 如果只有一个语句，我们可以使用下面这种更为简洁的形式</span></span><br><span class="line">  <span class="comment">// return (int x, int y) =&gt; x + y + extra;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> adder = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dart 里面不仅变量支持类型推断，lambda 的参数也支持自动推断。上面的代码还可以进一步简化为：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Adder = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">Adder makeAdder(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="comment">// 我们要返回的类型是 Adder，所以 Dart 知道 x, y 都是 int</span></span><br><span class="line">  <span class="keyword">return</span> (x, y) =&gt; x + y + extra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> adder = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>美中不足的是，Dart 不支持函数的重载。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>抛出异常：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> Exception(<span class="string">'put your error message here'</span>);</span><br></pre></td></tr></table></figure></p><p>捕获异常：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 捕获特定类型的异常</span></span><br><span class="line">&#125; on FormatException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 捕获特定类型的异常，但不需要这个对象</span></span><br><span class="line">&#125; on Exception &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line"><span class="comment">// 捕获所有异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟 Java 不同的是，Dart 可以抛出任意类型的对象：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>定义一个类：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> someConst = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="comment">// 成员变量也可以是 final 的</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point2D(<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于这种初始化方式很常见，Dart 提供了更简洁的方式：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point2d</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  point2d(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外，还可以使用初始化列表（initializer list）对对象进行初始化：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于是在 initializer list 中，Dart 知道第一个 x 是 this.x，</span></span><br><span class="line">  <span class="comment">// 第二个 x 是构造函数的参数</span></span><br><span class="line">  Point2D(<span class="built_in">int</span> x, <span class="built_in">int</span> y) : x = x, y = y &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>initializer list 会在构造函数的函数体运行前执行。</p><p>Dart 具有垃圾收集功能，对象的使用跟 Java 里几乎是一样的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point2D(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  point.x = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">print</span>(point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">  Point2D(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有的类都继承自 Object，toString() 是 Object 中的方法</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="comment">// 在字符串的内部可以通过 $&#123;expression&#125; 的方式插入值，如果</span></span><br><span class="line">    <span class="comment">// expression 是一个变量，可以省略花括号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Point2D&#123;x=$x, y=$y&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// Point2D&#123;x=4, y=2&#125;</span></span><br></pre></td></tr></table></figure></p><p>Dart 使用 package 的概念来管理源码和可见性。它没有 <code>public</code>、<code>private</code> 之类的访问权限控制符，默认情况下，所有的符号都是公开的。如果我们不想某个变量对包的外部可见，可以使用下划线开头来给变量命名。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们使用 Dart 的访问控制，实现一个带偏移量的 Point：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OffsetPoint</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _x;</span><br><span class="line">  <span class="built_in">int</span> _y;</span><br><span class="line">  <span class="built_in">int</span> offset;</span><br><span class="line"></span><br><span class="line">  OffsetPoint(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> offset)</span><br><span class="line">      : _x = x, _y = y, offset = offset &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义一个 getter</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> x =&gt; _x + offset;</span><br><span class="line">  <span class="comment">// getter 不能有参数，连括号都省掉了</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> y &#123;</span><br><span class="line">    <span class="keyword">return</span> _y + offset;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义 setter</span></span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">set</span> x (<span class="built_in">int</span> x) =&gt; _x = x;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">set</span> y (<span class="built_in">int</span> y) =&gt; _y = y;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"OffsetPoint&#123;x=$x, y=$y&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = OffsetPoint(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="comment">// 使用 getter/setter 时，就像它是一个普通的成员变量</span></span><br><span class="line">  <span class="built_in">print</span>(point.x)</span><br><span class="line">  <span class="built_in">print</span>(point);</span><br><span class="line">  point.x = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">print</span>(point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// OffsetPoint&#123;x=11, y=12&#125;</span></span><br><span class="line"><span class="comment">// OffsetPoint&#123;x=14, y=12&#125;</span></span><br></pre></td></tr></table></figure></p><p>在 Dart 里继承对象也很简单：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">  Point2D(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> <span class="keyword">extends</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> z;</span><br><span class="line">  <span class="comment">// 父类的构造函数只能在 initializer list 里调用</span></span><br><span class="line">  Point3D(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> z): z = z, <span class="keyword">super</span>(x, y) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是对象构造时它跟 Java、C++ 都不太一样：</p><ol><li>先执行子类 initializer list，但只初始化自己的成员变量</li><li>初始化父类的成员变量</li><li>执行父类构造函数的函数体</li><li>执行之类构造函数的函数体</li></ol><p>基于这个初始化顺序，推荐是把 <code>super()</code> 放在 initializer list 的最后。此外，在 initializer list 里不能访问 <code>this</code>（也就是说，只能调用静态方法）。</p><p>虽然 Dart 是单继承的，但它也提供了一定程度的多重继承支持：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bark</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> bark() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'woof'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> <span class="keyword">extends</span> <span class="title">Point2D</span> <span class="title">with</span> <span class="title">Bark</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> z;</span><br><span class="line">  <span class="comment">// 父类的构造函数只能在 initializer list 里调用</span></span><br><span class="line">  Point3D(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> z): z = z, <span class="keyword">super</span>(x, y) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有其他类需要继承，所以直接 extends Bark 就可以了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bark</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = Point3D(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  p.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dart 把支持多重继承的类叫做 mixin。更详细的介绍，读者可以参考<a href="https://www.dartlang.org/articles/language/mixins" target="_blank" rel="noopener">https://www.dartlang.org/articles/language/mixins</a>。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  S first;</span><br><span class="line">  T second;</span><br><span class="line">  Pair(<span class="keyword">this</span>.first, <span class="keyword">this</span>.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = Pair(<span class="string">'hello'</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(p <span class="keyword">is</span> Pair&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;);</span><br><span class="line">  <span class="comment">// is! 也是 Dart 的运算符，下面的语句跟 !(p is Pair&lt;int, int&gt;) 是一样的，</span></span><br><span class="line">  <span class="comment">// 但 is! 读起来跟像英语</span></span><br><span class="line">  <span class="built_in">print</span>(p <span class="keyword">is</span>! Pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;);</span><br><span class="line">  <span class="built_in">print</span>(p <span class="keyword">is</span> Pair);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>跟 Java 不同，Dart 的泛型参数类型在运行时是保留的。</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Dart 是单线程的，主线程由一个事件循环来执行（类似 Android 的主线程）。对于异步代码，我们通过 <code>Future</code> 来获取结果：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import 语句用于导入一个包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  file.exists()</span><br><span class="line">      .then((exists) =&gt; <span class="built_in">print</span>(<span class="string">'file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>))</span><br><span class="line">      .catchError((e) =&gt; <span class="built_in">print</span>(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dart 2 提供了 async 函数，用来简化这种编程范式。下面这段代码的效果跟上面是一样的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是要注意，上面两段代码并不是完全一样的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  foo();</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> bar() &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  file.exists()</span><br><span class="line">      .then((exists) =&gt; <span class="built_in">print</span>(<span class="string">'bar: file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>))</span><br><span class="line">      .catchError((e) =&gt; <span class="built_in">print</span>(e));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'bar: after file.exists() returned'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'bar: file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'bar: after file.exists() returned'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种可能的结果：</span></span><br><span class="line"><span class="comment">// bar: after file.exists() returned</span></span><br><span class="line"><span class="comment">// foo: file not exists</span></span><br><span class="line"><span class="comment">// foo: after file.exists() returned</span></span><br><span class="line"><span class="comment">// bar: file not exists</span></span><br></pre></td></tr></table></figure></p><p>这里的关键在于，bar 函数里面，<code>file.exists()...</code> 执行完后，会马上执行下面的语句；而 foo 则会等待结果，然后才继续执行。关于 Future 的更多的细节，<strong>强烈建议</strong>读者阅读<a href="https://webdev.dartlang.org/articles/performance/event-loop" target="_blank" rel="noopener">https://webdev.dartlang.org/articles/performance/event-loop</a>。</p><p>最后需要说明的是，Dart 的生成器、<code>Stream</code> 在这里我们并没有介绍，读者可以参考 <a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">https://www.dartlang.org/guides/language/language-tour</a>。此外，Dart 官网还有许多资源等待读者去发掘。</p>]]></content>
    
    <summary type="html">
    
      本篇文章假定读者有一定的编程经验。通过快速浏览 Dart 的一些基础特性，让读者具备使用它进行开发的基本能力。
    
    </summary>
    
      <category term="Dart" scheme="https://jekton.github.io/categories/Dart/"/>
    
    
      <category term="Dart" scheme="https://jekton.github.io/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（4）- 文件、存储和网络</title>
    <link href="https://jekton.github.io/2018/09/01/flutter-io-basic/"/>
    <id>https://jekton.github.io/2018/09/01/flutter-io-basic/</id>
    <published>2018-08-31T23:29:39.000Z</published>
    <updated>2018-09-18T12:16:58.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>本篇文章我们先学习 Flutter IO 相关的基础知识，然后在<a href="2018/08/29/flutter-ux-basic">Flutter 开发（3）- 交互、动画、手势和事件处理</a>的基础上，继续开发一个 echo 客户端。由于日常开发中 HTTP 比 socket 更常见，我们的 echo 客户端将会使用 HTTP 协议跟服务端通信。Echo 服务器也会使用 Dart 来实现。</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>为了执行文件操作，我们可以使用 Dart 的 io 包：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>在 Dart 里，我们通过类 <code>File</code> 来执行文件操作：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filepath = <span class="string">"path to your file"</span>;</span><br><span class="line">  <span class="keyword">var</span> file = File(filepath);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">    <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">      <span class="keyword">await</span> file.create();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相对于 CPU，IO 总是很慢的，所以大部分文件操作都返回一个 <code>Future</code>，并在出错的时候抛出一个异常。如果你需要，也可以使用同步版本，这些方法都带一个后缀 Sync：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">  <span class="keyword">const</span> filepath = <span class="string">"path to your file"</span>;</span><br><span class="line">  <span class="keyword">var</span> file = File(filepath);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> exists = file.existsSync();</span><br><span class="line">    <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">      file.createSync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>async 方法使得我们可以像写同步方法一样写异步代码，同步版本的 io 方法已经没有太多使用的必要了（Dart 1 不支持 async 函数，所以同步版本的方法的存在是有必要的）。</p><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>写 <code>String</code> 时我们可以使用 <code>writeAsString</code> 和 <code>writeAsBytes</code> 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filepath = <span class="string">"path to your file"</span>;</span><br><span class="line"><span class="keyword">var</span> file = File(filepath);</span><br><span class="line"><span class="keyword">await</span> file.writeAsString(<span class="string">'Hello, Dart IO'</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; toBeWritten = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">await</span> file.writeAsBytes(toBeWritten);</span><br></pre></td></tr></table></figure><p>如果只是为了写文件，还可以使用 <code>openWrite</code> 打开一个 <code>IOSink</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filepath = <span class="string">"path to your file"</span>;</span><br><span class="line">  <span class="keyword">var</span> file = File(filepath);</span><br><span class="line">  IOSink sink;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    sink = file.openWrite();</span><br><span class="line">    <span class="comment">// 默认的写文件操作会覆盖原有内容；如果要追究内容，用 append 模式</span></span><br><span class="line">    <span class="comment">// sink = file.openWrite(mode: FileMode.append);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// write() 的参数是一个 Object，他会执行 obj.toString() 把转换后</span></span><br><span class="line">    <span class="comment">// 的 String 写入文件</span></span><br><span class="line">    sink.write(<span class="string">'Hello, Dart'</span>);</span><br><span class="line">    <span class="keyword">await</span> sink.flush();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    sink?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>读写原始的 bytes 也是相当简单的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">await</span> file.readAsString();</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; content = <span class="keyword">await</span> file.readAsBytes();</span><br></pre></td></tr></table></figure></p><p>和写文件类似，它还有一个 <code>openRead</code> 方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream 是 async 包里的类</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="comment">// utf8、LineSplitter 属于 convert 包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filepath = <span class="string">"path to your file"</span>;</span><br><span class="line">  <span class="keyword">var</span> file = File(filepath);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Stream&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; stream = file.openRead();</span><br><span class="line">    <span class="keyword">var</span> lines = stream</span><br><span class="line">        <span class="comment">// 把内容用 utf-8 解码</span></span><br><span class="line">        .transform(utf8.decoder)</span><br><span class="line">        <span class="comment">// 每次返回一行</span></span><br><span class="line">        .transform(LineSplitter());</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> line <span class="keyword">in</span> lines) &#123;</span><br><span class="line">      <span class="built_in">print</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后需要注意的是，我们读写 bytes 的时候，使用的对象是 <code>List&lt;int&gt;</code>，而一个 <code>int</code> 在 Dart 里面有 64 位。Dart 一开始设计就是用于 Web，这部分的效率也就不那么高了。</p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON 相关的 API 放在了 convert 包里面：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="把对象转换为-JSON"><a href="#把对象转换为-JSON" class="headerlink" title="把对象转换为 JSON"></a>把对象转换为 JSON</h2><p>假设我们有这样一个对象：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">  <span class="built_in">String</span> description;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了把他转换为 JSON，我们给他定义一个 <code>toJson</code> 方法（注意，不能改变他的方法签名）：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，我们的方法只有一个语句，这个语句定义了一个 map。</span></span><br><span class="line">  <span class="comment">// 使用这种语法的时候，Dart 会自动把这个 map 当做方法的返回值</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; toJson() =&gt; &#123;</span><br><span class="line">    <span class="string">'x'</span>: x,</span><br><span class="line">    <span class="string">'y'</span>: y,</span><br><span class="line">    <span class="string">'desc'</span>: description</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们调用 <code>json.encode</code> 方法把对象转换为 JSON：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point(<span class="number">2</span>, <span class="number">12</span>, <span class="string">'Some point'</span>);</span><br><span class="line">  <span class="keyword">var</span> pointJson = json.encode(point);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'pointJson = $pointJson'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// List, Map 都是支持的</span></span><br><span class="line">  <span class="keyword">var</span> points = [point, point];</span><br><span class="line">  <span class="keyword">var</span> pointsJson = json.encode(points);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'pointsJson = $pointsJson'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行后打印出：</span></span><br><span class="line"><span class="comment">// pointJson = &#123;"x":2,"y":12,"desc":"Some point"&#125;</span></span><br><span class="line"><span class="comment">// pointsJson = [&#123;"x":2,"y":12,"desc":"Some point"&#125;,&#123;"x":2,"y":12,"desc":"Some point"&#125;]</span></span><br></pre></td></tr></table></figure></p><h2 id="把-JSON-转换为对象"><a href="#把-JSON-转换为对象" class="headerlink" title="把 JSON 转换为对象"></a>把 JSON 转换为对象</h2><p>首先，我们给 <code>Point</code> 类再加多一个构造函数：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; map)</span><br><span class="line">      : x = map[<span class="string">'x'</span>], y = map[<span class="string">'y'</span>], description = map[<span class="string">'desc'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了方便后面演示，也加入一个 toString</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Point&#123;x=$x, y=$y, desc=$description&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了解析 JSON 字符串，我们可以用 <code>json.decode</code> 方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> obj = json.decode(jsonString);</span><br></pre></td></tr></table></figure></p><p>返回一个 <code>dynamic</code> 的原因在于，Dart 不知道传进去的 JSON 是什么。如果是一个 JSON 对象，返回值将是一个 <code>Map&lt;String, dynamic&gt;</code>；如果是 JSON 数组，则会返回 <code>List&lt;dynamic&gt;</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point(<span class="number">2</span>, <span class="number">12</span>, <span class="string">'Some point'</span>);</span><br><span class="line">  <span class="keyword">var</span> pointJson = json.encode(point);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'pointJson = $pointJson'</span>);</span><br><span class="line">  <span class="keyword">var</span> points = [point, point];</span><br><span class="line">  <span class="keyword">var</span> pointsJson = json.encode(points);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'pointsJson = $pointsJson'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> decoded = json.decode(pointJson);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'decoded.runtimeType = <span class="subst">$&#123;decoded.runtimeType&#125;</span>'</span>);</span><br><span class="line">  <span class="keyword">var</span> point2 = Point.fromJson(decoded);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'point2 = $point2'</span>);</span><br><span class="line"></span><br><span class="line">  decoded = json.decode(pointsJson);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'decoded.runtimeType = <span class="subst">$&#123;decoded.runtimeType&#125;</span>'</span>);</span><br><span class="line">  <span class="keyword">var</span> points2 = &lt;Point&gt;[];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> map <span class="keyword">in</span> decoded) &#123;</span><br><span class="line">    points2.add(Point.fromJson(map));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'points2 = $points2'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pointJson = &#123;&quot;x&quot;:2,&quot;y&quot;:12,&quot;desc&quot;:&quot;Some point&quot;&#125;</span><br><span class="line">pointsJson = [&#123;&quot;x&quot;:2,&quot;y&quot;:12,&quot;desc&quot;:&quot;Some point&quot;&#125;,&#123;&quot;x&quot;:2,&quot;y&quot;:12,&quot;desc&quot;:&quot;Some point&quot;&#125;]</span><br><span class="line"></span><br><span class="line">decoded.runtimeType = _InternalLinkedHashMap&lt;String, dynamic&gt;</span><br><span class="line">point2 = Point&#123;x=2, y=12, desc=Some point&#125;</span><br><span class="line">decoded.runtimeType = List&lt;dynamic&gt;</span><br><span class="line">points2 = [Point&#123;x=2, y=12, desc=Some point&#125;, Point&#123;x=2, y=12, desc=Some point&#125;]</span><br></pre></td></tr></table></figure></p><p>需要说明的是，我们把 <code>Map&lt;String, dynamic&gt;</code> 转化为对象时使用时定义了一个构造函数，但这个是任意的，使用静态方法、Dart 工厂方法等都是可行的。之所以限定 <code>toJson</code> 方法的原型，是因为 <code>json.encode</code> 只支持 Map、List、String、int 等内置类型。当它遇到不认识的类型时，如果没有给它设置参数 toEncodable，就会调用对象的 <code>toJson</code> 方法（所以方法的原型不能改变）。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>为了向服务器发送 HTTP 请求，我们可以使用 io 包里面的 <code>HttpClient</code>。但它实在不是那么好用，于是就有人弄出了一个 http 包。为了使用 http 包，需要修改 pubspec.yaml：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pubspec.yaml</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  http:</span> <span class="string">^0.11.3+17</span></span><br></pre></td></tr></table></figure></p><p>http 包的使用非常直接，为了发出一个 GET，可以使用 <code>http.get</code> 方法；对应的，还有 <code>post</code>、<code>put</code> 等。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:http/http.dart'</span> <span class="keyword">as</span> http;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getMessage() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> response = <span class="keyword">await</span> http.<span class="keyword">get</span>(<span class="string">'http://www.xxx.com/yyy/zzz'</span>);</span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.body;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'getMessage: $e'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HTTP POST 的例子我们在下面实现 echo 客户端的时候再看。</p><h1 id="使用-SQLite-数据库"><a href="#使用-SQLite-数据库" class="headerlink" title="使用 SQLite 数据库"></a>使用 SQLite 数据库</h1><p>包 sqflite 可以让我们使用 SQLite：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  sqflite:</span> <span class="string">any</span></span><br></pre></td></tr></table></figure></p><p>sqflite 的 API 跟 Android 的那些非常像，下面我们直接用一个例子来演示：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:sqflite/sqflite.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnId = <span class="string">'id'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnTitle = <span class="string">'title'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnContent = <span class="string">'content'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> id;</span><br><span class="line">  <span class="built_in">String</span> title;</span><br><span class="line">  <span class="built_in">String</span> content;</span><br><span class="line"></span><br><span class="line">  Todo(<span class="keyword">this</span>.title, <span class="keyword">this</span>.content, [<span class="keyword">this</span>.id]);</span><br><span class="line"></span><br><span class="line">  Todo.fromMap(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; map)</span><br><span class="line">      : id = map[columnId], title = map[columnTitle], content = map[columnContent];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; toMap() =&gt; &#123;</span><br><span class="line">    columnTitle: title,</span><br><span class="line">    columnContent: content,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Todo&#123;id=$id, title=$title, content=$content&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> table = <span class="string">'Todo'</span>;</span><br><span class="line">  <span class="comment">// getDatabasesPath() 的 sqflite 提供的函数</span></span><br><span class="line">  <span class="keyword">var</span> path = <span class="keyword">await</span> getDatabasesPath() + <span class="string">'/demo.db'</span>;</span><br><span class="line">  <span class="comment">// 使用 openDatabase 打开数据库</span></span><br><span class="line">  <span class="keyword">var</span> database = <span class="keyword">await</span> openDatabase(</span><br><span class="line">      path,</span><br><span class="line">      version: <span class="number">1</span>,</span><br><span class="line">      onCreate: (db, version) <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sql =<span class="string">'''</span></span><br><span class="line"><span class="string">            CREATE TABLE $table ('</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;Todo.columnId&#125;</span> INTEGER PRIMARY KEY,'</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;Todo.columnTitle&#125;</span> TEXT,'</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;Todo.columnContent&#125;</span> TEXT'</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">            '''</span>;</span><br><span class="line">        <span class="comment">// execute 方法可以执行任意的 SQL</span></span><br><span class="line">        <span class="keyword">await</span> db.execute(sql);</span><br><span class="line">      &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 为了让每次运行的结果都一样，先把数据清掉</span></span><br><span class="line">  <span class="keyword">await</span> database.delete(table);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> todo1 = Todo(<span class="string">'Flutter'</span>, <span class="string">'Learn Flutter widgets.'</span>);</span><br><span class="line">  <span class="keyword">var</span> todo2 = Todo(<span class="string">'Flutter'</span>, <span class="string">'Learn how to to IO in Flutter.'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入数据</span></span><br><span class="line">  <span class="keyword">await</span> database.insert(table, todo1.toMap());</span><br><span class="line">  <span class="keyword">await</span> database.insert(table, todo2.toMap());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">Map</span>&gt; list = <span class="keyword">await</span> database.query(table);</span><br><span class="line">  <span class="comment">// 重新赋值，这样 todo.id 才不会为 0</span></span><br><span class="line">  todo1 = Todo.fromMap(list[<span class="number">0</span>]);</span><br><span class="line">  todo2 = Todo.fromMap(list[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'query: todo1 = $todo1'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'query: todo2 = $todo2'</span>);</span><br><span class="line"></span><br><span class="line">  todo1.content += <span class="string">' Come on!'</span>;</span><br><span class="line">  todo2.content += <span class="string">' I\'m tired'</span>;</span><br><span class="line">  <span class="comment">// 使用事务</span></span><br><span class="line">  <span class="keyword">await</span> database.transaction((txn) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 注意，这里面只能用 txn。直接使用 database 将导致死锁</span></span><br><span class="line">    <span class="keyword">await</span> txn.update(table, todo1.toMap(),</span><br><span class="line">        <span class="comment">// where 的参数里，我们可以使用 ? 作为占位符，对应的值按顺序放在 whereArgs</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，whereArgs 的参数类型是 List，这里不能写成 todo1.id.toString()。</span></span><br><span class="line">        <span class="comment">// 不然就变成了用 String 和 int 比较，这样一来就匹配不到待更新的那一行了</span></span><br><span class="line">        where: <span class="string">'<span class="subst">$&#123;Todo.columnId&#125;</span> = ?'</span>, whereArgs: [todo1.id]);</span><br><span class="line">    <span class="keyword">await</span> txn.update(table, todo2.toMap(),</span><br><span class="line">        where: <span class="string">'<span class="subst">$&#123;Todo.columnId&#125;</span> = ?'</span>, whereArgs: [todo2.id]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  list = <span class="keyword">await</span> database.query(table);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> map <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="keyword">var</span> todo = Todo.fromMap(map);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'updated: todo = $todo'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后，别忘了关闭数据库</span></span><br><span class="line">  <span class="keyword">await</span> database.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query: todo1 = Todo&#123;id=1, title=Flutter, content=Learn Flutter widgets&#125;</span><br><span class="line">query: todo2 = Todo&#123;id=2, title=Flutter, content=Learn how to to IO in Flutter&#125;</span><br><span class="line">updated: todo = Todo&#123;id=1, title=Flutter, content=Learn Flutter widgets. Come on!&#125;</span><br><span class="line">updated: todo = Todo&#123;id=2, title=Flutter, content=Learn how to to IO in Flutter. I&apos;m tired&#125;</span><br></pre></td></tr></table></figure></p><p>有 Android 经验的读者会发现，使用 Dart 编写数据库相关代码的时候舒服很多。如果读者对数据库不太熟悉，可以参考《SQL必知必会》。本篇的主要知识点到这里的就讲完了，作为练习，下面我们就一起来实现 echo 客户端的后端。</p><h1 id="echo-客户端"><a href="#echo-客户端" class="headerlink" title="echo 客户端"></a>echo 客户端</h1><h2 id="HTTP-服务端"><a href="#HTTP-服务端" class="headerlink" title="HTTP 服务端"></a>HTTP 服务端</h2><p>在开始之前，你可以在 GitHub 上找到上篇文章的代码，我们将在它的基础上进行开发。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ux-basic</span><br></pre></td></tr></table></figure></p><h3 id="服务端架构"><a href="#服务端架构" class="headerlink" title="服务端架构"></a>服务端架构</h3><p>首先我们来看看服务端的架构（说是架构，但其实非常的简单，或者说很简陋）：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> port;</span><br><span class="line">  HttpServer httpServer;</span><br><span class="line">  <span class="comment">// 在 Dart 里面，函数也是 first class object，所以我们可以直接把</span></span><br><span class="line">  <span class="comment">// 函数放到 Map 里面</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">void</span> <span class="built_in">Function</span>(HttpRequest)&gt; routes;</span><br><span class="line"></span><br><span class="line">  HttpEchoServer(<span class="keyword">this</span>.port) &#123;</span><br><span class="line">    _initRoutes();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _initRoutes() &#123;</span><br><span class="line">    routes = &#123;</span><br><span class="line">      <span class="comment">// 我们只支持 path 为 '/history' 和 '/echo' 的请求。</span></span><br><span class="line">      <span class="comment">// history 用于获取历史记录；</span></span><br><span class="line">      <span class="comment">// echo 则提供 echo 服务。</span></span><br><span class="line">      <span class="string">'/history'</span>: _history,</span><br><span class="line">      <span class="string">'/echo'</span>: _echo,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个 Future，这样客户端就能够在 start 完成后做一些事</span></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 HttpServer</span></span><br><span class="line">    httpServer = <span class="keyword">await</span> HttpServer.bind(InternetAddress.loopbackIPv4, port);</span><br><span class="line">    <span class="comment">// 2. 开始监听客户请求</span></span><br><span class="line">    <span class="keyword">return</span> httpServer.listen((request) &#123;</span><br><span class="line">      <span class="keyword">final</span> path = request.uri.path;</span><br><span class="line">      <span class="keyword">final</span> handler = routes[path];</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler(request);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 给客户返回一个 404</span></span><br><span class="line">        request.response.statusCode = HttpStatus.notFound;</span><br><span class="line">        request.response.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _history(HttpRequest request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> close() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> server = httpServer;</span><br><span class="line">    httpServer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">await</span> server?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在服务端框架里，我们把支持的所有路径都加到 routes 里面，当收到客户请求的时候，只需要直接从 routes 里取出对应的处理函数，把请求分发给他就可以了。如果读者对服务端编程没有太大兴趣或不太了解，这部分可以不用太关注。</p><h3 id="将对象序列化为-JSON"><a href="#将对象序列化为-JSON" class="headerlink" title="将对象序列化为 JSON"></a>将对象序列化为 JSON</h3><p>为了把 Message 对象序列化为 JSON，这里我们对 Message 做一些小修改：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> timestamp;</span><br><span class="line"></span><br><span class="line">  Message(<span class="keyword">this</span>.msg, <span class="keyword">this</span>.timestamp);</span><br><span class="line">  Message.create(<span class="built_in">String</span> msg)</span><br><span class="line">      : msg = msg, timestamp = <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; toJson() =&gt; &#123;</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">"$msg"</span>,</span><br><span class="line">    <span class="string">"timestamp"</span>: timestamp</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Message&#123;msg: $msg, timestamp: $timestamp&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们加入一个 toJson 方法。下面是服务端的 _echo 方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> GET = <span class="string">'GET'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> POST = <span class="string">'POST'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  _unsupportedMethod(HttpRequest request) &#123;</span><br><span class="line">    request.response.statusCode = HttpStatus.methodNotAllowed;</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.method != POST) &#123;</span><br><span class="line">      _unsupportedMethod(request);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取从客户端 POST 请求的 body，更多的知识，参考</span></span><br><span class="line">    <span class="comment">// https://www.dartlang.org/tutorials/dart-vm/httpserver</span></span><br><span class="line">    <span class="built_in">String</span> body = <span class="keyword">await</span> request.transform(utf8.decoder).join();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> message = Message.create(body);</span><br><span class="line">      messages.add(message);</span><br><span class="line">      request.response.statusCode = HttpStatus.ok;</span><br><span class="line">      <span class="comment">// json 是 convert 包里的对象，encode 方法还有第二个参数 toEncodable。当遇到对象不是</span></span><br><span class="line">      <span class="comment">// Dart 的内置对象时，如果提供这个参数，就会调用它对对象进行序列化；这里我们没有提供，</span></span><br><span class="line">      <span class="comment">// 所以 encode 方法会调用对象的 toJson 方法，这个方法在前面我们已经定义了</span></span><br><span class="line">      <span class="keyword">var</span> data = json.encode(message);</span><br><span class="line">      <span class="comment">// 把响应写回给客户端</span></span><br><span class="line">      request.response.write(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      request.response.statusCode = HttpStatus.badRequest;</span><br><span class="line">    &#125;</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h2><p>我们的 echo 服务器使用了 dart:io 包里面 HttpServer 来开发。对应的，我们也可以使用这个包里的 HttpRequest 来执行 HTTP 请求，但这里我们并不打算这么做。第三方库 http 提供了更简单易用的接口。</p><p>首先把依赖添加到 pubspec 里：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pubspec.yaml</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  http:</span> <span class="string">^0.11.3+17</span></span><br></pre></td></tr></table></figure></p><p>客户端实现如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:http/http.dart'</span> <span class="keyword">as</span> http;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> port;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> host;</span><br><span class="line"></span><br><span class="line">  HttpEchoClient(<span class="keyword">this</span>.port): host = <span class="string">'http://localhost:$port'</span>;</span><br><span class="line"></span><br><span class="line">  Future&lt;Message&gt; send(<span class="built_in">String</span> msg) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// http.post 用来执行一个 HTTP POST 请求。</span></span><br><span class="line">    <span class="comment">// 它的 body 参数是一个 dynamic，可以支持不同类型的 body，这里我们</span></span><br><span class="line">    <span class="comment">// 只是直接把客户输入的消息发给服务端就可以了。由于 msg 是一个 String，</span></span><br><span class="line">    <span class="comment">// post 方法会自动设置 HTTP 的 Content-Type 为 text/plain</span></span><br><span class="line">    <span class="keyword">final</span> response = <span class="keyword">await</span> http.post(host + <span class="string">'/echo'</span>, body: msg);</span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; msgJson = json.decode(response.body);</span><br><span class="line">      <span class="comment">// Dart 并不知道我们的 Message 长什么样，我们需要自己通过</span></span><br><span class="line">      <span class="comment">// Map&lt;String, dynamic&gt; 来构造对象</span></span><br><span class="line">      <span class="keyword">var</span> message = Message.fromJson(msgJson);</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> timestamp;</span><br><span class="line"></span><br><span class="line">  Message.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; json)</span><br><span class="line">    : msg = json[<span class="string">'msg'</span>], timestamp = json[<span class="string">'timestamp'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，让我们把他们和上一节的 UI 结合到一起。首先启动服务器，然后创建客户端：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HttpEchoServer _server;</span><br><span class="line">HttpEchoClient _client;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> port = <span class="number">6060</span>;</span><br><span class="line">    _server = HttpEchoServer(port);</span><br><span class="line">    <span class="comment">// initState 不是一个 async 函数，这里我们不能直接 await _server.start(),</span></span><br><span class="line">    <span class="comment">// future.then(...) 跟 await 是等价的</span></span><br><span class="line">    _server.start().then((_) &#123;</span><br><span class="line">      <span class="comment">// 等服务器启动后才创建客户端</span></span><br><span class="line">      _client = HttpEchoClient(port);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">          );</span><br><span class="line">          <span class="comment">// 以下是修改了的地方</span></span><br><span class="line">          <span class="keyword">if</span> (_client == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 现在，我们不是直接构造一个 Message，而是通过 _client 把消息</span></span><br><span class="line">          <span class="comment">// 发送给服务器</span></span><br><span class="line">          <span class="keyword">var</span> msg = <span class="keyword">await</span> _client.send(result);</span><br><span class="line">          <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            messageListKey.currentState.addMessage(msg);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            debugPrint(<span class="string">'fail to send $result'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成，在做了这么多工作以后，我们的应用现在是真正的 echo 客户端了，虽然看起来跟之前没什么两样。接下来，我们就做一些跟之前不一样的——把历史记录保存下来。</p><h2 id="历史记录存储、恢复"><a href="#历史记录存储、恢复" class="headerlink" title="历史记录存储、恢复"></a>历史记录存储、恢复</h2><h3 id="获取应用的存储路径"><a href="#获取应用的存储路径" class="headerlink" title="获取应用的存储路径"></a>获取应用的存储路径</h3><p>为了获得应用的文件存储路径，我们引入多一个库：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pubspec.yaml</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  path_provider:</span> <span class="string">^0.4.1</span></span><br></pre></td></tr></table></figure></p><p>通过它我们可以拿到应用的 file、cache 和 external storage 的路径：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:path_provider/path_provider.dart'</span> <span class="keyword">as</span> path_provider;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> historyFilepath;</span><br><span class="line"></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    historyFilepath = <span class="keyword">await</span> _historyPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; _historyPath() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 获取应用私有的文件目录</span></span><br><span class="line">    <span class="keyword">final</span> directory = <span class="keyword">await</span> path_provider.getApplicationDocumentsDirectory();</span><br><span class="line">    <span class="keyword">return</span> directory.path + <span class="string">'/messages.json'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="保存历史记录"><a href="#保存历史记录" class="headerlink" title="保存历史记录"></a>保存历史记录</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原谅我，为了简单，我们就多存几次吧</span></span><br><span class="line">    _storeMessages();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; _storeMessages() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// json.encode 支持 List、Map</span></span><br><span class="line">      <span class="keyword">final</span> data = json.encode(messages);</span><br><span class="line">      <span class="comment">// File 是 dart:io 里的类</span></span><br><span class="line">      <span class="keyword">final</span> file = File(historyFilepath);</span><br><span class="line">      <span class="keyword">final</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">      <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">        <span class="keyword">await</span> file.create();</span><br><span class="line">      &#125;</span><br><span class="line">      file.writeAsString(data);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 虽然文件操作方法都是异步的，我们仍然可以通过这种方式 catch 到</span></span><br><span class="line">    <span class="comment">// 他们抛出的异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'_storeMessages: $e'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载历史记录"><a href="#加载历史记录" class="headerlink" title="加载历史记录"></a>加载历史记录</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    historyFilepath = <span class="keyword">await</span> _historyPath();</span><br><span class="line">    <span class="comment">// 在启动服务器前先加载历史记录</span></span><br><span class="line">    <span class="keyword">await</span> _loadMessages();</span><br><span class="line">    httpServer = <span class="keyword">await</span> HttpServer.bind(InternetAddress.loopbackIPv4, port);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future _loadMessages() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> file = File(historyFilepath);</span><br><span class="line">      <span class="keyword">var</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">      <span class="keyword">if</span> (!exists) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> content = <span class="keyword">await</span> file.readAsString();</span><br><span class="line">      <span class="keyword">var</span> list = json.decode(content);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> msg <span class="keyword">in</span> list) &#123;</span><br><span class="line">        <span class="keyword">var</span> message = Message.fromJson(msg);</span><br><span class="line">        messages.add(message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'_loadMessages: $e'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们来实现 _history 函数：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _history(HttpRequest request) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.method != GET) &#123;</span><br><span class="line">      _unsupportedMethod(request);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> historyData = json.encode(messages);</span><br><span class="line">    request.response.write(historyData);</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>_history 的实现很直接，我们只是把 messages 全都返回给客户端。</p><p>接下来是客户端部分：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;Message&gt;&gt; getHistory() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// http 包的 get 方法用来执行 HTTP GET 请求</span></span><br><span class="line">      <span class="keyword">final</span> response = <span class="keyword">await</span> http.<span class="keyword">get</span>(host + <span class="string">'/history'</span>);</span><br><span class="line">      <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _decodeHistory(response.body);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'getHistory: $e'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;Message&gt; _decodeHistory(<span class="built_in">String</span> response) &#123;</span><br><span class="line">    <span class="comment">// JSON 数组 decode 出来是一个 &lt;Map&lt;String, dynamic&gt;&gt;[]</span></span><br><span class="line">    <span class="keyword">var</span> messages = json.decode(response);</span><br><span class="line">    <span class="keyword">var</span> list = &lt;Message&gt;[];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> msgJson <span class="keyword">in</span> messages) &#123;</span><br><span class="line">      list.add(Message.fromJson(msgJson));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> port = <span class="number">6060</span>;</span><br><span class="line">    _server = HttpEchoServer(port);</span><br><span class="line">    _server.start().then((_) &#123;</span><br><span class="line">      <span class="comment">// 我们等服务器启动后才创建客户端</span></span><br><span class="line">      _client = HttpEchoClient(port);</span><br><span class="line">      <span class="comment">// 创建客户端后马上拉取历史记录</span></span><br><span class="line">      _client.getHistory().then((list) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          messages.addAll(list);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>最后需要做的是，在 APP 退出后关闭服务器。这就要求我们能够收到应用生命周期变化的通知。为了达到这个目的，Flutter 为我们提供了 WidgetsBinding 类（虽然没有 Android 的 Lifecycle 那么好用就是啦）。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了使用 WidgetsBinding，我们继承 WidgetsBindingObserver 然后覆盖相应的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    _server.start().then((_) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册生命周期回调</span></span><br><span class="line">      WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == AppLifecycleState.paused) &#123;</span><br><span class="line">      <span class="keyword">var</span> server = _server;</span><br><span class="line">      _server = <span class="keyword">null</span>;</span><br><span class="line">      server?.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们的应用是这个样子的：<br><img src="/2018/09/01/flutter-io-basic/flutter-echo-demo.gif" alt="flutter-echo-demo"></p><p>所有的代码可以在 GitHub 上找到：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout io-basic</span><br></pre></td></tr></table></figure></p><h2 id="使用-SQLite-数据库-1"><a href="#使用-SQLite-数据库-1" class="headerlink" title="使用 SQLite 数据库"></a>使用 SQLite 数据库</h2><p>前面的实现中我们把 echo 服务器的数据存放在了文件里。这一节我们改一改，把数据存到 SQLite 中。</p><p>别忘了添加依赖：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  sqflite:</span> <span class="string">any</span></span><br></pre></td></tr></table></figure></p><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:sqflite/sqflite.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> tableName = <span class="string">'History'</span>;</span><br><span class="line">  <span class="comment">// 这部分常量最好是放到 Message 的定义里。为了方便阅读，就暂且放这里吧</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnId = <span class="string">'id'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnMsg = <span class="string">'msg'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnTimestamp = <span class="string">'timestamp'</span>;</span><br><span class="line"></span><br><span class="line">  Database database;</span><br><span class="line"></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> _initDatabase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future _initDatabase() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> path = <span class="keyword">await</span> getDatabasesPath() + <span class="string">'/history.db'</span>;</span><br><span class="line">    database = <span class="keyword">await</span> openDatabase(</span><br><span class="line">      path,</span><br><span class="line">      version: <span class="number">1</span>,</span><br><span class="line">      onCreate: (db, version) <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sql = <span class="string">'''</span></span><br><span class="line"><span class="string">            CREATE TABLE $tableName (</span></span><br><span class="line"><span class="string">            $columnId INTEGER PRIMARY KEY,</span></span><br><span class="line"><span class="string">            $columnMsg TEXT,</span></span><br><span class="line"><span class="string">            $columnTimestamp INTEGER</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">            '''</span>;</span><br><span class="line">        <span class="keyword">await</span> db.execute(sql);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载历史记录-1"><a href="#加载历史记录-1" class="headerlink" title="加载历史记录"></a>加载历史记录</h3><p>加载历史记录的相关代码在 <code>_loadMessages</code> 方法中，这里我们修改原有的实现，让它从数据库加载数据：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Future _loadMessages() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">await</span> database.query(</span><br><span class="line">      tableName,</span><br><span class="line">      columns: [columnMsg, columnTimestamp],</span><br><span class="line">      orderBy: columnId,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list) &#123;</span><br><span class="line">      <span class="comment">// fromJson 也适用于使用数据库的场景</span></span><br><span class="line">      <span class="keyword">var</span> message = Message.fromJson(item);</span><br><span class="line">      messages.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上改为使用数据库来存储后，我们并不需要把所有的消息都存放在内存中（也就是这里的 <code>_loadMessage</code>是不必要的）。客户请求历史记录时，我们再按需从数据库读取数据即可。为了避免修改到程序的逻辑，这里还是继续保持一份数据在内存中。有兴趣的读者可以对程序作出相应的修改。</p><h3 id="保存记录"><a href="#保存记录" class="headerlink" title="保存记录"></a>保存记录</h3><p>记录的保存很简单，一行代码就可以搞定了：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  _storeMessage(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _storeMessage(Message msg) &#123;</span><br><span class="line">  database.insert(tableName, msg.toJson());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 JSON 的版本，我们每次都需要把所有的数据都保存一遍。对数据库来说，只要把收到的这一条信息存进去即可。读者也应该能够感受到，就我们的需求来说，使用 SQLite 的版本实现起来更简单，也更高效。</p><h3 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h3><p><code>close</code> 方法也要做相应的修改：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> close() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> db = database;</span><br><span class="line">  database = <span class="keyword">null</span>;</span><br><span class="line">  db?.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这部分代码可以查看 tag echo-db：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout echo-db</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      本篇文章我们先学习 Flutter IO 相关的基础知识，然后在 flutter-ux-basic 一文的基础上，继续开发一个 echo 客户端。由于日常开发中 HTTP 比 socket 更常见，我们的 echo 客户端将会使用 HTTP 协议跟服务端通信。Echo 服务器也会使用 Dart 来实现。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（3）- 交互、动画、手势和事件处理</title>
    <link href="https://jekton.github.io/2018/08/29/flutter-ux-basic/"/>
    <id>https://jekton.github.io/2018/08/29/flutter-ux-basic/</id>
    <published>2018-08-29T01:06:41.000Z</published>
    <updated>2018-09-18T12:17:25.137Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>在这一篇文章中，我们首先介绍手势事件的处理和页面跳转的基础知识，然后通过实现一个 echo 客户端的前端页面来加强学习；最后我们再学习内置的动画 Widget 以及如何自定义动画效果。</p><h1 id="手势处理"><a href="#手势处理" class="headerlink" title="手势处理"></a>手势处理</h1><h2 id="按钮点击"><a href="#按钮点击" class="headerlink" title="按钮点击"></a>按钮点击</h2><p>为了获取按钮的点击事件，只需要设置 <code>onPressed</code> 参数就可以了：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      child: Text(<span class="string">'click'</span>),</span><br><span class="line">      onPressed: () =&gt; debugPrint(<span class="string">'clicked'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="任意控件的手势事件"><a href="#任意控件的手势事件" class="headerlink" title="任意控件的手势事件"></a>任意控件的手势事件</h2><p>跟 button 不同，大多数的控件没有手势事件监听函数可以设置，为了监听这些控件上的手势事件，我们需要使用另一个控件——<code>GestureDetector</code>（没错，它也是一个控件）：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      child: Text(<span class="string">'text'</span>),</span><br><span class="line">      onTap: () =&gt; debugPrint(<span class="string">'clicked'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了上面代码使用到的 <code>onTap</code>，<code>GestureDetector</code> 还支持许多其他事件：</p><ul><li>onTapDown：按下</li><li>onTap：点击动作</li><li>onTapUp：抬起</li><li>onTapCancel：前面触发了 onTapDown，但并没有完成一个 onTap 动作</li><li>onDoubleTap：双击</li><li>onLongPress：长按</li><li>onScaleStart, onScaleUpdate, onScaleEnd：缩放</li><li>onVerticalDragDown, onVerticalDragStart, onVerticalDragUpdate, onVerticalDragEnd, onVerticalDragCancel, onVerticalDragUpdate：在竖直方向上移动</li><li>onHorizontalDragDown, onHorizontalDragStart, onHorizontalDragUpdate, onHorizontalDragEnd, onHorizontalDragCancel, onHorizontalDragUpdate：在水平方向上移动</li><li>onPanDown, onPanStart, onPanUpdate, onPanEnd, onPanCancel：拖曳（水平、竖直方向上移动）</li></ul><p>如果同时设置了 onVerticalXXX 和 onHorizontalXXX，在一个手势里，只有一个会触发（如果用户首先在水平方向移动，则整个过程只触发 onHorizontalUpdate；竖直方向的类似）</p><p>这里要说明的是，onVerticalXXX/onHorizontalXXX 和 onPanXXX 不能同时设置。如果同时需要水平、竖直方向的移动，使用 onPanXXX。</p><p>如果读者希望在用户点击的时候能够有个水波纹效果，可以使用 <code>InkWell</code>，它的用法跟 <code>GestureDetector</code> 类似，只是少了拖动相关的手势（毕竟，这个水波纹效果只有在点击的时候才有意义）。</p><h2 id="原始手势事件监听"><a href="#原始手势事件监听" class="headerlink" title="原始手势事件监听"></a>原始手势事件监听</h2><p><code>GestureDetector</code> 在绝大部分时候都能够满足我们的需求，如果真的满足不了，我们还可以使用最原始的 <code>Listener</code> 控件。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Listener(</span><br><span class="line">      child: Text(<span class="string">'text'</span>),</span><br><span class="line">      onPointerDown: (event) =&gt; <span class="built_in">print</span>(<span class="string">'onPointerDown'</span>),</span><br><span class="line">      onPointerUp: (event) =&gt; <span class="built_in">print</span>(<span class="string">'onPointerUp'</span>),</span><br><span class="line">      onPointerMove: (event) =&gt; <span class="built_in">print</span>(<span class="string">'onPointerMove'</span>),</span><br><span class="line">      onPointerCancel: (event) =&gt; <span class="built_in">print</span>(<span class="string">'onPointerCancel'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="在页面间跳转"><a href="#在页面间跳转" class="headerlink" title="在页面间跳转"></a>在页面间跳转</h1><p>Flutter 里所有的东西都是 <code>widget</code>，所以，一个页面，也是 <code>widget</code>。为了调整到新的页面，我们可以 push 一个 route 到 <code>Navigator</code> 管理的栈中。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">  context,</span><br><span class="line">  MaterialPageRoute(builder: (_) =&gt; SecondScreen())</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>需要返回的话，pop 掉就可以了：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pop(context);</span><br></pre></td></tr></table></figure></p><p>下面是完整的例子：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter navigation'</span>,</span><br><span class="line">      home: FirstScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _FirstScreenState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FirstScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FirstScreen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Navigation deme'</span>),),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          child: Text(<span class="string">'First screen'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; SecondScreen())</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _SecondScreenState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_SecondScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">SecondScreen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Navigation deme'</span>),),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">            child: Text(<span class="string">'Second screen'</span>),</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              Navigator.pop(context);</span><br><span class="line">            &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了打开一个页面，Flutter 也支持从页面返回数据：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pop(context, <span class="string">'message from second screen'</span>);</span><br></pre></td></tr></table></figure></p><p>由于打开页面是异步的，页面的结果通过一个 <code>Future</code> 来返回：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// Navigator.push 会返回一个 Future&lt;T&gt;，如果你对这里使用的 await不太熟悉，可以参考</span></span><br><span class="line">  <span class="comment">// https://www.dartlang.org/guides/language/language-tour#asynchrony-support</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    MaterialPageRoute(builder: (_) =&gt; SecondScreen())</span><br><span class="line">  );</span><br><span class="line">  debugPrint(<span class="string">'msg = $msg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们还可以在 <code>MaterialApp</code> 里设置好每个 route 对应的页面，然后使用 <code>Navigator.pushNamed(context, routeName)</code> 来打开它们：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  <span class="comment">// 从名字叫做 '/' 的 route 开始（也就是 home）</span></span><br><span class="line">  initialRoute: <span class="string">'/'</span>,</span><br><span class="line">  routes: &#123;</span><br><span class="line">    <span class="string">'/'</span>: (context) =&gt; HomeScreen(),</span><br><span class="line">    <span class="string">'/about'</span>: (context) =&gt; AboutScreen(),</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>接下来，我们通过实现一个 echo 客户端的前端页面来综合运用前面所学的知识（逻辑部分我们留到下一篇文章再补充）。</p><h1 id="echo-客户端"><a href="#echo-客户端" class="headerlink" title="echo 客户端"></a>echo 客户端</h1><h2 id="消息输入页"><a href="#消息输入页" class="headerlink" title="消息输入页"></a>消息输入页</h2><p>这一节我们来实现一个用户输入的页面。UI 很简单，就是一个文本框和一个按钮。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageForm</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _MessageFormState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageForm</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> editController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象被从 widget 树里永久移除的时候调用 dispose 方法（可以理解为对象要销毁了）</span></span><br><span class="line">  <span class="comment">// 这里我们需要主动再调用 editController.dispose() 以释放资源</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    editController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Padding(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">      child: Row(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// 我们让输入框占满一行里除按钮外的所有空间</span></span><br><span class="line">          Expanded(</span><br><span class="line">            child: Container(</span><br><span class="line">              margin: EdgeInsets.only(right: <span class="number">8.0</span>),</span><br><span class="line">              child: TextField(</span><br><span class="line">                decoration: InputDecoration(</span><br><span class="line">                  hintText: <span class="string">'Input message'</span>,</span><br><span class="line">                  contentPadding: EdgeInsets.all(<span class="number">0.0</span>),</span><br><span class="line">                ),</span><br><span class="line">                style: TextStyle(</span><br><span class="line">                  fontSize: <span class="number">22.0</span>,</span><br><span class="line">                  color: Colors.black54</span><br><span class="line">                ),</span><br><span class="line">                controller: editController,</span><br><span class="line">                <span class="comment">// 自动获取焦点。这样在页面打开时就会自动弹出输入法</span></span><br><span class="line">                autofocus: <span class="keyword">true</span>,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          InkWell(</span><br><span class="line">            onTap: () =&gt; debugPrint(<span class="string">'send: <span class="subst">$&#123;editController.text&#125;</span>'</span>),</span><br><span class="line">            onDoubleTap: () =&gt; debugPrint(<span class="string">'double tapped'</span>),</span><br><span class="line">            onLongPress: () =&gt; debugPrint(<span class="string">'long pressed'</span>),</span><br><span class="line">            child: Container(</span><br><span class="line">              padding: EdgeInsets.symmetric(vertical: <span class="number">10.0</span>, horizontal: <span class="number">16.0</span>),</span><br><span class="line">              decoration: BoxDecoration(</span><br><span class="line">                color: Colors.black12,</span><br><span class="line">                borderRadius: BorderRadius.circular(<span class="number">5.0</span>)</span><br><span class="line">              ),</span><br><span class="line">              child: Text(<span class="string">'Send'</span>),</span><br><span class="line">            ),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UX demo'</span>,</span><br><span class="line">      home: AddMessageScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMessageScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Add message'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: MessageForm(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的按钮本应该使用 <code>RaisedButton</code> 或 <code>FlatButton</code>。为了演示如何监听手势事件，我们这里故意自己用 <code>Container</code> 做了一个按钮，然后通过 <code>InkWell</code> 监听手势事件。<code>InkWell</code> 除了上面展示的几个事件外，还带有一个水波纹效果。如果不需要这个水波纹效果，读者也可以使用 <code>GestureDetector</code>。</p><h2 id="消息列表页面"><a href="#消息列表页面" class="headerlink" title="消息列表页面"></a>消息列表页面</h2><p>我们的 echo 客户端共有两个页面，一个用于展示所有的消息，另一个页面用户输入消息，后者在上一小节我们已经写好了。下面，我们来实现用于展示消息的页面。</p><h3 id="页面间跳转"><a href="#页面间跳转" class="headerlink" title="页面间跳转"></a>页面间跳转</h3><p>我们的页面包含一个列表和一个按钮，列表用于展示信息，按钮则用来打开上一节我们所实现的 <code>AddMessageScreen</code>。这里我们先添加一个按钮并实现页面间的跳转。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是我们的消息展示页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Echo client'</span>),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="comment">// push 一个新的 route 到 Navigator 管理的栈中，以此来打开一个页面</span></span><br><span class="line">          Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: <span class="string">'Add message'</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在消息的输入页面，我们点击 Send 按钮后就返回：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onTap: () &#123;</span><br><span class="line">  debugPrint(<span class="string">'send: <span class="subst">$&#123;editController.text&#125;</span>'</span>);</span><br><span class="line">  Navigator.pop(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，我们加入一些骨架代码，实现一个完整的应用：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UX demo'</span>,</span><br><span class="line">      home: MessageListScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，上面代码所提供的功能还不够，我们需要从 <code>AddMessageScreen</code> 中返回一个消息。</p><p>首先我们对数据建模：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> timestamp;</span><br><span class="line"></span><br><span class="line">  Message(<span class="keyword">this</span>.msg, <span class="keyword">this</span>.timestamp);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Message&#123;msg: $msg, timestamp: $timestamp&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是返回数据和接收数据的代码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">onTap: () &#123;</span><br><span class="line">  debugPrint(<span class="string">'send: <span class="subst">$&#123;editController.text&#125;</span>'</span>);</span><br><span class="line">  <span class="keyword">final</span> msg = Message(</span><br><span class="line">    editController.text,</span><br><span class="line">    <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch</span><br><span class="line">  );</span><br><span class="line">  Navigator.pop(context, msg);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">floatingActionButton: FloatingActionButton(</span><br><span class="line">  onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">        context,</span><br><span class="line">        MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">    );</span><br><span class="line">    debugPrint(<span class="string">'result = $result'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="把数据展示到-ListView"><a href="#把数据展示到-ListView" class="headerlink" title="把数据展示到 ListView"></a>把数据展示到 ListView</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageList</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先忽略这里的参数 key，后面我们就会看到他的作用了</span></span><br><span class="line">  MessageList(&#123;Key key&#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _MessageListState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemCount: messages.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">final</span> msg = messages[index];</span><br><span class="line">        <span class="keyword">final</span> subtitle = <span class="built_in">DateTime</span>.fromMillisecondsSinceEpoch(msg.timestamp)</span><br><span class="line">            .toLocal().toIso8601String();</span><br><span class="line">        <span class="keyword">return</span> ListTile(</span><br><span class="line">          title: Text(msg.msg),</span><br><span class="line">          subtitle: Text(subtitle),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> addMessage(Message msg) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      messages.add(msg);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里唯一的新知识就是给 <code>MessageList</code> 的 <code>key</code> 参数，我们下面先看看如何使用他，然后再说明它的作用：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> messageListKey = GlobalKey&lt;_MessageListState&gt;(debugLabel: <span class="string">'messageListKey'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Echo client'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: MessageList(key: messageListKey),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">          );</span><br><span class="line">          debugPrint(<span class="string">'result = $result'</span>);</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">is</span> Message) &#123;</span><br><span class="line">            messageListKey.currentState.addMessage(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: <span class="string">'Add message'</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>引入一个 <code>GlobalKey</code> 的原因在于，<code>MessageListScreen</code> 需要把从 <code>AddMessageScreen</code> 返回的数据放到 <code>_MessageListState</code> 中，而我们无法从 <code>MessageList</code> 拿到这个 state。</p><p><code>GlobalKey</code> 的是应用全局唯一的 key，把这个 key 设置给 <code>MessageList</code> 后，我们就能够通过这个 key 拿到对应的 <code>statefulWidget</code> 的 <code>state</code>。</p><p>现在，整体的效果是这个样子的：<br><img src="/2018/08/29/flutter-ux-basic/message-list.gif" alt="message-list"></p><p>如果你遇到了麻烦，在 Github 上找到所有的代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ux-basic</span><br></pre></td></tr></table></figure></p><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>Flutter 动画的核心是 <code>Animation&lt;T&gt;</code>，<code>Animation</code> 接受一个时钟信号（<code>vsync</code>），转换为 <code>T</code> 值输出。它控制着动画的进度和状态，但不参与图像的绘制。最基本的 <code>Animation</code> 是 <code>AnimationController</code>，它输出 [0, 1] 之间的值。</p><h2 id="使用内置的-Widget-完成动画"><a href="#使用内置的-Widget-完成动画" class="headerlink" title="使用内置的 Widget 完成动画"></a>使用内置的 Widget 完成动画</h2><p>为了使用动画，我们可以用 Flutter 提供的 <code>AnimatedContainer</code>、<code>FadeTransition</code>、<code>ScaleTransition</code> 和 <code>RotationTransition</code> 等 Widget 来完成。</p><p>下面我们就来演示如何使用 <code>ScaleTransition</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'animation'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(<span class="string">'animation'</span>),),</span><br><span class="line">        body: AnimWidget(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画是有状态的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnimWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> controller;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    controller = AnimationController(</span><br><span class="line">      <span class="comment">// 动画的时长</span></span><br><span class="line">      duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">5000</span>),</span><br><span class="line">      <span class="comment">// 提供 vsync 最简单的方式，就是直接继承 SingleTickerProviderStateMixin</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 调用 forward 方法开始动画</span></span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ScaleTransition(</span><br><span class="line">      child: FlutterLogo(size: <span class="number">200.0</span>),</span><br><span class="line">      scale: controller,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>AnimationController</code> 的输出是线性的。非线性的效果可以使用 <code>CurveAnimation</code> 来实现：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  AnimationController controller;</span><br><span class="line">  CurvedAnimation curve;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    controller = AnimationController(</span><br><span class="line">      <span class="comment">// 动画的时长</span></span><br><span class="line">      duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">5000</span>),</span><br><span class="line">      <span class="comment">// 提供 vsync 最简单的方式，就是直接继承 SingleTickerProviderStateMixin</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line">    curve = CurvedAnimation(</span><br><span class="line">      parent: controller,</span><br><span class="line">      <span class="comment">// 更多的效果，参考 https://docs.flutter.io/flutter/animation/Curves-class.html</span></span><br><span class="line">      curve: Curves.easeInOut,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 调用 forward 方法开始动画</span></span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ScaleTransition(</span><br><span class="line">      child: FlutterLogo(size: <span class="number">200.0</span>),</span><br><span class="line">      <span class="comment">// 注意，这里我们把原先的 controller 改为了 curve</span></span><br><span class="line">      scale: curve,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，我们还可以组合不同的动画：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> scaled = ScaleTransition(</span><br><span class="line">      child: FlutterLogo(size: <span class="number">200.0</span>),</span><br><span class="line">      scale: curve,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> FadeTransition(</span><br><span class="line">      child: scaled,</span><br><span class="line">      opacity: curve,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更多的动画控件，读者可以参考 <a href="https://flutter.io/widgets/animation/" target="_blank" rel="noopener">https://flutter.io/widgets/animation/</a>。</p><h2 id="自定义动画效果"><a href="#自定义动画效果" class="headerlink" title="自定义动画效果"></a>自定义动画效果</h2><p>上一节我们使用 Flutter 内置的 <code>Widget</code> 来实现动画。他们虽然能够完成日常开发的大部分需求，但总有一些时候不太适用。这时我们就得自己实现动画效果了。</p><p>前面我们说，<code>AnimationController</code> 的输出在 [0, 1] 之间，这往往对我们需要实现的动画效果不太方便。为了将数值从 [0, 1] 映射到目标空间，可以使用 <code>Tween</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">animationValue = Tween(begin: <span class="number">0.0</span>, end: <span class="number">200.0</span>).animate(controller)</span><br><span class="line">    <span class="comment">// 每一帧都会触发 listener 回调</span></span><br><span class="line">    ..addListener(() &#123;</span><br><span class="line">      <span class="comment">// animationValue.value 随着动画的进行不断地变化。我们利用这个值来实现</span></span><br><span class="line">      <span class="comment">// 动画效果</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'value = <span class="subst">$&#123;animationValue.value&#125;</span>'</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>下面我们来画一个小圆点，让它往复不断地在正弦曲线上运动。</p><p><img src="/2018/08/29/flutter-ux-basic/sin-curve.gif" alt=""></p><p>先来实现小圆点沿着曲线运动的效果：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span> <span class="keyword">as</span> math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/animation.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimationDemoView</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnimationState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoView</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> padding = <span class="number">16.0</span>;</span><br><span class="line"></span><br><span class="line">  AnimationController controller;</span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; left;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 只有在 initState 执行完，我们才能通过 MediaQuery.of(context) 获取</span></span><br><span class="line">    <span class="comment">// mediaQueryData。这里通过创建一个 Future 从而在 Dart 事件队列里插入</span></span><br><span class="line">    <span class="comment">// 一个事件，以达到延后执行的目的（类似于在 Android 里 post 一个 Runnable）</span></span><br><span class="line">    <span class="comment">// 关于 Dart 的事件队列，读者可以参考 https://webdev.dartlang.org/articles/performance/event-loop</span></span><br><span class="line">    Future(_initState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _initState() &#123;</span><br><span class="line">    controller = AnimationController(</span><br><span class="line">        duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>),</span><br><span class="line">        <span class="comment">// 注意类定义的 with SingleTickerProviderStateMixin，提供 vsync 最简单的方法</span></span><br><span class="line">        <span class="comment">// 就是继承一个 SingleTickerProviderStateMixin。这里的 vsync 跟 Android 里</span></span><br><span class="line">        <span class="comment">// 的 vsync 类似，用来提供时针滴答，触发动画的更新。</span></span><br><span class="line">        vsync: <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们通过 MediaQuery 获取屏幕宽度</span></span><br><span class="line">    <span class="keyword">final</span> mediaQueryData = MediaQuery.of(context);</span><br><span class="line">    <span class="keyword">final</span> displayWidth = mediaQueryData.size.width;</span><br><span class="line">    debugPrint(<span class="string">'width = $displayWidth'</span>);</span><br><span class="line">    left = Tween(begin: padding, end: displayWidth - padding).animate(controller)</span><br><span class="line">      ..addListener(() &#123;</span><br><span class="line">        <span class="comment">// 调用 setState 触发他重新 build 一个 Widget。在 build 方法里，我们根据</span></span><br><span class="line">        <span class="comment">// Animatable&lt;T&gt; 的当前值来创建 Widget，达到动画的效果（类似 Android 的属性动画）。</span></span><br><span class="line">        setState(() &#123;</span><br><span class="line">          <span class="comment">// have nothing to do</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 监听动画状态变化</span></span><br><span class="line">      ..addStatusListener((status) &#123;</span><br><span class="line">        <span class="comment">// 这里我们让动画往复不断执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次动画完成</span></span><br><span class="line">        <span class="keyword">if</span> (status == AnimationStatus.completed) &#123;</span><br><span class="line">          <span class="comment">// 我们让动画反正执行一遍</span></span><br><span class="line">          controller.reverse();</span><br><span class="line">        <span class="comment">// 反着执行的动画结束</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AnimationStatus.dismissed) &#123;</span><br><span class="line">          <span class="comment">// 正着重新开始</span></span><br><span class="line">          controller.forward();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 假定一个单位是 24</span></span><br><span class="line">    <span class="keyword">final</span> unit = <span class="number">24.0</span>;</span><br><span class="line">    <span class="keyword">final</span> marginLeft = left == <span class="keyword">null</span> ? padding : left.value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 marginLeft 单位化</span></span><br><span class="line">    <span class="keyword">final</span> unitizedLeft = (marginLeft - padding) / unit;</span><br><span class="line">    <span class="keyword">final</span> unitizedTop = math.sin(unitizedLeft);</span><br><span class="line">    <span class="comment">// unitizedTop + 1 是了把 [-1, 1] 之间的值映射到 [0, 2]</span></span><br><span class="line">    <span class="comment">// (unitizedTop+1) * unit 后把单位化的值转回来</span></span><br><span class="line">    <span class="keyword">final</span> marginTop = (unitizedTop + <span class="number">1</span>) * unit + padding;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// 我们根据动画的进度设置圆点的位置</span></span><br><span class="line">      margin: EdgeInsets.only(left: marginLeft, top: marginTop),</span><br><span class="line">      <span class="comment">// 画一个小红点</span></span><br><span class="line">      child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            color: Colors.red, borderRadius: BorderRadius.circular(<span class="number">7.5</span>)),</span><br><span class="line">        width: <span class="number">15.0</span>,</span><br><span class="line">        height: <span class="number">15.0</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    controller.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter animation demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(<span class="string">'Animation demo'</span>)),</span><br><span class="line">        body: AnimationDemoView(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的动画中，我们只是对位置做出了改变，下面我们将在位置变化的同时，也让小圆点从红到蓝进行颜色的变化。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoView</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Animation&lt;Color&gt; color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _initState() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    color = ColorTween(begin: Colors.red, end: Colors.blue).animate(controller);</span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> color = <span class="keyword">this</span>.color == <span class="keyword">null</span> ? Colors.red : <span class="keyword">this</span>.color.value;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// 我们根据动画的进度设置圆点的位置</span></span><br><span class="line">      margin: EdgeInsets.only(left: marginLeft, top: marginTop),</span><br><span class="line">      <span class="comment">// 画一个小圆点</span></span><br><span class="line">      child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            color: color, borderRadius: BorderRadius.circular(<span class="number">7.5</span>)),</span><br><span class="line">        width: <span class="number">15.0</span>,</span><br><span class="line">        height: <span class="number">15.0</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 GitHub 上，可以找到所有的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout sin-curve</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们还可以加多一些效果，比方说让小圆点在运动的过程中大小也不断变化、使用 <code>CurveAnimation</code> 改变它运动的速度，这些就留给读者作为练习吧。</p>]]></content>
    
    <summary type="html">
    
      在这一篇文章中，我们首先介绍手势事件的处理和页面跳转的基础知识，然后通过实现一个 echo 客户端的前端页面来加强学习；最后我们再学习内置的动画 Widget 以及如何自定义动画效果。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（2）- UI控件和布局</title>
    <link href="https://jekton.github.io/2018/08/26/flutter-ui-basic/"/>
    <id>https://jekton.github.io/2018/08/26/flutter-ui-basic/</id>
    <published>2018-08-26T07:33:41.000Z</published>
    <updated>2018-09-18T12:17:18.177Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>本篇文章我们先介绍 Flutter 里一些常用的 UI 控件，然后借助官网提供的两个 demo 把所学的控件知识实际使用起来。</p><h1 id="基本控件"><a href="#基本控件" class="headerlink" title="基本控件"></a>基本控件</h1><h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>在 Flutter 里，UI 控件就是所谓的 Widget。通过组合不同的 Widget，来实现我们用户交互界面。</p><p>Widget 分为两种，一种是无状态的，叫 <code>StatelessWidget</code>，它只能用来展示信息，不能有动作（用户交互）；另一种是有状态的，叫 <code>StatefulWidget</code>，这种 Widget 可以通过改变状态使得 UI 发生变化，它可以包含用户交互。</p><p><code>StatelessWidget</code> 的使用非常简单，我们只需要继承 <code>StatelessWidget</code>，然后实现 <code>build</code> 方法就可以了：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于 <code>build</code> 方法的实现，在后面我们学习具体的控件时读者就会了解的，这里暂时忽略掉。</p><p><code>StatefulWidget</code> 用起来麻烦一些，他还需要一个 <code>State</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _BarWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BarWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BarWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里看起来可能有些绕，<code>BarWidget</code> 依赖了 <code>_BarWidgetState</code>，而 <code>_BarWidgetState</code> 又继承了 <code>State&lt;BarWidget&gt;</code>。如果读者不太理解，其实也没有什么关系，这只是一个样板代码，照着写就行了。</p><p>从 <code>BarWidget</code> 的实现来看，好像跟前面使用 <code>StatelessWidget</code> 没有什么区别，都是在 <code>build</code> 方法里面返回一个 <code>Widget</code>，只是 stateful widget 把这个方法挪到了 <code>State</code> 里面。实际上，两者的区别非常大。stateless widget 整个生命周期里都不会改变，所以 <code>build</code> 方法只会执行一次。而 stateful widget 只要状态改变，就会调用 <code>build</code> 方法重新创建 UI。</p><p>为了触发 UI 的重建，我们可以调用 <code>setState</code> 方法。下面的代码读者留意一下即可，在后面我们学习了相关的控件后再回过头来看。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _BarWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BarWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BarWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'i = $i'</span>),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            setState(() &#123;</span><br><span class="line">              ++i;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">          child: Text(<span class="string">'click'</span>),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们开始学习一些具体的控件。</p><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>为了展示文本，我们使用 <code>Text</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">"Put your text here"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是最简单的文本了，它使用的是默认的样式。很多情况下，我们都需要对文本的样式进行修改，这个时候，可以使用 <code>TextStyle</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(</span><br><span class="line">      <span class="string">"Put your text here"</span>,</span><br><span class="line">      style: TextStyle(</span><br><span class="line">        color: Colors.blue,</span><br><span class="line">        fontSize: <span class="number">16.0</span>,</span><br><span class="line">        fontWeight: FontWeight.bold</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用 <code>Image</code>，可以让我们向用户展示一张图片。图片的来源可以是网络、文件、资源和内存，它们对应的构造函数分别是：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Image.asset(name);</span><br><span class="line">Image.file(file);</span><br><span class="line">Image.memory(bytes);</span><br><span class="line">Image.network(src);</span><br></pre></td></tr></table></figure></p><p>比方说，为了展示一张来自网络的图片，我们可以这样：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Image.network(</span><br><span class="line">      <span class="string">"http://www.example.com/xxx.png"</span>,</span><br><span class="line">      width: <span class="number">200.0</span>,</span><br><span class="line">      height: <span class="number">150.0</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><p>Flutter 提供了两个基本的按钮控件：<code>FlatButton</code> 和 <code>RaisedButton</code>，它们的使用方法是类似的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> flatBtn = FlatButton(</span><br><span class="line">      onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'FlatButton pressed'</span>),</span><br><span class="line">      child: Text(<span class="string">'BUTTON'</span>),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> raisedButton = RaisedButton(</span><br><span class="line">      onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'RaisedButton pressed'</span>),</span><br><span class="line">      child: Text(<span class="string">'BUTTON'</span>),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> raisedButton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过设置 <code>onPressed</code> 回调，我们可以在按钮被点击的时候得到回调。<code>child</code> 参数用于设置按钮的内容。虽然我们给 <code>child</code> 传递的是 <code>Text</code>，但这不是必需的，它可以接受任意的 <code>Widget</code>，比方说，<code>Image</code>。</p><p>注意，由于我们只是在按钮点击的时候打印一个字符串，这里使用 <code>StatelessWidget</code> 是没有问题的。但如果有其他 UI 动作（比如弹出一个 dialog，则必须使用 <code>StatefulWidget</code>）。</p><p>它们的区别只是样式不同而已的：</p><p><code>FlatButton</code>：<br><img src="/2018/08/26/flutter-ui-basic/flat-button.png" alt=""></p><p><code>RaiseButton</code>：<br><img src="/2018/08/26/flutter-ui-basic/raised-button.png" alt=""></p><h2 id="文本输入框"><a href="#文本输入框" class="headerlink" title="文本输入框"></a>文本输入框</h2><p>Flutter 的文本输入框叫 <code>TextField</code>。为了获取用户输入的文本，我们需要给他设置一个 controller。通过这个 controller，就可以拿到文本框里的内容：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageForm</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _MessageFormState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageForm</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> editController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// Row、Expand 都是用于布局的控件，这里可以先忽略它们</span></span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Expanded(</span><br><span class="line">          child: TextField(</span><br><span class="line">            controller: editController,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">"click"</span>),</span><br><span class="line">          onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'text inputted: <span class="subst">$&#123;editController.text&#125;</span>'</span>),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    <span class="comment">// 手动调用 controller 的 dispose 方法以释放资源</span></span><br><span class="line">    editController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="显示弹框"><a href="#显示弹框" class="headerlink" title="显示弹框"></a>显示弹框</h2><p>在前面的 <code>TextField</code> 例子中，我们只是把用户的输入通过 <code>print</code> 打印出来，这未免也太无趣了。在这一小节，我们要把它显示在 dialog 里。为了弹出一个 dialog，我们需要调用 <code>showDialog</code> 方法并传递一个 builder：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageForm</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> editController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Expanded(</span><br><span class="line">          child: TextField(</span><br><span class="line">            controller: editController,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">"click"</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            showDialog(</span><br><span class="line">                <span class="comment">// 第一个 context 是参数名，第二个 context 是 State 的成员变量</span></span><br><span class="line">                context: context,</span><br><span class="line">                builder: (_) &#123;</span><br><span class="line">                  <span class="keyword">return</span> AlertDialog(</span><br><span class="line">                    <span class="comment">// dialog 的内容</span></span><br><span class="line">                    content: Text(editController.text),</span><br><span class="line">                    <span class="comment">// actions 设置 dialog 的按钮</span></span><br><span class="line">                    actions: &lt;Widget&gt;[</span><br><span class="line">                      FlatButton(</span><br><span class="line">                        child: Text(<span class="string">'OK'</span>),</span><br><span class="line">                        <span class="comment">// 用户点击按钮后，关闭弹框</span></span><br><span class="line">                        onPressed: () =&gt; Navigator.pop(context),</span><br><span class="line">                      )</span><br><span class="line">                    ],</span><br><span class="line">                  );</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    editController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最简单的布局——Container、Padding-和-Center："><a href="#最简单的布局——Container、Padding-和-Center：" class="headerlink" title="最简单的布局——Container、Padding 和 Center："></a>最简单的布局——Container、Padding 和 Center：</h2><p>我们经常说，Flutter 里面所有的东西都是 Widget，所以，布局也是 Widget。</p><p>控件 <code>Container</code> 可以让我们设置一个控件的尺寸、背景、margin 等：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Text(<span class="string">'text'</span>),</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      margin: EdgeInsets.all(<span class="number">4.0</span>),</span><br><span class="line">      width: <span class="number">80.0</span>,</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        <span class="comment">// 背景色</span></span><br><span class="line">        color: Colors.grey,</span><br><span class="line">        <span class="comment">// 圆角</span></span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">5.0</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们只需要 padding，可以使用控件 <code>Padding</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Padding(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      child: Text(<span class="string">'text'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Center</code> 就跟它的名字一样，把一个控件放在中间：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      margin: EdgeInsets.all(<span class="number">4.0</span>),</span><br><span class="line">      width: <span class="number">200.0</span>,</span><br><span class="line">      height: <span class="number">200.0</span>,</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        <span class="comment">// 背景色</span></span><br><span class="line">        color: Colors.grey,</span><br><span class="line">        <span class="comment">// 圆角</span></span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">5.0</span>),</span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把文本放在 Container 的中间</span></span><br><span class="line">      child: Center(</span><br><span class="line">        child: Text(<span class="string">'text'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="水平、竖直布局和-Expand"><a href="#水平、竖直布局和-Expand" class="headerlink" title="水平、竖直布局和 Expand"></a>水平、竖直布局和 Expand</h2><p>我们经常说，Flutter 里面所有的东西都是 <code>Widget</code>，所以，布局也是 <code>Widget</code>。水平布局我们可以使用 <code>Row</code>，竖直布局使用 <code>Column</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      <span class="comment">// 只有一个子元素的 widget，一般使用 child 参数来设置；Row 可以包含多个子控件，</span></span><br><span class="line">      <span class="comment">// 对应的则是 children。</span></span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'text1'</span>),</span><br><span class="line">        Text(<span class="string">'text2'</span>),</span><br><span class="line">        Text(<span class="string">'text3'</span>),</span><br><span class="line">        Text(<span class="string">'text4'</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Column</code> 的使用是一样的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'text1'</span>),</span><br><span class="line">        Text(<span class="string">'text2'</span>),</span><br><span class="line">        Text(<span class="string">'text3'</span>),</span><br><span class="line">        Text(<span class="string">'text4'</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于 <code>Expand</code> 控件，我们来看看 <code>TextField</code> 的那个例子：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageForm</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _MessageFormState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageForm</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> editController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        <span class="comment">// 占满一行里除 RaisedButton 外的所有空间</span></span><br><span class="line">        Expanded(</span><br><span class="line">          child: TextField(</span><br><span class="line">            controller: editController,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">"click"</span>),</span><br><span class="line">          onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">'text inputted: <span class="subst">$&#123;editController.text&#125;</span>'</span>),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    editController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里通过使用 <code>Expand</code>，<code>TextField</code> 才能够占满一行里除按钮外的所有空间。此外，当一行/列里有多个 <code>Expand</code> 时，我们还可以通过设置它的 <code>flex</code> 参数，在多个 <code>Expand</code> 之间按比例划分可用空间。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Expanded(</span><br><span class="line">          <span class="comment">// 占一行的 2/3</span></span><br><span class="line">          flex: <span class="number">2</span>,</span><br><span class="line">          child: RaisedButton(child: Text(<span class="string">'btn1'</span>),),</span><br><span class="line">        ),</span><br><span class="line">        Expanded(</span><br><span class="line">          <span class="comment">// 占一行的 1/3</span></span><br><span class="line">          flex: <span class="number">1</span>,</span><br><span class="line">          child: RaisedButton(child: Text(<span class="string">'btn2'</span>),),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stack-布局"><a href="#Stack-布局" class="headerlink" title="Stack 布局"></a>Stack 布局</h2><p>有些时候，我们可能会希望一个控件叠在另一个控件的上面。于是，<code>Stack</code> 应运而生：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'foobar'</span>),</span><br><span class="line">        Text(<span class="string">'barfoo'</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认情况下，子控件都按 <code>Stack</code> 的左上角对齐，于是，上面的两个文本完全一上一下堆叠在一起。我们还可以通过设置 <code>alignment</code> 参数来改变这个对齐的位置：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      <span class="comment">// Aligment 的取值范围为 [-1, 1]，Stack 中心为 (0, 0)，</span></span><br><span class="line">      <span class="comment">// 这里设置为 (-0.5, -0.5) 后，可以让文本对齐到 Container 的 1/4 处</span></span><br><span class="line">      alignment: <span class="keyword">const</span> Alignment(<span class="number">-0.5</span>, <span class="number">-0.5</span>),</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(</span><br><span class="line">          width: <span class="number">200.0</span>,</span><br><span class="line">          height: <span class="number">200.0</span>,</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        Text(<span class="string">'foobar'</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/08/26/flutter-ui-basic/screenshot-stack.png" alt="screenshot-stack"></p><p>通过组合 Row/Column 和 Stack，已经能够完成绝大部分的布局了，所以 Flutter 里没有相对布局之类的东西。更多的 Flutter 控件，读者可以参考 <a href="https://flutter.io/widgets/" target="_blank" rel="noopener">https://flutter.io/widgets/</a>。</p><h1 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h1><p>在这一节里，我们综合前面所学的知识，来实现下面这个界面。</p><p><img src="/2018/08/26/flutter-ui-basic/lakes-diagram.png" alt="lakes-diagram"></p><h2 id="展示图片"><a href="#展示图片" class="headerlink" title="展示图片"></a>展示图片</h2><ol><li>把图片 <a href="lake.png">lake</a> 放到项目根目录的 <code>images</code> 文件夹下（如果没有，你需要自己创建一个）</li><li><p>修改 <code>pubspec.yaml</code>，找到下面这个地方，然后把图片加进来</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line"></span><br><span class="line">  # The following line ensures that the Material Icons font is</span><br><span class="line">  # included with your application, so that you can use the icons in</span><br><span class="line">  # the material Icons class.</span><br><span class="line">  uses-material-design: true</span><br><span class="line"></span><br><span class="line">  # To add assets to your application, add an assets section, like this:</span><br><span class="line">  # assets:</span><br><span class="line">  #  - images/a_dot_burr.jpeg</span><br><span class="line">  #  - images/a_dot_ham.jpeg</span><br></pre></td></tr></table></figure><p> 修改后如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line"></span><br><span class="line">  # The following line ensures that the Material Icons font is</span><br><span class="line">  # included with your application, so that you can use the icons in</span><br><span class="line">  # the material Icons class.</span><br><span class="line">  uses-material-design: true</span><br><span class="line"></span><br><span class="line">  # To add assets to your application, add an assets section, like this:</span><br><span class="line">  assets:</span><br><span class="line">    - images/lake.jpg</span><br></pre></td></tr></table></figure></li><li><p>现在，我们可以把这张图片展示出来了：</p> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UI basic 1'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Top Lakes'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Image.asset(</span><br><span class="line">          <span class="string">'images/lake.jpg'</span>,</span><br><span class="line">          width: <span class="number">600.0</span>,</span><br><span class="line">          height: <span class="number">240.0</span>,</span><br><span class="line">          <span class="comment">// cover 类似于 Android 开发中的 centerCrop，其他一些类型，读者可以查看</span></span><br><span class="line">          <span class="comment">// https://docs.flutter.io/flutter/painting/BoxFit-class.html</span></span><br><span class="line">          fit: BoxFit.cover,</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果读者是初学 Flutter，<strong>强烈建议</strong>在遇到不熟悉的 API 时翻一翻文档，并在文档中找到 demo 所使用的 API。我们的例子不可能覆盖所有的 API，通过这种方式熟悉文档后，读者就可以根据文档实现出自己想要的效果。不妨就从 <code>Image</code> 开始吧，在 <a href="https://docs.flutter.io/flutter/widgets/Image/Image.asset.html" target="_blank" rel="noopener">https://docs.flutter.io/flutter/widgets/Image/Image.asset.html</a> 找出上面我们使用的 <code>Image.asset</code> 构造函数的几个参数的含义，还有 <code>BoxFit</code> 的其他几个枚举值。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>在这一小节，我们来实现图片下方的标题区域。</p><p><img src="/2018/08/26/flutter-ui-basic/title-section-diagram.png" alt=""></p><p>我们直接来看代码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TitleSection</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> subtitle;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> starCount;</span><br><span class="line"></span><br><span class="line">  _TitleSection(<span class="keyword">this</span>.title, <span class="keyword">this</span>.subtitle, <span class="keyword">this</span>.starCount);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 为了给 title section 加上 padding，这里我们给内容套一个 Container</span></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// 设置上下左右的 padding 都是 32。类似的还有 EdgeInsets.only/symmetric 等</span></span><br><span class="line">      padding: EdgeInsets.all(<span class="number">32.0</span>),</span><br><span class="line">      child: Row(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// 这里为了让标题占满屏幕宽度的剩余空间，用 Expanded 把标题包了起来</span></span><br><span class="line">          Expanded(</span><br><span class="line">            <span class="comment">// 再次提醒读者，Expanded 只能包含一个子元素，使用的参数名是 child。接下来，</span></span><br><span class="line">            <span class="comment">// 为了在竖直方向放两个标题，加入一个 Column。</span></span><br><span class="line">            child: Column(</span><br><span class="line">              <span class="comment">// Column 是竖直方向的，cross 为交叉的意思，也就是说，这里设置的是水平方向</span></span><br><span class="line">              <span class="comment">// 的对齐。在水平方向，我们让文本对齐到 start（读者可以修改为 end 看看效果）</span></span><br><span class="line">              crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                <span class="comment">// 聪明的你，这个时候肯定知道为什么突然加入一个 Container 了。</span></span><br><span class="line">                <span class="comment">// 跟前面一样，只是为了设置一个 padding</span></span><br><span class="line">                Container(</span><br><span class="line">                  padding: <span class="keyword">const</span> EdgeInsets.only(bottom: <span class="number">8.0</span>),</span><br><span class="line">                  child: Text(</span><br><span class="line">                    title,</span><br><span class="line">                    style: TextStyle(fontWeight: FontWeight.bold),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">                Text(</span><br><span class="line">                  subtitle,</span><br><span class="line">                  style: TextStyle(color: Colors.grey[<span class="number">500</span>]),</span><br><span class="line">                )</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这里是 Row 的第二个子元素，下面这两个就没用太多值得说的东西了。</span></span><br><span class="line">          Icon(</span><br><span class="line">            Icons.star,</span><br><span class="line">            color: Colors.red[<span class="number">500</span>],</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          Text(starCount.toString())</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><p>接下来我们要做的这一部分在布局上所用到的知识，基本知识在上一小节我们都已经学习了。这里唯一的区别在于，三个按钮是水平分布的。</p><p><img src="/2018/08/26/flutter-ui-basic/button-section-diagram.png" alt=""></p><p>实现如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildButtonColumn(BuildContext context, IconData icon, <span class="built_in">String</span> label) &#123;</span><br><span class="line">  <span class="keyword">final</span> color = Theme.of(context).primaryColor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Column(</span><br><span class="line">    <span class="comment">// main axis 跟我们前面提到的 cross axis 相对应，对 Column 来说，指的就是竖直方向。</span></span><br><span class="line">    <span class="comment">// 在放置完子控件后，屏幕上可能还会有一些剩余的空间（free space），min 表示尽量少占用</span></span><br><span class="line">    <span class="comment">// free space；类似于 Android 的 wrap_content。</span></span><br><span class="line">    <span class="comment">// 对应的，还有 MainAxisSize.max</span></span><br><span class="line">    mainAxisSize: MainAxisSize.min,</span><br><span class="line">    <span class="comment">// 沿着 main axis 居中放置</span></span><br><span class="line">    mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line"></span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Icon(icon, color: color),</span><br><span class="line">      Container(</span><br><span class="line">        margin: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">8.0</span>),</span><br><span class="line">        child: Text(</span><br><span class="line">          label,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">            fontSize: <span class="number">12.0</span>,</span><br><span class="line">            fontWeight: FontWeight.w400,</span><br><span class="line">            color: color,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      )</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    Widget buttonSection = Container(</span><br><span class="line">      child: Row(</span><br><span class="line">        <span class="comment">// 沿水平方向平均放置</span></span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">        children: [</span><br><span class="line">          _buildButtonColumn(context, Icons.call, <span class="string">'CALL'</span>),</span><br><span class="line">          _buildButtonColumn(context, Icons.near_me, <span class="string">'ROUTE'</span>),</span><br><span class="line">          _buildButtonColumn(context, Icons.share, <span class="string">'SHARE'</span>),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于 cross/main axis，看看下面这两个图就很清楚了：<br><img src="/2018/08/26/flutter-ui-basic/column-diagram.png" alt=""><br><img src="/2018/08/26/flutter-ui-basic/row-diagram.png" alt=""></p><p><code>MainAxisAlignment</code> 的更多的信息，可以查看 <a href="https://docs.flutter.io/flutter/rendering/MainAxisAlignment-class.html" target="_blank" rel="noopener">https://docs.flutter.io/flutter/rendering/MainAxisAlignment-class.html</a>。</p><h2 id="全部放到一起"><a href="#全部放到一起" class="headerlink" title="全部放到一起"></a>全部放到一起</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> titleSection = _TitleSection(</span><br><span class="line">        <span class="string">'Oeschinen Lake Campground'</span>, <span class="string">'Kandersteg, Switzerland'</span>, <span class="number">41</span>);</span><br><span class="line">    <span class="keyword">final</span> buttonSection = ...;</span><br><span class="line">    <span class="keyword">final</span> textSection = Container(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">32.0</span>),</span><br><span class="line">        child: Text(</span><br><span class="line">          <span class="string">'''</span></span><br><span class="line"><span class="string">Lake Oeschinen lies at the foot of the Blüemlisalp in the Bernese Alps. Situated 1,578 meters above sea level, it is one of the larger Alpine Lakes. A gondola ride from Kandersteg, followed by a half-hour walk through pastures and pine forest, leads you to the lake, which warms to 20 degrees Celsius in the summer. Activities enjoyed here include rowing, and riding the summer toboggan run.</span></span><br><span class="line"><span class="string">          '''</span>,</span><br><span class="line">          softWrap: <span class="keyword">true</span>,</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UI basic 1'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Top Lakes'</span>),</span><br><span class="line">          ),</span><br><span class="line">          <span class="comment">// 由于我们的内容可能会超出屏幕的长度，这里把内容都放到 ListView 里。</span></span><br><span class="line">          <span class="comment">// 除了这种用法，ListView 也可以像我们在 Android 原生开发中使用 ListView 那样，</span></span><br><span class="line">          <span class="comment">// 根据数据动态生成一个个 item。这个我们在下一节再来学习</span></span><br><span class="line">          body: ListView(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Image.asset(</span><br><span class="line">                <span class="string">'images/lake.jpg'</span>,</span><br><span class="line">                width: <span class="number">600.0</span>,</span><br><span class="line">                height: <span class="number">240.0</span>,</span><br><span class="line">                <span class="comment">// cover 类似于 Android 开发中的 centerCrop，其他一些类型，读者可以查看</span></span><br><span class="line">                <span class="comment">// https://docs.flutter.io/flutter/painting/BoxFit-class.html</span></span><br><span class="line">                fit: BoxFit.cover,</span><br><span class="line">              ),</span><br><span class="line"></span><br><span class="line">              titleSection,</span><br><span class="line">              buttonSection,</span><br><span class="line">              textSection</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果没有出错的话，运行后应该就可以看到下面这个页面。<br><img src="/2018/08/26/flutter-ui-basic/Screenshot_20180826-172022.png" alt=""></p><p>如果你遇到了麻烦，可以在这里找到所有的源码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ui-basic1</span><br></pre></td></tr></table></figure></p><p>更多的布局知识，读者还可以参考 <a href="https://flutter.io/tutorials/layout/" target="_blank" rel="noopener">https://flutter.io/tutorials/layout/</a>。</p><h1 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h1><p>在这一小节我们来实现一个 list view。</p><p><img src="/2018/08/26/flutter-ui-basic/listview.png" alt=""></p><p>这里我们采用的还是官网提供的例子，但是换一种方式来实现，让它跟我们平时使用 Java 时更像一些。</p><p>首先给数据建模：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BuildingType &#123; theater, restaurant &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> BuildingType type;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> address;</span><br><span class="line"></span><br><span class="line">  Building(<span class="keyword">this</span>.type, <span class="keyword">this</span>.title, <span class="keyword">this</span>.address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后实现每个 item 的 UI：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> position;</span><br><span class="line">  <span class="keyword">final</span> Building building;</span><br><span class="line"></span><br><span class="line">  ItemView(<span class="keyword">this</span>.position, <span class="keyword">this</span>.building);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> icon = Icon(</span><br><span class="line">        building.type == BuildingType.restaurant</span><br><span class="line">            ? Icons.restaurant</span><br><span class="line">            : Icons.theaters,</span><br><span class="line">        color: Colors.blue[<span class="number">500</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> widget = Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">          child: icon,</span><br><span class="line">        ),</span><br><span class="line">        Expanded(</span><br><span class="line">          child: Column(</span><br><span class="line">            crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(</span><br><span class="line">                building.title,</span><br><span class="line">                style: TextStyle(</span><br><span class="line">                  fontSize: <span class="number">20.0</span>,</span><br><span class="line">                  fontWeight: FontWeight.w500,</span><br><span class="line">                )</span><br><span class="line">              ),</span><br><span class="line">              Text(building.address)</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> widget;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着是 ListView。由于渲染机制不同，这里没必要弄个 adapter 来管理 widget：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildingListView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Building&gt; buildings;</span><br><span class="line"></span><br><span class="line">  BuildingListView(<span class="keyword">this</span>.buildings);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// ListView.builder 可以按需生成子控件</span></span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemCount: buildings.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ItemView(index, buildings[index]);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们来给 item 加上点击事件。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个回调接口</span></span><br><span class="line"><span class="keyword">typedef</span> OnItemClickListener = <span class="keyword">void</span> <span class="built_in">Function</span>(<span class="built_in">int</span> position);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> position;</span><br><span class="line">  <span class="keyword">final</span> Building building;</span><br><span class="line">  <span class="keyword">final</span> OnItemClickListener listener;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的 listener 会从 ListView 那边传过来</span></span><br><span class="line">  ItemView(<span class="keyword">this</span>.position, <span class="keyword">this</span>.building, <span class="keyword">this</span>.listener);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> widget = ...;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般来说，为了监听手势事件，我们使用 GestureDetector。但这里为了在点击的时候有个</span></span><br><span class="line">    <span class="comment">// 水波纹效果，使用的是 InkWell。</span></span><br><span class="line">    <span class="keyword">return</span> InkWell(</span><br><span class="line">      onTap: () =&gt; listener(position),</span><br><span class="line">      child: widget</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildingListView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Building&gt; buildings;</span><br><span class="line">  <span class="keyword">final</span> OnItemClickListener listener;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是对外接口。外部通过构造函数传入数据和 listener</span></span><br><span class="line">  BuildingListView(<span class="keyword">this</span>.buildings, <span class="keyword">this</span>.listener);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemCount: buildings.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ItemView(index, buildings[index], listener);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后加上一些脚手架代码，我们的列表就能够跑起来了：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> buildings = [</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'CineArts at the Empire'</span>, <span class="string">'85 W Portal Ave'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'The Castro Theater'</span>, <span class="string">'429 Castro St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Alamo Drafthouse Cinema'</span>, <span class="string">'2550 Mission St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Roxie Theater'</span>, <span class="string">'3117 16th St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'United Artists Stonestown Twin'</span>, <span class="string">'501 Buckingham Way'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'AMC Metreon 16'</span>, <span class="string">'135 4th St #3000'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'K\'s Kitchen'</span>, <span class="string">'1923 Ocean Ave'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'Chaiya Thai Restaurant'</span>, <span class="string">'72 Claremont Blvd'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'La Ciccia'</span>, <span class="string">'291 30th St'</span>),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// double 一下</span></span><br><span class="line">      Building(BuildingType.theater, <span class="string">'CineArts at the Empire'</span>, <span class="string">'85 W Portal Ave'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'The Castro Theater'</span>, <span class="string">'429 Castro St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Alamo Drafthouse Cinema'</span>, <span class="string">'2550 Mission St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Roxie Theater'</span>, <span class="string">'3117 16th St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'United Artists Stonestown Twin'</span>, <span class="string">'501 Buckingham Way'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'AMC Metreon 16'</span>, <span class="string">'135 4th St #3000'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'K\'s Kitchen'</span>, <span class="string">'1923 Ocean Ave'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'Chaiya Thai Restaurant'</span>, <span class="string">'72 Claremont Blvd'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'La Ciccia'</span>, <span class="string">'291 30th St'</span>),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'ListView demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Buildings'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: BuildingListView(buildings, (index) =&gt; debugPrint(<span class="string">'item $index clicked'</span>))</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候你应该可以看到像这样的界面了：<br><img src="/2018/08/26/flutter-ui-basic/screenshot-listview.png" alt=""></p><p>如果你遇到了什么麻烦，可以查看 tag ui-basic2 的代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ui-basic2</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      本篇文章我们先介绍 Flutter 里一些常用的 UI 控件，然后借助官网提供的两个 demo 把所学的控件知识实际使用起来。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（1）- 开发框架、流程、编译打包、调试</title>
    <link href="https://jekton.github.io/2018/08/26/flutter-first-app/"/>
    <id>https://jekton.github.io/2018/08/26/flutter-first-app/</id>
    <published>2018-08-26T01:41:42.000Z</published>
    <updated>2018-09-18T12:16:48.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a>提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>Flutter 是 Google 推出的移动端跨平台开发框架，使用的编程语言是 Dart。从 React Native 到 Flutter，开发者对跨平台解决方案的探索从未停止，毕竟，它可以让我们节省移动端一半的人力。本篇文章中，我们就通过编写一个简单的 Flutter 来了解他的开发流程。</p><p>这里我们要开发的 demo 很简单，只是在屏幕中间放一个按钮，点击的时候，模拟摇两个骰子并弹窗显示结果。我们撸起袖子开干吧。</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>我们这里假定读者已经安装好 Flutter，并且使用安装了 Flutter 插件的 Android Studio 进行开发。如果你还没有配置好开发环境，可以参考 <a href="https://mp.weixin.qq.com/s/6lmhHNBRcmoNqkMHaCBx8A" target="_blank" rel="noopener">这篇文章</a>。</p><p>下面我们开始创建项目：</p><ol><li>选择 File &gt; New &gt; New Flutter project…</li><li>在接下来弹出的选择面板里，选择 Flutter Application</li><li>这里填应用的基本信息。Project name 我们就写 flutter_demo 好了。这里要注意的是，Project name 必须是一个合法的 Dart 包名（小写+下划线，可以有数字）。填好以后点击 next，然后 finish。</li></ol><p>第一次创建项目时，由于要下载 gradle，时间会稍微长一些。</p><h1 id="编写代码（1）"><a href="#编写代码（1）" class="headerlink" title="编写代码（1）"></a>编写代码（1）</h1><p>在上一小节里我们所创建的项目，已经有了一些代码，感兴趣的读者可以跑到自己手机上看一看，相关的代码在 <code>lib/main.dart</code> 里面。</p><p>为了体验从头开发一个应用的过程，这里我们先把 <code>lib/main.dart</code> 里的内容都删除。</p><p>首先，我们创建一个 <code>main</code> 函数。跟其他语言一样，<code>main</code> 函数是应用的入口：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们编写一个 <code>Widget</code> 作为我们的 app。在 Flutter 里，所有的东西都是 <code>Widget</code>。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 创建一个 MyApp</span></span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这个 widget 作用这个应用的顶层 widget.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 这个 widget 是无状态的，所以我们继承的是 [StatelessWidget].</span></span><br><span class="line"><span class="comment">/// 对应的，有状态的 widget 可以继承 [StatefulWidget]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 创建内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们可以进入正题，进入一个按钮，在点击的时候弹框显示结果：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">// 我们想使用 material 风格的应用，所以这里用 MaterialApp</span></span><br><span class="line">  <span class="keyword">return</span> MaterialApp(</span><br><span class="line">    <span class="comment">// 移动设备使用这个 title 来表示我们的应用。具体一点说，在 Android 设备里，我们点击</span></span><br><span class="line">    <span class="comment">// recent 按钮打开最近应用列表的时候，显示的就是这个 title。</span></span><br><span class="line">    title: <span class="string">'Our first Flutter app'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用的“主页”</span></span><br><span class="line">    home: Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Flutter rolling demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 我们知道，Flutter 里所有的东西都是 widget。为了把按钮放在屏幕的中央，</span></span><br><span class="line">      <span class="comment">// 这里使用了 Center（它是一个 widget）。</span></span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          <span class="comment">// 用户点击时候调用</span></span><br><span class="line">          onPressed: _onPressed,</span><br><span class="line">          child: Text(<span class="string">'roll'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="安装、调试（1）"><a href="#安装、调试（1）" class="headerlink" title="安装、调试（1）"></a>安装、调试（1）</h1><p>现在，点击 Run，把我们的第一个 Flutter 应用跑起来吧。没有意外的话，你会看到下面这个页面：<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-pic1.png" alt="Screenshot with a button in the center"></p><p>如果你遇到了什么困难，可以查看 tag <code>first_app_step1</code> 的代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout first_app_step1</span><br></pre></td></tr></table></figure></p><p>由于是第一次写 Flutter 应用，我们对上面的代码是否能够按照预期执行还不是那么有信心，所以我们先打个 log 确认一下，点击按钮后是不是真的会执行 <code>onPress</code>。</p><p>打 log 可以使用 Dart 提供的 <code>print</code>，但在日志比较多的时候，<code>print</code> 的输出可能会被 Android 丢弃，这个时候 <code>debugPrint</code> 会是更好的选择。对应的日志信息可以在 <code>Dart Console</code> 里查看（View -&gt; Tool Windows -&gt; Run 或者 Mac 上使用 Command+4 打开）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">  debugPrint(<span class="string">'_onPressed'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后（会自动 Hot Reload）后，我们再次点击按钮，在我的设备上，打印出了下面这样的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (11297): _onPressed</span><br><span class="line">V/AudioManager(11297): playSoundEffect   effectType: 0</span><br><span class="line">V/AudioManager(11297): querySoundEffectsEnabled...</span><br></pre></td></tr></table></figure></p><p>这里的第一行，就是我们打印的。现在我们有足够的自信说，点击按钮后，会执行 <code>_onPressed</code> 方法。</p><h1 id="编写代码（2）"><a href="#编写代码（2）" class="headerlink" title="编写代码（2）"></a>编写代码（2）</h1><p>软件开发通常是一个螺旋式上升的过程，不可能通过一次编码、调试就完成。现在，开始第二轮迭代过程。</p><p>接下来我们要做的，便是在 <code>_onPressed</code> 里面弹一个框：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context 这里使用的是 MyApp.build 的参数</span></span><br><span class="line"><span class="keyword">void</span> _onPressed(BuildContext context) &#123;</span><br><span class="line">  debugPrint(<span class="string">'_onPressed'</span>);</span><br><span class="line"></span><br><span class="line">  showDialog(</span><br><span class="line">    context: context,</span><br><span class="line">    builder: (_) &#123;</span><br><span class="line">      <span class="keyword">return</span> AlertDialog(</span><br><span class="line">        content: Text(<span class="string">'AlertDialog'</span>),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遗憾的是，这一次并不那么顺利。Dialog 没有弹出来，而且报了下面这问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (11297): Navigator operation requested with a context that does not include a Navigator.</span><br><span class="line">I/flutter (11297): The context used to push or pop routes from the Navigator must be that of a widget that is a</span><br><span class="line">I/flutter (11297): descendant of a Navigator widget.</span><br></pre></td></tr></table></figure></p><p>原因在于，stateless 的 widget 只能用于显示信息，而不能有其他动作。所以，该让 <code>StatefulWidget</code> 上场了。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RollingButton</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// StatefulWidget 需要实现这个方法，返回一个 State</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _RollingState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能看起来有点恶心，这里的泛型参数居然是 RollingButton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RollingState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RollingButton</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      child: Text(<span class="string">'Roll'</span>),</span><br><span class="line">      onPressed: _onPressed,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">    debugPrint(<span class="string">'_RollingState._onPressed'</span>);</span><br><span class="line">    showDialog(</span><br><span class="line">        <span class="comment">// 第一个 context 是参数名，第二个 context 是 State 的成员变量</span></span><br><span class="line">        context: context,</span><br><span class="line">        builder: (_) &#123;</span><br><span class="line">          <span class="keyword">return</span> AlertDialog(</span><br><span class="line">            content: Text(<span class="string">'AlertDialog'</span>),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要实现一个 stateful 的 widget，需要继承 <code>StatefulWidget</code> 并在 <code>createState</code> 方法中返回一个 <code>State</code>。除了这一部分，上面的代码跟我们之前写的并没有太大的区别。</p><p>剩下的，就是替换 <code>MyApp</code> 里面使用的按钮，修改后的代码如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Our first Flutter app'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Flutter rolling demo'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: RollingButton(),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再次运行，点击按钮后，我们将看到梦寐以求的 dialog。<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-pic2.png" alt="Screenshot with a dialog"></p><p>如果你遇到了麻烦，可以查看 tag <code>first_app_step2</code> 的代码。</p><p>最后，我们来实现“roll”：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RollingState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RollingButton</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> _random = Random();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; _roll() &#123;</span><br><span class="line">    <span class="keyword">final</span> roll1 = _random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> roll2 = _random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> [roll1, roll1];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">    debugPrint(<span class="string">'_RollingState._onPressed'</span>);</span><br><span class="line">    <span class="keyword">final</span> rollResults = _roll();</span><br><span class="line">    showDialog(</span><br><span class="line">        <span class="comment">// 第一个 context 是参数名，第二个 context 是 State 的成员变量</span></span><br><span class="line">        context: context,</span><br><span class="line">        builder: (_) &#123;</span><br><span class="line">          <span class="keyword">return</span> AlertDialog(</span><br><span class="line">            content: Text(<span class="string">'Roll result: (<span class="subst">$&#123;rollResults[<span class="number">0</span>]&#125;</span>, <span class="subst">$&#123;rollResults[<span class="number">1</span>]&#125;</span>)'</span>),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="安装、调试（2）"><a href="#安装、调试（2）" class="headerlink" title="安装、调试（2）"></a>安装、调试（2）</h1><p>还是一样，重新运行后，我们就能够看到每次点击按钮的结果随机地出现 <code>[1, 6]</code> 中的数……慢着，怎么弹出的消息里的两个号码总是一样的！好吧，肯定是哪里出错了。</p><p>这次，我们不采用打 log 的方法，改用 debugger 来调试。</p><ol><li>在 <code>final rollResults = _roll();</code> 这一行打个断点</li><li>然后点击 Debug main.dart 开始调试</li><li>点击 APP 里的 Roll 按钮</li></ol><p>现在，应用停在了我们所打的断点处：<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-debug1.png" alt="debug step1"></p><p>接下来：</p><ol><li>Step Into 进入 <code>_roll</code> 方法</li><li>进入 <code>_roll</code> 后，Step Over 一行执行。<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-debug2.png" alt="debug step2"><br>这里我们看到，两次 random 确实产生了不同的结果。我们继续：</li><li>继续 Step Over，这个时候 <code>_roll</code> 就返回了</li><li>切换到 Variables 这个选项卡，查看 <code>rollResults</code> 的值<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-debug3.png" alt="debug step3"></li></ol><p>可以发现，两个结果居然变成一样的了。再往回查看一下代码，我们竟然 <code>return [roll1, roll1]</code>。修改后一个为 <code>roll2</code>，我们就程序就能够按预期的正常执行了。</p><p>最终的代码，可以看 tag <code>first_app_done</code>。</p><h2 id="调试总结"><a href="#调试总结" class="headerlink" title="调试总结"></a>调试总结</h2><p>本篇文章其实介绍了两种调试方法：打 log 和 debugger。虽然现在 Flutter 提供的 log 工具比较简陋，可以预期未来还会进一步完善。</p><p>使用打 log 的方式，好处在于不会对执行流程产生较大的影响，在多线程环境尤为有用。它的速度也比较快，不需要我们去单步执行。不足之处在于，如果原先没有对应的 log，我们只能修改代码重新运行，才能查看相应的状态。对于线上的应用，我们也只能够通过分析 log 来定位问题。</p><p>debugger 跟打 log 方式是互补的。使用 debugger 时，我们可以随意查看我们需要知道的变量的值，一步一步近距离观察代码的运行状态。坏处当然就是太慢了。在什么时候使用什么方法，需要一些经验；但有时候就全凭个人喜好了，没有优劣之分。</p><p>更多的调试方法，读者可以根据需要查看<a href="https://flutter.io/debugging/" target="_blank" rel="noopener">https://flutter.io/debugging/</a>进一步学习。</p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>编写完应用后，是时候打包 apk 分发给用户使用了。在这一小节，我们就来看看怎么给 Flutter 项目打包。</p><p>在我们项目的根目录，有一个 android 文件夹，下面我们将主要对这个目录的文件进行修改。</p><ol><li>查看 <code>AndroidManifest.xml</code>。这是一个按模板生成的文件，有些东西可能需要修改一下</li><li><code>build.gradle</code>，这里面也可能有你需要修改的地方。对我们的应用来说，目前都先维持原样</li><li>如果有需要，更新 <code>res/mipmap</code> 里的应用启动图标。这里我们不改</li><li><p>签名</p><ol><li>生成签名的 key（如果你已经有了，跳过这一步）,<code>keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key</code>。为了让读者也可以编译，这里我把 key 也放到了项目中。</li><li><p>添加一个 <code>android/key.properties</code>，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storePassword=123456</span><br><span class="line">keyPassword=123456</span><br><span class="line">keyAlias=key</span><br><span class="line">storeFile=../key.jks</span><br></pre></td></tr></table></figure></li><li><p>更新 build.gradle 里的签名配置</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> keystorePropertiesFile = rootProject.<span class="keyword">file</span>(<span class="string">"key.properties"</span>)</span><br><span class="line"><span class="keyword">def</span> keystoreProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">keystoreProperties.load(<span class="keyword">new</span> FileInputStream(keystorePropertiesFile))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            keyAlias keystoreProperties[<span class="string">'keyAlias'</span>]</span><br><span class="line">            keyPassword keystoreProperties[<span class="string">'keyPassword'</span>]</span><br><span class="line">            storeFile <span class="keyword">file</span>(keystoreProperties[<span class="string">'storeFile'</span>])</span><br><span class="line">            storePassword keystoreProperties[<span class="string">'storePassword'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line"></span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            useProguard <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// proguard 文件我们在下一步添加</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>添加 <code>/android/app/proguard-rules.pro</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#Flutter Wrapper</span><br><span class="line">-keep class io.flutter.app.** &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.plugin.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.util.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.view.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.plugins.**  &#123; *; &#125;</span><br></pre></td></tr></table></figure></li><li><p>编译 apk。在项目的根目录，执行 <code>flutter build apk</code>， 编译后的应用在 <code>build/app/outputs/apk/release/app-release.apk</code>。</p></li><li>还是在根目录下，执行 <code>flutter install</code> 就可以安装这个 apk 了。</li></ol><p><br><br>对于 iOS，读者可以看<a href="https://flutter.io/ios-release/" target="_blank" rel="noopener">https://flutter.io/ios-release/</a>，这里就不再演示了。 查看最终的项目，可以 checkout 到 tag <code>first_app_signing</code>。恭喜你，第一个 Flutter 应用完成啦。</p>]]></content>
    
    <summary type="html">
    
      Flutter 是 Google 推出的移动端跨平台开发框架，使用的编程语言是 Dart。从 React Native 到 Flutter，开发者对跨平台解决方案的探索从未停止，毕竟，它可以让我们节省移动端一半的人力。本篇文章中，我们就通过编写一个简单的 Flutter 来了解他的开发流程。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>JDK 源码分析（1）- FutureTask</title>
    <link href="https://jekton.github.io/2018/07/25/jdk-FutureTask/"/>
    <id>https://jekton.github.io/2018/07/25/jdk-FutureTask/</id>
    <published>2018-07-25T05:27:45.000Z</published>
    <updated>2018-08-18T12:47:22.691Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是 JDK 源码分析的第一篇，主要关注 <code>FutureTask</code> 的实现。我们所分析的源码使用的是 Java10，因此也假设了读者了解 <code>VarHandle</code>（Java9 新增的 API），不了解的读者可以看我翻译的<a href="https://jekton.github.io/2018/07/22/java-translation-jep-193-Variable-Handles/">JEP 193</a>。</p><a id="more"></a><h2 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h2><p>这里我们不准备详细讲 <code>FutureTask</code> 的用法，只是简单提一下，帮组读者回忆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首先我们构造一个 `FutureTask`</span></span><br><span class="line">FutureTask&lt;Foo&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 然后我们把这个实例放在后台线程执行，比方说 executor：</span></span><br><span class="line">executor.execute(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 最后，我们获取执行的结果</span></span><br><span class="line">Foo foo = task.get();</span><br></pre></td></tr></table></figure><p>如果读者对 <code>FutureTask</code> 的用法不是很熟悉，等看完源码就会非常清楚了。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The run state of this task, initially NEW.  The run state</span></span><br><span class="line"><span class="comment">     * transitions to a terminal state only in methods set,</span></span><br><span class="line"><span class="comment">     * setException, and cancel.  During completion, state may take on</span></span><br><span class="line"><span class="comment">     * transient values of COMPLETING (while outcome is being set) or</span></span><br><span class="line"><span class="comment">     * INTERRUPTING (only while interrupting the runner to satisfy a</span></span><br><span class="line"><span class="comment">     * cancel(true)). Transitions from these intermediate to final</span></span><br><span class="line"><span class="comment">     * states use cheaper ordered/lazy writes because values are unique</span></span><br><span class="line"><span class="comment">     * and cannot be further modified.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Possible state transitions:</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">// this.state 是 volatile，对 volatile 字段的写入，存在一个 happen-before</span></span><br><span class="line">        <span class="comment">// 关系；也就是说，`this.state = NEW` 执行完毕时，`this.callable = callable`</span></span><br><span class="line">        <span class="comment">// 也保证已经写入</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为标准库的实现，在性能上我们锱铢必较。这里利用 <code>volatile</code> 的特性，可以不需要设置 <code>callable</code> 为 <code>volatile</code>。</p><h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>创建了 <code>FutureTask</code> 实例后，我们就可以执行他了。这个由 <code>run()</code> 方法来完成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            <span class="comment">// 这是一个原子操作</span></span><br><span class="line">            !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="comment">// 假设有两个线程竞争执行这个 futureTask，线程1 执行了</span></span><br><span class="line">            <span class="comment">// state != NEW 后，轮到线程2，同样执行成功；接着线程2</span></span><br><span class="line">            <span class="comment">// 继续执行到方法结束并设置 runner 回 null；再后面，线</span></span><br><span class="line">            <span class="comment">// 程1 重新被调度，来到了下面这个 if 语句。此时其实已经</span></span><br><span class="line">            <span class="comment">// 执行完成，所以这里要再判断一次</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 情况1：发生异常</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    <span class="comment">// 情况2：执行成功</span></span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 情况3：任务被取消</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VarHandle mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MethodHandles.Lookup l = MethodHandles.lookup();</span><br><span class="line">            STATE = l.findVarHandle(FutureTask.class, <span class="string">"state"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">            RUNNER = l.findVarHandle(FutureTask.class, <span class="string">"runner"</span>, Thread.class);</span><br><span class="line">            WAITERS = l.findVarHandle(FutureTask.class, <span class="string">"waiters"</span>, WaitNode.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reduce the risk of rare disastrous classloading in first call to</span></span><br><span class="line">        <span class="comment">// LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span></span><br><span class="line">        Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们分 3 种情况来看代码。</p><h3 id="情况1：发生异常"><a href="#情况1：发生异常" class="headerlink" title="情况1：发生异常"></a>情况1：发生异常</h3><p>如果执行的过程发生了异常，会调用 <code>setException</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可能客户会调用 cancel 方法取消任务，所以这里要用原子操作</span></span><br><span class="line">        <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">            outcome = t;</span><br><span class="line">            STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>VarHandle</code> 的 <code>setRelease</code> 有这样一句注释：</p><blockquote><p>Sets the value of a variable to the {@code newValue}, and ensures that prior loads and stores are not reordered after this access.</p></blockquote><p>所以（如果 <code>compareAndSet</code> 执行成功），当我们把 <code>state</code> 设置为 <code>EXCEPTIONAL</code> 前，能够保证 <code>outcome = t</code> 已经执行完成。</p><p><code>finishCompletion</code> 我们留到后面再看。</p><h3 id="情况2：执行成功"><a href="#情况2：执行成功" class="headerlink" title="情况2：执行成功"></a>情况2：执行成功</h3><p>执行成功时调用 <code>set</code> 方法，它的实现跟 <code>setException</code> 差不多：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="情况3：任务被取消"><a href="#情况3：任务被取消" class="headerlink" title="情况3：任务被取消"></a>情况3：任务被取消</h3><p>如果需要取消任务，可以调用 <code>FutureTask</code> 的 <code>cancel</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">              (<span class="keyword">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="comment">// 如果当前状态不是 NEW 并且不能成功将其设置为 INTERRUPTING/CANCELLED</span></span><br><span class="line">            <span class="comment">// 表示任务已经执行完，所以 cancel 失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="comment">// 如果 t == null，要么是这个任务还没开始执行，要么已经执行</span></span><br><span class="line">                    <span class="comment">// 到了 run 方法里的 finally 块</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    STATE.setRelease(<span class="keyword">this</span>, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果 <code>mayInterruptIfRunning == false</code>，那就直接尝试把状态设置为 <code>CANCELLED</code>；否则需要 interrupt 线程。下面是 <code>run</code> 方法最后的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">final</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 对应 mayInterruptIfRunning == true 的情况</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensures that any interrupt from a possible cancel(true) is only</span></span><br><span class="line"><span class="comment">     * delivered to a task while in run or runAndReset.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">        <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></span><br><span class="line">        <span class="comment">// 注意，第一个比较的是参数 s，s 可能是 `INTERRUPTED`</span></span><br><span class="line">        <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">            <span class="comment">// state 是 volatile，保证我们这里每次都能够读到最新的值</span></span><br><span class="line">            <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">                Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// assert state == INTERRUPTED;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We want to clear any interrupt we may have received from</span></span><br><span class="line">        <span class="comment">// cancel(true).  However, it is permissible to use interrupts</span></span><br><span class="line">        <span class="comment">// as an independent mechanism for a task to communicate with</span></span><br><span class="line">        <span class="comment">// its caller, and there is no way to clear only the</span></span><br><span class="line">        <span class="comment">// cancellation interrupt.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Thread.interrupted();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有 3 种情况，最后都会调用 <code>finishCompletion</code> 方法，这部分我们下一节继续看。</p><h2 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h2><p>在 <code>finishCompletion</code> 的内部，会唤醒等待结果的线程。这里我们先不看 <code>finishCompletion</code>，而是看看 <code>get</code> 方法，这样会更容易理解一些。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">// awaitDone 会返回结束时的状态</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            <span class="comment">// timeout 后还没有结束</span></span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这部分的重点在于 <code>awaitDone</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class="line"><span class="comment">     * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class="line"><span class="comment">     * for more detailed explanation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Awaits completion or aborts on interrupt or timeout.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timed true if use timed waits</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanos time to wait, if timed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> state upon completion or at timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// The code below is very delicate, to achieve these goals:</span></span><br><span class="line">        <span class="comment">// - call nanoTime exactly once for each call to park</span></span><br><span class="line">        <span class="comment">// - if nanos &lt;= 0L, return promptly without allocation or nanoTime</span></span><br><span class="line">        <span class="comment">// - if nanos == Long.MIN_VALUE, don't underflow</span></span><br><span class="line">        <span class="comment">// - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic</span></span><br><span class="line">        <span class="comment">//   and we suffer a spurious wakeup, we will do no worse than</span></span><br><span class="line">        <span class="comment">//   to park-spin for a while</span></span><br><span class="line">        <span class="keyword">long</span> startTime = <span class="number">0L</span>;    <span class="comment">// Special value 0L means not yet parked</span></span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 任务完成或被取消</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">                <span class="comment">// 到 COMPLETING 状态了的话，预期很快就会结束，所以 yield 一下</span></span><br><span class="line">                <span class="comment">// 就够了</span></span><br><span class="line">                <span class="comment">// We may have already promised (via isDone) that we are done</span></span><br><span class="line">                <span class="comment">// so never return empty-handed or throw InterruptedException</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">// removeWaiter 把节点从 waiters 列表里移除</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一个循环，q == null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用 get 方法时传入时间为 0 或负值，可以轮询任务；</span></span><br><span class="line">                <span class="comment">// 默认版本的 get 传入的 timed == false，会无限等待</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> s;</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// queued 初始为 false</span></span><br><span class="line">            <span class="comment">// 第二个循环会执行下面这个语句，把 q 入队。</span></span><br><span class="line">            <span class="comment">// （上一步成功的情况下）第三个循环才会开始执行再往下的休眠操作</span></span><br><span class="line">            <span class="comment">// 注意：每个循环都会检查 state</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                <span class="comment">// 这里我们先把队头 waiters 赋值给 q.next，赋值语句的返回值还是</span></span><br><span class="line">                <span class="comment">// waiters。执行这个语句的时候，我们期待 waiter 的当前值是 waiters</span></span><br><span class="line">                <span class="comment">// 并且将它设置为 q。</span></span><br><span class="line">                <span class="comment">// 因为可能有多个线程同时执行这个方法，这个语句还是有可能会执行</span></span><br><span class="line">                <span class="comment">// 失败的。如果失败，在接下来的循环里会重试</span></span><br><span class="line">                <span class="comment">// weakCompareAndSet 就姑且当做原子的 compareAndSet 吧</span></span><br><span class="line">                queued = WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> parkNanos;</span><br><span class="line">                <span class="keyword">if</span> (startTime == <span class="number">0L</span>) &#123; <span class="comment">// first time</span></span><br><span class="line">                    startTime = System.nanoTime();</span><br><span class="line">                    <span class="keyword">if</span> (startTime == <span class="number">0L</span>)</span><br><span class="line">                        startTime = <span class="number">1L</span>;</span><br><span class="line">                    parkNanos = nanos;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class="line">                    <span class="keyword">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class="line">                        removeWaiter(q);</span><br><span class="line">                        <span class="keyword">return</span> state;</span><br><span class="line">                    &#125;</span><br><span class="line">                    parkNanos = nanos - elapsed;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// nanoTime may be slow; recheck before parking</span></span><br><span class="line">                <span class="keyword">if</span> (state &lt; COMPLETING)</span><br><span class="line">                    <span class="comment">// 把线程投入休眠</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, parkNanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们继续看 <code>removeWaiter</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to unlink a timed-out or interrupted wait node to avoid</span></span><br><span class="line"><span class="comment"> * accumulating garbage.  Internal nodes are simply unspliced</span></span><br><span class="line"><span class="comment"> * without CAS since it is harmless if they are traversed anyway</span></span><br><span class="line"><span class="comment"> * by releasers.  To avoid effects of unsplicing from already</span></span><br><span class="line"><span class="comment"> * removed nodes, the list is retraversed in case of an apparent</span></span><br><span class="line"><span class="comment"> * race.  This is slow when there are a lot of nodes, but we don't</span></span><br><span class="line"><span class="comment"> * expect lists to be long enough to outweigh higher-overhead</span></span><br><span class="line"><span class="comment"> * schemes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 为了能够重新开始整个循环，包裹了一层 for 循环</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">            <span class="comment">// 遍历 waiters</span></span><br><span class="line">            <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="comment">// 下面两种情况对应 q.thread == null，也就是说，q 是待删除的节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// next 字段是 volatile，所以这里可以直接赋值。把 prev.next</span></span><br><span class="line">                    <span class="comment">// 指向 s （q.next）后就删除了 q。</span></span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                        <span class="comment">// 很倒霉的，prev 也要被删除（或已经被删除）</span></span><br><span class="line">                        <span class="comment">// 这里有三种可能：</span></span><br><span class="line">                        <span class="comment">// 1. prev.node 刚被设置为 null，但这个节点还在列表里，</span></span><br><span class="line">                        <span class="comment">//    prev.next = s 成功把 q 从列表里删除</span></span><br><span class="line">                        <span class="comment">// 2. 节点已经被删除</span></span><br><span class="line">                        <span class="comment">//    2.1 prev 是头节点（这将会执行下面那个else if 子句），</span></span><br><span class="line">                        <span class="comment">//        q 被设置为队头，q.next 仍旧指向 s；</span></span><br><span class="line">                        <span class="comment">//    2.2 prev 不是头结点，prev.prev.next 指向了 q；</span></span><br><span class="line">                        <span class="comment">//    这两种情况下，q 还留在列表里</span></span><br><span class="line">                        <span class="comment">// 所有这3种情况下，数据结构都是正常的。如果 q 还在列表里，</span></span><br><span class="line">                        <span class="comment">// 重新开始循环后总会删除它。如果已经被删除，遍历完列表后</span></span><br><span class="line">                        <span class="comment">// 也会退出。</span></span><br><span class="line">                        <span class="comment">// q 已经被删除的情况下，即使下个循环里我们把别人要删除的</span></span><br><span class="line">                        <span class="comment">// 节点给删除了也没关系。</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// q 在队头，所要把 waiters 设置为 s</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!WAITERS.compareAndSet(<span class="keyword">this</span>, q, s))</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你觉得 <code>removeWaiter</code> 难以理解，建议多看几遍（我自己也是研究了很久），使用原子操作来实现并发访问是会带来比较大的复杂度的。</p><p>最后，我们来看个简单的 <code>finishCompletion</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 把 waiters 设置为 null 后相当于取出所有的 waiter</span></span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 遍历 waiters</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 唤醒线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>FutureTask</code> 到这里我们就看完了。虽然代码量不多，但还是比预料中的复杂。除了上面代码里明确使用的 volatile 和原子操作，<code>FutureTask</code> 对 <code>state</code> 的定义也是很讲究的。通过增序定义 state 常量，在某些情况下我们可以直接通过比较常量值来判断状态是否处于某些状态集。比方说，是否被中断使用的是 <code>state &gt;= INTERRUPTING</code>；如果不这么做，我们就需要 <code>state == INTERRUPTING || state == INTERRUPTED</code>，毫无疑问，前者会执行得更快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是 JDK 源码分析的第一篇，主要关注 &lt;code&gt;FutureTask&lt;/code&gt; 的实现。我们所分析的源码使用的是 Java10，因此也假设了读者了解 &lt;code&gt;VarHandle&lt;/code&gt;（Java9 新增的 API），不了解的读者可以看我翻译的&lt;a href=&quot;https://jekton.github.io/2018/07/22/java-translation-jep-193-Variable-Handles/&quot;&gt;JEP 193&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jekton.github.io/categories/Java/"/>
    
    
      <category term="JDK" scheme="https://jekton.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>翻译 - JEP 193：Variable Handles</title>
    <link href="https://jekton.github.io/2018/07/22/java-translation-jep-193-Variable-Handles/"/>
    <id>https://jekton.github.io/2018/07/22/java-translation-jep-193-Variable-Handles/</id>
    <published>2018-07-22T05:10:24.000Z</published>
    <updated>2018-08-18T12:47:22.691Z</updated>
    
    <content type="html"><![CDATA[<p>Author: Doug Lea<br>Owner: Paul Sandoz<br>Type: Feature<br>Scope: SE<br>Status: Closed/Delivered<br>Release: 9<br>Component: core-libs/java.lang<br>Discussion: core dash libs dash dev at openjdk dot java dot net<br>Effort: M<br>Duration: L<br>Relates to <a href="http://openjdk.java.net/jeps/266" target="_blank" rel="noopener">JEP 266: More Concurrency Updates</a><br>Reviewed by: Dave Dice, Paul Sandoz<br>Endorsed by: Brian Goetz<br>Created: 2014/01/06 20:00<br>Updated: 2017/08/17 16:45<br>Issue: <a href="https://bugs.openjdk.java.net/browse/JDK-8046183" target="_blank" rel="noopener">8046183</a></p><blockquote><p>原文地址：<a href="http://openjdk.java.net/jeps/193" target="_blank" rel="noopener">JEP 193: Variable Handles</a>，JEP 表示 JDK Enhancement Proposal</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>定义一个用来操作对象的字段、数组元素的跟 <code>java.util.concurrent.atomic</code> 和 <code>sun.misc.Unsafe</code> 等价的标准工具，它提供了一个标准的栅栏操作（fence operation）工具集用于精细地控制内存排序和一个标准的可达性栅栏操作（reachability-fence operation）来保证一个被引用的对象是强可达的（strongly reachable）。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>下面是一些必须达到的目标：</p><ul><li>安全性。它不能使 JVM 处于一个不一致的状态。例如，对象的某个字段只能用一个能够转换成对应类型的（castable to the field type）值来更新，一个数组的元素只有当下标处于正常范围内才能够被访问。</li><li>一致性（Integrity）。访问对象的字段遵循跟 <code>getfield</code>、<code>putfield</code> 这两个指令一样的访问权限控制，并且 <code>final</code> 域不能被更新。（<code>MethodHandles</code> 在读写成员变量时同样遵守这里所说的安全和一致性规则）</li><li>性能。它所提供的性能必须跟 <code>sun.misc.Unsafe</code> 差不多（特别地，除了某些无法折叠的安全检查，生成的汇编代码应该几乎完全相同。</li><li>可用性。它的 API 必须必 <code>sun.misc.Unsafe</code> 更好。</li></ul><p>我们希望它的 API 能够比 <code>java.util.concurrent.atomic</code> 更好，但这不是必须的。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>随着 Java 并发、并行编程的发展，程序员们对于不能对类的成员执行原子操作或对操作进行排序感到越来越失望；比方说，原子地递增一个用于计数的成员变量。到目前为止，唯一能够实现这一目标的方法就是使用一个独立的 <code>AtomicInteger</code>（不仅增加了内存，还因为这个额外的间接性引入了其他并发问题）；或者，在某些情况下，使用一个原子的 <code>FieldUpdaters</code> （通常带来更多的性能损耗（overhead））；亦或者，使用不安全的用于 JVM 的基础设施（JVM intrinsics）<code>sun.misc.Unsafe</code>（它经常是不可移植且不可用的）。</p><p>如果没有这个 JEP，随着对 Java 内存模型的修改，这些问题会因原子 API 扩充对访问一致性（access-consistency）（对应于 C++11 的内存模型）的支持而变得更糟糕。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一个变量句柄（variable handle）是一个变量的带类型的引用，它支持使用一系列访问模型对变量进行读写。支持的变量类型包括成员变量、静态成员变量和数组元素。另一些正在考虑是否支持的类型有数组视图（array views），它把一个 <code>byte</code> 或 <code>char</code> 数组当成 <code>long</code> 数组；就像 <code>ByteBuffer</code> 用来描述一个堆外内存（off-heap regions）一样。</p><p>变量句柄需要我们增强标准库、JVM，增加编译器的支持。此外，它还需要对 Java 语言规范和 Java 虚拟机规范进行小的修改。一个小小的语言增强，用于编译时的类型检查并且补足现有的语法，也是需要考虑的。</p><p>规范应该通过一种自然的方式来扩展额外的类基本类型（primitive-like）数值类型和类数组（array-like）类型，如果它们曾经被添加到 Java 里。这不是一个通用的用来访问、更新多个变量的事务机制。其他可选的用来表述、实现这些构件的方案可能会在这篇 JEP 里探讨，也可能是在更进一步的 JEP 里。</p><p>变量句柄使用一个抽象类 <code>java.lang.invoke.VarHandle</code> 来表示，每个变量的访问模式用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html#sigpoly" target="_blank" rel="noopener">多态签名（signature-polymorphic）</a>来表示。</p><blockquote><p>小罗路过：关于多态签名，在后面看了 <code>VarHandle</code> 的方法后读者就会明白的。</p></blockquote><p>访问模式（access mode）代表一个最小可用集合，它被设计成跟 C/C++ 11 的原子变量相兼容而不是依赖一个修改过的 Java 内存模型。如果需要的话，也可以添加额外的访问模式。某些变量可能不支持特定的访问模式，如果在对应的 <code>VarHandle</code> 上执行这些操作，将会抛出 <code>UnsupportedOperationException</code> 异常。</p><p>访问模式可以归纳为以下几类：</p><ol><li>读模式，例如用带 <code>volatile</code> 内存排序效果（volatile memory ordering effects）的语义去读一个变量；</li><li>写模式，比如使用 release memory ordering effects 去更新变量；</li><li>原子更新模式，例如使用带 volatile memory ordering effects 的 compare-and-set 去更新变量；</li><li>数值原子更新模式，例如使用带 plain memory order effects 的写和用于读的 acquire memory order effects 来执行 get-and-add；</li><li>按位原子更新模式，例如使用 release memory order effects 的写和 plain memory order effects 的读来执行 get-and-bitwise-and。</li></ol><p>最后三个通常也称为 read-modify-write 模式。</p><p>访问模式方法的签名多态特性让变量句柄可以仅使用一个抽象类而支持各种各样的类型。这可以防止类型的爆炸。更进一步，尽管访问模式方法签名里的参数定义为 <code>Object</code> 数组，签名多态的特性仍然可以防止对基本类型的自动装箱操作并且不会将参数打包成数组。这使它们有了可预测的行为从而在 HotSpot 翻译器的运行时和 C1/C2 编译器上有更好的性能。</p><blockquote><p>小罗路过：访问模式方法原文为 access mode method，指的是 <code>VarHandle</code> 的成员方法。</p></blockquote><p>用于生成 <code>VarHandle</code> 的方法跟生成 <code>MethodHandle</code> 实例的方法放在了同一个地方，它们生成相等或类似的变量类型。</p><p>用于成员变量和静态变量的 <code>VarHandle</code> 使用 <code>java.lang.invoke.MethodHandles.Lookup</code> 下的方法生成，它通过查找接收类的字段来实例化对象。举个例子，通过查找来生成接收类 <code>Foo</code> 的 <code>int</code> 型成员 <code>i</code> 的 <code>VarHandle</code> 可以像下面这样来做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> VarHandle VH_FOO_FIELD_I;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            VH_FOO_FIELD_I = MethodHandles.lookup().</span><br><span class="line">                in(Foo.class).</span><br><span class="line">                findVarHandle(Foo.class, <span class="string">"i"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个查找过程在生成并返回 <code>VarHandle</code> 前，会检查一系列的访问控制权限。对 <code>MethodHandle</code> 来说也一样，会看提供了读、写的 <code>MethodHandle</code> （参考 <code>MethodHandles.Lookup</code> 的 <code>find{,Static}{Getter,Setter}</code> 方法）的针对特定字段是否有对应的权限。</p><blockquote><p>小罗路过：举个栗子。下面把 <code>Foo.i</code> 改成了 <code>private</code>，所以 <code>VH_FOO_FIELD_I</code> 可以成功生成，而 <code>Bar.MH_FOO_FIELD_I</code> lookup 的时候会抛异常。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> VarHandle VH_FOO_FIELD_I;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            VH_FOO_FIELD_I = MethodHandles.lookup().</span><br><span class="line">                    in(Foo.class).</span><br><span class="line">                    findVarHandle(Foo.class, <span class="string">"i"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> MethodHandle MH_FOO_FIELD_I;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MH_FOO_FIELD_I = MethodHandles.lookup().</span><br><span class="line">                    in(Foo.class).</span><br><span class="line">                    findSetter(Foo.class, <span class="string">"i"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面这些条件下，访问模式方法会抛出 <code>UnsupportedOperationException</code> 异常：</p><ul><li>对一个 <code>final</code> 变量调用写访问模式方法</li><li>对引用类型或非数值类型（如 <code>boolean</code>）调用数值访问模式方法（<code>getAndAdd</code>，<code>addAndGet</code>）</li><li>对引用类型或 <code>float/double</code> 执行按位访问模式方法（后者以后可能会移除）</li></ul><p>一个字段不需要声明为 <code>volatile</code> 也可以使用 <code>VarHandle</code> 来进行 volatile access。实际上，如果携带了 <code>volatile</code> 修饰符，它会被忽略掉。这个行为跟 <code>java.util.concurrent.atomic.Atomic{Int, Long, Reference}FieldUpdater</code> 是不一样的，使用后者时对应的字段需要声明为 <code>volatile</code>。当我们在某些时候需要 volatile 语义而其他时候不需要时，FilldUpdater 就显得过于受限了。</p><p>生成用于数组的 <code>VarHandle</code> 位于 <code>java.lang.invoke.MethodHandles</code> （参考 <code>MethodHandles</code> 的 <code>arrayElement{Getter, Setter}</code> 方法）。例如，用于 <code>int</code> 数组的 <code>VarHandle</code> 可以这样生成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VarHandle intArrayHandle = MethodHandles.arrayElementVarHandle(<span class="keyword">int</span>[].class);</span><br></pre></td></tr></table></figure></p><p>在下列情况下，访问模式方法会抛出 <code>UnsupportedOperationException</code> 异常：</p><ul><li>使用数值方法模式方法去修改引用类型或非数值类型（如 <code>boolean</code>）数组的元素</li><li>对引用类型或 <code>float/double</code> 执行按位访问模式方法（后者以后可能会移除）</li></ul><p>所有的变量类型的基本类型（primitive types）和引用类型都是被支持的，只要它们的变量种类（variable kinds）是成员变量、静态变量或数组。其他变量种类可能会部分或全部支持。</p><blockquote><p>小罗路过：这里的变量种类指的是局部变量，成员变量这一些</p></blockquote><p>生成用于 array-view-based 的 <code>VarHandle</code> 的方法位于 <code>java.lang.invoke.MethodHandles</code>。举个例子，下面生成的 <code>VarHandle</code> 把一个 <code>byte</code> 数组看成一个非对其（unaligned）的 <code>long</code> 数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VarHandle longArrayViewHandle = MethodHandles.byteArrayViewVarHandle(</span><br><span class="line">        <span class="keyword">long</span>[].class, java.nio.ByteOrder.BIG_ENDIAN);</span><br></pre></td></tr></table></figure></p><p>尽管同样的效果可以通过 <code>java.nio.ByteBuffer</code> 得到，但这种方式需要一个 <code>ByteBuffer</code> 实例用于包裹 <code>byte</code> 数组。由于这导致了脆弱的逃逸分析，它并不总是能够得到可接受的性能并且每次访问都需要通过一个 <code>ByteBuffer</code> 实例。在非对其访问的情况下，除了普通（plain）的方法模式方法，都会抛出 <code>IllegalStateException</code> 异常。对齐访问的情况下，取决于变量的类型，一些 volatile 访问模式是允许的。这些 <code>VarHandle</code> 可以用来向量化（vectorize）数组存取操作。</p><p>访问模式方法的参数的数量、参数的类型、返回值的类型取决于变量种类（viriable kind）、变量类型和访问模式的特性。<code>VarHandle</code> 的生成方法（我们前面提到的那些）会在文档里说明必要条件。例如，对前面我们所生成的 <code>VH_FOO_FIELD_I</code> 调用 <code>compareAndSet</code> 需要 3 个参数，一个 Foo 实例作为接收者，一个 <code>int</code> 作为 expected value 和另一个作为 actual value：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo f = ...</span><br><span class="line"><span class="keyword">boolean</span> r = VH_FOO_FIELD_I.compareAndSet(f, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>相对的，<code>getAndSet</code> 只需要两个参数，一个 Foo 实例作为接收者，一个 <code>int</code> 用于设置值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> o = (<span class="keyword">int</span>) VH_FOO_FIELD_I.getAndSet(f, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>访问数组元素的时候需要一个额外的 <code>int</code> 型的参数，它位于接收者和其他参数之间（如果有的话），这个参数对应于需要操作的元素的下标。</p><p>为了可预测的行为和运行时性能，<code>VarHandle</code> 实例必须放在一个 <code>static final</code> 的字段里（就跟 <code>Atomic{Int, Long, Reference}FieldUpdater</code> 所要求的那样）。这可以保证在调用访问模式方法的时候会发生常量折叠，例如去掉方法签名的检查和/或参数的类型转换检查。</p><blockquote><p>注：将来的 HotSpot 增强可能会支持没有使用 <code>static final</code> 持有的 <code>VarHandle</code> 和 <code>MethodHandle</code>。</p></blockquote><p>一个 <code>MethodHandle</code> 可以使用 <code>VarHandle</code> 的访问模式方法通过 <code>MethodHandles.Lookup.findVirtual</code> 来生成。例如，下面给一个特定的变量类型和变量种类生成一个 <code>compareAndSet</code> 访问模式方法对应的 <code>MethodHandle</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo f = ...</span><br><span class="line">MethodHandle mhToVhCompareAndSet = MethodHandles.publicLookup().findVirtual(</span><br><span class="line">        VarHandle.class,</span><br><span class="line">        <span class="string">"compareAndSet"</span>,</span><br><span class="line">        MethodType.methodType(<span class="keyword">boolean</span>.class, Foo.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class));</span><br></pre></td></tr></table></figure></p><p><code>MethodHandle</code> 可以用一个变量种类和类型都兼容的 <code>VarHandle</code> 实例作为第一个参数来调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> r = (<span class="keyword">boolean</span>) mhToVhCompareAndSet.invokeExact(VH_FOO_FIELD_I, f, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>或者，<code>mhToVhCompareAndSet</code> 可以绑定到一个 <code>VarHandle</code> 实例然后再调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MethodHandle mhToBoundVhCompareAndSet = mhToVhCompareAndSet</span><br><span class="line">        .bindTo(VH_FOO_FIELD_I);</span><br><span class="line"><span class="keyword">boolean</span> r = (<span class="keyword">boolean</span>) mhToBoundVhCompareAndSet.invokeExact(f, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>像这样的使用 <code>findVirtual</code> 进行的 <code>MethodHandle</code> 查找会使用一个 asType 转换来调整参数然后再返回结果。这个行为跟使用 <code>MethodHandles.invoker</code> 的类比物 <code>MethodHandles.varHandleInvoker</code> 来生成 <code>MethodHandle</code> 是一样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MethodHandle mhToVhCompareAndSet = MethodHandles.varHandleExactInvoker(</span><br><span class="line">        VarHandle.AccessMode.COMPARE_AND_SET,</span><br><span class="line">        MethodType.methodType(<span class="keyword">boolean</span>.class, Foo.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class));</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> r = (<span class="keyword">boolean</span>) mhToVhCompareAndSet.invokeExact(VH_FOO_FIELD_I, f, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>所以通过包装在一个类中， <code>VarHandle</code> 可以在（类型被擦除）或反射的情景下使用。比方说，用来替代 <code>java.util.concurrent.Atomic*FieldUpdater/Atomic*Array</code> 中对 <code>Unsafe</code> 的使用（尽管需要更进一步的工作，以保证这些 updater 对相应的字段用于足够的访问权限）。</p><p>对访问模式方法的调用的编译跟具有签名多态的 <code>MethodHandle.invokeExact</code> 和 <code>MethodHandle.invoke</code> 所遵守的规则是一样的。下面这些是对 Java 语言规范所附加的内容：</p><ol><li>生成对 <code>VarHandle</code> 的签名多态的访问模式方法的引用</li><li>允许签名多态方法返回不是 <code>Object</code> 类型的值，这意味着返回值类型不再是多态的（并且也因为可以在调用的地方声明一个强制类型转换）。这可以让写访问模式方法放回 <code>void</code>，<code>compareAndSet</code> 返回 <code>boolean</code> 变得更容易。</li></ol><p>如果对签名多态的方法的调用行为可以增强为自动识别返回值的类型会很好，但这不是必须的。</p><blockquote><p>注：使用像方法引用那样的语法来生成 <code>VarHandle</code> 和 <code>MethodHandle</code>，比方说 <code>VarHandle VH_FOO_FIELD_I = Foo::i</code>，它所需要的语法和运行时支持是可取的，但不会在这篇 JEP 里讨论。</p></blockquote><p>运行时对访问模式方法的调用跟使用 <code>MethodHandle.invokeExact</code> 和 <code>MethodHandle.invoke</code> 进行签名多态方法调用所遵循的规则是类似的。下面是对 Java 虚拟机规范所附加的要求：</p><ol><li>在 <code>VarHandle</code> 内引用签名多态的访问模式方法</li><li>定义对签名多态的访问模式方法进行 <code>invokevirtual</code> 时的行为。预期这种行为会通过一个从访问模式方法的调用到对应的 <code>MethodHandle</code> 之间的使用相同参数的转换来定义（参考前面对 <code>MethodHandles.Lookup.findVirtual</code> 的使用）。</li></ol><blockquote><p>小罗路过：这里第1条说我们可以拿到一个 access mode method（这些方法属于 <code>VarHandle</code>） 的 reference，所以自然就可以对这个 reference invokevirtual。通过使用类似 <code>MethodHandles.Lookup.findVirtual</code> 的机制生成 <code>MethodHandle</code> 后，就能够真正执行方法调用了（在这个意义上，我们可以认为这个 <code>MethodHandle</code> 实例对应着 <code>VarHandle</code> 的某一个 access mode method）。之所以这个转换是必须的，前面我们提到，对 <code>VarHandle</code> 的调用都会被折叠掉，所以也就不会有真正的方法存在。</p></blockquote><p><code>VarHandle</code> 对于所支持的变量类型、种类能够具有可靠的效率以达到目标性能要求是非常重要的。利用签名多态的方法可以避免自动装箱和数组的打包。（Java）实现必须：</p><ul><li>在包 <code>java.lang.invoke</code> 的内部，HotSpot 将类中的 <code>final</code> 字段认为是真正的 final，这使得 <code>VarHandle</code> 被 <code>static final</code> 域引用的时候可以进行常量折叠。</li><li>利用 JDK 内部的 <code>@Stable</code> 为那些仅改变一次的值进行常量折叠，利用 <code>@ForceInline</code> 来保证方法即使已经达到普通方法的 inline 上限也会被 inline</li><li>使用 <code>sun.misc.Unsafe</code> 实现底层增强的 volatile 访问</li></ul><p>一些 HotSpot 固有的支持（intrinsics）是必须的，部分罗列如下：</p><ul><li>对 <code>Class.cast</code> 的支持，它已经被添加了（参考<a href="https://bugs.openjdk.java.net/browse/JDK-8054492" target="_blank" rel="noopener">JDK-8054492</a>）。在虚拟机添加这个支持前，一个常量折叠的 <code>Class.cast</code> 还会遗留冗余的检查，这会导致不必要的性能损失。</li><li>当并发访问时，acquire-get 访问模式能够与 set-release 访问模式进行同步（参考 <code>sun.misc.Unsafe.putOrdered{Int, Long, Object}</code>）。</li><li>对数组范围检查<a href="https://bugs.openjdk.java.net/browse/JDK-8042997" target="_blank" rel="noopener">JDK-8042997</a>的原生支持。静态方法可以被添加到 <code>java.util.Arrays</code> 来做这个检查，它接受一个待调用的函数，然后在检查出错的情况下，返回一个异常或者一个出错消息，这个错误消息可以被用于包含在一个待抛出的异常中。像这样的原生支持可以使用无符号数进行更好地比较（毕竟，数组长度总是正的）并且更好地把范围检查提升到一个被展开（unrolled）了的循环的外面进行检查。</li></ul><p>此外，HotSpot 里更近一步的范围检查已经在 <a href="https://bugs.openjdk.java.net/browse/JDK-8073480" target="_blank" rel="noopener">JDK-8073480</a> 实现了（<a href="https://bugs.openjdk.java.net/browse/JDK-8003585" target="_blank" rel="noopener">JDK-8003585</a> 则用于强力去除 fork/join 框架、<code>HashMap</code> 和 <code>ConcurrentHashMap</code> 里的范围检查）。</p><p><code>VarHandle</code> 的实现必须保持对 <code>java.lang.invoke</code> 包里的其他类的最小依赖，以避免启动时间的增加和在静态初始化时产生循环依赖。比方说，如果 <code>VarHandle</code> 的某些实现使用 <code>ConcurrentHashMap</code>，而 <code>ConcurrentHashMap</code> 也被修改成使用了 <code>VarHandle</code>，此时必须保证没有引入循环依赖。另一个更微妙的循环是 <code>ThreadLocalRandom</code> 和他对 <code>AtomicInteger</code> 的使用。保证 HotSpot 的 C2 编译器编译时间不会因为对 <code>VarHandle</code> 的使用而过度增加也是很值得要的。</p><blockquote><p>小罗路过：<code>VarHandle</code> 是一个抽象类，这里 “<code>VarHandle</code> 的实现应该指的是它的子类”</p></blockquote><h2 id="内存栅栏（Memory-fences）"><a href="#内存栅栏（Memory-fences）" class="headerlink" title="内存栅栏（Memory fences）"></a>内存栅栏（Memory fences）</h2><blockquote><p>小罗路过：memory fences 跟所谓的 memory barrier 是同一个东西，memory barrier 现在大多翻译为内存屏障。</p></blockquote><p>屏障操作（fenced operations）作为 <code>VarHandle</code> 的静态方法来定义，是一个最小可用的精细控制内存顺序工具集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that loads and stores before the fence will not be</span></span><br><span class="line"><span class="comment"> * reordered with loads and stores after the fence.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span> Ignoring the many semantic differences from C and</span></span><br><span class="line"><span class="comment"> * C++, this method has memory ordering effects compatible with</span></span><br><span class="line"><span class="comment"> * atomic_thread_fence(memory_order_seq_cst)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that loads before the fence will not be reordered with</span></span><br><span class="line"><span class="comment"> * loads and stores after the fence.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span> Ignoring the many semantic differences from C and</span></span><br><span class="line"><span class="comment"> * C++, this method has memory ordering effects compatible with</span></span><br><span class="line"><span class="comment"> * atomic_thread_fence(memory_order_acquire)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acquireFence</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that loads and stores before the fence will not be</span></span><br><span class="line"><span class="comment"> * reordered with stores after the fence.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span> Ignoring the many semantic differences from C and</span></span><br><span class="line"><span class="comment"> * C++, this method has memory ordering effects compatible with</span></span><br><span class="line"><span class="comment"> * atomic_thread_fence(memory_order_release)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseFence</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that loads before the fence will not be reordered with</span></span><br><span class="line"><span class="comment"> * loads after the fence.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLoadFence</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that stores before the fence will not be reordered with</span></span><br><span class="line"><span class="comment"> * stores after the fence.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">storeStoreFence</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>一个 full fense 比 acquire fence 要更强一些（在对排序的保证这一意义上），后者又比 load load fence 更强。类似的，full fence 比 release fence 更强，后者比 store store fence 又更强。</p><h2 id="可访问性栅栏（Reachability-fence）"><a href="#可访问性栅栏（Reachability-fence）" class="headerlink" title="可访问性栅栏（Reachability fence）"></a>可访问性栅栏（Reachability fence）</h2><p>可访问行栅栏作为静态方法定义在 <code>java.lang.ref.Reference</code> 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">ref</span>.<span class="title">Reference</span> </span>&#123;</span><br><span class="line">   <span class="comment">// add:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Ensures that the object referenced by the given reference</span></span><br><span class="line"><span class="comment">    * remains &lt;em&gt;strongly reachable&lt;/em&gt; (as defined in the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">    * java.lang.ref&#125; package documentation), regardless of any prior</span></span><br><span class="line"><span class="comment">    * actions of the program that might otherwise cause the object to</span></span><br><span class="line"><span class="comment">    * become unreachable; thus, the referenced object is not</span></span><br><span class="line"><span class="comment">    * reclaimable by garbage collection at least until after the</span></span><br><span class="line"><span class="comment">    * invocation of this method. Invocation of this method does not</span></span><br><span class="line"><span class="comment">    * itself initiate garbage collection or finalization.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ref the reference. If null, this method has no effect.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reachabilityFence</span><span class="params">(Object ref)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考 <a href="https://bugs.openjdk.java.net/browse/JDK-8133348" target="_blank" rel="noopener">JDK-8133348</a>。</p><p>现在已经太迟了，无法添加一个类似于 <code>@Finalized</code> 的东西，用于修饰一个方法，使得在编译时或运行时对应的方法体看起来像下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    &lt;method body&gt;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Reference.reachabilityFence(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以预感，类似的机制将会在某些编译期处理器得到支持。</p><h2 id="其他选择"><a href="#其他选择" class="headerlink" title="其他选择"></a>其他选择</h2><p>引入一种新形式的值类型（value type）用于支持 volatile 操作。然而，这会导致跟其他类型的性质不一致，程序员也需要付出更多努力来学习使用它。也考虑过依靠 <code>java.util.concurrent.atomic FieldUpdater</code>s 来完成这一目标，但它们的动态损耗（dynamic overhead）和使用限制使得这一选项并不适用的。</p><p>一些其他的选择，包括那些基于字段引用（field references）的方法在这些年都有人提出并讨论过，但最终因为语法上不可行、效率或者可用性问题消失了。</p><p>语法增强在这个 JEP 之前的版本考虑过，但被认为太过于奇异（magical）了。它重载了 <code>volatile</code> 关键字的语义并扩展到飘浮接口（译者注：with the overloaded use of the volatile keyword scoping to floating interfaces），一个用于引用类型而另一个用于所有支持的基本类型（primitive type）。</p><p>上一个版本的 JEP 也考虑过从 <code>VarHandle</code> 扩展出泛型类型（generic type），但这个带有多态签名的泛型加上对自动装箱类型的特殊对待，被认为是不成熟的。因为将来的 Java 版本会带有值类型（value type）、允许基于基本数据类型的泛型（参考<a href="http://openjdk.java.net/jeps/218" target="_blank" rel="noopener">JEP-218</a>）和一个增强的数组 <a href="http://cr.openjdk.java.net/~jrose/pres/201207-Arrays-2.pdf" target="_blank" rel="noopener">Arrays 2.0</a>。</p><p>基于特定实现的 <code>invokedynamic</code> 这一方法在这个 JEP 的之前版本也考虑过。这需要仔细地让带或不带 <code>invokedynamic</code> 的编译后的方法调用在语义上保持一致。此外，一些使用了 <code>invokedynamic</code> 的核心类，如 <code>ConcurrentHashMap</code> 将会导致循环依赖。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>压力测试将会使用 <a href="http://openjdk.java.net/projects/code-tools/jcstress/" target="_blank" rel="noopener">jcstress</a> 工具来开发。</p><h2 id="风险和假设"><a href="#风险和假设" class="headerlink" title="风险和假设"></a>风险和假设</h2><p>有个 <code>VarHandle</code> 的原型实现已经使用 nano-benchmarks 和 fork/join benchmarks 进行了性能测试，其中 fork/join 使用了 <code>sun.misc.Unsafe</code> 的地方都替换成了 <code>VarHandle</code>。目前为止还没有发现明显的性能损失，HotSpot 上的问题也都不太麻烦（折叠掉强制类型转换检查和改进数组范围检查）。我们对这个方法的可行性是有信心的。尽管如此，我们也启动能够进行更多的实验，来保证在性能要求非常严格的环境下有可靠的编译技术，因为这种情况会更需要 <code>VarHandle</code>。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>那些在包 <code>java.util.concurrent</code> 里的类（包括 JDK 中其他一下地方）会从 <code>sun.misc.Unsafe</code> 迁移到 <code>VarHandle</code>。</p><p>这篇 JEP 不依赖于 <a href="http://openjdk.java.net/jeps/188" target="_blank" rel="noopener">JEP 188: Java Memory Model Update</a>。</p>]]></content>
    
    <summary type="html">
    
      定义一个用来操作对象的字段、数组元素的跟 `&quot;java.util.concurrent.atomic&quot;` 和 `&quot;sun.misc.Unsafe&quot;` 等价的标准工具，它提供了一个标准的栅栏操作（fence operation）集用于精细地控制内存排序和一个标准的可达性栅栏操作（reachability-fence operation）来保证一个被引用的对象是强可达的（strongly reachable）。
    
    </summary>
    
      <category term="Java" scheme="https://jekton.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jekton.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>个人记录帖 - 编译 OpenJDK 10</title>
    <link href="https://jekton.github.io/2018/07/22/openjdk-build/"/>
    <id>https://jekton.github.io/2018/07/22/openjdk-build/</id>
    <published>2018-07-22T01:32:41.000Z</published>
    <updated>2018-08-18T12:47:22.693Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章纯粹是记录个人编译 openjdk10 的过程，不会很详细地说明各个步奏。这里就算是给自己立 flag 吧。</p><a id="more"></a><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone git@github.com:unofficial-openjdk/openjdk.git</span><br><span class="line"><span class="meta">#</span> 写作时 openjdk10 最新的 tag</span><br><span class="line"><span class="meta">$</span> git checkout -b jdk-10+46 jdk-10+46</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bash ./configure --enable-debug --with-target-bits=64 --with-jobs=8 --disable-warnings-as-errors --with-jvm-variants=server</span><br><span class="line"><span class="meta">$</span> make</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>为了方便以后使用，在 <code>.zshrc</code> 加入：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function openjdk_env &#123;</span><br><span class="line">    export JAVA_HOME="$HOME/dev/java/openjdk10/build/macosx-x86_64-normal-server-fastdebug/jdk"</span><br><span class="line">    export PATH="$JAVA_HOME/bin"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后还是回到 terminal：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> source ~/.zshrc</span><br><span class="line"><span class="meta">$</span> openjdk_env </span><br><span class="line"><span class="meta">$</span> java -version</span><br><span class="line">openjdk version "10-internal" 2018-03-20</span><br><span class="line">OpenJDK Runtime Environment (fastdebug build 10-internal+0-adhoc.jekton.openjdk10)</span><br><span class="line">OpenJDK 64-Bit Server VM (fastdebug build 10-internal+0-adhoc.jekton.openjdk10, mixed mode)</span><br></pre></td></tr></table></figure></p><h3 id="使用-idea-阅读-JDK"><a href="#使用-idea-阅读-JDK" class="headerlink" title="使用 idea 阅读 JDK"></a>使用 idea 阅读 JDK</h3><p>执行源码下的 <code>bin/idea.sh</code>，它会在源码根目录生成 <code>.idea</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 假定当前在源码根目录</span><br><span class="line"><span class="meta">$</span> cd bin</span><br><span class="line"><span class="meta">$</span> bash idea.sh</span><br></pre></td></tr></table></figure><p>这个过程可能会提示你安装 <code>ant</code>。</p><p>生成后，直接用 idea 打开就可以了，JDK 源码在 <code>src/java.base</code> 目录下。</p><h3 id="使用-VS-Code-阅读-hotspot-源码"><a href="#使用-VS-Code-阅读-hotspot-源码" class="headerlink" title="使用 VS Code 阅读 hotspot 源码"></a>使用 VS Code 阅读 hotspot 源码</h3><p>由于 idea 的 CLion 是付费的，所以这部分选用 VS Code 来阅读。没什么好说的，就不写了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章纯粹是记录个人编译 openjdk10 的过程，不会很详细地说明各个步奏。这里就算是给自己立 flag 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://jekton.github.io/categories/JVM/"/>
    
    
      <category term="openjdk" scheme="https://jekton.github.io/tags/openjdk/"/>
    
  </entry>
  
  <entry>
    <title>Android arch components 源码分析（3）—— LiveData</title>
    <link href="https://jekton.github.io/2018/07/14/android-arch-LiveData/"/>
    <id>https://jekton.github.io/2018/07/14/android-arch-LiveData/</id>
    <published>2018-07-14T07:42:06.000Z</published>
    <updated>2018-08-18T12:47:22.677Z</updated>
    
    <content type="html"><![CDATA[<p>本篇我们来看看 Android 架构组件中的 <code>LiveData</code> 。跟 <code>ViewModel</code> 相比，<code>LiveData</code> 具有生命周期感知能力，也就是说，他把 <code>ViewModel</code> 和 lifecycle 结合了起来。当应用的数据有更新时，一般我们仅希望应用对用户可见时才更新 UI；更进一步，如果应用不可见，我们甚至可以停止数据的更新。这就是所谓的“感知应用的生命周期”。</p><p>这里我们主要关注 <code>LiveData</code> 的实现，用法可以参考 Google 的<a href="https://developer.android.google.cn/topic/libraries/architecture/" target="_blank" rel="noopener">教程</a>。</p><h2 id="添加-Observer"><a href="#添加-Observer" class="headerlink" title="添加 Observer"></a>添加 Observer</h2><p>使用 <code>LiveData</code> 时，首先要做的，就是添加一个 <code>Observer&lt;T&gt;</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the data is changed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t  The new data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(@Nullable T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，他是 abstract class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有 onStart 后，对数据的修改才会触发 observer.onChanged()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无论何时，只要数据发生改变，就会触发 observer.onChanged()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observeForever</span><span class="params">(@NonNull Observer&lt;T&gt; observer)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于 <code>LiveData</code> 是一个 <code>abstract class</code>，我们不能直接生成他的实例。对于数据的<em>拥有者</em>，可以使用 <code>MutableLiveData</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableLiveData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LiveData.postValue() 是一个 protected 方法</span></span><br><span class="line">        <span class="keyword">super</span>.postValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LiveData.setValue() 是一个 protected 方法</span></span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>所谓数据的拥有者。举个例子，你使用的是 MVP 模式，那么数据就属于 Model 层，另外两层不应该修改数据。</p></blockquote><p>通过让这两个 setter 方法成为 <code>protected</code>，只要我们给客户返回的是 <code>LiveData</code>，就不用担心数据会被客户意外修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类的内部持有的是 MutableLiveData，所以我们可以调用 postValue/setValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Foo&gt; mYourData = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是 LiveData，LiveData 的 public 方法中并没有 postValue/setValue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;Foo&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mYourData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>活用 <code>public</code>, <code>protected</code>, <code>private</code>, <code>default access</code> 和 <code>final</code> 可以让我们的设计意图更加清晰。</p></blockquote><p>现在回到我们的 <code>observe()</code> 方法，<code>observeForever</code> 的实现跟 <code>observe</code> 是类似的，我们就不看了，这里只看 <code>observe()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// activity 已经 destroy，也就没必要添加 observer 了</span></span><br><span class="line">        <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">            <span class="comment">// 同一个 observer，只有对应的 lifecycleOwner 不一样，才可以重新添加</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add the same observer"</span></span><br><span class="line">                    + <span class="string">" with different lifecycles"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这种方式添加的 observer，只有 activity 可见时才会收到数据更新的通知，</span></span><br><span class="line">        <span class="comment">// 为了知道什么时候 activity 是可见的，这里需要注册到 Lifecycle。</span></span><br><span class="line">        <span class="comment">// 也是因为这个，observe() 比 observeForever() 多了一个参数 lifecycleOwner</span></span><br><span class="line">        owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们继续看 <code>LifecycleBoundObserver</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空实现，如果在 LiveData 变为 inactive 状态后想停止更新数据，可以</span></span><br><span class="line">    <span class="comment">// override 这两个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWrapper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;T&gt; mObserver;</span><br><span class="line">        <span class="keyword">boolean</span> mActive;</span><br><span class="line">        <span class="keyword">int</span> mLastVersion = START_VERSION;</span><br><span class="line"></span><br><span class="line">        ObserverWrapper(Observer&lt;T&gt; observer) &#123;</span><br><span class="line">            mObserver = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 observer 处于 active 状态，则返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// immediately set active state, so we'd never dispatch anything to inactive</span></span><br><span class="line">            <span class="comment">// owner</span></span><br><span class="line">            mActive = newActive;</span><br><span class="line">            <span class="comment">// LiveData.this.mActiveCount 表示处于 active 状态的 observer 的数量</span></span><br><span class="line">            <span class="comment">// 当 mActiveCount 大于 0 时，`LiveData` 处于 active 状态</span></span><br><span class="line">            <span class="comment">// 注意区分 observer 的 active 状态和 LiveData 的 active 状态</span></span><br><span class="line">            <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">            LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">                <span class="comment">// inactive -&gt; active</span></span><br><span class="line">                onActive();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里用 else if 比较好，因为只有一个会执行。else if 更易读</span></span><br><span class="line">            <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">                <span class="comment">// mActiveCount 在我们修改前等于 1，也就是说，`LiveData` 从 active</span></span><br><span class="line">                <span class="comment">// 状态变到了 inactive</span></span><br><span class="line">                onInactive();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">                <span class="comment">// observer 从 inactive 到 active，此时客户拿到的数据可能不是最新的，这里需要 dispatch 一下</span></span><br><span class="line">                <span class="comment">// 关于他的实现，我们下一节再看</span></span><br><span class="line">                dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@NonNull</span> <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">        LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">super</span>(observer);</span><br><span class="line">            mOwner = owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// onStart 到 onStop 之间则认为是 active 状态</span></span><br><span class="line">            <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个是 lifecycle 的回调函数</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">                removeObserver(mObserver);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 刚刚生成 LifecycleBoundObserver 的实例时，mActive == false，注册到</span></span><br><span class="line">            <span class="comment">// Lifecycle 后，Lifecycle 会同步状态给我们（也就是回调本函数）。</span></span><br><span class="line">            <span class="comment">// 不熟悉 lifecycle 的读者，可以看</span></span><br><span class="line">            <span class="comment">// https://jekton.github.io/2018/07/06/android-arch-lifecycle/</span></span><br><span class="line">            activeStateChanged(shouldBeActive());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，observer 的注册我们就看完了。下面我们看看如何发布(publish)数据给 <code>LiveData</code>。</p><h2 id="发布修改"><a href="#发布修改" class="headerlink" title="发布修改"></a>发布修改</h2><p>要修改 <code>LiveData</code>，有两种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步修改数据</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会用 Handler post 一个 runnable，然后在 runnable 里面 setValue</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>setValue</code> 比较简单，我们先看 <code>setValue</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">"setValue"</span>);</span><br><span class="line">        <span class="comment">// 每次更新 value，都会使 mVersion + 1</span></span><br><span class="line">        <span class="comment">// ObserverWrapper 也有一个字段，叫 mLastVersion</span></span><br><span class="line">        <span class="comment">// 通过比较这两个字段，可以避免重复通知客户（具体在后面会看到）</span></span><br><span class="line">        mVersion++;</span><br><span class="line">        mData = value;</span><br><span class="line">        dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 initiator == null，表示要通知所有的 observer</span></span><br><span class="line">    <span class="comment">// 不等于 null 则只通知 initiator</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">            <span class="comment">// 在 observer 的回调里面又触发了数据的修改</span></span><br><span class="line">            <span class="comment">// 设置 mDispatchInvalidated 为 true 后，可以让下面的循环知道</span></span><br><span class="line">            <span class="comment">// 数据被修改了，从而开始一轮新的迭代。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 比方说，dispatchingValue -&gt; observer.onChanged -&gt; setValue</span></span><br><span class="line">            <span class="comment">//            -&gt; dispatchingValue</span></span><br><span class="line">            <span class="comment">// 这里 return 的是后面那个 dispatchingValue，然后在第一个</span></span><br><span class="line">            <span class="comment">// dispatchingValue 会重新遍历所有的 observer，并调用他们的</span></span><br><span class="line">            <span class="comment">// onChanged。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 如果想避免这种情况，可以在回调里面使用 postValue 来更新数据</span></span><br><span class="line">            mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用 observer.onChanged()</span></span><br><span class="line">                considerNotify(initiator);</span><br><span class="line">                initiator = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                    considerNotify(iterator.next().getValue());</span><br><span class="line">                    <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                        <span class="comment">// 某个客户在回调里面更新了数据，break 后，这个 for 循环会</span></span><br><span class="line">                        <span class="comment">// 重新开始</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 当某个客户在回调里面更新了数据，mDispatchInvalidated == true</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">        mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看过我那篇 lifecycle 源码分析的读者应该对 <code>dispatchingValue</code> 处理循环调用的方式很熟悉了。以这里为例，为了防止循环调用，我们在调用客户代码前先置位一个标志（<code>mDispatchingValue</code>），结束后再设为 <code>false</code>。如果在回调里面又触发了这个方法，可以通过 <code>mDispatchingValue</code> 来检测。</p><p>检测到循环调用后，再设置第二个标志（<code>mDispatchInvalidated</code>），然后返回。返回又会回到之前的调用，前一个调用通过检查 <code>mDispatchInvalidated</code>，知道数据被修改，于是开始一轮新的迭代。</p><p>下面是 <code>considerNotify</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">        <span class="comment">// the observer moved to an active state, if we've not received that event, we better not</span></span><br><span class="line">        <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">        <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">            observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于 LifecycleBoundObserver 来说，即使 `LiveData` 的数据没有变化，只要 activity 的生命</span></span><br><span class="line">        <span class="comment">// 周期发生了改变，还是可能会调用 considerNotify 多次</span></span><br><span class="line">        <span class="comment">// 通过比较 observer.mLastVersion 和 mVersion，就能够知道 observer 是否已经拥有了最新的数据</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 实际上，observer.mLastVersion 最多只能等于 mVersion</span></span><br><span class="line">        <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        observer.mLastVersion = mVersion;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看完了 <code>setValue</code>，<code>postValue</code> 对我们来说就很简单了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，他是 volatile。因为 postValue 可以从后台线程调用，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object mPendingData = NOT_SET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mPostValueRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Object newValue;</span><br><span class="line">            <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">                newValue = mPendingData;</span><br><span class="line">                mPendingData = NOT_SET;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            setValue((T) newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> postTask;</span><br><span class="line">        <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">            postTask = mPendingData == NOT_SET;</span><br><span class="line">            mPendingData = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">            <span class="comment">// 已经有一个 post 后还没有执行的 runnable，所以就不需要再 post 了，</span></span><br><span class="line">            <span class="comment">// 前面 post 的 runnable 执行时，会拿到这个新设置的 value</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终执行的就是 handler.post()</span></span><br><span class="line">        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LiveData</code> 的核心代码我们已经看完了，其实他的实现也挺简单的，对吧？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 <code>LiveData</code>，有两个值得我们学习的，一个是循环调用的处理，另一个是 <code>mVersion</code> 的使用。关于 <code>mVersion</code>，这里再举一个之前工作中遇到的例子。在后台线程对数据进行持久化的时候（这个线程拷贝了一份数据），数据还有可能会被更新。为了判断所保存的数据是不是最新的，我当时的做法就是引入一个类似 <code>mVersion</code> 的东西，每次修改数据，都把 <code>mVersion</code> 加 1。通过比较 <code>mVersion</code> 和所保存的数据的 version，就能够知道是不是保存了最新的数据（当然，更好的做法是告诉后台线程数据已经修改，让他重新拿一次数据）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇我们来看看 Android 架构组件中的 &lt;code&gt;LiveData&lt;/code&gt; 。跟 &lt;code&gt;ViewModel&lt;/code&gt; 相比，&lt;code&gt;LiveData&lt;/code&gt; 具有生命周期感知能力，也就是说，他把 &lt;code&gt;ViewModel&lt;/code&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android arch" scheme="https://jekton.github.io/tags/Android-arch/"/>
    
  </entry>
  
  <entry>
    <title>Android arch components 源码分析（2）—— Lifecycle</title>
    <link href="https://jekton.github.io/2018/07/06/android-arch-lifecycle/"/>
    <id>https://jekton.github.io/2018/07/06/android-arch-lifecycle/</id>
    <published>2018-07-06T03:10:47.000Z</published>
    <updated>2018-08-18T12:47:22.677Z</updated>
    
    <content type="html"><![CDATA[<p><code>Lifecycle</code> 的实现跟 <code>ViewModel</code> 类似，都是利用 <code>Fragment</code> 来实现它的功能。通过添加一个 <code>fragment</code> 到 <code>activity</code> 中，这个 <code>fragment</code> 便能够接收到各个生命周期回调。</p><blockquote><p>以下源码使用 1.1.1 版本</p></blockquote><h2 id="使用方法简介"><a href="#使用方法简介" class="headerlink" title="使用方法简介"></a>使用方法简介</h2><p>这里我并不打算讲太多 lifecycle 的用法，不熟悉的同学，可以参考<a href="https://developer.android.google.cn/topic/libraries/architecture/" target="_blank" rel="noopener">这里</a>。</p><p>为了使用 lifecycle，首先需要获取到一个 <code>LifecycleOwner</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lifecycleOwner.getLifecycle().addObserver(observer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the Lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Lifecycle <span class="title">getLifecycle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 support 包时，<code>AppCompatActivity</code> 就是一个 <code>LifecycleOwner</code>。具体的实现是 <code>SupportActivity</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>下面，我们就从 <code>SupportActivity</code> 开始分析 lifecycle 组件的实现。</p><h2 id="获取生命周期"><a href="#获取生命周期" class="headerlink" title="获取生命周期"></a>获取生命周期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 初始化 ReportFragment</span></span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在上一节中我们执行的 <code>lifecycleOwner.getLifecycle()</code> 返回的，就是 <code>mLifecycleRegistry</code>。关于 <code>LifecycleRegistry</code>，我们在下一节再看，这里先看 <code>ReportFragment</code>。</p><p><code>ReportFragment</code> 就是我们在一开始说的，用于获取生命周期的 <code>fragment</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_FRAGMENT_TAG = <span class="string">"android.arch.lifecycle"</span></span><br><span class="line">            + <span class="string">".LifecycleDispatcher.report_fragment_tag"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span></span><br><span class="line">        <span class="comment">// FragmentActivity from support lib, so we use framework fragments for activities</span></span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ReportFragment <span class="title">get</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ReportFragment) activity.getFragmentManager().findFragmentByTag(</span><br><span class="line">                REPORT_FRAGMENT_TAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityInitializationListener mProcessListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchCreate</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchStart</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchResume</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        dispatchCreate(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        dispatchResume(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">        <span class="comment">// just want to be sure that we won't leak reference to an activity</span></span><br><span class="line">        mProcessListener = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        Activity activity = getActivity();</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于 SupportActivity 来说，执行的是下面这个</span></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">            <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProcessListener</span><span class="params">(ActivityInitializationListener processListener)</span> </span>&#123;</span><br><span class="line">        mProcessListener = processListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ActivityInitializationListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ReportFragment</code> 的实现很简单，读者自己看看就好。下面我们开始看不那么好理解的 <code>LifecycleRegistry</code>。</p><h2 id="生命周期事件的分发"><a href="#生命周期事件的分发" class="headerlink" title="生命周期事件的分发"></a>生命周期事件的分发</h2><p>在看代码前，我们先来了解一下 <code>Lifecycle</code> 的状态和事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Event &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onCreate event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_CREATE,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onStart event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_START,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onResume event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_RESUME,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onPause event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_PAUSE,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onStop event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_STOP,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onDestroy event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_DESTROY,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * An &#123;<span class="doctag">@link</span> Event Event&#125; constant that can be used to match all events.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_ANY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lifecycle states. You can consider the states as the nodes in a graph and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Event&#125;s as the edges between these nodes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch</span></span><br><span class="line"><span class="comment">         * any more events. For instance, for an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state is reached</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;right before&lt;/b&gt; Activity's &#123;<span class="doctag">@link</span> android.app.Activity#onDestroy() onDestroy&#125; call.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DESTROYED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Initialized state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this is</span></span><br><span class="line"><span class="comment">         * the state when it is constructed but has not received</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        INITIALIZED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Created state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span></span><br><span class="line"><span class="comment">         * is reached in two cases:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;after &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="doctag">@link</span> android.app.Activity#onStop() onStop&#125; call.</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CREATED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Started state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span></span><br><span class="line"><span class="comment">         * is reached in two cases:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;after &#123;<span class="doctag">@link</span> android.app.Activity#onStart() onStart&#125; call;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="doctag">@link</span> android.app.Activity#onPause() onPause&#125; call.</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        STARTED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Resumed state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span></span><br><span class="line"><span class="comment">         * is reached after &#123;<span class="doctag">@link</span> android.app.Activity#onResume() onResume&#125; is called.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RESUMED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Compares if this State is greater or equal to the given &#123;<span class="doctag">@code</span> state&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> state State to compare with</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true if this State is greater or equal to the given &#123;<span class="doctag">@code</span> state&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(@NonNull State state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Lifecycle.Event</code> 对应 activity 的各个声明周期，<code>State</code> 则是 <code>Lifecycle</code> 的状态。在 <code>LifecycleRegistry</code> 中定义了状态间的转化关系：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> State <span class="title">getStateAfter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">            <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">            <span class="keyword">case</span> ON_STOP:</span><br><span class="line">                <span class="keyword">return</span> CREATED;</span><br><span class="line">            <span class="keyword">case</span> ON_START:</span><br><span class="line">            <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">                <span class="keyword">return</span> STARTED;</span><br><span class="line">            <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">                <span class="keyword">return</span> RESUMED;</span><br><span class="line">            <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">                <span class="keyword">return</span> DESTROYED;</span><br><span class="line">            <span class="keyword">case</span> ON_ANY:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected event value "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">downEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">case</span> CREATED:</span><br><span class="line">                <span class="keyword">return</span> ON_DESTROY;</span><br><span class="line">            <span class="keyword">case</span> STARTED:</span><br><span class="line">                <span class="keyword">return</span> ON_STOP;</span><br><span class="line">            <span class="keyword">case</span> RESUMED:</span><br><span class="line">                <span class="keyword">return</span> ON_PAUSE;</span><br><span class="line">            <span class="keyword">case</span> DESTROYED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">upEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">            <span class="keyword">case</span> DESTROYED:</span><br><span class="line">                <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">            <span class="keyword">case</span> CREATED:</span><br><span class="line">                <span class="keyword">return</span> ON_START;</span><br><span class="line">            <span class="keyword">case</span> STARTED:</span><br><span class="line">                <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">            <span class="keyword">case</span> RESUMED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这三个方法，可以总结为下面这样一张图：<br><img src="/2018/07/06/android-arch-lifecycle/android-arch-lifecycle-states.png" alt="android-arch-lifecycle-states"></p><p><code>downEvent</code> 在图中表示从一个状态到他下面的那个状态，<code>upEvent</code> 则是往上。</p><p>了解了 <code>Lifecycle</code> 的状态后，我们继续来看 <code>LifecycleRegistry</code>。上一节我们知道，activity 的生命周期发生变化后，会调用到 <code>LifecycleRegistry</code> 的 <code>handleLifecycleEvent</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mAddingObserverCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(@NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        State next = getStateAfter(event);</span><br><span class="line">        moveToState(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mState = next;</span><br><span class="line">        <span class="comment">// 当我们在 LifecycleRegistry 回调 LifecycleObserver 的时候触发状态变化时，</span></span><br><span class="line">        <span class="comment">// mHandlingEvent 为 true；</span></span><br><span class="line">        <span class="comment">// 添加 observer 的时候，也可能会执行回调方法，这时候如果触发了状态变化，</span></span><br><span class="line">        <span class="comment">// 则 mAddingObserverCounter != 0</span></span><br><span class="line">        <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">            mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 不需要执行 sync。</span></span><br><span class="line">            <span class="comment">// 执行到这里的情况是：sync() -&gt; LifecycleObserver -&gt; moveToState()</span></span><br><span class="line">            <span class="comment">// 这里直接返回后，还是会回到 sync()，然后继续同步状态给 observer</span></span><br><span class="line">            <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// sync() 会把状态的变化转化为生命周期事件，然后转发给 LifecycleObserver</span></span><br><span class="line">        sync();</span><br><span class="line">        mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LifecycleRegistry</code> 本来要做的事其实是很简单的，但由于他需要执行客户的代码，由此引入了很多额外的复杂度。原因是，客户代码并不处在我们的控制之下，他们可能做出任何可以做到的事。例如这里，在回调中又触发状态变化。类似的情况是，在持有锁的时候不调用客户代码，这个也会让实现变得比较复杂。</p><p>接下来我们看 <code>sync()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Custom list that keeps observers and can handle removals / additions during traversal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个 Invariant 非常重要，他会影响到 sync() 的逻辑</span></span><br><span class="line"><span class="comment">     * Invariant: at any moment of time for observer1 &amp; observer2:</span></span><br><span class="line"><span class="comment">     * if addition_order(observer1) &lt; addition_order(observer2), then</span></span><br><span class="line"><span class="comment">     * state(observer1) &gt;= state(observer2),</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class="line">            <span class="keyword">new</span> FastSafeIterableMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// happens only on the top of stack (never in reentrance),</span></span><br><span class="line">    <span class="comment">// so it doesn't have to take in account parents</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">        <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(LOG_TAG, <span class="string">"LifecycleOwner is garbage collected, you shouldn't try dispatch "</span></span><br><span class="line">                    + <span class="string">"new events from it."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">            <span class="comment">// mNewEventOccurred 是为了在 observer 触发状态变化时让 backwardPass/forwardPass()</span></span><br><span class="line">            <span class="comment">// 提前返回用的。我们刚准备调他们，这里设置为 false 即可。</span></span><br><span class="line">            mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">            <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// mObserverMap 里的元素的状态是非递增排列的，也就是说，队头的 state 最大</span></span><br><span class="line">                <span class="comment">// 如果 mState 小于队列里最大的那个，说明有元素需要更新状态</span></span><br><span class="line">                <span class="comment">// 为了维持 mObserverMap 的 Invariant，这里我们需要从队尾往前更新元素的状态</span></span><br><span class="line">                backwardPass(lifecycleOwner);</span><br><span class="line">            &#125;</span><br><span class="line">            Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">            <span class="comment">// 如果 mNewEventOccurred，说明在上面调用 backwardPass() 时，客户触发了状态修改</span></span><br><span class="line">            <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                forwardPass(lifecycleOwner);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有的 observer 的状态都已经同步完，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSynced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mObserverMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        State eldestObserverState = mObserverMap.eldest().getValue().mState;</span><br><span class="line">        State newestObserverState = mObserverMap.newest().getValue().mState;</span><br><span class="line">        <span class="comment">// 因为我们保证队头的 state &gt;= 后面的元素的 state，所以只要判断头尾就够了</span></span><br><span class="line">        <span class="keyword">return</span> eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>sync()</code> 的主要作用就是根据把 <code>mObserverMap</code> 里所有元素的状态都同步为 <code>mState</code>。我们继续看剩下的 <code>backwardPass/forwardPass</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;State&gt; mParentStates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从队头开始迭代</span></span><br><span class="line">        Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">                mObserverMap.iteratorWithAdditions();</span><br><span class="line">        <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">            Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">            ObserverWithState observer = entry.getValue();</span><br><span class="line">            <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                    <span class="comment">// 可能在回调客户代码的时候，客户把自己移除了</span></span><br><span class="line">                    &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">                <span class="comment">// pushParentState 和 popParentState 我们下一小节再看，这里先忽略</span></span><br><span class="line">                pushParentState(observer.mState);</span><br><span class="line">                observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">                popParentState();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从队尾开始迭代</span></span><br><span class="line">        Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class="line">                mObserverMap.descendingIterator();</span><br><span class="line">        <span class="keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">            Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class="line">            ObserverWithState observer = entry.getValue();</span><br><span class="line">            <span class="keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                    &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">                Event event = downEvent(observer.mState);</span><br><span class="line">                pushParentState(getStateAfter(event));</span><br><span class="line">                observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">                popParentState();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">popParentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mParentStates.remove(mParentStates.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushParentState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        mParentStates.add(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在看这两个方法时，可以参考上面的状态图。比方说，假设当前队列里的元素都处于 <code>CREATED</code>。接着收到了一个 <code>ON_START</code> 事件，从图里面可以看出，接下来应该是要到 <code>STARTED</code> 状态。由于 <code>STARTED</code> 大于 <code>CREATED</code>，所以会执行 <code>forwardPass()</code>。<code>forwardPass()</code> 里面调用 <code>upEvent(observer.mState)</code>，返回从 <code>CREATED</code> 往上到 <code>STARTED</code> 需要发送的事件，也就是 <code>ON_START</code>，于是 <code>ON_START</code> 事件发送给了客户。</p><h2 id="注册-注销-observer"><a href="#注册-注销-observer" class="headerlink" title="注册/注销 observer"></a>注册/注销 observer</h2><p>注册 observer 由 <code>addObserver</code> 方法完成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这段注释应该是这整个类里面最难理解的了吧，至少对于我来说是这样</span></span><br><span class="line">    <span class="comment">// we have to keep it for cases:</span></span><br><span class="line">    <span class="comment">// void onStart() &#123;</span></span><br><span class="line">    <span class="comment">//     // removeObserver(this)，说明 this 是一个 LifecycleObserver</span></span><br><span class="line">    <span class="comment">//     // 所以这里说的是，我们在回调里执行了下面两个操作</span></span><br><span class="line">    <span class="comment">//     mRegistry.removeObserver(this);</span></span><br><span class="line">    <span class="comment">//     mRegistry.add(newObserver);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 假定现在我们要从 CREATED 转到 STARTED 状态（也就是说，mState 现在是 STARTED）。</span></span><br><span class="line">    <span class="comment">// 这种情况下，只有将新的 observer 设置为 CREATED 状态，它的 onStart 才会被调用</span></span><br><span class="line">    <span class="comment">// 为了得到这个 CREATED，在这里才引入了 mParentStates。在 forwardPass 中执行</span></span><br><span class="line">    <span class="comment">// pushParentState(observer.mState) 时，observer.mState 就是我们需要的 CREATED。</span></span><br><span class="line">    <span class="comment">// backwardPass 的情况类似。</span></span><br><span class="line">    <span class="comment">// newObserver should be brought only to CREATED state during the execution of</span></span><br><span class="line">    <span class="comment">// this onStart method. our invariant with mObserverMap doesn't help, because parent observer</span></span><br><span class="line">    <span class="comment">// is no longer in the map.</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;State&gt; mParentStates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> State <span class="title">calculateTargetState</span><span class="params">(LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);</span><br><span class="line"></span><br><span class="line">        State siblingState = previous != <span class="keyword">null</span> ? previous.getValue().mState : <span class="keyword">null</span>;</span><br><span class="line">        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class="number">1</span>)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 返回最小的 state</span></span><br><span class="line">        <span class="keyword">return</span> min(min(mState, siblingState), parentState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">        ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">        <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在回调中执行了 addObserver()</span></span><br><span class="line">        <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">        State targetState = calculateTargetState(observer);</span><br><span class="line">        mAddingObserverCounter++;</span><br><span class="line">        <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">            pushParentState(statefulObserver.mState);</span><br><span class="line">            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">            <span class="comment">// 我们 dispatch 了一个事件给客户，在回调客户代码的时候，客户可能会修改我们的状态</span></span><br><span class="line">            <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">            targetState = calculateTargetState(observer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">            <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">            sync();</span><br><span class="line">        &#125;</span><br><span class="line">        mAddingObserverCounter--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">        State mState;</span><br><span class="line">        GenericLifecycleObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">        ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">            mLifecycleObserver = Lifecycling.getCallback(observer);</span><br><span class="line">            mState = initialState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">            State newState = getStateAfter(event);</span><br><span class="line">            mState = min(mState, newState);</span><br><span class="line">            mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">            mState = newState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于篇幅有限，这里的 <code>Lifecycling.getCallback</code> 就不看了。简单提一下，在使用 annotion 的时候，对应的 observer 会生成一个 adapter，这个 adapter 会把对应的 <code>Lifecycle.Event</code> 装换为方法调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundLocationListener</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLocationListener</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeLocationListener</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundLocationManager_BoundLocationListener_LifecycleAdapter</span> <span class="keyword">implements</span> <span class="title">GeneratedAdapter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> BoundLocationManager.BoundLocationListener mReceiver;</span><br><span class="line"></span><br><span class="line">  BoundLocationManager_BoundLocationListener_LifecycleAdapter(BoundLocationManager.BoundLocationListener receiver) &#123;</span><br><span class="line">    <span class="keyword">this</span>.mReceiver = receiver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callMethods</span><span class="params">(LifecycleOwner owner, Lifecycle.Event event, <span class="keyword">boolean</span> onAny,</span></span></span><br><span class="line"><span class="function"><span class="params">      MethodCallsLogger logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasLogger = logger != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (onAny) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_RESUME) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">"addLocationListener"</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.addLocationListener();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_PAUSE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">"removeLocationListener"</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.removeLocationListener();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注销 observer 的实现就比较简单了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we consciously decided not to send destruction events here in opposition to addObserver.</span></span><br><span class="line">        <span class="comment">// Our reasons for that:</span></span><br><span class="line">        <span class="comment">// 1. These events haven't yet happened at all. In contrast to events in addObservers, that</span></span><br><span class="line">        <span class="comment">// actually occurred but earlier.</span></span><br><span class="line">        <span class="comment">// 2. There are cases when removeObserver happens as a consequence of some kind of fatal</span></span><br><span class="line">        <span class="comment">// event. If removeObserver method sends destruction events, then a clean up routine becomes</span></span><br><span class="line">        <span class="comment">// more cumbersome. More specific example of that is: your LifecycleObserver listens for</span></span><br><span class="line">        <span class="comment">// a web connection, in the usual routine in OnStop method you report to a server that a</span></span><br><span class="line">        <span class="comment">// session has just ended and you close the connection. Now let's assume now that you</span></span><br><span class="line">        <span class="comment">// lost an internet and as a result you removed this observer. If you get destruction</span></span><br><span class="line">        <span class="comment">// events in removeObserver, you should have a special case in your onStop method that</span></span><br><span class="line">        <span class="comment">// checks if your web connection died and you shouldn't try to report anything to a server.</span></span><br><span class="line">        mObserverMap.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>恭喜你，相信你现在对 lifecycle 的实现已经胸有成竹，可以愉快地装逼了。</p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Lifecycle&lt;/code&gt; 的实现跟 &lt;code&gt;ViewModel&lt;/code&gt; 类似，都是利用 &lt;code&gt;Fragment&lt;/code&gt; 来实现它的功能。通过添加一个 &lt;code&gt;fragment&lt;/code&gt; 到 &lt;code&gt;activity&lt;/c
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android arch" scheme="https://jekton.github.io/tags/Android-arch/"/>
    
  </entry>
  
  <entry>
    <title>Android arch components 源码分析（1）—— ViewModel</title>
    <link href="https://jekton.github.io/2018/06/30/android-arch-ViewModel/"/>
    <id>https://jekton.github.io/2018/06/30/android-arch-ViewModel/</id>
    <published>2018-06-30T05:26:59.000Z</published>
    <updated>2018-08-18T12:47:22.677Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要关注 <code>ViewModel</code> 的实现而非其用法，关于他的用法，可以参考<a href="https://developer.android.google.cn/topic/libraries/architecture/" target="_blank" rel="noopener">这里</a>。</p><p><code>ViewModel</code> 主要用于在 activity/fragment 被自动销毁时保存一些数据。从实现原理上讲，主要就是利用了 <code>fragment.setRetainInstance(true)</code>。如此一来，这个 <code>fragment</code> 就能够跨越 <code>activity</code> 的生命周期。</p><blockquote><p>以下源码使用 1.1.1 版本</p></blockquote><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul><li><code>ViewModel</code>：这个是我们的主角。我们定义的 model 类需要继承它。</li><li><code>ViewModelProvider</code>：用于生成 <code>ViewModel</code> 实例</li><li><code>ViewModelStore</code>：跟他的名字一样，主要用来存储 <code>ViewModel</code> 的实例。</li><li><code>HolderFragment</code>：这个就是我们上面提到的调用了 <code>setRetainInstance(true)</code> 的那个 <code>fragment</code>。<code>ViewModelStore</code> 实例存储会在这里。</li></ul><p>下面是 Google 给出的<a href="https://github.com/googlecodelabs/android-lifecycles" target="_blank" rel="noopener">示例</a> step2 中的一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChronometerViewModel chronometerViewModel</span><br><span class="line">       = ViewModelProviders.of(<span class="keyword">this</span>).get(ChronometerViewModel.class);</span><br></pre></td></tr></table></figure></p><p>下面我们就根据这个调用来学习 <code>ViewModel</code> 的源码。</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>前面我们说过，自己定义的 model 类需要继承它。这里借花献佛，我们直接看 Google 的 sample：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChronometerViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不用关心它的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ViewModel</code> 虽然是主角，但他非常的简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCleared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就这样，他只是定义了一个空方法 <code>onCleared()</code>。当对应的 model 实例被销毁时，<code>onCleared()</code> 将会执行。通过让他成为 <code>abstract class</code> 并给予 <code>onCleared</code> 一个默认实现，让 <code>ViewModel</code> 有了 tag interface 的效果。</p><blockquote><p>所谓的 tag interface 是指不带任何方法的 <code>interface</code>。</p></blockquote><p>接下来是男二号 <code>AndroidViewModel</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Application mApplication;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidViewModel</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">        mApplication = application;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Application&gt; <span class="function">T <span class="title">getApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>没有太多可圈可点的东西，我们继续看下一个。</p><h2 id="ViewModelProvider"><a href="#ViewModelProvider" class="headerlink" title="ViewModelProvider"></a>ViewModelProvider</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChronometerViewModel chronometerViewModel</span><br><span class="line">       = ViewModelProviders.of(<span class="keyword">this</span>).get(ChronometerViewModel.class);</span><br></pre></td></tr></table></figure><p>我们继续从这个调用往下看。</p><p><code>ViewModelProviders</code> 可以看成是 <code>ViewModelProvider</code> 的工厂或相关工具类的合集。他的命名跟 JDK 里的 <code>Collections/Arrays</code> 类似。这里的 <code>this</code> 是 <code>FragmentActivity</code>，所以接下来执行的是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelProviders</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> of(activity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Factory factory)</span> </span>&#123;</span><br><span class="line">        Application application = checkApplication(activity);</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，最终 <code>ViewModelProviders</code> 会创建一个 <code>ViewModelProvider</code> 实例并返回。</p><p><code>Factory</code> 是用于创建 model 实例的工厂：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认的实现是 <code>AndroidViewModelFactory</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidViewModelFactory</span> <span class="keyword">extends</span> <span class="title">ViewModelProvider</span>.<span class="title">NewInstanceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AndroidViewModelFactory sInstance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AndroidViewModelFactory <span class="title">getInstance</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> AndroidViewModelFactory(application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">            <span class="comment">// model 类继承了 AndroidViewModel</span></span><br><span class="line">            <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> modelClass.getConstructor(Application.class).newInstance(mApplication);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，由父类 `NewInstanceFactory` 处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>父类 <code>NewInstanceFactory</code> 的实现一样很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"ClassNewInstance"</span>)</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> modelClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这里可以看出，使用默认的 <code>Factory</code> 实现时，如果 model 类继承 <code>ViewModel</code>，需要有一个默认构造函数；如果继承 <code>AndroidViewModel</code>，必须有一个以 <code>Application</code> 为唯一参数构造函数。否则，我们需要自己实现一个 <code>Factory</code>。</p><p>我们先把 <code>ViewModelStore</code> 放一放，先假设成功拿到了他的实例，于是，我们创建 <code>ViewModelProvider</code> 实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @Nullable Factory factory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(@NonNull ViewModelStore store, @NonNull Factory factory)</span> </span>&#123;</span><br><span class="line">        mFactory = factory;</span><br><span class="line">        mViewModelStore = store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 <code>ViewModelProvider</code> 获取 model 实例时，使用的是他的 <code>get</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ViewModelProvider &#123;</span><br><span class="line"></span><br><span class="line">    private static final String DEFAULT_KEY =</span><br><span class="line">            &quot;android.arch.lifecycle.ViewModelProvider.DefaultKey&quot;;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @MainThread</span><br><span class="line">    public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">        String canonicalName = modelClass.getCanonicalName();</span><br><span class="line">        if (canonicalName == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return get(DEFAULT_KEY + &quot;:&quot; + canonicalName, modelClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @MainThread</span><br><span class="line">    public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">        ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">        // 当使用不同的类加载器加载同一个类的时候，这里会是 false</span><br><span class="line">        if (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">            //noinspection unchecked</span><br><span class="line">            return (T) viewModel;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //noinspection StatementWithEmptyBody</span><br><span class="line">            if (viewModel != null) &#123;</span><br><span class="line">                // TODO: log a warning.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        viewModel = mFactory.create(modelClass);</span><br><span class="line">        mViewModelStore.put(key, viewModel);</span><br><span class="line">        //noinspection unchecked</span><br><span class="line">        return (T) viewModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ViewModelProvider</code> 他的职责就是从 <code>ViewModelStore</code> 里取出对象，如果对象不存在，就新创建一个，并把新创建的这个对象放到 <code>ViewModelStore</code>。</p><h2 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a>ViewModelStore</h2><p>和 <code>ViewModelProvider</code> 一样，<code>ViewModelStore</code> 也有一个工厂类叫 <code>ViewModelStores</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStores</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们的 activity 可以自己实现 ViewModelStoreOwner</span></span><br><span class="line">        <span class="comment">// 默认情况下，这里的判断为 false，ViewModelStoreOwner 由 HolderFragment 实现</span></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// holderFragmentFor 在 HolderFragment 中实现，我们留到下一节再看</span></span><br><span class="line">        <span class="keyword">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>HolderFragment</code> 实现了 <code>ViewModelStoreOwner</code> 接口，<code>holderFragmentFor(activity)</code> 返回 <code>activity</code> 对应的 <code>holderFragment</code> 后，即可以拿到 <code>ViewModelStore</code> 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HolderFragment"><a href="#HolderFragment" class="headerlink" title="HolderFragment"></a>HolderFragment</h2><p><code>HolderFragment</code> 是整个实现的核心。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HolderFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如此一来，当 activity 由于屏幕旋转等被系统销毁时，这个 fragment 实例也不会被销毁</span></span><br><span class="line">        setRetainInstance(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 把 activity 从 mNotCommittedActivityHolders 中移除</span></span><br><span class="line">        sHolderFragmentManager.holderFragmentCreated(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HolderFragment <span class="title">holderFragmentFor</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sHolderFragmentManager.holderFragmentFor(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderFragmentManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Activity, HolderFragment&gt; mNotCommittedActivityHolders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ActivityLifecycleCallbacks mActivityCallbacks =</span><br><span class="line">                <span class="keyword">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                        HolderFragment fragment = mNotCommittedActivityHolders.remove(activity);</span><br><span class="line">                        <span class="comment">// fragment 创建成功后，会把 activity 从 mNotCommittedActivityHolders 中</span></span><br><span class="line">                        <span class="comment">// 移除。如果 fragment != null，说明 fragment 没有创建完 activity 就跪了</span></span><br><span class="line">                        <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            Log.e(LOG_TAG, <span class="string">"Failed to save a ViewModel for "</span> + activity);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mActivityCallbacksIsAdded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">HolderFragment <span class="title">holderFragmentFor</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">            FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">            <span class="comment">// 通过 fragmentManager 获取 fragment 实例</span></span><br><span class="line">            HolderFragment holder = findHolderFragment(fm);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125;</span><br><span class="line">            holder = mNotCommittedActivityHolders.get(activity);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mActivityCallbacksIsAdded) &#123;</span><br><span class="line">                mActivityCallbacksIsAdded = <span class="keyword">true</span>;</span><br><span class="line">                activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks);</span><br><span class="line">            &#125;</span><br><span class="line">            holder = createHolderFragment(fm);</span><br><span class="line">            <span class="comment">// 我们 add 进去的 fragment 并不会马上就执行完（也就是说，这个方法执行完成后，马上再</span></span><br><span class="line">            <span class="comment">// 调用一次，上面的 findHolderFragment 会返回 null。但是这没有关系，因为接下来我们还可</span></span><br><span class="line">            <span class="comment">// 从 mNotCommittedActivityHolders 获取到对应的实例），所以我们这里先把他放在</span></span><br><span class="line">            <span class="comment">// mNotCommittedActivityHolders 中。Not Committed 表示 fragment 的 commit 还没有完成</span></span><br><span class="line">            mNotCommittedActivityHolders.put(activity, holder);</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HolderFragment <span class="title">createHolderFragment</span><span class="params">(FragmentManager fragmentManager)</span> </span>&#123;</span><br><span class="line">            HolderFragment holder = <span class="keyword">new</span> HolderFragment();</span><br><span class="line">            <span class="comment">// 这个 fragment 只是用来存数据，允许他的状态丢失可以让用户在更多情景下使用我们的API</span></span><br><span class="line">            <span class="comment">// 例如，onStop() 中也可以使用（当然，onDestroy 就不行了，因为我们需要往 activity 悄悄</span></span><br><span class="line">            <span class="comment">// 添加一个 fragment）</span></span><br><span class="line">            fragmentManager.beginTransaction().add(holder, HOLDER_TAG).commitAllowingStateLoss();</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>HolderFragment</code> 对 <code>ViewModelStoreOwner</code> 实现是相当直接的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ViewModelStore mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mViewModelStore.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，<code>ViewModel</code> 的实现我们就看完了。需要注意的是，<code>ViewModel</code> 还支持 <code>fragment</code>，这部分跟 <code>activity</code> 是类似的，有兴趣的读者自己看一看就好。</p><h2 id=""><a href="#" class="headerlink" title=""></a><br></h2><p><br></p><blockquote><p>@大熊：ViewModelStores.of(FragmentActivity)需要区分下Support Library的版本，如果在v27.1.0版本及以上的，FragmentActivity已经实现了ViewModelStoreOwner接口，最终是通过FragmentActivity.onRetainNonConfigurationInstance()完成ViewModelStore的存储的，v27.1.0版本以下才是通过Fragment.setRetainInstance(true)实现。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要关注 &lt;code&gt;ViewModel&lt;/code&gt; 的实现而非其用法，关于他的用法，可以参考&lt;a href=&quot;https://developer.android.google.cn/topic/libraries/architecture/&quot; target=&quot;_bl
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android arch" scheme="https://jekton.github.io/tags/Android-arch/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP、Socket 和协议设计</title>
    <link href="https://jekton.github.io/2018/06/23/socket-intro/"/>
    <id>https://jekton.github.io/2018/06/23/socket-intro/</id>
    <published>2018-06-23T01:12:16.000Z</published>
    <updated>2019-03-05T11:34:16.727Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a><sup>[1]</sup>提供写作赞助，版权归玉刚说微信公众号所有<br>原作者：<a href="https://jekton.github.io/">水晶虾饺</a><sup>[2]</sup><br>版权声明：未经玉刚说许可，不得以任何形式转载</p></blockquote><p>本篇我们先简单了解一下 TCP/IP，然后通过实现一个 echo 服务器来学习 Java 的 Socket API。最后我们聊聊偏高级一点点的 socket 长连接和协议设计。</p><h2 id="TCP-IP-协议简介"><a href="#TCP-IP-协议简介" class="headerlink" title="TCP/IP 协议简介"></a>TCP/IP 协议简介</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>首先我们看 IP（Internet Protocol）协议。IP 协议提供了<strong>主机和主机</strong>间的通信。</p><p>为了完成不同主机的通信，我们需要某种方式来唯一标识一台主机，这个标识，就是著名的<strong>IP地址</strong>。通过IP地址，IP 协议就能够帮我们把一个数据包发送给对方。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>前面我们说过，IP 协议提供了主机和主机间的通信。TCP 协议在 IP 协议提供的主机间通信功能的基础上，完成这两个主机上<strong>进程对进程</strong>的通信。</p><p>有了 IP，不同主机就能够交换数据。但是，计算机收到数据后，并不知道这个数据属于哪个进程（简单讲，进程就是一个正在运行的应用程序）。TCP 的作用就在于，让我们能够知道这个数据属于哪个进程，从而完成进程间的通信。</p><p>为了标识数据属于哪个进程，我们给需要进行 TCP 通信的进程分配一个唯一的数字来标识它。这个数字，就是我们常说的<strong>端口号</strong>。</p><p>TCP 的全称是 Transmission Control Protocol，大家对它说得最多的，大概就是<strong>面向连接</strong>的特性了。之所以说它是有连接的，是说在进行通信前，通信双方需要先经过一个<em>三次握手</em>的过程。三次握手完成后，连接便建立了。这时候我们才可以开始发送/接收数据。（与之相对的是 UDP，不需要经过握手，就可以直接发送数据）。</p><p>下面我们简单了解一下三次握手的过程。</p><p><img src="/2018/06/23/socket-intro/tcp-three-way-handshake.png" alt="tcp-three-way-handshake"></p><ol><li>首先，客户向服务端发送一个 <code>SYN</code>，假设此时 sequence number 为 <code>x</code>。这个 <code>x</code> 是由操作系统根据一定的规则生成的，不妨认为它是一个随机数。</li><li>服务端收到 <code>SYN</code> 后，会向客户端再发送一个 <code>SYN</code>，此时服务器的 <code>seq number = y</code>。与此同时，会 <code>ACK x+1</code>，告诉客户端“已经收到了 <code>SYN</code>，可以发送数据了”。</li><li>客户端收到服务器的 <code>SYN</code> 后，回复一个 <code>ACK y+1</code>，这个 <code>ACK</code> 则是告诉服务器，<code>SYN</code> 已经收到，服务器可以发送数据了。</li></ol><p>经过这 3 步，TCP 连接就建立了。这里需要注意的有三点：</p><ol><li>连接是由客户端主动发起的</li><li>在第 3 步客户端向服务器回复 <code>ACK</code> 的时候，TCP 协议是允许我们携带数据的。之所以做不到，是 API 的限制导致的。</li><li>TCP 协议还允许 “四次握手” 的发生，同样的，由于 API 的限制，这个极端的情况并不会发生。</li></ol><p>TCP/IP 相关的理论知识我们就先了解到这里。关于 TCP，还有诸如可靠性、流量控制、拥塞控制等非常有趣的特性，<strong>强烈推荐</strong>读者看一看 Richard 的名著《TCP/IP 详解 - 卷1》（注意，是<strong>第1版</strong>，不是第2版）。</p><p>下面我们看一些偏实战的东西。</p><h2 id="Socket-基本用法"><a href="#Socket-基本用法" class="headerlink" title="Socket 基本用法"></a>Socket 基本用法</h2><p>Socket 是 TCP 层的封装，通过 socket，我们就能进行 TCP 通信。</p><p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。使用 socket 的步骤如下：</p><ol><li>创建 <code>ServerSocket</code> 并监听客户连接</li><li>使用 <code>Socket</code> 连接服务端</li><li>通过 <code>Socket.getInputStream()/getOutputStream()</code> 获取输入输出流进行通信</li></ol><p>下面，我们通过实现一个简单的 echo 服务来学习 socket 的使用。所谓的 echo 服务，就是客户端向服务端写入任意数据，服务器都将数据原封不动地写回给客户端。</p><h3 id="1-创建-ServerSocket-并监听客户连接"><a href="#1-创建-ServerSocket-并监听客户连接" class="headerlink" title="1. 创建 ServerSocket 并监听客户连接"></a>1. 创建 <code>ServerSocket</code> 并监听客户连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocket mServerSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个 ServerSocket 并监听端口 port</span></span><br><span class="line">        mServerSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 开始接受客户连接</span></span><br><span class="line">        Socket client = mServerSocket.accept();</span><br><span class="line">        handleClient(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleClient</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 使用 socket 进行通信 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EchoServer server = <span class="keyword">new</span> EchoServer(<span class="number">9877</span>);</span><br><span class="line">            server.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用-Socket-连接服务端"><a href="#2-使用-Socket-连接服务端" class="headerlink" title="2. 使用 Socket 连接服务端"></a>2. 使用 <code>Socket</code> 连接服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket mSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 socket 并连接服务器</span></span><br><span class="line">        mSocket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 和服务端进行通信</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 由于服务端运行在同一主机，这里我们使用 localhost</span></span><br><span class="line">            EchoClient client = <span class="keyword">new</span> EchoClient(<span class="string">"localhost"</span>, <span class="number">9877</span>);</span><br><span class="line">            client.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-通过-socket-getInputStream-getOutputStream-获取输入-输出流进行通信"><a href="#3-通过-socket-getInputStream-getOutputStream-获取输入-输出流进行通信" class="headerlink" title="3. 通过 socket.getInputStream()/getOutputStream() 获取输入/输出流进行通信"></a>3. 通过 <code>socket.getInputStream()/getOutputStream()</code> 获取输入/输出流进行通信</h3><p>首先，我们来实现服务端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleClient</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，服务端的实现其实很简单，我们不停地读取输入数据，然后写回给客户端。</p><p>下面我们看看客户端。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Thread readerThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>::readResponse);</span><br><span class="line">        readerThread.start();</span><br><span class="line"></span><br><span class="line">        OutputStream out = mSocket.getOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = System.in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream in = mSocket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端会稍微复杂一点点，在读取用户输入的同时，我们又想读取服务器的响应。所以，这里创建了一个线程来读服务器的响应。</p><p>不熟悉 lambda 的读者，可以把<code>Thread readerThread = new Thread(this::readResponse)</code> 换成下面这个代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread readerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readResponse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>打开两个 terminal 分别执行如下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> javac EchoServer.java</span><br><span class="line"><span class="meta">$</span> java EchoServer</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> javac EchoClient.java</span><br><span class="line"><span class="meta">$</span> java EchoClient</span><br><span class="line">hello Server</span><br><span class="line">hello Server</span><br><span class="line">foo</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><p>在客户端，我们会看到，输入的所有字符都打印了出来。</p><p>最后需要注意的有几点：</p><ol><li>在上面的代码中，我们所有的异常都没有处理。实际应用中，在发生异常时，需要关闭 socket，并根据实际业务做一些错误处理工作</li><li>在客户端，我们没有停止 <code>readThread</code>。实际应用中，我们可以通过关闭 socket 来让线程从阻塞读中返回。推荐读者阅读《Java并发编程实战》</li><li>我们的服务端只处理了一个客户连接。如果需要同时处理多个客户端，可以创建线程来处理请求。这个作为练习留给读者来完全。</li></ol><h2 id="Socket、ServerSocket-傻傻分不清楚"><a href="#Socket、ServerSocket-傻傻分不清楚" class="headerlink" title="Socket、ServerSocket 傻傻分不清楚"></a>Socket、ServerSocket 傻傻分不清楚</h2><p>在进入这一节的主题前，读者不妨先考虑一个问题：在上一节的实例中，我们运行 echo 服务后，在客户端连接成功时，一个有多少个 socket 存在？</p><p>答案是 3 个 socket。客户端一个，服务端有两个。跟这个问题的答案直接关联的是本节的主题——<code>Socket</code> 和 <code>ServerSocket</code> 的区别是什么。</p><p>眼尖的读者，可能会注意到在上一节我是这样描述他们的：</p><blockquote><p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。</p></blockquote><p>注意，我只说 <code>ServerSocket</code> 是用于监听客户连接，而没有说它也可以用来通信。下面我们来详细了解一下他们的区别。</p><blockquote><p>注：以下描述使用的是 UNIX/Linux 系统的 API</p></blockquote><p>首先，我们创建 <code>ServerSocket</code> 后，内核会创建一个 socket。这个 socket 既可以拿来监听客户连接，也可以连接远端的服务。由于 <code>ServerSocket</code> 是用来监听客户连接的，紧接着它就会对内核创建的这个 socket 调用 <code>listen</code> 函数。这样一来，这个 socket 就成了所谓的 listening socket，它开始监听客户的连接。</p><p>接下来，我们的客户端创建一个 <code>Socket</code>，同样的，内核也创建一个 socket 实例。内核创建的这个 socket 跟 <code>ServerSocket</code> 一开始创建的那个没有什么区别。不同的是，接下来 <code>Socket</code> 会对它执行 <code>connect</code>，发起对服务端的连接。前面我们说过，socket API 其实是 TCP 层的封装，所以 <code>connect</code> 后，内核会发送一个 <code>SYN</code> 给服务端。</p><p>现在，我们切换角色到服务端。<strong>服务端的主机在收到这个 <code>SYN</code> 后，会创建一个新的 socket</strong>，这个新创建的 socket 跟客户端继续执行三次握手过程。</p><p>三次握手完成后，我们执行的 <code>serverSocket.accept()</code> 会返回一个 <code>Socket</code> 实例，这个 socket 就是上一步内核自动帮我们创建的。</p><p>所以说，在一个客户端连接的情况下，其实有 3 个 socket。</p><p>关于内核自动创建的这个 socket，还有一个很有意思的地方。它的端口号跟 <code>ServerSocket</code> 是一毛一样的。咦！！不是说，一个端口只能绑定一个 socket 吗？其实这个说法并不够准确。</p><p>前面我说的TCP 通过端口号来区分数据属于哪个进程的说法，在 socket 的实现里需要改一改。Socket 并不仅仅使用端口号来区别不同的 socket 实例，而是使用 <code>&lt;peer addr:peer port, local addr:local port&gt;</code> 这个四元组。</p><p>在上面的例子中，我们的 <code>ServerSocket</code> 长这样：<code>&lt;*:*, *:9877&gt;</code>。意思是，可以接受任何的客户端，和本地任何 IP。</p><p><code>accept</code> 返回的 <code>Socket</code> 则是这样：<code>&lt;127.0.0.1:xxxx, 127.0.0.1:9877&gt;</code>。其中，<code>xxxx</code> 是客户端的端口号。</p><p>如果数据是发送给一个已连接的 socket，内核会找到一个完全匹配的实例，所以数据准确发送给了对端。</p><p>如果是客户端要发起连接，这时候只有 <code>&lt;*:*, *:9877&gt;</code> 会匹配成功，所以 <code>SYN</code> 也准确发送给了监听套接字。</p><p><code>Socket/ServerSocket</code> 的区别我们就讲到这里。如果读者觉得不过瘾，可以参考《TCP/IP 详解》卷1、卷2。</p><h2 id="Socket-长连接的实现"><a href="#Socket-长连接的实现" class="headerlink" title="Socket 长连接的实现"></a>Socket 长连接的实现</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。</p><p>比较熟悉 <code>Socket</code> 的读者，可能知道有这样一个 API：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.setKeepAlive(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>嗯……keep alive，“保持活着”，这个应该就是让 TCP 不断开的意思。那么，我们要实现一个 socket 的长连接，只需要这一个调用即可。</p><p>遗憾的是，生活并不总是那么美好。对于 4.4BSD 的实现来说，Socket 的这个 keep alive 选项如果打开并且<strong>两个小时</strong>内没有通信，那么底层会发一个心跳，看看对方是不是还活着。</p><p>注意，两个小时才会发一次。也就是说，在没有实际数据通信的时候，我把网线拔了，你的应用程序要经过两个小时才会知道。</p><p>在说明如果实现长连接前，我们先来理一理我们面临的问题。假定现在有一对已经连接的 socket，在以下情况发生时候，socket 将不再可用：</p><ol><li>某一端关闭是 socket（这不是废话吗）。主动关闭的一方会发送 <code>FIN</code>，通知对方要关闭 TCP 连接。在这种情况下，另一端如果去读 socket，将会读到 <code>EoF</code>（End of File）。于是我们知道对方关闭了 socket。</li><li>应用程序奔溃。此时 socket 会由内核关闭，结果跟情况1一样。</li><li>系统奔溃。这时候系统是来不及发送 <code>FIN</code> 的，因为它已经跪了。此时对方无法得知这一情况。对方在尝试读取数据时，最后会返回 read time out。如果写数据，则是 host unreachable 之类的错误。</li><li>电缆被挖断、网线被拔。跟情况3差不多，如果没有对 socket 进行读写，两边都不知道发生了事故。跟情况3不同的是，如果我们把网线接回去，socket 依旧可以正常使用。</li></ol><p>在上面的几种情形中，有一个共同点就是，只要去读、写 socket，只要 socket 连接不正常，我们就能够知道。基于这一点，要实现一个 socket 长连接，我们需要做的就是不断地给对方写数据，然后读取对方的数据，也就是所谓的<strong>心跳</strong>。只要心还在跳，socket 就是活的。写数据的间隔，需要根据实际的应用需求来决定。</p><p>心跳包不是实际的业务数据，根据通信协议的不同，需要做不同的处理。</p><p>比方说，我们使用 JSON 进行通信，那么，我们可以加一个 <code>type</code> 字段，表面这个 JSON 是心跳还是业务数据。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "type": 0,  // 0 表示心跳</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用二进制协议的情况类似。要求就是，我们能够区别一个数据包是心跳还是真实数据。这样，我们便实现了一个 socket 长连接。</p><h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h3><p>这一小节我们一起来实现一个带长连接的 Android echo 客户端。完整的代码可以在<a href="https://github.com/Jekton/Echo" target="_blank" rel="noopener">这里</a><sup>[3]</sup>找到。</p><p>首先了接口部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LongLiveSocket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorCallback</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果需要重连，返回 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">onError</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onData</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritingCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onFail</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongLiveSocket</span><span class="params">(String host, <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">                          DataCallback dataCallback, ErrorCallback errorCallback)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, WritingCallback callback)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, WritingCallback callback)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们这个支持长连接的类就叫 <code>LongLiveSocket</code> 好了。如果在 socket 断开后需要重连，只需要在对应的接口里面返回 true 即可（在真实场景里，我们还需要让客户设置重连的等待时间，还有读写、连接的 timeout等。为了简单，这里就直接不支持了。</p><p>另外需要注意的一点是，如果要做一个完整的库，需要同时提供阻塞式和回调式API。同样由于篇幅原因，这里直接省掉了。</p><p>下面我们直接看实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LongLiveSocket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"LongLiveSocket"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RETRY_INTERVAL_MILLIS = <span class="number">3</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> HEART_BEAT_INTERVAL_MILLIS = <span class="number">5</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> HEART_BEAT_TIMEOUT_MILLIS = <span class="number">2</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorCallback</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果需要重连，返回 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">onError</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onData</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritingCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onFail</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mHost;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mPort;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataCallback mDataCallback;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ErrorCallback mErrorCallback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HandlerThread mWriterThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mWriterHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mUIHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Socket mSocket;  <span class="comment">// guarded by mLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mClosed; <span class="comment">// guarded by mLock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mHeartBeatTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] mHeartBeat = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 我们使用长度为 0 的数据作为 heart beat</span></span><br><span class="line">            write(mHeartBeat, <span class="keyword">new</span> WritingCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 每隔 HEART_BEAT_INTERVAL_MILLIS 发送一次</span></span><br><span class="line">                    mWriterHandler.postDelayed(mHeartBeatTask, HEART_BEAT_INTERVAL_MILLIS);</span><br><span class="line">                    mUIHandler.postDelayed(mHeartBeatTimeoutTask, HEART_BEAT_TIMEOUT_MILLIS);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// nop</span></span><br><span class="line">                    <span class="comment">// write() 方法会处理失败</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mHeartBeatTimeoutTask = () -&gt; &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"mHeartBeatTimeoutTask#run: heart beat timeout"</span>);</span><br><span class="line">        closeSocket();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongLiveSocket</span><span class="params">(String host, <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">                          DataCallback dataCallback, ErrorCallback errorCallback)</span> </span>&#123;</span><br><span class="line">        mHost = host;</span><br><span class="line">        mPort = port;</span><br><span class="line">        mDataCallback = dataCallback;</span><br><span class="line">        mErrorCallback = errorCallback;</span><br><span class="line"></span><br><span class="line">        mWriterThread = <span class="keyword">new</span> HandlerThread(<span class="string">"socket-writer"</span>);</span><br><span class="line">        mWriterThread.start();</span><br><span class="line">        mWriterHandler = <span class="keyword">new</span> Handler(mWriterThread.getLooper());</span><br><span class="line">        mWriterHandler.post(<span class="keyword">this</span>::initSocket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Socket socket = <span class="keyword">new</span> Socket(mHost, mPort);</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="comment">// 在我们创建 socket 的时候，客户可能就调用了 close()</span></span><br><span class="line">                    <span class="keyword">if</span> (mClosed) &#123;</span><br><span class="line">                        silentlyClose(socket);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mSocket = socket;</span><br><span class="line">                    <span class="comment">// 每次创建新的 socket，会开一个线程来读数据</span></span><br><span class="line">                    Thread reader = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReaderTask(socket), <span class="string">"socket-reader"</span>);</span><br><span class="line">                    reader.start();</span><br><span class="line">                    mWriterHandler.post(mHeartBeatTask);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"initSocket: "</span>, e);</span><br><span class="line">                <span class="keyword">if</span> (closed() || !mErrorCallback.onError()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(RETRY_INTERVAL_MILLIS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    <span class="comment">// interrupt writer-thread to quit</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, WritingCallback callback)</span> </span>&#123;</span><br><span class="line">        write(data, <span class="number">0</span>, data.length, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, WritingCallback callback)</span> </span>&#123;</span><br><span class="line">        mWriterHandler.post(() -&gt; &#123;</span><br><span class="line">            Socket socket = getSocket();</span><br><span class="line">            <span class="keyword">if</span> (socket == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// initSocket 失败而客户说不需要重连，但客户又叫我们给他发送数据</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Socket not initialized"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                DataOutputStream out = <span class="keyword">new</span> DataOutputStream(outputStream);</span><br><span class="line">                out.writeInt(len);</span><br><span class="line">                out.write(data, offset, len);</span><br><span class="line">                callback.onSuccess();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"write: "</span>, e);</span><br><span class="line">                closeSocket();</span><br><span class="line">                callback.onFail(data, offset, len);</span><br><span class="line">                <span class="keyword">if</span> (!closed() &amp;&amp; mErrorCallback.onError()) &#123;</span><br><span class="line">                    initSocket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">closed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> mClosed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Socket <span class="title">getSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> mSocket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            closeSocketLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeSocketLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mSocket == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        silentlyClose(mSocket);</span><br><span class="line">        mSocket = <span class="keyword">null</span>;</span><br><span class="line">        mWriterHandler.removeCallbacks(mHeartBeatTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Looper.getMainLooper() == Looper.myLooper()) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    doClose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mClosed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 关闭 socket，从而使得阻塞在 socket 上的线程返回</span></span><br><span class="line">            closeSocketLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mWriterThread.quit();</span><br><span class="line">        <span class="comment">// 在重连的时候，有个 sleep</span></span><br><span class="line">        mWriterThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">silentlyClose</span><span class="params">(Closeable closeable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"silentlyClose: "</span>, e);</span><br><span class="line">                <span class="comment">// error ignored</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket mSocket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReaderTask</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            mSocket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                readResponse();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"ReaderTask#run: "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">// For simplicity, assume that a msg will not exceed 1024-byte</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            InputStream inputStream = mSocket.getInputStream();</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(inputStream);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> nbyte = in.readInt();</span><br><span class="line">                <span class="keyword">if</span> (nbyte == <span class="number">0</span>) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"readResponse: heart beat received"</span>);</span><br><span class="line">                    mUIHandler.removeCallbacks(mHeartBeatTimeoutTask);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nbyte &gt; buffer.length) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Receive message with len "</span> + nbyte +</span><br><span class="line">                                    <span class="string">" which exceeds limit "</span> + buffer.length);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (readn(in, buffer, nbyte) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Socket might be closed twice but it does no harm</span></span><br><span class="line">                    silentlyClose(mSocket);</span><br><span class="line">                    <span class="comment">// Socket will be re-connected by writer-thread if you want</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mDataCallback.onData(buffer, <span class="number">0</span>, nbyte);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readn</span><span class="params">(InputStream in, <span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> readBytes = in.read(buffer, offset, n);</span><br><span class="line">                <span class="keyword">if</span> (readBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// EoF</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                n -= readBytes;</span><br><span class="line">                offset += readBytes;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是我们新实现的 <code>EchoClient</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"EchoClient"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongLiveSocket mLongLiveSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        mLongLiveSocket = <span class="keyword">new</span> LongLiveSocket(</span><br><span class="line">                host, port,</span><br><span class="line">                (data, offset, len) -&gt; Log.i(TAG, <span class="string">"EchoClient: received: "</span> + <span class="keyword">new</span> String(data, offset, len)),</span><br><span class="line">                <span class="comment">// 返回 true，所以只要出错，就会一直重连</span></span><br><span class="line">                () -&gt; <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        mLongLiveSocket.write(msg.getBytes(), <span class="keyword">new</span> LongLiveSocket.WritingCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSuccess: "</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onFail: fail to write: "</span> + <span class="keyword">new</span> String(data, offset, len));</span><br><span class="line">                <span class="comment">// 连接成功后，还会发送这个消息</span></span><br><span class="line">                mLongLiveSocket.write(data, offset, len, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就这样，一个带 socket 长连接的客户端就完成了。剩余代码跟我们这里的主题没有太大关系，感兴趣的读者可以看<a href="https://github.com/Jekton/Echo" target="_blank" rel="noopener">这里</a><sup>[3]</sup>或者自己完成这个例子。下面是一些输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">03:54:55.583 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:00.588 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:05.594 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:09.638 12691-12710/com.example.echo D/EchoClient: onSuccess: </span><br><span class="line">03:55:09.639 12691-12713/com.example.echo I/EchoClient: EchoClient: received: hello</span><br><span class="line">03:55:10.595 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:14.652 12691-12710/com.example.echo D/EchoClient: onSuccess: </span><br><span class="line">03:55:14.654 12691-12713/com.example.echo I/EchoClient: EchoClient: received: echo</span><br><span class="line">03:55:15.596 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:20.597 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:25.602 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br></pre></td></tr></table></figure></p><p>最后需要说明的是，如果想节省资源，在有客户发送数据的时候可以省略 heart beat。</p><p>我们对读出错时候的处理，可能也存在一些争议。读出错后，我们只是关闭了 socket。socket 需要等到下一次写动作发生时，才会重新连接。实际应用中，如果这是一个问题，在读出错后可以直接开始重连。这种情况下，还需要一些额外的同步，避免重复创建 socket。heart beat timeout 的情况类似。</p><h2 id="跟-TCP-IP-学协议设计"><a href="#跟-TCP-IP-学协议设计" class="headerlink" title="跟 TCP/IP 学协议设计"></a>跟 TCP/IP 学协议设计</h2><p>如果仅仅是为了使用是 socket，我们大可以不去理会协议的细节。之所以推荐大家去看一看《TCP/IP 详解》，是因为它们有太多值得学习的地方。很多我们工作中遇到的问题，都可以在这里找到答案。</p><p>以下每一个小节的标题都是一个小问题，建议读者独立思考一下，再继续往下看。如果你发现你的答案比我的更好，请一定发送邮件到 ljtong64 AT gmail DOT com 告诉我。</p><h3 id="协议版本如何升级？"><a href="#协议版本如何升级？" class="headerlink" title="协议版本如何升级？"></a>协议版本如何升级？</h3><p>有这么一句流行的话：这个世界唯一不变的，就是变化。当我们对协议版本进行升级的时候，正确识别不同版本的协议对软件的兼容非常重要。那么，我们如何设计协议，才能够为将来的版本升级做准备呢？</p><p>答案可以在 IP 协议找到。</p><p>IP 协议的第一个字段叫 version，目前使用的是 4 或 6，分别表示 IPv4 和 IPv6。由于这个字段在协议的开头，接收端收到数据后，只要根据第一个字段的值就能够判断这个数据包是 IPv4 还是 IPv6。</p><p>再强调一下，这个字段在两个版本的IP协议都位于第一个字段，为了做兼容处理，对应的这个字段必须位于同一位置。文本协议（如，JSON、HTML）的情况类似。</p><h3 id="如何发送不定长数据的数据包"><a href="#如何发送不定长数据的数据包" class="headerlink" title="如何发送不定长数据的数据包"></a>如何发送不定长数据的数据包</h3><p>举个例子，我们用微信发送一条消息。这条消息的长度是不确定的，并且每条消息都有它的边界。我们如何来处理这个边界呢？</p><p>还是一样，看看 IP。IP 的头部有个 header length 和 data length 两个字段。通过添加一个 len 域，我们就能够把数据根据应用逻辑分开。</p><p>跟这个相对的，还有另一个方案，那就是在数据的末尾放置终止符。比方说，想 C 语言的字符串那样，我们在每个数据的末尾放一个 <code>\0</code> 作为终止符，用以标识一条消息的尾部。这个方法带来的问题是，用户的数据也可能存在 <code>\0</code>。此时，我们就需要对用户的数据进行<strong>转义</strong>。比方说，把用户数据的所有 <code>\0</code> 都变成 <code>\0\0</code>。读消息的过程总，如果遇到 <code>\0\0</code>，那它就代表 <code>\0</code>，如果只有一个 <code>\0</code>，那就是消息尾部。</p><p>使用 len 字段的好处是，我们不需要对数据进行转义。读取数据的时候，只要根据 len 字段，一次性把数据都读进来就好，效率会更高一些。</p><p>终止符的方案虽然要求我们对数据进行扫描，但是如果我们可能从任意地方开始读取数据，就需要这个终止符来确定哪里才是消息的开头了。</p><p>当然，这两个方法不是互斥的，可以一起使用。</p><h3 id="上传多个文件，只有所有文件都上传成功时才算成功"><a href="#上传多个文件，只有所有文件都上传成功时才算成功" class="headerlink" title="上传多个文件，只有所有文件都上传成功时才算成功"></a>上传多个文件，只有所有文件都上传成功时才算成功</h3><p>现在我们有一个需求，需要一次上传多个文件到服务器，只有在所有文件都上传成功的情况下，才算成功。我们该如何来实现呢？</p><p>IP 在数据报过大的时候，会把一个数据报拆分成多个，并设置一个 MF （more fragments）位，表示这个包只是被拆分后的数据的一部分。</p><p>好，我们也学一学 IP。这里，我们可以给每个文件从 0 开始编号。上传文件的同时，也携带这个编号，并额外附带一个 MF 标志。除了编号最大的文件，所有文件的 MF 标志都置位。因为 MF 没有置位的是最后一个文件，服务器就可以根据这个得出总共有多少个文件。</p><p>另一种不使用 MF 标志的方法是，我们在上传文件前，就告诉服务器总共有多少个文件。</p><p>如果读者对数据库比较熟悉，学数据库用事务来处理，也是可以的。这里就不展开讨论了。</p><h3 id="如何保证数据的有序性"><a href="#如何保证数据的有序性" class="headerlink" title="如何保证数据的有序性"></a>如何保证数据的有序性</h3><p>这里讲一个我曾经遇到过的面试题。现在有一个任务队列，多个工作线程从中取出任务并执行，执行结果放到一个结果队列中。先要求，放入结果队列的时候，顺序顺序需要跟从工作队列取出时的一样（也就是说，先取出的任务，执行结果需要先放入结果队列）。</p><p>我们看看 TCP/IP 是怎么处理的。IP 在发送数据的时候，不同数据报到达对端的时间是不确定的，后面发送的数据有可能较先到达。TCP 为了解决这个问题，给所发送数据的每个字节都赋了一个序列号，通过这个序列号，TCP 就能够把数据按原顺序重新组装。</p><p>一样，我们也给每个任务赋一个值，根据进入工作队列的顺序依次递增。工作线程完成任务后，在将结果放入结果队列前，先检查要放入对象的写一个序列号是不是跟自己的任务相同，如果不同，这个结果就不能放进去。此时，最简单的做法是等待，知道下一个可以放入队列的结果是自己所执行的那一个。但是，这个线程就没办法继续处理任务了。</p><p>更好的方法是，我们维护多一个结果队列的缓冲，这个缓冲里面的数据按序列号从小到大排序。工作线程要将结果放入，有两种可能：</p><ol><li>刚刚完成的任务刚好是下一个，将这个结果放入队列。然后从缓冲的头部开始，将所有可以放入结果队列的数据都放进去。</li><li>所完成的任务不能放入结果队列，这个时候就插入结果队列。然后，跟上一种情况一样，需要检查缓冲。</li></ol><p>如果测试表明，这个结果缓冲的数据不多，那么使用普通的链表就可以。如果数据比较多，可以使用一个最小堆。</p><h3 id="如何保证对方收到了消息"><a href="#如何保证对方收到了消息" class="headerlink" title="如何保证对方收到了消息"></a>如何保证对方收到了消息</h3><p>我们说，TCP 提供了可靠的传输。这样不就能够保证对方收到消息了吗？</p><p>很遗憾，其实不能。在我们往 socket 写入的数据，只要对端的内核收到后，就会返回 <code>ACK</code>，此时，socket 就认为数据已经写入成功。然而要注意的是，这里只是对方所运行的系统的内核成功收到了数据，并不表示应用程序已经成功处理了数据。</p><p>解决办法还是一样，我们学 <code>TCP</code>，添加一个应用层的 <code>APP ACK</code>。应用接收到消息并处理成功后，发送一个 <code>APP ACK</code> 给对方。</p><p>有了 <code>APP ACK</code>，我们需要处理的另一个问题是，如果对方真的没有收到，需要怎么做？</p><p>TCP 发送数据的时候，消息一样可能丢失。TCP 发送数据后，如果长时间没有收到对方的 <code>ACK</code>，就假设数据已经丢失，并重新发送。</p><p>我们也一样，如果长时间没有收到 <code>APP ACK</code>，就假设数据丢失，重新发送一个。</p><p><br><br></p><p>附：<br>[1] <a href="http://renyugang.io/post/75" target="_blank" rel="noopener">http://renyugang.io/post/75</a><br>[2] <a href="https://jekton.github.io/">https://jekton.github.io</a><br>[3] <a href="https://github.com/Jekton/Echo" target="_blank" rel="noopener">https://github.com/Jekton/Echo</a></p><hr><p>2019.5.5</p><p>前段时间经 @老A 同学反馈，修复了 Echo 程序一个竞争条件导致的心跳超时问题，见 commit <code>1cd262</code>。今天自己在某个项目上实际使用的时候，非常惭愧，又发现了一个超时相关的 bug（参见 commit <code>27923b</code>）。为了不给文章中的代码增加过多的复杂度（加上想悄悄偷个懒），就不更新文中的代码了。</p><p>尽管有 bug，但长连接的实现思路是没有问题的。如果读者在实际工作中需要用到，或者自己实现，或者参考我的代码，一定要参考 GitHub 仓库中最新的代码，而不是直接 copy 文章里的。</p>]]></content>
    
    <summary type="html">
    
      本篇我们先简单了解一下 TCP/IP，然后通过实现一个 echo 服务器来学习 Java 的 Socket API。最后我们聊聊偏高级一点点的 socket 长连接和协议设计。
    
    </summary>
    
      <category term="Java" scheme="https://jekton.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jekton.github.io/tags/Java/"/>
    
      <category term="Socket" scheme="https://jekton.github.io/tags/Socket/"/>
    
  </entry>
  
</feed>
