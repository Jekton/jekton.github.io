<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jekton</title>
  
  <subtitle>Keep on Learning, Keep on Thinking</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jekton.github.io/"/>
  <updated>2018-09-05T15:05:36.611Z</updated>
  <id>https://jekton.github.io/</id>
  
  <author>
    <name>Jekton</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dart 语言快速入门</title>
    <link href="https://jekton.github.io/2018/09/04/dart-tutorial/"/>
    <id>https://jekton.github.io/2018/09/04/dart-tutorial/</id>
    <published>2018-09-04T01:49:17.000Z</published>
    <updated>2018-09-05T15:05:36.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<code>玉刚说写作平</code>台提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>本篇文章假定读者有一定的编程经验。通过快速浏览 Dart 的一些基础特性，让读者具备使用它进行开发的基本能力。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> done = <span class="keyword">true</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">double</span> x = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">bool</span> visible = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> amount = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">double</span> y = <span class="number">2.7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">bool</span> debug = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> sum = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> z = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure><p>跟常用的其他语言不同，Dart 没有 <code>byte</code>、<code>char</code> 和 <code>float</code>，<code>int</code>、<code>double</code> 都是 64 位。<code>final</code> 跟 Java 里的 final 一样，表示一个运行时常量（在程序运行的时候赋值，赋值后值不再改变）。<code>const</code> 表示一个编译时常量，在程序编译的时候它的值就确定了。</p><p>如果你觉得每次写变量类型太麻烦，你应该会喜欢 Dart 的类型推断功能：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> visible = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">final</span> amount = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">final</span> y = <span class="number">2.7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> sum = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> z = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure></p><p>Dart 里所有的东西都是对象，包括 <code>int</code>、函数。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">' foo'</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = str.toUpperCase();</span><br><span class="line"><span class="keyword">var</span> str3 = str.trim();</span><br><span class="line"><span class="keyword">assert</span>(str == str2);</span><br><span class="line"><span class="keyword">assert</span>(!identical(str, str2));</span><br></pre></td></tr></table></figure><p>Dart 里的 <code>String</code> 跟 Java 中的一样，是不可变对象；不同的是，检测两个 <code>String</code> 的内容是否一样事，我们使用 <code>==</code> 进行比较；如果要测试两个对象是否是同一个对象（indentity test），使用 <code>identical</code> 函数。</p><h2 id="List、Map-和-Set"><a href="#List、Map-和-Set" class="headerlink" title="List、Map 和 Set"></a>List、Map 和 Set</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数创建对象</span></span><br><span class="line"><span class="comment">// 跟 var list = new List&lt;int&gt;(); 一样</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字面量创建对象，list 的泛型参数可以从变量定义推断出来。</span></span><br><span class="line"><span class="comment">// 推荐使用字面量方式创建对象</span></span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 没有元素，显式指定泛型参数为 int</span></span><br><span class="line"><span class="keyword">var</span> list3 = &lt;<span class="built_in">int</span>&gt;[];</span><br><span class="line">list3.add(<span class="number">1</span>);</span><br><span class="line">list3.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list4 = <span class="keyword">const</span>[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// list4 指向的是一个常量，我们不能给它添加元素（不能修改它）</span></span><br><span class="line">list4.add(<span class="number">3</span>);       <span class="comment">// error</span></span><br><span class="line"><span class="comment">// list4 本身不是一个常量，所以它可以指向另一个对象</span></span><br><span class="line">list4 = [<span class="number">4</span>, <span class="number">5</span>];     <span class="comment">// it's fine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list5 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 相当于 const list5 = const[1, 2];</span></span><br><span class="line">list5.add(<span class="number">3</span>);       <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dart 同样提供了 for-in 循环。</span></span><br><span class="line"><span class="comment">// 因为语音设计时就考虑到了这个需求，in 在 Dart 里是一个关键字</span></span><br><span class="line"><span class="keyword">var</span> list6 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">in</span> list6) &#123;</span><br><span class="line">  <span class="built_in">print</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Dart 2 里，创建对象时可以省略 <code>new</code> 关键字，也推荐省略 <code>new</code>。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"><span class="keyword">set</span>.add(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">set</span>.add(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="keyword">set</span>.contains(<span class="string">'foo'</span>));</span><br></pre></td></tr></table></figure><p>我们只能通过 <code>Set</code> 的构造函数创建实例。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">map[<span class="string">'foo'</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="string">'bar'</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">map[<span class="string">'foo'</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 对应的 key 不存在时，返回 null</span></span><br><span class="line"><span class="keyword">if</span> (map[<span class="string">'foobar'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'map does not contain foobar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map2 = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">'foo'</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">'bar'</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> map3 = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="dynamic-和-Object"><a href="#dynamic-和-Object" class="headerlink" title="dynamic 和 Object"></a>dynamic 和 Object</h2><p>前面我们说过，Dart 里所有东西都是对象。所有这些对象的父类就是 <code>Object</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> o = <span class="string">'string'</span>;</span><br><span class="line">o = <span class="number">42</span>;</span><br><span class="line">o.toString();   <span class="comment">// 我们只能调用 Object 支持的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic</span> obj = <span class="string">'string'</span>;</span><br><span class="line">obj[<span class="string">'foo'</span>] = <span class="number">4</span>;  <span class="comment">// 可以编译通过，但在运行时会抛出 NoSuchMethodError</span></span><br></pre></td></tr></table></figure><p><code>Object</code> 和 <code>dynamic</code> 都使得我们可以接收任意类型的参数，但两者的区别非常的大。</p><p>使用 <code>Object</code> 时，我们只是在说接受任意类型，我们需要的是一个 <code>Object</code>。类型系统会保证其类型安全。</p><p>使用 <code>dynamic</code> 则是告诉编译器，我们知道自己在做什么，<strong>不用做类型检测</strong>。当我们调用一个不存在的方法时，会执行 <code>noSuchMethod()</code> 方法，默认情况下（在 <code>Object</code> 里实现）它会抛出 <code>NoSuchMethodError</code>。</p><p>为了在运行时检测进行类型检测，Dart 提供了一个关键字 <code>is</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> obj = &lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;) &#123;</span><br><span class="line">  <span class="comment">// 进过类型判断后，Dart 知道 obj 是一个 Map&lt;String, int&gt;，</span></span><br><span class="line">  <span class="comment">// 所以这里不用强制转换 obj 的类型，即使我们声明 obj 为 Object。</span></span><br><span class="line">  obj[<span class="string">'foo'</span>] = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然 Dart 也提供了 as 让我们进行类型的强制转换，但为了进来更安全</span></span><br><span class="line"><span class="comment">// 的转换，更推荐使用 is</span></span><br><span class="line"><span class="keyword">var</span> map = obj <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;;</span><br></pre></td></tr></table></figure></p><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> success = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (success) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'done'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'fail'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  sum += j;</span><br><span class="line">  ++j;</span><br><span class="line">&#125; <span class="keyword">while</span> (j &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (sum-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> type = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的 <code>if/else</code>，<code>do while</code>，<code>while</code> 和 <code>switch</code> 在 Dart 里面都支持。<code>switch</code> 也支持 <code>String</code> 和 <code>enum</code>。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>最普通的函数看起来跟 Java 里的一样：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> foo(<span class="built_in">int</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dart 也支持可选参数：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(foo(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> foo(<span class="built_in">int</span> x, [<span class="built_in">int</span> y]) &#123;</span><br><span class="line">  <span class="comment">// 是的，int 也可以是 null</span></span><br><span class="line">  <span class="keyword">if</span> (y != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>默认参数也是支持的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> foo(<span class="built_in">int</span> x, [<span class="built_in">int</span> y = <span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还能用具名参数（named parameters）：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo(x: <span class="number">1</span>, y: <span class="number">2</span>));</span><br><span class="line">  <span class="comment">// 具名参数的顺序可以是任意的</span></span><br><span class="line">  <span class="built_in">print</span>(foo(y: <span class="number">3</span>, x: <span class="number">4</span>));</span><br><span class="line">  <span class="comment">// 所有的具名参数都是可选的，这个调用是合法的，但它会导致 foo() 在运行时抛异常</span></span><br><span class="line">  <span class="built_in">print</span>(foo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> foo(&#123;<span class="built_in">int</span> x, <span class="built_in">int</span> y&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具名参数也可以有默认参数：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo(x: <span class="number">1</span>, y: <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(foo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> foo(&#123;<span class="built_in">int</span> x = <span class="number">0</span>, <span class="built_in">int</span> y = <span class="number">0</span>&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果想告诉用户某个具名参数是必须的，可以使用注解 <code>@required</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> foo(&#123;<span class="meta">@required</span> <span class="built_in">int</span> x, <span class="meta">@required</span> <span class="built_in">int</span> y&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>@required</code> 是 <code>meta</code> 包里提供的 API，更多的信息读者可以查看 <a href="https://pub.dartlang.org/packages/meta" target="_blank" rel="noopener">https://pub.dartlang.org/packages/meta</a>。</p><p>函数还可以在函数的内部定义：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typedef 在 Dart 里面用于定义函数类型的别名</span></span><br><span class="line"><span class="keyword">typedef</span> Adder = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">Adder makeAdder(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="built_in">int</span> adder(<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + extra;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> adder = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p>像上面这样简单的函数，我们还可以使用 lambda：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Adder = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">Adder makeAdder(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + extra;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 如果只有一个语句，我们可以使用下面这种更为简洁的形式</span></span><br><span class="line">  <span class="comment">// return (int x, int y) =&gt; x + y + extra;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> adder = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dart 里面不仅变量支持类型推断，lambda 的参数也支持自动推断。上面的代码还可以进一步简化为：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Adder = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">int</span>, <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">Adder makeAdder(<span class="built_in">int</span> extra) &#123;</span><br><span class="line">  <span class="comment">// 我们要返回的类型是 Adder，所以 Dart 知道 x, y 都是 int</span></span><br><span class="line">  <span class="keyword">return</span> (x, y) =&gt; x + y + extra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> adder = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>美中不足的是，Dart 不支持函数的重载。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>抛出异常：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> Exception(<span class="string">'put your error message here'</span>);</span><br></pre></td></tr></table></figure></p><p>捕获异常：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 捕获特定类型的异常</span></span><br><span class="line">&#125; on FormatException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 捕获特定类型的异常，但不需要这个对象</span></span><br><span class="line">&#125; on Exception &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line"><span class="comment">// 捕获所有异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟 Java 不同的是，Dart 可以抛出任意类型的对象：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>定义一个类：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> someConst = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="comment">// 成员变量也可以是 final 的</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point2D(<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于这种初始化方式很常见，Dart 提供了更简洁的方式：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point2d</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  point2d(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外，还可以使用初始化列表（initializer list）对对象进行初始化：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于是在 initializer list 中，Dart 知道第一个 x 是 this.x，</span></span><br><span class="line">  <span class="comment">// 第二个 x 是构造函数的参数</span></span><br><span class="line">  Point2D(<span class="built_in">int</span> x, <span class="built_in">int</span> y) : x = x, y = y &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>initializer list 会在构造函数的函数体运行前执行。</p><p>Dart 具有垃圾收集功能，对象的使用跟 Java 里几乎是一样的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point2D(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  point.x = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">print</span>(point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">  Point2D(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有的类都继承自 Object，toString() 是 Object 中的方法</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="comment">// 在字符串的内部可以通过 $&#123;expression&#125; 的方式插入值，如果</span></span><br><span class="line">    <span class="comment">// expression 是一个变量，可以省略花括号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Point2D&#123;x=$x, y=$y&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// Point2D&#123;x=4, y=2&#125;</span></span><br></pre></td></tr></table></figure></p><p>Dart 使用 package 的概念来管理源码和可见性。它没有 <code>public</code>、<code>private</code> 之类的访问权限控制符，默认情况下，所有的符号都是公开的。如果我们不想某个变量对包的外部可见，可以使用下划线开头来给变量命名。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们使用 Dart 的访问控制，实现一个带偏移量的 Point：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OffsetPoint</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _x;</span><br><span class="line">  <span class="built_in">int</span> _y;</span><br><span class="line">  <span class="built_in">int</span> offset;</span><br><span class="line"></span><br><span class="line">  OffsetPoint(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> offset)</span><br><span class="line">      : _x = x, _y = y, offset = offset &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义一个 getter</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> x =&gt; _x + offset;</span><br><span class="line">  <span class="comment">// getter 不能有参数，连括号都省掉了</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> y &#123;</span><br><span class="line">    <span class="keyword">return</span> _y + offset;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义 setter</span></span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">set</span> x (<span class="built_in">int</span> x) =&gt; _x = x;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">set</span> y (<span class="built_in">int</span> y) =&gt; _y = y;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"OffsetPoint&#123;x=$x, y=$y&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = OffsetPoint(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="comment">// 使用 getter/setter 时，就像它是一个普通的成员变量</span></span><br><span class="line">  <span class="built_in">print</span>(point.x)</span><br><span class="line">  <span class="built_in">print</span>(point);</span><br><span class="line">  point.x = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">print</span>(point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// OffsetPoint&#123;x=11, y=12&#125;</span></span><br><span class="line"><span class="comment">// OffsetPoint&#123;x=14, y=12&#125;</span></span><br></pre></td></tr></table></figure></p><p>在 Dart 里继承对象也很简单：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">  Point2D(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> <span class="keyword">extends</span> <span class="title">Point2D</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> z;</span><br><span class="line">  <span class="comment">// 父类的构造函数只能在 initializer list 里调用</span></span><br><span class="line">  Point3D(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> z): z = z, <span class="keyword">super</span>(x, y) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是对象构造时它跟 Java、C++ 都不太一样：</p><ol><li>先执行子类 initializer list，但只初始化自己的成员变量</li><li>初始化父类的成员变量</li><li>执行父类构造函数的函数体</li><li>执行之类构造函数的函数体</li></ol><p>基于这个初始化顺序，推荐是把 <code>super()</code> 放在 initializer list 的最后。此外，在 initializer list 里不能访问 <code>this</code>（也就是说，只能调用静态方法）。</p><p>虽然 Dart 是单继承的，但它也提供了一定程度的多重继承支持：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bark</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> bark() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'woof'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> <span class="keyword">extends</span> <span class="title">Point2D</span> <span class="title">with</span> <span class="title">Bark</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> z;</span><br><span class="line">  <span class="comment">// 父类的构造函数只能在 initializer list 里调用</span></span><br><span class="line">  Point3D(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> z): z = z, <span class="keyword">super</span>(x, y) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有其他类需要继承，所以直接 extends Bark 就可以了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bark</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = Point3D(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  p.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dart 把支持多重继承的类叫做 mixin。更详细的介绍，读者可以参考<a href="https://www.dartlang.org/articles/language/mixins" target="_blank" rel="noopener">https://www.dartlang.org/articles/language/mixins</a>。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  S first;</span><br><span class="line">  T second;</span><br><span class="line">  Pair(<span class="keyword">this</span>.first, <span class="keyword">this</span>.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = Pair(<span class="string">'hello'</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(p <span class="keyword">is</span> Pair&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;);</span><br><span class="line">  <span class="comment">// is! 也是 Dart 的运算符，下面的语句跟 !(p is Pair&lt;int, int&gt;) 是一样的，</span></span><br><span class="line">  <span class="comment">// 但 is! 读起来跟像英语</span></span><br><span class="line">  <span class="built_in">print</span>(p <span class="keyword">is</span>! Pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;);</span><br><span class="line">  <span class="built_in">print</span>(p <span class="keyword">is</span> Pair);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>跟 Java 不同，Dart 的泛型参数类型在运行时是保留的。</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Dart 是单线程的，主线程由一个事件循环来执行（类似 Android 的主线程）。对于异步代码，我们通过 <code>Future</code> 来获取结果：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import 语句用于导入一个包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  file.exists()</span><br><span class="line">      .then((exists) =&gt; <span class="built_in">print</span>(<span class="string">'file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>))</span><br><span class="line">      .catchError((e) =&gt; <span class="built_in">print</span>(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dart 2 提供了 async 函数，用来简化这种编程范式。下面这段代码的效果跟上面是一样的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是要注意，上面两段代码并不是完全一样的：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  foo();</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> bar() &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  file.exists()</span><br><span class="line">      .then((exists) =&gt; <span class="built_in">print</span>(<span class="string">'bar: file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>))</span><br><span class="line">      .catchError((e) =&gt; <span class="built_in">print</span>(e));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'bar: after file.exists() returned'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(<span class="string">'path-to-your-file'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'bar: file <span class="subst">$&#123;exists ? <span class="string">'exists'</span> : <span class="string">'not exists'</span>&#125;</span>'</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'bar: after file.exists() returned'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种可能的结果：</span></span><br><span class="line"><span class="comment">// bar: after file.exists() returned</span></span><br><span class="line"><span class="comment">// foo: file not exists</span></span><br><span class="line"><span class="comment">// foo: after file.exists() returned</span></span><br><span class="line"><span class="comment">// bar: file not exists</span></span><br></pre></td></tr></table></figure></p><p>这里的关键在于，bar 函数里面，<code>file.exists()...</code> 执行完后，会马上执行下面的语句；而 foo 则会等待结果，然后才继续执行。关于 Future 的更多的细节，<strong>强烈建议</strong>读者阅读<a href="https://webdev.dartlang.org/articles/performance/event-loop" target="_blank" rel="noopener">https://webdev.dartlang.org/articles/performance/event-loop</a>。</p><p>最后需要说明的是，Dart 的生成器、<code>Stream</code> 在这里我们并没有介绍，读者可以参考 <a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">https://www.dartlang.org/guides/language/language-tour</a>。此外，Dart 官网还有许多资源等待读者去发掘。</p>]]></content>
    
    <summary type="html">
    
      本篇文章假定读者有一定的编程经验。通过快速浏览 Dart 的一些基础特性，让读者具备使用它进行开发的基本能力。
    
    </summary>
    
      <category term="Dart" scheme="https://jekton.github.io/categories/Dart/"/>
    
    
      <category term="Dart" scheme="https://jekton.github.io/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（4）- 文件、存储和网络</title>
    <link href="https://jekton.github.io/2018/09/01/flutter-io-basic/"/>
    <id>https://jekton.github.io/2018/09/01/flutter-io-basic/</id>
    <published>2018-08-31T23:29:39.000Z</published>
    <updated>2018-09-02T12:34:06.306Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<code>玉刚说写作平</code>台提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>我们将在<a href="2018/08/29/flutter-ux-basic">Flutter 开发（3）- 交互、动画、手势和事件处理</a>的基础上，继续开发一个 echo 客户端。由于日常开发中 HTTP 比 socket 更常见，我们的 echo 客户端将会使用 HTTP 协议跟服务端通信。Echo 服务器也会使用 Dart 来实现。</p><h1 id="HTTP-服务端"><a href="#HTTP-服务端" class="headerlink" title="HTTP 服务端"></a>HTTP 服务端</h1><p>在开始之前，你可以在 GitHub 上找到上篇文章的代码，我们将在它的基础上进行开发。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ux-basic</span><br></pre></td></tr></table></figure></p><h2 id="服务端架构"><a href="#服务端架构" class="headerlink" title="服务端架构"></a>服务端架构</h2><p>首先我们来看看服务端的架构（说是架构，但其实非常的简单，或者说很简陋）：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> port;</span><br><span class="line">  HttpServer httpServer;</span><br><span class="line">  <span class="comment">// 在 Dart 里面，函数也是 first class object，所以我们可以直接把</span></span><br><span class="line">  <span class="comment">// 函数放到 Map 里面</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">void</span> <span class="built_in">Function</span>(HttpRequest)&gt; routes;</span><br><span class="line"></span><br><span class="line">  HttpEchoServer(<span class="keyword">this</span>.port) &#123;</span><br><span class="line">    _initRoutes();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _initRoutes() &#123;</span><br><span class="line">    routes = &#123;</span><br><span class="line">      <span class="comment">// 我们只支持 path 为 '/history' 和 '/echo' 的请求。</span></span><br><span class="line">      <span class="comment">// history 用于获取历史记录；</span></span><br><span class="line">      <span class="comment">// echo 则提供 echo 服务。</span></span><br><span class="line">      <span class="string">'/history'</span>: _history,</span><br><span class="line">      <span class="string">'/echo'</span>: _echo,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个 Future，这样客户端就能够在 start 完成后做一些事</span></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 HttpServer</span></span><br><span class="line">    httpServer = <span class="keyword">await</span> HttpServer.bind(InternetAddress.loopbackIPv4, port);</span><br><span class="line">    <span class="comment">// 2. 开始监听客户请求</span></span><br><span class="line">    <span class="keyword">return</span> httpServer.listen((request) &#123;</span><br><span class="line">      <span class="keyword">final</span> path = request.uri.path;</span><br><span class="line">      <span class="keyword">final</span> handler = routes[path];</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler(request);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 给客户返回一个 404</span></span><br><span class="line">        request.response.statusCode = HttpStatus.notFound;</span><br><span class="line">        request.response.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _history(HttpRequest request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> close() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> server = httpServer;</span><br><span class="line">    httpServer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">await</span> server?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在服务端框架里，我们把支持的所有路径都加到 routes 里面，当收到客户请求的时候，只需要直接从 routes 里取出对应的处理函数，把请求分发给他就可以了。</p><h2 id="将对象序列化为-JSON"><a href="#将对象序列化为-JSON" class="headerlink" title="将对象序列化为 JSON"></a>将对象序列化为 JSON</h2><p>为了把 Message 对象序列化为 JSON，这里我们对 Message 做一些小修改：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Message(<span class="keyword">this</span>.msg, <span class="keyword">this</span>.timestamp);</span><br><span class="line"></span><br><span class="line">  Message.create(<span class="built_in">String</span> msg)</span><br><span class="line">      : msg = msg, timestamp = <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; toJson() =&gt; &#123;</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">"$msg"</span>,</span><br><span class="line">    <span class="string">"timestamp"</span>: timestamp</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Message&#123;msg: $msg, timestamp: $timestamp&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们加入一个 toJson 方法。下面是服务端的 _echo 方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> GET = <span class="string">'GET'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> POST = <span class="string">'POST'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  _unsupportedMethod(HttpRequest request) &#123;</span><br><span class="line">    request.response.statusCode = HttpStatus.methodNotAllowed;</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.method != POST) &#123;</span><br><span class="line">      _unsupportedMethod(request);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取从客户端 POST 请求的 body，更多的知识，参考</span></span><br><span class="line">    <span class="comment">// https://www.dartlang.org/tutorials/dart-vm/httpserver</span></span><br><span class="line">    <span class="built_in">String</span> body = <span class="keyword">await</span> request.transform(utf8.decoder).join();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> message = Message.create(body);</span><br><span class="line">      messages.add(message);</span><br><span class="line">      request.response.statusCode = HttpStatus.ok;</span><br><span class="line">      <span class="comment">// json 是 convert 包里的对象，encode 方法还有第二个参数 toEncodable。当遇到对象不是</span></span><br><span class="line">      <span class="comment">// Dart 的内置对象时，如果提供这个参数，就会调用它对对象进行序列化；这里我们没有提供，</span></span><br><span class="line">      <span class="comment">// 所以 encode 方法会调用对象的 toJson 方法，这个方法在前面我们已经定义了</span></span><br><span class="line">      <span class="keyword">var</span> data = json.encode(message);</span><br><span class="line">      <span class="comment">// 把响应写回给客户端</span></span><br><span class="line">      request.response.write(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      request.response.statusCode = HttpStatus.badRequest;</span><br><span class="line">    &#125;</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果读者对服务端编程没有太大兴趣或不太了解，这里重点关注如果把对象序列化为 JSON 就可以了。下面是客户端部分。</p><h1 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h1><p>我们的 echo 服务器使用了 dart:io 包里面 HttpServer 来开发。对应的，我们也可以使用这个包里的 HttpRequest 来执行 HTTP 请求，但这里我们并不打算这么做。第三方库 http 提供了更简单易用的接口。</p><p>首先，别忘了把依赖添加到 pubspec 里：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pubspec.yaml</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  http:</span> <span class="string">^0.11.3+17</span></span><br></pre></td></tr></table></figure></p><p>客户端实现如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:http/http.dart'</span> <span class="keyword">as</span> http;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> port;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> host;</span><br><span class="line"></span><br><span class="line">  HttpEchoClient(<span class="keyword">this</span>.port): host = <span class="string">'http://localhost:$port'</span>;</span><br><span class="line"></span><br><span class="line">  Future&lt;Message&gt; send(<span class="built_in">String</span> msg) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// http.post 用来执行一个 HTTP POST 请求。</span></span><br><span class="line">    <span class="comment">// 它的 body 参数是一个 dynamic，可以支持不同类型的 body，这里我们</span></span><br><span class="line">    <span class="comment">// 只是直接把客户输入的消息发给服务端就可以了。由于 msg 是一个 String，</span></span><br><span class="line">    <span class="comment">// post 方法会自动设置 HTTP 的 Content-Type 为 text/plain</span></span><br><span class="line">    <span class="keyword">final</span> response = <span class="keyword">await</span> http.post(host + <span class="string">'/echo'</span>, body: msg);</span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; msgJson = json.decode(response.body);</span><br><span class="line">      <span class="comment">// Dart 并不知道我们的 Message 长什么样，我们需要自己通过</span></span><br><span class="line">      <span class="comment">// Map&lt;String, dynamic&gt; 来构造对象</span></span><br><span class="line">      <span class="keyword">var</span> message = Message.fromJson(msgJson);</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> timestamp;</span><br><span class="line"></span><br><span class="line">  Message.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; json)</span><br><span class="line">    : msg = json[<span class="string">'msg'</span>], timestamp = json[<span class="string">'timestamp'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，让我们把他们和上一节的 UI 结合到一起。首先启动服务器，然后创建客户端：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HttpEchoServer _server;</span><br><span class="line">HttpEchoClient _client;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> port = <span class="number">6060</span>;</span><br><span class="line">    _server = HttpEchoServer(port);</span><br><span class="line">    <span class="comment">// initState 不是一个 async 函数，这里我们不能直接 await _server.start(),</span></span><br><span class="line">    <span class="comment">// future.then(...) 跟 await 是等价的</span></span><br><span class="line">    _server.start().then((_) &#123;</span><br><span class="line">      <span class="comment">// 等服务器启动后才创建客户端</span></span><br><span class="line">      _client = HttpEchoClient(port);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">          );</span><br><span class="line">          <span class="comment">// 以下是修改了的地方</span></span><br><span class="line">          <span class="keyword">if</span> (_client == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 现在，我们不是直接构造一个 Message，而是通过 _client 把消息</span></span><br><span class="line">          <span class="comment">// 发送给服务器</span></span><br><span class="line">          <span class="keyword">var</span> msg = <span class="keyword">await</span> _client.send(result);</span><br><span class="line">          <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            messageListKey.currentState.addMessage(msg);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            debugPrint(<span class="string">'fail to send $result'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成，在做了这么多工作以后，我们的应用现在是真正的 echo 客户端了，虽然看起来跟之前没什么两样。接下来，我们就做一些跟之前不一样的——把历史记录保存下来。</p><h1 id="历史记录存储、恢复"><a href="#历史记录存储、恢复" class="headerlink" title="历史记录存储、恢复"></a>历史记录存储、恢复</h1><h2 id="获取应用的存储路径"><a href="#获取应用的存储路径" class="headerlink" title="获取应用的存储路径"></a>获取应用的存储路径</h2><p>为了获得应用的文件存储路径，我们引入多一个库：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pubspec.yaml</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  path_provider:</span> <span class="string">^0.4.1</span></span><br></pre></td></tr></table></figure></p><p>通过它我们可以拿到应用的 file、cache 和 external storage 的路径：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:path_provider/path_provider.dart'</span> <span class="keyword">as</span> path_provider;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> historyFilepath;</span><br><span class="line"></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    historyFilepath = <span class="keyword">await</span> _historyPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; _historyPath() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 获取应用私有的文件目录</span></span><br><span class="line">    <span class="keyword">final</span> directory = <span class="keyword">await</span> path_provider.getApplicationDocumentsDirectory();</span><br><span class="line">    <span class="keyword">return</span> directory.path + <span class="string">'/messages.json'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="保存历史记录"><a href="#保存历史记录" class="headerlink" title="保存历史记录"></a>保存历史记录</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _echo(HttpRequest request) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原谅我，为了简单，我们就多存几次吧</span></span><br><span class="line">    _storeMessages();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; _storeMessages() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// json.encode 支持 List、Map</span></span><br><span class="line">      <span class="keyword">final</span> data = json.encode(messages);</span><br><span class="line">      <span class="comment">// File 是 dart:io 里的类</span></span><br><span class="line">      <span class="keyword">final</span> file = File(historyFilepath);</span><br><span class="line">      <span class="keyword">final</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">      <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">        <span class="keyword">await</span> file.create();</span><br><span class="line">      &#125;</span><br><span class="line">      file.writeAsString(data);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 虽然文件操作方法都是异步的，我们仍然可以通过这种方式 catch 到</span></span><br><span class="line">    <span class="comment">// 他们抛出的异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'_storeMessages: $e'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加载历史记录"><a href="#加载历史记录" class="headerlink" title="加载历史记录"></a>加载历史记录</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Future start() <span class="keyword">async</span> &#123;</span><br><span class="line">    historyFilepath = <span class="keyword">await</span> _historyPath();</span><br><span class="line">    <span class="comment">// 在启动服务器前先加载历史记录</span></span><br><span class="line">    <span class="keyword">await</span> _loadMessages();</span><br><span class="line">    httpServer = <span class="keyword">await</span> HttpServer.bind(InternetAddress.loopbackIPv4, port);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future _loadMessages() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> file = File(historyFilepath);</span><br><span class="line">      <span class="keyword">var</span> exists = <span class="keyword">await</span> file.exists();</span><br><span class="line">      <span class="keyword">if</span> (!exists) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> content = <span class="keyword">await</span> file.readAsString();</span><br><span class="line">      <span class="keyword">var</span> list = json.decode(content);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> msg <span class="keyword">in</span> list) &#123;</span><br><span class="line">        <span class="keyword">var</span> message = Message.fromJson(msg);</span><br><span class="line">        messages.add(message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'_loadMessages: $e'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们来实现 _history 函数：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _history(HttpRequest request) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.method != GET) &#123;</span><br><span class="line">      _unsupportedMethod(request);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> historyData = json.encode(messages);</span><br><span class="line">    request.response.write(historyData);</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>_history 的实现很直接，我们只是把 messages 全都返回给客户端。</p><p>接下来是客户端部分：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpEchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">List</span>&lt;Message&gt;&gt; getHistory() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// http 包的 get 方法用来执行 HTTP GET 请求</span></span><br><span class="line">      <span class="keyword">final</span> response = <span class="keyword">await</span> http.<span class="keyword">get</span>(host + <span class="string">'/history'</span>);</span><br><span class="line">      <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _decodeHistory(response.body);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'getHistory: $e'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;Message&gt; _decodeHistory(<span class="built_in">String</span> response) &#123;</span><br><span class="line">    <span class="comment">// JSON 数组 decode 出来是一个 &lt;Map&lt;String, dynamic&gt;&gt;[]</span></span><br><span class="line">    <span class="keyword">var</span> messages = json.decode(response);</span><br><span class="line">    <span class="keyword">var</span> list = &lt;Message&gt;[];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> msgJson <span class="keyword">in</span> messages) &#123;</span><br><span class="line">      list.add(Message.fromJson(msgJson));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> port = <span class="number">6060</span>;</span><br><span class="line">    _server = HttpEchoServer(port);</span><br><span class="line">    _server.start().then((_) &#123;</span><br><span class="line">      <span class="comment">// 我们等服务器启动后才创建客户端</span></span><br><span class="line">      _client = HttpEchoClient(port);</span><br><span class="line">      <span class="comment">// 创建客户端后马上拉取历史记录</span></span><br><span class="line">      _client.getHistory().then((list) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          messages.addAll(list);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>最后需要做的是，在 APP 退出后关闭服务器。这就要求我们能够收到应用生命周期变化的通知。为了达到这个目的，Flutter 为我们提供了 WidgetsBinding 类（虽然没有 Android 的 Lifecycle 那么好用就是啦）。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了使用 WidgetsBinding，我们继承 WidgetsBindingObserver 然后覆盖相应的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    _server.start().then((_) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册生命周期回调</span></span><br><span class="line">      WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == AppLifecycleState.paused) &#123;</span><br><span class="line">      <span class="keyword">var</span> server = _server;</span><br><span class="line">      _server = <span class="keyword">null</span>;</span><br><span class="line">      server?.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们的应用是这个样子的：<br><img src="/2018/09/01/flutter-io-basic/flutter-echo-demo.gif" alt="flutter-echo-demo"></p><p>所有的代码可以在 GitHub 上找到：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout io-basic</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      我们将在 flutter-ux-basic 一文的基础上，继续开发一个 echo 客户端。由于日常开发中 HTTP 比 socket 更常见，我们的 echo 客户端将会使用 HTTP 协议跟服务端通信。Echo 服务器也会使用 Dart 来实现。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（3）- 交互、动画、手势和事件处理</title>
    <link href="https://jekton.github.io/2018/08/29/flutter-ux-basic/"/>
    <id>https://jekton.github.io/2018/08/29/flutter-ux-basic/</id>
    <published>2018-08-29T01:06:41.000Z</published>
    <updated>2018-08-31T00:40:43.744Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<code>玉刚说写作平</code>台提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>在这一篇文章中，我们将通过实现一个 echo 客户端的前端页面来学习如何在 Flutter 中进行页面的跳转、手势事件处理。至于动画，我们弄一个小圆点，让他沿着正弦曲线运动，同时改变自身的颜色。</p><h1 id="手势处理、获取文本"><a href="#手势处理、获取文本" class="headerlink" title="手势处理、获取文本"></a>手势处理、获取文本</h1><p>本节我们来实现一个用户输入的页面。UI 很简单，就是一个文本框和一个按钮。</p><p>为了获取文本，我们可以使用 <code>TextField</code> 并给它设置一个 <code>TextEditingController</code>。通过这个 <code>controller</code>，我们就能够拿到输入框中的文本。由于这里需要响应用户事件，必须使用 <code>StatefulWidget</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageForm</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _MessageFormState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageForm</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> editController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象被从 widget 树里永久移除的时候调用 dispose 方法（可以理解为对象要销毁了）</span></span><br><span class="line">  <span class="comment">// 这里我们需要主动再调用 editController.dispose() 以释放资源</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    editController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Padding(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">      child: Row(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// 我们让输入框占满一行里除按钮外的所有空间</span></span><br><span class="line">          Expanded(</span><br><span class="line">            child: Container(</span><br><span class="line">              margin: EdgeInsets.only(right: <span class="number">8.0</span>),</span><br><span class="line">              child: TextField(</span><br><span class="line">                decoration: InputDecoration(</span><br><span class="line">                  hintText: <span class="string">'Input message'</span>,</span><br><span class="line">                  contentPadding: EdgeInsets.all(<span class="number">0.0</span>),</span><br><span class="line">                ),</span><br><span class="line">                style: TextStyle(</span><br><span class="line">                  fontSize: <span class="number">22.0</span>,</span><br><span class="line">                  color: Colors.black54</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// 获取文本的关键，这里要设置一个 controller</span></span><br><span class="line">                controller: editController,</span><br><span class="line">                <span class="comment">// 自动获取焦点。这样在页面打开时就会自动弹出输入法</span></span><br><span class="line">                autofocus: <span class="keyword">true</span>,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          InkWell(</span><br><span class="line">            onTap: () =&gt; debugPrint(<span class="string">'send: <span class="subst">$&#123;editController.text&#125;</span>'</span>),</span><br><span class="line">            onDoubleTap: () =&gt; debugPrint(<span class="string">'double tapped'</span>),</span><br><span class="line">            onLongPress: () =&gt; debugPrint(<span class="string">'long pressed'</span>),</span><br><span class="line">            child: Container(</span><br><span class="line">              padding: EdgeInsets.symmetric(vertical: <span class="number">10.0</span>, horizontal: <span class="number">16.0</span>),</span><br><span class="line">              decoration: BoxDecoration(</span><br><span class="line">                color: Colors.black12,</span><br><span class="line">                borderRadius: BorderRadius.circular(<span class="number">5.0</span>)</span><br><span class="line">              ),</span><br><span class="line">              child: Text(<span class="string">'Send'</span>),</span><br><span class="line">            ),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UX demo'</span>,</span><br><span class="line">      home: AddMessageScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMessageScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Add message'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: MessageForm(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的代码其实没有包含太多的新知识，我们只需要机械地加入一个 <code>controller</code> 就可以拿到输入框中的文本了。就按钮而言，这里本应该使用 <code>RaisedButton</code> 或 <code>FlatButton</code>。为了演示如何监听手势事件，我们这里故意自己用 <code>Container</code> 做了一个按钮，然后通过 <code>InkWell</code> 监听手势事件。<code>InkWell</code> 除了上面展示的几个事件外，还带有一个水波纹效果。如果不需要这个水波纹效果，读者可以使用支持更多手势事件的 G<code>estureDetector</code>。</p><h1 id="在页面间跳转"><a href="#在页面间跳转" class="headerlink" title="在页面间跳转"></a>在页面间跳转</h1><p>我们知道，Flutter 里所有的东西都是 <code>widget</code>，所以，一个页面，也是 <code>widget</code>。我们的 echo 客户端共有两个页面，一个用于展示所有的消息，另一个页面用户输入消息，后者在上一小节我们已经写好了。下面，我们来实现用于展示消息的页面。</p><p>我们的页面包含一个列表和一个按钮，列表用于展示信息，按钮则用来打开上一节我们所实现的 <code>AddMessageScreen</code>。这里我们先添加一个按钮并实现页面间的跳转。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是我们的消息展示页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Echo client'</span>),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="comment">// push 一个新的 route 到 Navigator 管理的栈中，以此来打开一个页面</span></span><br><span class="line">          Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: <span class="string">'Add message'</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在消息的输入页面，我们点击 Send 按钮后就返回：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onTap: () &#123;</span><br><span class="line">  debugPrint(<span class="string">'send: <span class="subst">$&#123;editController.text&#125;</span>'</span>);</span><br><span class="line">  Navigator.pop(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，我们加入一些骨架代码，实现一个完整的应用：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UX demo'</span>,</span><br><span class="line">      home: MessageListScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Flutter 引入了 route 的概念。为了打开一个新的页面，我们创建一个 <code>MaterialPageRoute</code> 并把它 push 到 <code>Navigator</code> 管理的栈中。返回前一个页面时，只需要 pop 这个 route 即可。</p><p>我们还可以在 <code>MaterialApp</code> 里设置好每个 route 对应的页面，然后使用 <code>Navigator.pushNamed(context, routeName)</code> 来打开它们：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  <span class="comment">// Start the app with the "/" named route. In our case, the app will start</span></span><br><span class="line">  <span class="comment">// on the FirstScreen Widget</span></span><br><span class="line">  initialRoute: <span class="string">'/'</span>,</span><br><span class="line">  routes: &#123;</span><br><span class="line">    <span class="comment">// When we navigate to the "/" route, build the FirstScreen Widget</span></span><br><span class="line">    <span class="string">'/'</span>: (context) =&gt; HomeScreen(),</span><br><span class="line">    <span class="comment">// When we navigate to the "/second" route, build the SecondScreen Widget</span></span><br><span class="line">    <span class="string">'/about'</span>: (context) =&gt; AboutScreen(),</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>但是，上面代码所提供的功能还不够，我们需要从 <code>AddMessageScreen</code> 中返回一个消息。下面我们就来看看如何获取返回值：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先我们对数据建模</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> timestamp;</span><br><span class="line"></span><br><span class="line">  Message(<span class="keyword">this</span>.msg, <span class="keyword">this</span>.timestamp);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Message&#123;msg: $msg, timestamp: $timestamp&#125;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">onTap: () &#123;</span><br><span class="line">  debugPrint(<span class="string">'send: <span class="subst">$&#123;editController.text&#125;</span>'</span>);</span><br><span class="line">  <span class="keyword">final</span> msg = Message(</span><br><span class="line">    editController.text,</span><br><span class="line">    <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 为了返回一个值，我们把它传递给 pop</span></span><br><span class="line">  Navigator.pop(context, msg);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">floatingActionButton: FloatingActionButton(</span><br><span class="line">  onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// push 一个新的 route 到 Navigator 管理的栈中，以此来打开一个页面</span></span><br><span class="line">    <span class="comment">// Navigator.push 会返回一个 Future&lt;T&gt;，如果你对这里使用的 await</span></span><br><span class="line">    <span class="comment">// 不太熟悉，可以参考</span></span><br><span class="line">    <span class="comment">// https://www.dartlang.org/guides/language/language-tour#asynchrony-support</span></span><br><span class="line">    <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">        context,</span><br><span class="line">        MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">    );</span><br><span class="line">    debugPrint(<span class="string">'result = $result'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h1 id="把数据展示到-ListView"><a href="#把数据展示到-ListView" class="headerlink" title="把数据展示到 ListView"></a>把数据展示到 ListView</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageList</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先忽略这里的参数 key，后面我们就会看到他的作用了</span></span><br><span class="line">  MessageList(&#123;Key key&#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _MessageListState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MessageListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MessageList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Message&gt; messages = [];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemCount: messages.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">final</span> msg = messages[index];</span><br><span class="line">        <span class="keyword">final</span> subtitle = <span class="built_in">DateTime</span>.fromMillisecondsSinceEpoch(msg.timestamp)</span><br><span class="line">            .toLocal().toIso8601String();</span><br><span class="line">        <span class="keyword">return</span> ListTile(</span><br><span class="line">          title: Text(msg.msg),</span><br><span class="line">          subtitle: Text(subtitle),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> addMessage(Message msg) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      messages.add(msg);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里唯一的新知识就是给 <code>MessageList</code> 的 <code>key</code> 参数，我们下面先看看如何使用他，然后再说明它的作用：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> messageListKey = GlobalKey&lt;_MessageListState&gt;(debugLabel: <span class="string">'messageListKey'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Echo client'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: MessageList(key: messageListKey),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">          <span class="comment">// push 一个新的 route 到 Navigator 管理的栈中，以此来打开一个页面</span></span><br><span class="line">          <span class="comment">// Navigator.push 会返回一个 Future&lt;T&gt;，如果你对这里使用的 await</span></span><br><span class="line">          <span class="comment">// 不太熟悉，可以参考</span></span><br><span class="line">          <span class="comment">// https://www.dartlang.org/guides/language/language-tour#asynchrony-support</span></span><br><span class="line">          <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (_) =&gt; AddMessageScreen())</span><br><span class="line">          );</span><br><span class="line">          debugPrint(<span class="string">'result = $result'</span>);</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">is</span> Message) &#123;</span><br><span class="line">            messageListKey.currentState.addMessage(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: <span class="string">'Add message'</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>引入一个 <code>GlobalKey</code> 的原因在于，<code>MessageListScreen</code> 需要把从 <code>AddMessageScreen</code> 返回的数据放到 <code>_MessageListState</code> 中，而我们无法从 <code>MessageList</code> 拿到这个 state。</p><p><code>GlobalKey</code> 的是应用全局唯一的 key，把这个 key 设置给 <code>MessageList</code>，我们就能够通过这个 key 拿到对应的 <code>statefulWidget</code> 的 <code>state</code>。</p><p>现在，整体的效果是这个样子的：<br><img src="/2018/08/29/flutter-ux-basic/message-list.gif" alt="message-list"></p><p>如果你遇到了麻烦，在 Github 上找到所有的代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ux-basic</span><br></pre></td></tr></table></figure></p><p>前面我们说要写一个 echo 程序，到目前为止只是实现了一些 UI，剩余的逻辑我们将在下一篇文章完成。最后，由于没能在我们的例子里找到适合使用动画的地方，下面我们在一个独立的上下文里学习 Flutter 的动画。</p><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>在这一节我们来画一个小圆点，它往复不断地在正弦曲线上运动。</p><p><img src="/2018/08/29/flutter-ux-basic/sin-curve.gif" alt=""></p><p>下面我们先来实现小圆点沿着曲线运动的效果：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span> <span class="keyword">as</span> math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/animation.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimationDemoView</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnimationState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoView</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> padding = <span class="number">16.0</span>;</span><br><span class="line"></span><br><span class="line">  AnimationController controller;</span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; left;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 只有在 initState 执行完，我们才能通过 MediaQuery.of(context) 获取</span></span><br><span class="line">    <span class="comment">// mediaQueryData。这里通过创建一个 Future 从而在 Dart 事件队列里插入</span></span><br><span class="line">    <span class="comment">// 一个事件，以达到延后执行的目的（类似于在 Android 里 post 一个 Runnable）</span></span><br><span class="line">    <span class="comment">// 关于 Dart 的事件队列，读者可以参考 https://webdev.dartlang.org/articles/performance/event-loop</span></span><br><span class="line">    Future(_initState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _initState() &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 Animation&lt;T&gt;，最简单的方式就是直接使用 AnimationController。</span></span><br><span class="line">    <span class="comment">// Animation 用户控制动画的进度、状态，但它并不关心屏幕上是什么东西在做动画。</span></span><br><span class="line">    <span class="comment">// AnimationController 输出的值在 0 ~ 1 之间</span></span><br><span class="line">    controller = AnimationController(</span><br><span class="line">        duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>),</span><br><span class="line">        <span class="comment">// 注意类定义的 with SingleTickerProviderStateMixin，提供 vsync 最简单的方法</span></span><br><span class="line">        <span class="comment">// 就是继承一个 SingleTickerProviderStateMixin。这里的 vsync 跟 Android 里</span></span><br><span class="line">        <span class="comment">// 的 vsync 类似，用来提供时针滴答，触发动画的更新。</span></span><br><span class="line">        vsync: <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们通过 MediaQuery 获取屏幕宽度</span></span><br><span class="line">    <span class="keyword">final</span> mediaQueryData = MediaQuery.of(context);</span><br><span class="line">    <span class="keyword">final</span> displayWidth = mediaQueryData.size.width;</span><br><span class="line">    debugPrint(<span class="string">'width = $displayWidth'</span>);</span><br><span class="line">    <span class="comment">// 2. 我们用 Tween 把 controller 输出的 0 ~ 1 之间的值映射到 [begin, end]</span></span><br><span class="line">    <span class="comment">// Tween.animate(controller) 返回一个 Animatable&lt;T&gt;，通过这个 Animatable&lt;T&gt; 我们</span></span><br><span class="line">    <span class="comment">// 可以获取映射过的值</span></span><br><span class="line">    left = Tween(begin: padding, end: displayWidth - padding).animate(controller)</span><br><span class="line">      <span class="comment">// 每一帧都会回调这里添加的回调函数</span></span><br><span class="line">      ..addListener(() &#123;</span><br><span class="line">        <span class="comment">// 3. 调用 setState 触发他重新 build 一个 Widget。在 build 方法里，我们根据</span></span><br><span class="line">        <span class="comment">//    Animatable&lt;T&gt; 的当前值来创建 Widget，达到动画的效果（类似 Android 的属</span></span><br><span class="line">        <span class="comment">//    性动画）。</span></span><br><span class="line">        setState(() &#123;</span><br><span class="line">          <span class="comment">// nothing have to do</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 监听动画状态变化</span></span><br><span class="line">      ..addStatusListener((status) &#123;</span><br><span class="line">        <span class="comment">// 这里我们让动画往复不断执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次动画完成</span></span><br><span class="line">        <span class="keyword">if</span> (status == AnimationStatus.completed) &#123;</span><br><span class="line">          <span class="comment">// 我们让动画反正执行一遍</span></span><br><span class="line">          controller.reverse();</span><br><span class="line">        <span class="comment">// 反着执行的动画结束</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AnimationStatus.dismissed) &#123;</span><br><span class="line">          <span class="comment">// 正着重新开始</span></span><br><span class="line">          controller.forward();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="comment">// 4. 开始动画</span></span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 假定一个单位是 24</span></span><br><span class="line">    <span class="keyword">final</span> unit = <span class="number">24.0</span>;</span><br><span class="line">    <span class="keyword">final</span> marginLeft = left == <span class="keyword">null</span> ? padding : left.value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 marginLeft 单位化</span></span><br><span class="line">    <span class="keyword">final</span> unitizedLeft = (marginLeft - padding) / unit;</span><br><span class="line">    <span class="keyword">final</span> unitizedTop = math.sin(unitizedLeft);</span><br><span class="line">    <span class="comment">// unitizedTop + 1 是了把 [-1, 1] 之间的值映射到 [0, 2]</span></span><br><span class="line">    <span class="comment">// (unitizedTop+1) * unit 后把单位化的值转回来</span></span><br><span class="line">    <span class="keyword">final</span> marginTop = (unitizedTop + <span class="number">1</span>) * unit + padding;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// 我们根据动画的进度设置圆点的位置</span></span><br><span class="line">      margin: EdgeInsets.only(left: marginLeft, top: marginTop),</span><br><span class="line">      <span class="comment">// 画一个小红点</span></span><br><span class="line">      child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            color: Colors.red, borderRadius: BorderRadius.circular(<span class="number">7.5</span>)),</span><br><span class="line">        width: <span class="number">15.0</span>,</span><br><span class="line">        height: <span class="number">15.0</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    controller.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter animation demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(<span class="string">'Animation demo'</span>)),</span><br><span class="line">        body: AnimationDemoView(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的动画中，我们只是对位置做出了改变，下面我们将在位置变化的同时，也让小圆点从红到蓝进行颜色的变化。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimationState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimationDemoView</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Animation&lt;Color&gt; color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _initState() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    color = ColorTween(begin: Colors.red, end: Colors.blue).animate(controller);</span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> color = <span class="keyword">this</span>.color == <span class="keyword">null</span> ? Colors.red : <span class="keyword">this</span>.color.value;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// 我们根据动画的进度设置圆点的位置</span></span><br><span class="line">      margin: EdgeInsets.only(left: marginLeft, top: marginTop),</span><br><span class="line">      <span class="comment">// 画一个小圆点</span></span><br><span class="line">      child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            color: color, borderRadius: BorderRadius.circular(<span class="number">7.5</span>)),</span><br><span class="line">        width: <span class="number">15.0</span>,</span><br><span class="line">        height: <span class="number">15.0</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 GitHub 上，可以找到所有的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout sin-curve</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们还可以加多一个效果，让小圆点在运动的过程中大小也不断变化，这个就留给读者作为练习。更多的 Flutter 动画知识，可以参考 <a href="https://flutter.io/animations/" target="_blank" rel="noopener">https://flutter.io/animations/</a>。</p>]]></content>
    
    <summary type="html">
    
      在这一篇文章中，我们将通过实现一个 echo 客户端的前端页面来学习如何在 Flutter 中进行页面的跳转、手势事件处理。至于动画，我们弄一个小圆点，让他沿着正弦曲线运动，同时改变自身的颜色。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（2）- UI控件和布局</title>
    <link href="https://jekton.github.io/2018/08/26/flutter-ui-basic/"/>
    <id>https://jekton.github.io/2018/08/26/flutter-ui-basic/</id>
    <published>2018-08-26T07:33:41.000Z</published>
    <updated>2018-08-30T07:12:21.046Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<code>玉刚说写作平</code>台提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>本篇文章我们借助 Flutter 官网提供的两个 demo，来介绍 Flutter 的一些基本 UI 控件和布局方法。原文地址是 <a href="https://flutter.io/tutorials/layout/" target="_blank" rel="noopener">https://flutter.io/tutorials/layout/</a>。在第一个例子中，我们将不加修改（或仅做少量修改）地采用原文的代码来讲述问题。第二个例子的数据来自官网，但使用一种大家更为熟悉的方式开发。</p><h1 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h1><p>在这一节里，我们的目标是通过实现下面这个界面，来学习基本的 UI 空间和布局方法。</p><p><img src="/2018/08/26/flutter-ui-basic/lakes-diagram.png" alt="lakes-diagram"></p><h2 id="展示图片"><a href="#展示图片" class="headerlink" title="展示图片"></a>展示图片</h2><ol><li>把图片 <a href="lake.png">lake</a> 放到项目根目录的 <code>images</code> 文件夹下（如果没有，你需要自己创建一个）</li><li><p>修改 <code>pubspec.yaml</code>，找到下面这个地方，然后把图片加进来</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line"></span><br><span class="line">  # The following line ensures that the Material Icons font is</span><br><span class="line">  # included with your application, so that you can use the icons in</span><br><span class="line">  # the material Icons class.</span><br><span class="line">  uses-material-design: true</span><br><span class="line"></span><br><span class="line">  # To add assets to your application, add an assets section, like this:</span><br><span class="line">  # assets:</span><br><span class="line">  #  - images/a_dot_burr.jpeg</span><br><span class="line">  #  - images/a_dot_ham.jpeg</span><br></pre></td></tr></table></figure><p> 修改后如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line"></span><br><span class="line">  # The following line ensures that the Material Icons font is</span><br><span class="line">  # included with your application, so that you can use the icons in</span><br><span class="line">  # the material Icons class.</span><br><span class="line">  uses-material-design: true</span><br><span class="line"></span><br><span class="line">  # To add assets to your application, add an assets section, like this:</span><br><span class="line">  assets:</span><br><span class="line">    - images/lake.jpg</span><br></pre></td></tr></table></figure></li><li><p>现在，我们可以把这张图片展示出来了：</p> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UI basic 1'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Top Lakes'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Image.asset(</span><br><span class="line">          <span class="string">'images/lake.jpg'</span>,</span><br><span class="line">          width: <span class="number">600.0</span>,</span><br><span class="line">          height: <span class="number">240.0</span>,</span><br><span class="line">          <span class="comment">// cover 类似于 Android 开发中的 centerCrop，其他一些类型，读者可以查看</span></span><br><span class="line">          <span class="comment">// https://docs.flutter.io/flutter/painting/BoxFit-class.html</span></span><br><span class="line">          fit: BoxFit.cover,</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>关于 <code>StatelessWidget</code> 和 <code>MaterialApp</code> 这些，我们在<a href="https://jekton.github.io/2018/08/26/flutter-first-app/">Flutter 开发框架、流程、编译打包、调试</a>中已经有说明，这里不再赘述。</p><p>如果读者是初学 Flutter，<strong>强烈建议</strong>在遇到不熟悉的 API 时翻一翻文档，并在文档中找到 demo 所使用的 API。我们的例子不可能覆盖所有的 API，通过这种方式熟悉文档后，读者就可以根据文档实现出自己想要的效果。不妨就从 <code>Image</code> 开始吧，在 <a href="https://docs.flutter.io/flutter/widgets/Image/Image.asset.html" target="_blank" rel="noopener">https://docs.flutter.io/flutter/widgets/Image/Image.asset.html</a> 找出上面我们使用的 <code>Image.asset</code> 构造函数的几个参数的含义，还有 <code>BoxFit</code> 的其他几个枚举值。</p><h2 id="基本的布局"><a href="#基本的布局" class="headerlink" title="基本的布局"></a>基本的布局</h2><p>在这一小节，我们来实现图片下方的标题区域。完成这一小节后，读者对 Flutter 的布局将会有一个基本的认识。</p><p><img src="/2018/08/26/flutter-ui-basic/title-section-diagram.png" alt=""></p><p>我们直接来看代码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TitleSection</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> subtitle;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> starCount;</span><br><span class="line"></span><br><span class="line">  _TitleSection(<span class="keyword">this</span>.title, <span class="keyword">this</span>.subtitle, <span class="keyword">this</span>.starCount);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 我们知道，Flutter 里所有的东西都是 Widget。为了给 title section 加上 padding，</span></span><br><span class="line">    <span class="comment">// 这里我们给内容套一个 Container</span></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// 设置上下左右的 padding 都是 32px。类似的还有 EdgeInsets.only/symmetric 等</span></span><br><span class="line">      padding: EdgeInsets.all(<span class="number">32.0</span>),</span><br><span class="line">      <span class="comment">// 只有一个子元素的 widget，一般使用 child 参数来设置；像下面使用的 Row，包含有多</span></span><br><span class="line">      <span class="comment">// 个元素，对应的则是 children。</span></span><br><span class="line">      <span class="comment">// Row、Column 类似于我们 Android 开发里面使用的 LinearLayout，分别对应 orien-</span></span><br><span class="line">      <span class="comment">// tation 为 horizontal 和 vertical。</span></span><br><span class="line">      child: Row(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// 和 LinearLayout 一样，我们从左到右放入子元素。</span></span><br><span class="line">          <span class="comment">// Expanded 提供了 LinearLayout layout_weight 类似的功能。这里为了让标题占</span></span><br><span class="line">          <span class="comment">// 满屏幕宽度的剩余空间，用 Expanded 把标题包了起来</span></span><br><span class="line">          Expanded(</span><br><span class="line">            <span class="comment">// 再次提醒读者，Expanded 只能包含一个子元素，使用的参数名是 child。接下来，</span></span><br><span class="line">            <span class="comment">// 为了在竖直方向放两个标题，加入一个 Column。</span></span><br><span class="line">            child: Column(</span><br><span class="line">              <span class="comment">// Column 是竖直方向的，cross 为交叉的意思，也就是说，这里设置的是水平方向</span></span><br><span class="line">              <span class="comment">// 的对齐。在水平方向，我们让文本对齐到 start（读者可以修改为 end 看看效果）</span></span><br><span class="line">              crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                <span class="comment">// 聪明的你，这个时候肯定知道为什么突然加入一个 Container 了。</span></span><br><span class="line">                <span class="comment">// 跟前面一样，只是为了设置一个 padding</span></span><br><span class="line">                Container(</span><br><span class="line">                  padding: <span class="keyword">const</span> EdgeInsets.only(bottom: <span class="number">8.0</span>),</span><br><span class="line">                  child: Text(</span><br><span class="line">                    title,</span><br><span class="line">                    style: TextStyle(fontWeight: FontWeight.bold),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">                Text(</span><br><span class="line">                  subtitle,</span><br><span class="line">                  style: TextStyle(color: Colors.grey[<span class="number">500</span>]),</span><br><span class="line">                )</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这里是 Row 的第二个子元素，下面这两个就没用太多值得说的东西了。</span></span><br><span class="line">          Icon(</span><br><span class="line">            Icons.star,</span><br><span class="line">            color: Colors.red[<span class="number">500</span>],</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          Text(starCount.toString())</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，我们把这一整个区域的 UI 用一个类 <code>_TitleSection</code> 封装起来。下面我们总结一下：</p><ol><li>layout 类型的控件分两种：只含一个子元素或包含多个子元素。前者使用参数 <code>child</code>，后者则是 <code>children</code>。</li><li>把控件按功能分，又可以分为展示内容的控件，如 Text；和用于布局的控件，如 Container。当然，还有其他类型的控件用于提供动画、手势等。</li><li>为了让控件具有 padding、margin 和 width/height 等，我们可以使用一个 Container 把它包起来。</li><li>Row/Column 提供了类似于 <code>LinearLayout</code> 的功能。</li></ol><p>建议读者粗略浏览一下 <a href="https://flutter.io/widgets/" target="_blank" rel="noopener">https://flutter.io/widgets/</a>，大概了解 Flutter 提供的 widget 和它们对应的功能。以后在开发过程中，有需要的时候再详细查看相关文档。</p><h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><p>接下来我们要做的这一部分在布局上所用到的知识，基本知识在上一小节我们都已经学习了。这里唯一的区别在于，三个按钮是水平分布的。</p><p><img src="/2018/08/26/flutter-ui-basic/button-section-diagram.png" alt=""></p><p>实现如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildButtonColumn(BuildContext context, IconData icon, <span class="built_in">String</span> label) &#123;</span><br><span class="line">  <span class="keyword">final</span> color = Theme.of(context).primaryColor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Column(</span><br><span class="line">    <span class="comment">// main axis 跟我们前面提到的 cross axis 相对应，对 Column 来说，指的就是竖直方向。</span></span><br><span class="line">    <span class="comment">// 在放置完子控件后，屏幕上可能还会有一些剩余的空间（free space），min 表示尽量少占用</span></span><br><span class="line">    <span class="comment">// free space；类似于 Android 的 wrap_content。</span></span><br><span class="line">    <span class="comment">// 对应的，还有 MainAxisSize.max</span></span><br><span class="line">    mainAxisSize: MainAxisSize.min,</span><br><span class="line">    <span class="comment">// 沿着 main axis 居中放置</span></span><br><span class="line">    mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line"></span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Icon(icon, color: color),</span><br><span class="line">      Container(</span><br><span class="line">        margin: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">8.0</span>),</span><br><span class="line">        child: Text(</span><br><span class="line">          label,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">            fontSize: <span class="number">12.0</span>,</span><br><span class="line">            fontWeight: FontWeight.w400,</span><br><span class="line">            color: color,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      )</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    Widget buttonSection = Container(</span><br><span class="line">      child: Row(</span><br><span class="line"><span class="comment">// 沿水平方向平均放置</span></span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">        children: [</span><br><span class="line">          _buildButtonColumn(context, Icons.call, <span class="string">'CALL'</span>),</span><br><span class="line">          _buildButtonColumn(context, Icons.near_me, <span class="string">'ROUTE'</span>),</span><br><span class="line">          _buildButtonColumn(context, Icons.share, <span class="string">'SHARE'</span>),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于 cross/main axis，看看下面这两个图就很清楚了：<br><img src="/2018/08/26/flutter-ui-basic/column-diagram.png" alt=""><br><img src="/2018/08/26/flutter-ui-basic/row-diagram.png" alt=""></p><p><code>MainAxisAlignment</code> 的更多的信息，可以查看 <a href="https://docs.flutter.io/flutter/rendering/MainAxisAlignment-class.html" target="_blank" rel="noopener">https://docs.flutter.io/flutter/rendering/MainAxisAlignment-class.html</a>。</p><h2 id="全部放到一起"><a href="#全部放到一起" class="headerlink" title="全部放到一起"></a>全部放到一起</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> titleSection = _TitleSection(</span><br><span class="line">        <span class="string">'Oeschinen Lake Campground'</span>, <span class="string">'Kandersteg, Switzerland'</span>, <span class="number">41</span>);</span><br><span class="line">    <span class="keyword">final</span> buttonSection = ...;</span><br><span class="line">    <span class="keyword">final</span> textSection = Container(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">32.0</span>),</span><br><span class="line">        child: Text(</span><br><span class="line">          <span class="string">'''</span></span><br><span class="line"><span class="string">Lake Oeschinen lies at the foot of the Blüemlisalp in the Bernese Alps. Situated 1,578 meters above sea level, it is one of the larger Alpine Lakes. A gondola ride from Kandersteg, followed by a half-hour walk through pastures and pine forest, leads you to the lake, which warms to 20 degrees Celsius in the summer. Activities enjoyed here include rowing, and riding the summer toboggan run.</span></span><br><span class="line"><span class="string">          '''</span>,</span><br><span class="line">          softWrap: <span class="keyword">true</span>,</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter UI basic 1'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Top Lakes'</span>),</span><br><span class="line">          ),</span><br><span class="line">  <span class="comment">// 由于我们的内容可能会超出屏幕的长度，这里把内容都放到 ListView 里。</span></span><br><span class="line">  <span class="comment">// 除了这种用法，ListView 也可以像我们在 Android 原生开发中使用 ListView 那样，</span></span><br><span class="line">  <span class="comment">// 根据数据动态生成一个个 item。这个我们在下一节再来学习</span></span><br><span class="line">          body: ListView(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Image.asset(</span><br><span class="line">                <span class="string">'images/lake.jpg'</span>,</span><br><span class="line">                width: <span class="number">600.0</span>,</span><br><span class="line">                height: <span class="number">240.0</span>,</span><br><span class="line">                <span class="comment">// cover 类似于 Android 开发中的 centerCrop，其他一些类型，读者可以查看</span></span><br><span class="line">                <span class="comment">// https://docs.flutter.io/flutter/painting/BoxFit-class.html</span></span><br><span class="line">                fit: BoxFit.cover,</span><br><span class="line">              ),</span><br><span class="line"></span><br><span class="line">              titleSection,</span><br><span class="line">              buttonSection,</span><br><span class="line">              textSection</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果没有出错的话，运行后应该就可以看到下面这个页面。<br><img src="/2018/08/26/flutter-ui-basic/Screenshot_20180826-172022.png" alt=""></p><p>如果你遇到了麻烦，可以在这里找到所有的源码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ui-basic1</span><br></pre></td></tr></table></figure></p><p>更多的布局知识，读者可以参考 <a href="https://flutter.io/tutorials/layout/" target="_blank" rel="noopener">https://flutter.io/tutorials/layout/</a>。</p><h1 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h1><p>在这一小节我们来实现一个 list view。</p><p><img src="/2018/08/26/flutter-ui-basic/listview.png" alt=""></p><p>这里我们采用的还是官网提供的例子，但是换一种方式来实现，让它跟我们平时使用 Java 时更像一些。由于这部分是建立在读者已经学习了上一节知识的基础上，不会很详细地对 API 进行讲解。希望读者在遇到不明白的地方，能够多查查文档。</p><p>首先给数据建模：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BuildingType &#123; theater, restaurant &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> BuildingType type;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> address;</span><br><span class="line"></span><br><span class="line">  Building(<span class="keyword">this</span>.type, <span class="keyword">this</span>.title, <span class="keyword">this</span>.address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后实现每个 item 的 UI：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> position;</span><br><span class="line">  <span class="keyword">final</span> Building building;</span><br><span class="line"></span><br><span class="line">  ItemView(<span class="keyword">this</span>.position, <span class="keyword">this</span>.building);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> icon = Icon(</span><br><span class="line">        building.type == BuildingType.restaurant</span><br><span class="line">            ? Icons.restaurant</span><br><span class="line">            : Icons.theaters,</span><br><span class="line">        color: Colors.blue[<span class="number">500</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> widget = Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">          child: icon,</span><br><span class="line">        ),</span><br><span class="line">        Expanded(</span><br><span class="line">          child: Column(</span><br><span class="line">            crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(</span><br><span class="line">                building.title,</span><br><span class="line">                style: TextStyle(</span><br><span class="line">                  fontSize: <span class="number">20.0</span>,</span><br><span class="line">                  fontWeight: FontWeight.w500,</span><br><span class="line">                )</span><br><span class="line">              ),</span><br><span class="line">              Text(building.address)</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> widget;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着是 ListView。由于渲染机制不同，这里没必要弄个 adapter 来管理 widget：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildingListView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Building&gt; buildings;</span><br><span class="line">  <span class="keyword">final</span> OnItemClickListener listener;</span><br><span class="line"></span><br><span class="line">  BuildingListView(<span class="keyword">this</span>.buildings, <span class="keyword">this</span>.listener);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemCount: buildings.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ItemView(index, buildings[index], listener);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们来给 item 加上点击事件。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OnItemClickListener = <span class="keyword">void</span> <span class="built_in">Function</span>(<span class="built_in">int</span> position);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> position;</span><br><span class="line">  <span class="keyword">final</span> Building building;</span><br><span class="line">  <span class="keyword">final</span> OnItemClickListener listener;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的 listener 会从 ListView 那边传过来</span></span><br><span class="line">  ItemView(<span class="keyword">this</span>.position, <span class="keyword">this</span>.building, <span class="keyword">this</span>.listener);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> widget = ...;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般来说，为了监听手势事件，我们使用 GestureDetector。但这里为了在点击的时候有个</span></span><br><span class="line">    <span class="comment">// 水波纹效果，使用的是 InkWell。</span></span><br><span class="line">    <span class="keyword">return</span> InkWell(</span><br><span class="line">      onTap: () =&gt; listener(position),</span><br><span class="line">      child: widget</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildingListView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Building&gt; buildings;</span><br><span class="line">  <span class="keyword">final</span> OnItemClickListener listener;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是对外接口。外部通过构造函数传入数据和 listener</span></span><br><span class="line">  BuildingListView(<span class="keyword">this</span>.buildings, <span class="keyword">this</span>.listener);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemCount: buildings.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ItemView(index, buildings[index], listener);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后加上一些脚手架代码，我们的列表就能够跑起来了：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> buildings = [</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'CineArts at the Empire'</span>, <span class="string">'85 W Portal Ave'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'The Castro Theater'</span>, <span class="string">'429 Castro St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Alamo Drafthouse Cinema'</span>, <span class="string">'2550 Mission St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Roxie Theater'</span>, <span class="string">'3117 16th St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'United Artists Stonestown Twin'</span>, <span class="string">'501 Buckingham Way'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'AMC Metreon 16'</span>, <span class="string">'135 4th St #3000'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'K\'s Kitchen'</span>, <span class="string">'1923 Ocean Ave'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'Chaiya Thai Restaurant'</span>, <span class="string">'72 Claremont Blvd'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'La Ciccia'</span>, <span class="string">'291 30th St'</span>),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// double 一下</span></span><br><span class="line">      Building(BuildingType.theater, <span class="string">'CineArts at the Empire'</span>, <span class="string">'85 W Portal Ave'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'The Castro Theater'</span>, <span class="string">'429 Castro St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Alamo Drafthouse Cinema'</span>, <span class="string">'2550 Mission St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'Roxie Theater'</span>, <span class="string">'3117 16th St'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'United Artists Stonestown Twin'</span>, <span class="string">'501 Buckingham Way'</span>),</span><br><span class="line">      Building(BuildingType.theater, <span class="string">'AMC Metreon 16'</span>, <span class="string">'135 4th St #3000'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'K\'s Kitchen'</span>, <span class="string">'1923 Ocean Ave'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'Chaiya Thai Restaurant'</span>, <span class="string">'72 Claremont Blvd'</span>),</span><br><span class="line">      Building(BuildingType.restaurant, <span class="string">'La Ciccia'</span>, <span class="string">'291 30th St'</span>),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'ListView demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Buildings'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: BuildingListView(buildings, (index) =&gt; debugPrint(<span class="string">'item $index clicked'</span>))</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候你应该可以看到像这样的界面了：<br><img src="/2018/08/26/flutter-ui-basic/screenshot-listview.png" alt=""></p><p>如果你遇到了什么麻烦，可以查看 tag ui-basic2 的代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout ui-basic2</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      本篇文章我们借助 Flutter 官网提供的两个 demo，来介绍 Flutter 的一些基本 UI 控件和布局方法。在第一个例子中，我们将不加修改（或仅做少量修改）地采用原文的代码来讲述问题。第二个例子的数据来自官网，但使用一种大家更为熟悉的方式开发。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发（1）- 开发框架、流程、编译打包、调试</title>
    <link href="https://jekton.github.io/2018/08/26/flutter-first-app/"/>
    <id>https://jekton.github.io/2018/08/26/flutter-first-app/</id>
    <published>2018-08-26T01:41:42.000Z</published>
    <updated>2018-08-26T05:47:56.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<code>玉刚说写作平</code>台提供写作赞助<br>赞助金额：200元<br>原作者：<code>水晶虾饺</code><br>版权声明：本文版权归微信公众号<code>玉刚说</code>所有，未经许可，不得以任何形式转载</p></blockquote><p>Flutter 是 Google 推出的移动端跨平台开发框架，使用的编程语言是 Dart。从 React Native 到 Flutter，开发者对跨平台解决方案的探索从未停止，毕竟，它可以让我们节省移动端一半的人力。本篇文章中，我们就通过编写一个简单的 Flutter 来了解他的开发流程。</p><p>这里我们要开发的 demo 很简单，只是在屏幕中间放一个按钮，点击的时候，模拟摇两个骰子并弹窗显示结果。我们撸起袖子开干吧。</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>我们这里假定读者已经安装好 Flutter，并且使用安装了 Flutter 插件的 Android Studio 进行开发。如果你还没有配置好开发环境，可以参考 <a href="https://mp.weixin.qq.com/s/6lmhHNBRcmoNqkMHaCBx8A" target="_blank" rel="noopener">这篇文章</a>。</p><p>下面我们开始创建项目：</p><ol><li>选择 File &gt; New &gt; New Flutter project…</li><li>在接下来弹出的选择面板里，选择 Flutter Application</li><li>这里填应用的基本信息。Project name 我们就写 flutter_demo 好了。这里要注意的是，Project name 必须是一个合法的 Dart 包名（小写+下划线，可以有数字）。填好以后点击 next，然后 finish。</li></ol><p>第一次创建项目时，由于要下载 gradle，时间会稍微长一些。</p><h1 id="编写代码（1）"><a href="#编写代码（1）" class="headerlink" title="编写代码（1）"></a>编写代码（1）</h1><p>在上一小节里我们所创建的项目，已经有了一些代码，感兴趣的读者可以跑到自己手机上看一看，相关的代码在 <code>lib/main.dart</code> 里面。</p><p>为了体验从头开发一个应用的过程，这里我们先把 <code>lib/main.dart</code> 里的内容都删除。</p><p>首先，我们创建一个 <code>main</code> 函数。跟其他语言一样，<code>main</code> 函数是应用的入口：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们编写一个 <code>Widget</code> 作为我们的 app。在 Flutter 里，所有的东西都是 <code>Widget</code>。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 创建一个 MyApp</span></span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这个 widget 作用这个应用的顶层 widget.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 这个 widget 是无状态的，所以我们继承的是 [StatelessWidget].</span></span><br><span class="line"><span class="comment">/// 对应的，有状态的 widget 可以继承 [StatefulWidget]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 创建内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们可以进入正题，进入一个按钮，在点击的时候弹框显示结果：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">// 我们想使用 material 风格的应用，所以这里用 MaterialApp</span></span><br><span class="line">  <span class="keyword">return</span> MaterialApp(</span><br><span class="line">    <span class="comment">// 移动设备使用这个 title 来表示我们的应用。具体一点说，在 Android 设备里，我们点击</span></span><br><span class="line">    <span class="comment">// recent 按钮打开最近应用列表的时候，显示的就是这个 title。</span></span><br><span class="line">    title: <span class="string">'Our first Flutter app'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用的“主页”</span></span><br><span class="line">    home: Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Flutter rolling demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 我们知道，Flutter 里所有的东西都是 widget。为了把按钮放在屏幕的中央，</span></span><br><span class="line">      <span class="comment">// 这里使用了 Center（它是一个 widget）。</span></span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          <span class="comment">// 用户点击时候调用</span></span><br><span class="line">          onPressed: _onPressed,</span><br><span class="line">          child: Text(<span class="string">'roll'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="安装、调试（1）"><a href="#安装、调试（1）" class="headerlink" title="安装、调试（1）"></a>安装、调试（1）</h1><p>现在，点击 Run，把我们的第一个 Flutter 应用跑起来吧。没有意外的话，你会看到下面这个页面：<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-pic1.png" alt="Screenshot with a button in the center"></p><p>如果你遇到了什么困难，可以查看 tag <code>first_app_step1</code> 的代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Jekton/flutter_demo.git</span><br><span class="line">cd flutter_demo</span><br><span class="line">git checkout first_app_step1</span><br></pre></td></tr></table></figure></p><p>由于是第一次写 Flutter 应用，我们对上面的代码是否能够按照预期执行还不是那么有信心，所以我们先打个 log 确认一下，点击按钮后是不是真的会执行 <code>onPress</code>。</p><p>打 log 可以使用 Dart 提供的 <code>print</code>，但在日志比较多的时候，<code>print</code> 的输出可能会被 Android 丢弃，这个时候 <code>debugPrint</code> 会是更好的选择。对应的日志信息可以在 <code>Dart Console</code> 里查看（View -&gt; Tool Windows -&gt; Run 或者 Mac 上使用 Command+4 打开）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">  debugPrint(<span class="string">'_onPressed'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后（会自动 Hot Reload）后，我们再次点击按钮，在我的设备上，打印出了下面这样的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (11297): _onPressed</span><br><span class="line">V/AudioManager(11297): playSoundEffect   effectType: 0</span><br><span class="line">V/AudioManager(11297): querySoundEffectsEnabled...</span><br></pre></td></tr></table></figure></p><p>这里的第一行，就是我们打印的。现在我们有足够的自信说，点击按钮后，会执行 <code>_onPressed</code> 方法。</p><h1 id="编写代码（2）"><a href="#编写代码（2）" class="headerlink" title="编写代码（2）"></a>编写代码（2）</h1><p>软件开发通常是一个螺旋式上升的过程，不可能通过一次编码、调试就完成。现在，开始第二轮迭代过程。</p><p>接下来我们要做的，便是在 <code>_onPressed</code> 里面弹一个框：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context 这里使用的是 MyApp.build 的参数</span></span><br><span class="line"><span class="keyword">void</span> _onPressed(BuildContext context) &#123;</span><br><span class="line">  debugPrint(<span class="string">'_onPressed'</span>);</span><br><span class="line"></span><br><span class="line">  showDialog(</span><br><span class="line">    context: context,</span><br><span class="line">    builder: (_) &#123;</span><br><span class="line">      <span class="keyword">return</span> AlertDialog(</span><br><span class="line">        content: Text(<span class="string">'AlertDialog'</span>),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遗憾的是，这一次并不那么顺利。Dialog 没有弹出来，而且报了下面这问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (11297): Navigator operation requested with a context that does not include a Navigator.</span><br><span class="line">I/flutter (11297): The context used to push or pop routes from the Navigator must be that of a widget that is a</span><br><span class="line">I/flutter (11297): descendant of a Navigator widget.</span><br></pre></td></tr></table></figure></p><p>原因在于，stateless 的 widget 只能用于显示信息，而不能有其他动作。所以，该让 <code>StatefulWidget</code> 上场了。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RollingButton</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// StatefulWidget 需要实现这个方法，返回一个 State</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _RollingState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能看起来有点恶心，这里的泛型参数居然是 RollingButton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RollingState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RollingButton</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      child: Text(<span class="string">'Roll'</span>),</span><br><span class="line">      onPressed: _onPressed,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">    debugPrint(<span class="string">'_RollingState._onPressed'</span>);</span><br><span class="line">    showDialog(</span><br><span class="line">        <span class="comment">// 第一个 context 是参数名，第二个 context 是 State 的成员变量</span></span><br><span class="line">        context: context,</span><br><span class="line">        builder: (_) &#123;</span><br><span class="line">          <span class="keyword">return</span> AlertDialog(</span><br><span class="line">            content: Text(<span class="string">'AlertDialog'</span>),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要实现一个 stateful 的 widget，需要继承 <code>StatefulWidget</code> 并在 <code>createState</code> 方法中返回一个 <code>State</code>。除了这一部分，上面的代码跟我们之前写的并没有太大的区别。</p><p>剩下的，就是替换 <code>MyApp</code> 里面使用的按钮，修改后的代码如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Our first Flutter app'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Flutter rolling demo'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: RollingButton(),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再次运行，点击按钮后，我们将看到梦寐以求的 dialog。<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-pic2.png" alt="Screenshot with a dialog"></p><p>如果你遇到了麻烦，可以查看 tag <code>first_app_step2</code> 的代码。</p><p>最后，我们来实现“roll”：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RollingState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RollingButton</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> _random = Random();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; _roll() &#123;</span><br><span class="line">    <span class="keyword">final</span> roll1 = _random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> roll2 = _random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> [roll1, roll1];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">    debugPrint(<span class="string">'_RollingState._onPressed'</span>);</span><br><span class="line">    <span class="keyword">final</span> rollResults = _roll();</span><br><span class="line">    showDialog(</span><br><span class="line">        <span class="comment">// 第一个 context 是参数名，第二个 context 是 State 的成员变量</span></span><br><span class="line">        context: context,</span><br><span class="line">        builder: (_) &#123;</span><br><span class="line">          <span class="keyword">return</span> AlertDialog(</span><br><span class="line">            content: Text(<span class="string">'Roll result: (<span class="subst">$&#123;rollResults[<span class="number">0</span>]&#125;</span>, <span class="subst">$&#123;rollResults[<span class="number">1</span>]&#125;</span>)'</span>),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="安装、调试（2）"><a href="#安装、调试（2）" class="headerlink" title="安装、调试（2）"></a>安装、调试（2）</h1><p>还是一样，重新运行后，我们就能够看到每次点击按钮的结果随机地出现 <code>[1, 6]</code> 中的数……慢着，怎么弹出的消息里的两个号码总是一样的！好吧，肯定是哪里出错了。</p><p>这次，我们不采用打 log 的方法，改用 debugger 来调试。</p><ol><li>在 <code>final rollResults = _roll();</code> 这一行打个断点</li><li>然后点击 Debug main.dart 开始调试</li><li>点击 APP 里的 Roll 按钮</li></ol><p>现在，应用停在了我们所打的断点处：<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-debug1.png" alt="debug step1"></p><p>接下来：</p><ol><li>Step Into 进入 <code>_roll</code> 方法</li><li>进入 <code>_roll</code> 后，Step Over 一行执行。<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-debug2.png" alt="debug step2"><br>这里我们看到，两次 random 确实产生了不同的结果。我们继续：</li><li>继续 Step Over，这个时候 <code>_roll</code> 就返回了</li><li>切换到 Variables 这个选项卡，查看 <code>rollResults</code> 的值<br><img src="/2018/08/26/flutter-first-app/flutter-first-app-debug3.png" alt="debug step3"></li></ol><p>可以发现，两个结果居然变成一样的了。再往回查看一下代码，我们竟然 <code>return [roll1, roll1]</code>。修改后一个为 <code>roll2</code>，我们就程序就能够按预期的正常执行了。</p><p>最终的代码，可以看 tag <code>first_app_done</code>。</p><h2 id="调试总结"><a href="#调试总结" class="headerlink" title="调试总结"></a>调试总结</h2><p>本篇文章其实介绍了两种调试方法：打 log 和 debugger。虽然现在 Flutter 提供的 log 工具比较简陋，可以预期未来还会进一步完善。</p><p>使用打 log 的方式，好处在于不会对执行流程产生较大的影响，在多线程环境尤为有用。它的速度也比较快，不需要我们去单步执行。不足之处在于，如果原先没有对应的 log，我们只能修改代码重新运行，才能查看相应的状态。对于线上的应用，我们也只能够通过分析 log 来定位问题。</p><p>debugger 跟打 log 方式是互补的。使用 debugger 时，我们可以随意查看我们需要知道的变量的值，一步一步近距离观察代码的运行状态。坏处当然就是太慢了。在什么时候使用什么方法，需要一些经验；但有时候就全凭个人喜好了，没有优劣之分。</p><p>更多的调试方法，读者可以根据需要查看<a href="https://flutter.io/debugging/" target="_blank" rel="noopener">https://flutter.io/debugging/</a>进一步学习。</p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>编写完应用后，是时候打包 apk 分发给用户使用了。在这一小节，我们就来看看怎么给 Flutter 项目打包。</p><p>在我们项目的根目录，有一个 android 文件夹，下面我们将主要对这个目录的文件进行修改。</p><ol><li>查看 <code>AndroidManifest.xml</code>。这是一个按模板生成的文件，有些东西可能需要修改一下</li><li><code>build.gradle</code>，这里面也可能有你需要修改的地方。对我们的应用来说，目前都先维持原样</li><li>如果有需要，更新 <code>res/mipmap</code> 里的应用启动图标。这里我们不改</li><li><p>签名</p><ol><li>生成签名的 key（如果你已经有了，跳过这一步）,<code>keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key</code>。为了让读者也可以编译，这里我把 key 也放到了项目中。</li><li><p>添加一个 <code>android/key.properties</code>，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storePassword=123456</span><br><span class="line">keyPassword=123456</span><br><span class="line">keyAlias=key</span><br><span class="line">storeFile=../key.jks</span><br></pre></td></tr></table></figure></li><li><p>更新 build.gradle 里的签名配置</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> keystorePropertiesFile = rootProject.<span class="keyword">file</span>(<span class="string">"key.properties"</span>)</span><br><span class="line"><span class="keyword">def</span> keystoreProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">keystoreProperties.load(<span class="keyword">new</span> FileInputStream(keystorePropertiesFile))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            keyAlias keystoreProperties[<span class="string">'keyAlias'</span>]</span><br><span class="line">            keyPassword keystoreProperties[<span class="string">'keyPassword'</span>]</span><br><span class="line">            storeFile <span class="keyword">file</span>(keystoreProperties[<span class="string">'storeFile'</span>])</span><br><span class="line">            storePassword keystoreProperties[<span class="string">'storePassword'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line"></span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            useProguard <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// proguard 文件我们在下一步添加</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>添加 <code>/android/app/proguard-rules.pro</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#Flutter Wrapper</span><br><span class="line">-keep class io.flutter.app.** &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.plugin.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.util.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.view.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.**  &#123; *; &#125;</span><br><span class="line">-keep class io.flutter.plugins.**  &#123; *; &#125;</span><br></pre></td></tr></table></figure></li><li><p>编译 apk。在项目的根目录，执行 <code>flutter build apk</code>， 编译后的应用在 <code>build/app/outputs/apk/release/app-release.apk</code>。</p></li><li>还是在根目录下，执行 <code>flutter install</code> 就可以安装这个 apk 了。</li></ol><p><br><br>对于 iOS，读者可以看<a href="https://flutter.io/ios-release/" target="_blank" rel="noopener">https://flutter.io/ios-release/</a>，这里就不再演示了。 查看最终的项目，可以 checkout 到 tag <code>first_app_signing</code>。恭喜你，第一个 Flutter 应用完成啦。</p>]]></content>
    
    <summary type="html">
    
      Flutter 是 Google 推出的移动端跨平台开发框架，使用的编程语言是 Dart。从 React Native 到 Flutter，开发者对跨平台解决方案的探索从未停止，毕竟，它可以让我们节省移动端一半的人力。本篇文章中，我们就通过编写一个简单的 Flutter 来了解他的开发流程。
    
    </summary>
    
      <category term="Flutter" scheme="https://jekton.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://jekton.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>JVM 之路（1）- cmake 学习</title>
    <link href="https://jekton.github.io/2018/08/19/way-to-JVM-1/"/>
    <id>https://jekton.github.io/2018/08/19/way-to-JVM-1/</id>
    <published>2018-08-19T12:39:36.000Z</published>
    <updated>2018-08-27T10:21:28.153Z</updated>
    
    <content type="html"><![CDATA[<p>在看一本书，《自己动手写JVM》，语言用的是 Go。想提高一下 C++ 的熟练度，所以自己用 C++ 跟着写一遍。既然用 C++，就得给自己找一个编译工具，最后选定的是 cmake。这篇文章记录的是个人 cmake 学习的一些总结，书籍使用《Professional CMake - A Practical Guide》。</p><a id="more"></a><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure><h2 id="最简单的项目"><a href="#最简单的项目" class="headerlink" title="最简单的项目"></a>最简单的项目</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(MyApp)</span><br><span class="line"><span class="keyword">add_executable</span>(myExe main.cpp)</span><br></pre></td></tr></table></figure><p>参数可以跨越多行，命令名不区分大小写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_executable(myExe</span><br><span class="line">    main.cpp</span><br><span class="line">    foo.cpp</span><br><span class="line">    bar.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="添加库"><a href="#添加库" class="headerlink" title="添加库"></a>添加库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_library(targetName [STATIC | SHARED | MODULE]</span><br><span class="line">              [EXCLUDE_FROM_ALL]</span><br><span class="line">              source1 [source2 ...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>也可以直到编译时才指定使用静态还是动态库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DBUILD_SHARED_LIBS=YES /path/to/source</span><br></pre></td></tr></table></figure></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(targetName</span><br><span class="line">       &lt;PRIVATE|PUBLIC|INTERFACE&gt; item1 [item2 ...]</span><br><span class="line">      [&lt;PRIVATE|PUBLIC|INTERFACE&gt; item3 [item4 ...]]</span><br><span class="line">      ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里的库既可以是 cmake 里面定义的，也可以是一个路径、或者库名（如，pthread）</p><h2 id=""><a href="#" class="headerlink" title=""></a><br></h2><p>书还没看完，待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看一本书，《自己动手写JVM》，语言用的是 Go。想提高一下 C++ 的熟练度，所以自己用 C++ 跟着写一遍。既然用 C++，就得给自己找一个编译工具，最后选定的是 cmake。这篇文章记录的是个人 cmake 学习的一些总结，书籍使用《Professional CMake - A Practical Guide》。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://jekton.github.io/categories/JVM/"/>
    
    
      <category term="way to JVM" scheme="https://jekton.github.io/tags/way-to-JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 之路（0）- 我将去往何方？</title>
    <link href="https://jekton.github.io/2018/08/19/way-to-JVM-0/"/>
    <id>https://jekton.github.io/2018/08/19/way-to-JVM-0/</id>
    <published>2018-08-19T10:01:21.000Z</published>
    <updated>2018-08-19T12:44:13.204Z</updated>
    
    <content type="html"><![CDATA[<p>前不久（2018.7）是我毕业后第一次跳槽，薪水也如愿得到了不小的提升与。之相伴的，还有成长的苦恼。这篇文章作为开篇，主要包括我对个人的现状的思考，也确定了自己未来一段时间内的方向。如果你觉得这个目标不错，也可以一起学习。</p><a id="more"></a><h2 id="迷茫"><a href="#迷茫" class="headerlink" title="迷茫"></a>迷茫</h2><p>毕业后一直在 A 公司上班，A 公司团队比较小，所做的应用（Android应用）的体量也大多是几千行到一万。大部分工作，都是在写一些业务代码。现在在 B 公司，B 公司应用比较大，团队人数也多，分工很细。在 B 公司，主要的工作仍然是写业务代码。</p><p>那我就不禁要问自己，继续这样做下去，两年后，我能够达到什么样的高度？如果单以薪资论，两年后我还能有像刚毕业的这前两年一样的涨幅吗？答案是，不可能。</p><p>有这样一句鸡汤，大意是：迷茫都是能力配不上理想/抱负。根本问题还在于，我们要如何提升自己的能力？</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>前面我说工作一直写业务代码，能力得不到提升。但你可千万别误会，我绝对不是说，写业务代码不能提升个人能力，只是说无法达到我想要的高度。</p><p>这个世界唯一不变的，就是变化。需求总是在变，足够多的业务代码经验，可以让我们写出更能适应变化的代码；由于大部分时候我们都在使用别人提供的 API，我们很清楚什么样的 API 更受客户青睐，这在将来自己设计 API 的时候会非常有帮助。我倾向于把这部分能力称为“道”（区别于特定的编程领域的“术”），这就是日常工作所能够带给我的东西。我所欠缺的，是术。</p><p>我希望有深研某一方向的经验，即某个领域的专家。目前来看并没有这样的机会。那么，我还能做些什么？</p><p>《原则》这书里面提到这样一个原则，为了达到某个目的，我们要先看看自己处于什么位置（拥有什么），然后考虑如何利用这些东西达到目标。所以这里先回顾一下我会什么。</p><p>首先，我对所谓的“底层”比较感兴趣。这个很重要，既然不是工作，当然要做一些自己喜欢的事。</p><p>其次，我希望能够做一些没有人在做的东西。</p><p>最后才是我目前拥有的技能，这部分的重要程度比较低，因为技能可以快速学到：</p><ol><li>学过 C/C++，看过不少 C 代码，但实操经验不足</li><li>对内核、网络比较了解</li></ol><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>考虑到深度，我大概考虑过这样一些方向：内核、JVM、浏览器、Android framework。考虑到跟工作的相关性，就剩下 JVM 和 Android framework。说实话，我对 Android framework 那一大坨代码实在没有什么兴趣。这样一来，就剩下 JVM 了。JVM 相关的书籍倒是有一些，看过一两本，也还是不知道如何去看 HotSpot 的源码，也不知道怎么自己写一个。哎，HotSpot 相关的资源太不成体系了！</p><p>咦，既然我觉得 JVM 不好学，那别人不是也一样？！那我可以做的，就是把自己学习 JVM 的过程整理出来。如果我学成了，别人也有大概的路径可寻，何乐而不为。</p><p>这就是我要做的事在——把自己学习的过程中整理记录下来，帮助别人学习 JVM。另一方面也是敦促我自己走下去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前不久（2018.7）是我毕业后第一次跳槽，薪水也如愿得到了不小的提升与。之相伴的，还有成长的苦恼。这篇文章作为开篇，主要包括我对个人的现状的思考，也确定了自己未来一段时间内的方向。如果你觉得这个目标不错，也可以一起学习。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://jekton.github.io/categories/JVM/"/>
    
    
      <category term="way to JVM" scheme="https://jekton.github.io/tags/way-to-JVM/"/>
    
  </entry>
  
  <entry>
    <title>JDK 源码分析（1）- FutureTask</title>
    <link href="https://jekton.github.io/2018/07/25/jdk-FutureTask/"/>
    <id>https://jekton.github.io/2018/07/25/jdk-FutureTask/</id>
    <published>2018-07-25T05:27:45.000Z</published>
    <updated>2018-08-18T12:47:22.691Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是 JDK 源码分析的第一篇，主要关注 <code>FutureTask</code> 的实现。我们所分析的源码使用的是 Java10，因此也假设了读者了解 <code>VarHandle</code>（Java9 新增的 API），不了解的读者可以看我翻译的<a href="https://jekton.github.io/2018/07/22/java-translation-jep-193-Variable-Handles/">JEP 193</a>。</p><a id="more"></a><h2 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h2><p>这里我们不准备详细讲 <code>FutureTask</code> 的用法，只是简单提一下，帮组读者回忆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首先我们构造一个 `FutureTask`</span></span><br><span class="line">FutureTask&lt;Foo&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 然后我们把这个实例放在后台线程执行，比方说 executor：</span></span><br><span class="line">executor.execute(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 最后，我们获取执行的结果</span></span><br><span class="line">Foo foo = task.get();</span><br></pre></td></tr></table></figure><p>如果读者对 <code>FutureTask</code> 的用法不是很熟悉，等看完源码就会非常清楚了。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The run state of this task, initially NEW.  The run state</span></span><br><span class="line"><span class="comment">     * transitions to a terminal state only in methods set,</span></span><br><span class="line"><span class="comment">     * setException, and cancel.  During completion, state may take on</span></span><br><span class="line"><span class="comment">     * transient values of COMPLETING (while outcome is being set) or</span></span><br><span class="line"><span class="comment">     * INTERRUPTING (only while interrupting the runner to satisfy a</span></span><br><span class="line"><span class="comment">     * cancel(true)). Transitions from these intermediate to final</span></span><br><span class="line"><span class="comment">     * states use cheaper ordered/lazy writes because values are unique</span></span><br><span class="line"><span class="comment">     * and cannot be further modified.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Possible state transitions:</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">// this.state 是 volatile，对 volatile 字段的写入，存在一个 happen-before</span></span><br><span class="line">        <span class="comment">// 关系；也就是说，`this.state = NEW` 执行完毕时，`this.callable = callable`</span></span><br><span class="line">        <span class="comment">// 也保证已经写入</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为标准库的实现，在性能上我们锱铢必较。这里利用 <code>volatile</code> 的特性，可以不需要设置 <code>callable</code> 为 <code>volatile</code>。</p><h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>创建了 <code>FutureTask</code> 实例后，我们就可以执行他了。这个由 <code>run()</code> 方法来完成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            <span class="comment">// 这是一个原子操作</span></span><br><span class="line">            !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="comment">// 假设有两个线程竞争执行这个 futureTask，线程1 执行了</span></span><br><span class="line">            <span class="comment">// state != NEW 后，轮到线程2，同样执行成功；接着线程2</span></span><br><span class="line">            <span class="comment">// 继续执行到方法结束并设置 runner 回 null；再后面，线</span></span><br><span class="line">            <span class="comment">// 程1 重新被调度，来到了下面这个 if 语句。此时其实已经</span></span><br><span class="line">            <span class="comment">// 执行完成，所以这里要再判断一次</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 情况1：发生异常</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    <span class="comment">// 情况2：执行成功</span></span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 情况3：任务被取消</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VarHandle mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MethodHandles.Lookup l = MethodHandles.lookup();</span><br><span class="line">            STATE = l.findVarHandle(FutureTask.class, <span class="string">"state"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">            RUNNER = l.findVarHandle(FutureTask.class, <span class="string">"runner"</span>, Thread.class);</span><br><span class="line">            WAITERS = l.findVarHandle(FutureTask.class, <span class="string">"waiters"</span>, WaitNode.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reduce the risk of rare disastrous classloading in first call to</span></span><br><span class="line">        <span class="comment">// LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span></span><br><span class="line">        Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们分 3 种情况来看代码。</p><h3 id="情况1：发生异常"><a href="#情况1：发生异常" class="headerlink" title="情况1：发生异常"></a>情况1：发生异常</h3><p>如果执行的过程发生了异常，会调用 <code>setException</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可能客户会调用 cancel 方法取消任务，所以这里要用原子操作</span></span><br><span class="line">        <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">            outcome = t;</span><br><span class="line">            STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>VarHandle</code> 的 <code>setRelease</code> 有这样一句注释：</p><blockquote><p>Sets the value of a variable to the {@code newValue}, and ensures that prior loads and stores are not reordered after this access.</p></blockquote><p>所以（如果 <code>compareAndSet</code> 执行成功），当我们把 <code>state</code> 设置为 <code>EXCEPTIONAL</code> 前，能够保证 <code>outcome = t</code> 已经执行完成。</p><p><code>finishCompletion</code> 我们留到后面再看。</p><h3 id="情况2：执行成功"><a href="#情况2：执行成功" class="headerlink" title="情况2：执行成功"></a>情况2：执行成功</h3><p>执行成功时调用 <code>set</code> 方法，它的实现跟 <code>setException</code> 差不多：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="情况3：任务被取消"><a href="#情况3：任务被取消" class="headerlink" title="情况3：任务被取消"></a>情况3：任务被取消</h3><p>如果需要取消任务，可以调用 <code>FutureTask</code> 的 <code>cancel</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">              (<span class="keyword">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="comment">// 如果当前状态不是 NEW 并且不能成功将其设置为 INTERRUPTING/CANCELLED</span></span><br><span class="line">            <span class="comment">// 表示任务已经执行完，所以 cancel 失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="comment">// 如果 t == null，要么是这个任务还没开始执行，要么已经执行</span></span><br><span class="line">                    <span class="comment">// 到了 run 方法里的 finally 块</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    STATE.setRelease(<span class="keyword">this</span>, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果 <code>mayInterruptIfRunning == false</code>，那就直接尝试把状态设置为 <code>CANCELLED</code>；否则需要 interrupt 线程。下面是 <code>run</code> 方法最后的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">final</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 对应 mayInterruptIfRunning == true 的情况</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensures that any interrupt from a possible cancel(true) is only</span></span><br><span class="line"><span class="comment">     * delivered to a task while in run or runAndReset.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">        <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></span><br><span class="line">        <span class="comment">// 注意，第一个比较的是参数 s，s 可能是 `INTERRUPTED`</span></span><br><span class="line">        <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">            <span class="comment">// state 是 volatile，保证我们这里每次都能够读到最新的值</span></span><br><span class="line">            <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">                Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// assert state == INTERRUPTED;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We want to clear any interrupt we may have received from</span></span><br><span class="line">        <span class="comment">// cancel(true).  However, it is permissible to use interrupts</span></span><br><span class="line">        <span class="comment">// as an independent mechanism for a task to communicate with</span></span><br><span class="line">        <span class="comment">// its caller, and there is no way to clear only the</span></span><br><span class="line">        <span class="comment">// cancellation interrupt.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Thread.interrupted();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有 3 种情况，最后都会调用 <code>finishCompletion</code> 方法，这部分我们下一节继续看。</p><h2 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h2><p>在 <code>finishCompletion</code> 的内部，会唤醒等待结果的线程。这里我们先不看 <code>finishCompletion</code>，而是看看 <code>get</code> 方法，这样会更容易理解一些。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">// awaitDone 会返回结束时的状态</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            <span class="comment">// timeout 后还没有结束</span></span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这部分的重点在于 <code>awaitDone</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class="line"><span class="comment">     * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class="line"><span class="comment">     * for more detailed explanation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Awaits completion or aborts on interrupt or timeout.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timed true if use timed waits</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanos time to wait, if timed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> state upon completion or at timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// The code below is very delicate, to achieve these goals:</span></span><br><span class="line">        <span class="comment">// - call nanoTime exactly once for each call to park</span></span><br><span class="line">        <span class="comment">// - if nanos &lt;= 0L, return promptly without allocation or nanoTime</span></span><br><span class="line">        <span class="comment">// - if nanos == Long.MIN_VALUE, don't underflow</span></span><br><span class="line">        <span class="comment">// - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic</span></span><br><span class="line">        <span class="comment">//   and we suffer a spurious wakeup, we will do no worse than</span></span><br><span class="line">        <span class="comment">//   to park-spin for a while</span></span><br><span class="line">        <span class="keyword">long</span> startTime = <span class="number">0L</span>;    <span class="comment">// Special value 0L means not yet parked</span></span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 任务完成或被取消</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">                <span class="comment">// 到 COMPLETING 状态了的话，预期很快就会结束，所以 yield 一下</span></span><br><span class="line">                <span class="comment">// 就够了</span></span><br><span class="line">                <span class="comment">// We may have already promised (via isDone) that we are done</span></span><br><span class="line">                <span class="comment">// so never return empty-handed or throw InterruptedException</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">// removeWaiter 把节点从 waiters 列表里移除</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一个循环，q == null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用 get 方法时传入时间为 0 或负值，可以轮询任务；</span></span><br><span class="line">                <span class="comment">// 默认版本的 get 传入的 timed == false，会无限等待</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> s;</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// queued 初始为 false</span></span><br><span class="line">            <span class="comment">// 第二个循环会执行下面这个语句，把 q 入队。</span></span><br><span class="line">            <span class="comment">// （上一步成功的情况下）第三个循环才会开始执行再往下的休眠操作</span></span><br><span class="line">            <span class="comment">// 注意：每个循环都会检查 state</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                <span class="comment">// 这里我们先把队头 waiters 赋值给 q.next，赋值语句的返回值还是</span></span><br><span class="line">                <span class="comment">// waiters。执行这个语句的时候，我们期待 waiter 的当前值是 waiters</span></span><br><span class="line">                <span class="comment">// 并且将它设置为 q。</span></span><br><span class="line">                <span class="comment">// 因为可能有多个线程同时执行这个方法，这个语句还是有可能会执行</span></span><br><span class="line">                <span class="comment">// 失败的。如果失败，在接下来的循环里会重试</span></span><br><span class="line">                <span class="comment">// weakCompareAndSet 就姑且当做原子的 compareAndSet 吧</span></span><br><span class="line">                queued = WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> parkNanos;</span><br><span class="line">                <span class="keyword">if</span> (startTime == <span class="number">0L</span>) &#123; <span class="comment">// first time</span></span><br><span class="line">                    startTime = System.nanoTime();</span><br><span class="line">                    <span class="keyword">if</span> (startTime == <span class="number">0L</span>)</span><br><span class="line">                        startTime = <span class="number">1L</span>;</span><br><span class="line">                    parkNanos = nanos;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class="line">                    <span class="keyword">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class="line">                        removeWaiter(q);</span><br><span class="line">                        <span class="keyword">return</span> state;</span><br><span class="line">                    &#125;</span><br><span class="line">                    parkNanos = nanos - elapsed;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// nanoTime may be slow; recheck before parking</span></span><br><span class="line">                <span class="keyword">if</span> (state &lt; COMPLETING)</span><br><span class="line">                    <span class="comment">// 把线程投入休眠</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, parkNanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们继续看 <code>removeWaiter</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to unlink a timed-out or interrupted wait node to avoid</span></span><br><span class="line"><span class="comment"> * accumulating garbage.  Internal nodes are simply unspliced</span></span><br><span class="line"><span class="comment"> * without CAS since it is harmless if they are traversed anyway</span></span><br><span class="line"><span class="comment"> * by releasers.  To avoid effects of unsplicing from already</span></span><br><span class="line"><span class="comment"> * removed nodes, the list is retraversed in case of an apparent</span></span><br><span class="line"><span class="comment"> * race.  This is slow when there are a lot of nodes, but we don't</span></span><br><span class="line"><span class="comment"> * expect lists to be long enough to outweigh higher-overhead</span></span><br><span class="line"><span class="comment"> * schemes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 为了能够重新开始整个循环，包裹了一层 for 循环</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">            <span class="comment">// 遍历 waiters</span></span><br><span class="line">            <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="comment">// 下面两种情况对应 q.thread == null，也就是说，q 是待删除的节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// next 字段是 volatile，所以这里可以直接赋值。把 prev.next</span></span><br><span class="line">                    <span class="comment">// 指向 s （q.next）后就删除了 q。</span></span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                        <span class="comment">// 很倒霉的，prev 也要被删除（或已经被删除）</span></span><br><span class="line">                        <span class="comment">// 这里有三种可能：</span></span><br><span class="line">                        <span class="comment">// 1. prev.node 刚被设置为 null，但这个节点还在列表里，</span></span><br><span class="line">                        <span class="comment">//    prev.next = s 成功把 q 从列表里删除</span></span><br><span class="line">                        <span class="comment">// 2. 节点已经被删除</span></span><br><span class="line">                        <span class="comment">//    2.1 prev 是头节点（这将会执行下面那个else if 子句），</span></span><br><span class="line">                        <span class="comment">//        q 被设置为队头，q.next 仍旧指向 s；</span></span><br><span class="line">                        <span class="comment">//    2.2 prev 不是头结点，prev.prev.next 指向了 q；</span></span><br><span class="line">                        <span class="comment">//    这两种情况下，q 还留在列表里</span></span><br><span class="line">                        <span class="comment">// 所有这3种情况下，数据结构都是正常的。如果 q 还在列表里，</span></span><br><span class="line">                        <span class="comment">// 重新开始循环后总会删除它。如果已经被删除，遍历完列表后</span></span><br><span class="line">                        <span class="comment">// 也会退出。</span></span><br><span class="line">                        <span class="comment">// q 已经被删除的情况下，即使下个循环里我们把别人要删除的</span></span><br><span class="line">                        <span class="comment">// 节点给删除了也没关系。</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// q 在队头，所要把 waiters 设置为 s</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!WAITERS.compareAndSet(<span class="keyword">this</span>, q, s))</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你觉得 <code>removeWaiter</code> 难以理解，建议多看几遍（我自己也是研究了很久），使用原子操作来实现并发访问是会带来比较大的复杂度的。</p><p>最后，我们来看个简单的 <code>finishCompletion</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 把 waiters 设置为 null 后相当于取出所有的 waiter</span></span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 遍历 waiters</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 唤醒线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>FutureTask</code> 到这里我们就看完了。虽然代码量不多，但还是比预料中的复杂。除了上面代码里明确使用的 volatile 和原子操作，<code>FutureTask</code> 对 <code>state</code> 的定义也是很讲究的。通过增序定义 state 常量，在某些情况下我们可以直接通过比较常量值来判断状态是否处于某些状态集。比方说，是否被中断使用的是 <code>state &gt;= INTERRUPTING</code>；如果不这么做，我们就需要 <code>state == INTERRUPTING || state == INTERRUPTED</code>，毫无疑问，前者会执行得更快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是 JDK 源码分析的第一篇，主要关注 &lt;code&gt;FutureTask&lt;/code&gt; 的实现。我们所分析的源码使用的是 Java10，因此也假设了读者了解 &lt;code&gt;VarHandle&lt;/code&gt;（Java9 新增的 API），不了解的读者可以看我翻译的&lt;a href=&quot;https://jekton.github.io/2018/07/22/java-translation-jep-193-Variable-Handles/&quot;&gt;JEP 193&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jekton.github.io/categories/Java/"/>
    
    
      <category term="JDK" scheme="https://jekton.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>翻译 - JEP 193：Variable Handles</title>
    <link href="https://jekton.github.io/2018/07/22/java-translation-jep-193-Variable-Handles/"/>
    <id>https://jekton.github.io/2018/07/22/java-translation-jep-193-Variable-Handles/</id>
    <published>2018-07-22T05:10:24.000Z</published>
    <updated>2018-08-18T12:47:22.691Z</updated>
    
    <content type="html"><![CDATA[<p>Author: Doug Lea<br>Owner: Paul Sandoz<br>Type: Feature<br>Scope: SE<br>Status: Closed/Delivered<br>Release: 9<br>Component: core-libs/java.lang<br>Discussion: core dash libs dash dev at openjdk dot java dot net<br>Effort: M<br>Duration: L<br>Relates to <a href="http://openjdk.java.net/jeps/266" target="_blank" rel="noopener">JEP 266: More Concurrency Updates</a><br>Reviewed by: Dave Dice, Paul Sandoz<br>Endorsed by: Brian Goetz<br>Created: 2014/01/06 20:00<br>Updated: 2017/08/17 16:45<br>Issue: <a href="https://bugs.openjdk.java.net/browse/JDK-8046183" target="_blank" rel="noopener">8046183</a></p><blockquote><p>原文地址：<a href="http://openjdk.java.net/jeps/193" target="_blank" rel="noopener">JEP 193: Variable Handles</a>，JEP 表示 JDK Enhancement Proposal</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>定义一个用来操作对象的字段、数组元素的跟 <code>java.util.concurrent.atomic</code> 和 <code>sun.misc.Unsafe</code> 等价的标准工具，它提供了一个标准的栅栏操作（fence operation）工具集用于精细地控制内存排序和一个标准的可达性栅栏操作（reachability-fence operation）来保证一个被引用的对象是强可达的（strongly reachable）。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>下面是一些必须达到的目标：</p><ul><li>安全性。它不能使 JVM 处于一个不一致的状态。例如，对象的某个字段只能用一个能够转换成对应类型的（castable to the field type）值来更新，一个数组的元素只有当下标处于正常范围内才能够被访问。</li><li>一致性（Integrity）。访问对象的字段遵循跟 <code>getfield</code>、<code>putfield</code> 这两个指令一样的访问权限控制，并且 <code>final</code> 域不能被更新。（<code>MethodHandles</code> 在读写成员变量时同样遵守这里所说的安全和一致性规则）</li><li>性能。它所提供的性能必须跟 <code>sun.misc.Unsafe</code> 差不多（特别地，除了某些无法折叠的安全检查，生成的汇编代码应该几乎完全相同。</li><li>可用性。它的 API 必须必 <code>sun.misc.Unsafe</code> 更好。</li></ul><p>我们希望它的 API 能够比 <code>java.util.concurrent.atomic</code> 更好，但这不是必须的。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>随着 Java 并发、并行编程的发展，程序员们对于不能对类的成员执行原子操作或对操作进行排序感到越来越失望；比方说，原子地递增一个用于计数的成员变量。到目前为止，唯一能够实现这一目标的方法就是使用一个独立的 <code>AtomicInteger</code>（不仅增加了内存，还因为这个额外的间接性引入了其他并发问题）；或者，在某些情况下，使用一个原子的 <code>FieldUpdaters</code> （通常带来更多的性能损耗（overhead））；亦或者，使用不安全的用于 JVM 的基础设施（JVM intrinsics）<code>sun.misc.Unsafe</code>（它经常是不可移植且不可用的）。</p><p>如果没有这个 JEP，随着对 Java 内存模型的修改，这些问题会因原子 API 扩充对访问一致性（access-consistency）（对应于 C++11 的内存模型）的支持而变得更糟糕。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一个变量句柄（variable handle）是一个变量的带类型的引用，它支持使用一系列访问模型对变量进行读写。支持的变量类型包括成员变量、静态成员变量和数组元素。另一些正在考虑是否支持的类型有数组视图（array views），它把一个 <code>byte</code> 或 <code>char</code> 数组当成 <code>long</code> 数组；就像 <code>ByteBuffer</code> 用来描述一个堆外内存（off-heap regions）一样。</p><p>变量句柄需要我们增强标准库、JVM，增加编译器的支持。此外，它还需要对 Java 语言规范和 Java 虚拟机规范进行小的修改。一个小小的语言增强，用于编译时的类型检查并且补足现有的语法，也是需要考虑的。</p><p>规范应该通过一种自然的方式来扩展额外的类基本类型（primitive-like）数值类型和类数组（array-like）类型，如果它们曾经被添加到 Java 里。这不是一个通用的用来访问、更新多个变量的事务机制。其他可选的用来表述、实现这些构件的方案可能会在这篇 JEP 里探讨，也可能是在更进一步的 JEP 里。</p><p>变量句柄使用一个抽象类 <code>java.lang.invoke.VarHandle</code> 来表示，每个变量的访问模式用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html#sigpoly" target="_blank" rel="noopener">多态签名（signature-polymorphic）</a>来表示。</p><blockquote><p>小罗路过：关于多态签名，在后面看了 <code>VarHandle</code> 的方法后读者就会明白的。</p></blockquote><p>访问模式（access mode）代表一个最小可用集合，它被设计成跟 C/C++ 11 的原子变量相兼容而不是依赖一个修改过的 Java 内存模型。如果需要的话，也可以添加额外的访问模式。某些变量可能不支持特定的访问模式，如果在对应的 <code>VarHandle</code> 上执行这些操作，将会抛出 <code>UnsupportedOperationException</code> 异常。</p><p>访问模式可以归纳为以下几类：</p><ol><li>读模式，例如用带 <code>volatile</code> 内存排序效果（volatile memory ordering effects）的语义去读一个变量；</li><li>写模式，比如使用 release memory ordering effects 去更新变量；</li><li>原子更新模式，例如使用带 volatile memory ordering effects 的 compare-and-set 去更新变量；</li><li>数值原子更新模式，例如使用带 plain memory order effects 的写和用于读的 acquire memory order effects 来执行 get-and-add；</li><li>按位原子更新模式，例如使用 release memory order effects 的写和 plain memory order effects 的读来执行 get-and-bitwise-and。</li></ol><p>最后三个通常也称为 read-modify-write 模式。</p><p>访问模式方法的签名多态特性让变量句柄可以仅使用一个抽象类而支持各种各样的类型。这可以防止类型的爆炸。更进一步，尽管访问模式方法签名里的参数定义为 <code>Object</code> 数组，签名多态的特性仍然可以防止对基本类型的自动装箱操作并且不会将参数打包成数组。这使它们有了可预测的行为从而在 HotSpot 翻译器的运行时和 C1/C2 编译器上有更好的性能。</p><blockquote><p>小罗路过：访问模式方法原文为 access mode method，指的是 <code>VarHandle</code> 的成员方法。</p></blockquote><p>用于生成 <code>VarHandle</code> 的方法跟生成 <code>MethodHandle</code> 实例的方法放在了同一个地方，它们生成相等或类似的变量类型。</p><p>用于成员变量和静态变量的 <code>VarHandle</code> 使用 <code>java.lang.invoke.MethodHandles.Lookup</code> 下的方法生成，它通过查找接收类的字段来实例化对象。举个例子，通过查找来生成接收类 <code>Foo</code> 的 <code>int</code> 型成员 <code>i</code> 的 <code>VarHandle</code> 可以像下面这样来做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> VarHandle VH_FOO_FIELD_I;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            VH_FOO_FIELD_I = MethodHandles.lookup().</span><br><span class="line">                in(Foo.class).</span><br><span class="line">                findVarHandle(Foo.class, <span class="string">"i"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个查找过程在生成并返回 <code>VarHandle</code> 前，会检查一系列的访问控制权限。对 <code>MethodHandle</code> 来说也一样，会看提供了读、写的 <code>MethodHandle</code> （参考 <code>MethodHandles.Lookup</code> 的 <code>find{,Static}{Getter,Setter}</code> 方法）的针对特定字段是否有对应的权限。</p><blockquote><p>小罗路过：举个栗子。下面把 <code>Foo.i</code> 改成了 <code>private</code>，所以 <code>VH_FOO_FIELD_I</code> 可以成功生成，而 <code>Bar.MH_FOO_FIELD_I</code> lookup 的时候会抛异常。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> VarHandle VH_FOO_FIELD_I;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            VH_FOO_FIELD_I = MethodHandles.lookup().</span><br><span class="line">                    in(Foo.class).</span><br><span class="line">                    findVarHandle(Foo.class, <span class="string">"i"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> MethodHandle MH_FOO_FIELD_I;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MH_FOO_FIELD_I = MethodHandles.lookup().</span><br><span class="line">                    in(Foo.class).</span><br><span class="line">                    findSetter(Foo.class, <span class="string">"i"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面这些条件下，访问模式方法会抛出 <code>UnsupportedOperationException</code> 异常：</p><ul><li>对一个 <code>final</code> 变量调用写访问模式方法</li><li>对引用类型或非数值类型（如 <code>boolean</code>）调用数值访问模式方法（<code>getAndAdd</code>，<code>addAndGet</code>）</li><li>对引用类型或 <code>float/double</code> 执行按位访问模式方法（后者以后可能会移除）</li></ul><p>一个字段不需要声明为 <code>volatile</code> 也可以使用 <code>VarHandle</code> 来进行 volatile access。实际上，如果携带了 <code>volatile</code> 修饰符，它会被忽略掉。这个行为跟 <code>java.util.concurrent.atomic.Atomic{Int, Long, Reference}FieldUpdater</code> 是不一样的，使用后者时对应的字段需要声明为 <code>volatile</code>。当我们在某些时候需要 volatile 语义而其他时候不需要时，FilldUpdater 就显得过于受限了。</p><p>生成用于数组的 <code>VarHandle</code> 位于 <code>java.lang.invoke.MethodHandles</code> （参考 <code>MethodHandles</code> 的 <code>arrayElement{Getter, Setter}</code> 方法）。例如，用于 <code>int</code> 数组的 <code>VarHandle</code> 可以这样生成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VarHandle intArrayHandle = MethodHandles.arrayElementVarHandle(<span class="keyword">int</span>[].class);</span><br></pre></td></tr></table></figure></p><p>在下列情况下，访问模式方法会抛出 <code>UnsupportedOperationException</code> 异常：</p><ul><li>使用数值方法模式方法去修改引用类型或非数值类型（如 <code>boolean</code>）数组的元素</li><li>对引用类型或 <code>float/double</code> 执行按位访问模式方法（后者以后可能会移除）</li></ul><p>所有的变量类型的基本类型（primitive types）和引用类型都是被支持的，只要它们的变量种类（variable kinds）是成员变量、静态变量或数组。其他变量种类可能会部分或全部支持。</p><blockquote><p>小罗路过：这里的变量种类指的是局部变量，成员变量这一些</p></blockquote><p>生成用于 array-view-based 的 <code>VarHandle</code> 的方法位于 <code>java.lang.invoke.MethodHandles</code>。举个例子，下面生成的 <code>VarHandle</code> 把一个 <code>byte</code> 数组看成一个非对其（unaligned）的 <code>long</code> 数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VarHandle longArrayViewHandle = MethodHandles.byteArrayViewVarHandle(</span><br><span class="line">        <span class="keyword">long</span>[].class, java.nio.ByteOrder.BIG_ENDIAN);</span><br></pre></td></tr></table></figure></p><p>尽管同样的效果可以通过 <code>java.nio.ByteBuffer</code> 得到，但这种方式需要一个 <code>ByteBuffer</code> 实例用于包裹 <code>byte</code> 数组。由于这导致了脆弱的逃逸分析，它并不总是能够得到可接受的性能并且每次访问都需要通过一个 <code>ByteBuffer</code> 实例。在非对其访问的情况下，除了普通（plain）的方法模式方法，都会抛出 <code>IllegalStateException</code> 异常。对齐访问的情况下，取决于变量的类型，一些 volatile 访问模式是允许的。这些 <code>VarHandle</code> 可以用来向量化（vectorize）数组存取操作。</p><p>访问模式方法的参数的数量、参数的类型、返回值的类型取决于变量种类（viriable kind）、变量类型和访问模式的特性。<code>VarHandle</code> 的生成方法（我们前面提到的那些）会在文档里说明必要条件。例如，对前面我们所生成的 <code>VH_FOO_FIELD_I</code> 调用 <code>compareAndSet</code> 需要 3 个参数，一个 Foo 实例作为接收者，一个 <code>int</code> 作为 expected value 和另一个作为 actual value：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo f = ...</span><br><span class="line"><span class="keyword">boolean</span> r = VH_FOO_FIELD_I.compareAndSet(f, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>相对的，<code>getAndSet</code> 只需要两个参数，一个 Foo 实例作为接收者，一个 <code>int</code> 用于设置值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> o = (<span class="keyword">int</span>) VH_FOO_FIELD_I.getAndSet(f, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>访问数组元素的时候需要一个额外的 <code>int</code> 型的参数，它位于接收者和其他参数之间（如果有的话），这个参数对应于需要操作的元素的下标。</p><p>为了可预测的行为和运行时性能，<code>VarHandle</code> 实例必须放在一个 <code>static final</code> 的字段里（就跟 <code>Atomic{Int, Long, Reference}FieldUpdater</code> 所要求的那样）。这可以保证在调用访问模式方法的时候会发生常量折叠，例如去掉方法签名的检查和/或参数的类型转换检查。</p><blockquote><p>注：将来的 HotSpot 增强可能会支持没有使用 <code>static final</code> 持有的 <code>VarHandle</code> 和 <code>MethodHandle</code>。</p></blockquote><p>一个 <code>MethodHandle</code> 可以使用 <code>VarHandle</code> 的访问模式方法通过 <code>MethodHandles.Lookup.findVirtual</code> 来生成。例如，下面给一个特定的变量类型和变量种类生成一个 <code>compareAndSet</code> 访问模式方法对应的 <code>MethodHandle</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo f = ...</span><br><span class="line">MethodHandle mhToVhCompareAndSet = MethodHandles.publicLookup().findVirtual(</span><br><span class="line">        VarHandle.class,</span><br><span class="line">        <span class="string">"compareAndSet"</span>,</span><br><span class="line">        MethodType.methodType(<span class="keyword">boolean</span>.class, Foo.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class));</span><br></pre></td></tr></table></figure></p><p><code>MethodHandle</code> 可以用一个变量种类和类型都兼容的 <code>VarHandle</code> 实例作为第一个参数来调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> r = (<span class="keyword">boolean</span>) mhToVhCompareAndSet.invokeExact(VH_FOO_FIELD_I, f, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>或者，<code>mhToVhCompareAndSet</code> 可以绑定到一个 <code>VarHandle</code> 实例然后再调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MethodHandle mhToBoundVhCompareAndSet = mhToVhCompareAndSet</span><br><span class="line">        .bindTo(VH_FOO_FIELD_I);</span><br><span class="line"><span class="keyword">boolean</span> r = (<span class="keyword">boolean</span>) mhToBoundVhCompareAndSet.invokeExact(f, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>像这样的使用 <code>findVirtual</code> 进行的 <code>MethodHandle</code> 查找会使用一个 asType 转换来调整参数然后再返回结果。这个行为跟使用 <code>MethodHandles.invoker</code> 的类比物 <code>MethodHandles.varHandleInvoker</code> 来生成 <code>MethodHandle</code> 是一样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MethodHandle mhToVhCompareAndSet = MethodHandles.varHandleExactInvoker(</span><br><span class="line">        VarHandle.AccessMode.COMPARE_AND_SET,</span><br><span class="line">        MethodType.methodType(<span class="keyword">boolean</span>.class, Foo.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class));</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> r = (<span class="keyword">boolean</span>) mhToVhCompareAndSet.invokeExact(VH_FOO_FIELD_I, f, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>所以通过包装在一个类中， <code>VarHandle</code> 可以在（类型被擦除）或反射的情景下使用。比方说，用来替代 <code>java.util.concurrent.Atomic*FieldUpdater/Atomic*Array</code> 中对 <code>Unsafe</code> 的使用（尽管需要更进一步的工作，以保证这些 updater 对相应的字段用于足够的访问权限）。</p><p>对访问模式方法的调用的编译跟具有签名多态的 <code>MethodHandle.invokeExact</code> 和 <code>MethodHandle.invoke</code> 所遵守的规则是一样的。下面这些是对 Java 语言规范所附加的内容：</p><ol><li>生成对 <code>VarHandle</code> 的签名多态的访问模式方法的引用</li><li>允许签名多态方法返回不是 <code>Object</code> 类型的值，这意味着返回值类型不再是多态的（并且也因为可以在调用的地方声明一个强制类型转换）。这可以让写访问模式方法放回 <code>void</code>，<code>compareAndSet</code> 返回 <code>boolean</code> 变得更容易。</li></ol><p>如果对签名多态的方法的调用行为可以增强为自动识别返回值的类型会很好，但这不是必须的。</p><blockquote><p>注：使用像方法引用那样的语法来生成 <code>VarHandle</code> 和 <code>MethodHandle</code>，比方说 <code>VarHandle VH_FOO_FIELD_I = Foo::i</code>，它所需要的语法和运行时支持是可取的，但不会在这篇 JEP 里讨论。</p></blockquote><p>运行时对访问模式方法的调用跟使用 <code>MethodHandle.invokeExact</code> 和 <code>MethodHandle.invoke</code> 进行签名多态方法调用所遵循的规则是类似的。下面是对 Java 虚拟机规范所附加的要求：</p><ol><li>在 <code>VarHandle</code> 内引用签名多态的访问模式方法</li><li>定义对签名多态的访问模式方法进行 <code>invokevirtual</code> 时的行为。预期这种行为会通过一个从访问模式方法的调用到对应的 <code>MethodHandle</code> 之间的使用相同参数的转换来定义（参考前面对 <code>MethodHandles.Lookup.findVirtual</code> 的使用）。</li></ol><blockquote><p>小罗路过：这里第1条说我们可以拿到一个 access mode method（这些方法属于 <code>VarHandle</code>） 的 reference，所以自然就可以对这个 reference invokevirtual。通过使用类似 <code>MethodHandles.Lookup.findVirtual</code> 的机制生成 <code>MethodHandle</code> 后，就能够真正执行方法调用了（在这个意义上，我们可以认为这个 <code>MethodHandle</code> 实例对应着 <code>VarHandle</code> 的某一个 access mode method）。之所以这个转换是必须的，前面我们提到，对 <code>VarHandle</code> 的调用都会被折叠掉，所以也就不会有真正的方法存在。</p></blockquote><p><code>VarHandle</code> 对于所支持的变量类型、种类能够具有可靠的效率以达到目标性能要求是非常重要的。利用签名多态的方法可以避免自动装箱和数组的打包。（Java）实现必须：</p><ul><li>在包 <code>java.lang.invoke</code> 的内部，HotSpot 将类中的 <code>final</code> 字段认为是真正的 final，这使得 <code>VarHandle</code> 被 <code>static final</code> 域引用的时候可以进行常量折叠。</li><li>利用 JDK 内部的 <code>@Stable</code> 为那些仅改变一次的值进行常量折叠，利用 <code>@ForceInline</code> 来保证方法即使已经达到普通方法的 inline 上限也会被 inline</li><li>使用 <code>sun.misc.Unsafe</code> 实现底层增强的 volatile 访问</li></ul><p>一些 HotSpot 固有的支持（intrinsics）是必须的，部分罗列如下：</p><ul><li>对 <code>Class.cast</code> 的支持，它已经被添加了（参考<a href="https://bugs.openjdk.java.net/browse/JDK-8054492" target="_blank" rel="noopener">JDK-8054492</a>）。在虚拟机添加这个支持前，一个常量折叠的 <code>Class.cast</code> 还会遗留冗余的检查，这会导致不必要的性能损失。</li><li>当并发访问时，acquire-get 访问模式能够与 set-release 访问模式进行同步（参考 <code>sun.misc.Unsafe.putOrdered{Int, Long, Object}</code>）。</li><li>对数组范围检查<a href="https://bugs.openjdk.java.net/browse/JDK-8042997" target="_blank" rel="noopener">JDK-8042997</a>的原生支持。静态方法可以被添加到 <code>java.util.Arrays</code> 来做这个检查，它接受一个待调用的函数，然后在检查出错的情况下，返回一个异常或者一个出错消息，这个错误消息可以被用于包含在一个待抛出的异常中。像这样的原生支持可以使用无符号数进行更好地比较（毕竟，数组长度总是正的）并且更好地把范围检查提升到一个被展开（unrolled）了的循环的外面进行检查。</li></ul><p>此外，HotSpot 里更近一步的范围检查已经在 <a href="https://bugs.openjdk.java.net/browse/JDK-8073480" target="_blank" rel="noopener">JDK-8073480</a> 实现了（<a href="https://bugs.openjdk.java.net/browse/JDK-8003585" target="_blank" rel="noopener">JDK-8003585</a> 则用于强力去除 fork/join 框架、<code>HashMap</code> 和 <code>ConcurrentHashMap</code> 里的范围检查）。</p><p><code>VarHandle</code> 的实现必须保持对 <code>java.lang.invoke</code> 包里的其他类的最小依赖，以避免启动时间的增加和在静态初始化时产生循环依赖。比方说，如果 <code>VarHandle</code> 的某些实现使用 <code>ConcurrentHashMap</code>，而 <code>ConcurrentHashMap</code> 也被修改成使用了 <code>VarHandle</code>，此时必须保证没有引入循环依赖。另一个更微妙的循环是 <code>ThreadLocalRandom</code> 和他对 <code>AtomicInteger</code> 的使用。保证 HotSpot 的 C2 编译器编译时间不会因为对 <code>VarHandle</code> 的使用而过度增加也是很值得要的。</p><blockquote><p>小罗路过：<code>VarHandle</code> 是一个抽象类，这里 “<code>VarHandle</code> 的实现应该指的是它的子类”</p></blockquote><h2 id="内存栅栏（Memory-fences）"><a href="#内存栅栏（Memory-fences）" class="headerlink" title="内存栅栏（Memory fences）"></a>内存栅栏（Memory fences）</h2><blockquote><p>小罗路过：memory fences 跟所谓的 memory barrier 是同一个东西，memory barrier 现在大多翻译为内存屏障。</p></blockquote><p>屏障操作（fenced operations）作为 <code>VarHandle</code> 的静态方法来定义，是一个最小可用的精细控制内存顺序工具集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that loads and stores before the fence will not be</span></span><br><span class="line"><span class="comment"> * reordered with loads and stores after the fence.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span> Ignoring the many semantic differences from C and</span></span><br><span class="line"><span class="comment"> * C++, this method has memory ordering effects compatible with</span></span><br><span class="line"><span class="comment"> * atomic_thread_fence(memory_order_seq_cst)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that loads before the fence will not be reordered with</span></span><br><span class="line"><span class="comment"> * loads and stores after the fence.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span> Ignoring the many semantic differences from C and</span></span><br><span class="line"><span class="comment"> * C++, this method has memory ordering effects compatible with</span></span><br><span class="line"><span class="comment"> * atomic_thread_fence(memory_order_acquire)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acquireFence</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that loads and stores before the fence will not be</span></span><br><span class="line"><span class="comment"> * reordered with stores after the fence.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span> Ignoring the many semantic differences from C and</span></span><br><span class="line"><span class="comment"> * C++, this method has memory ordering effects compatible with</span></span><br><span class="line"><span class="comment"> * atomic_thread_fence(memory_order_release)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseFence</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that loads before the fence will not be reordered with</span></span><br><span class="line"><span class="comment"> * loads after the fence.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLoadFence</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that stores before the fence will not be reordered with</span></span><br><span class="line"><span class="comment"> * stores after the fence.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">storeStoreFence</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>一个 full fense 比 acquire fence 要更强一些（在对排序的保证这一意义上），后者又比 load load fence 更强。类似的，full fence 比 release fence 更强，后者比 store store fence 又更强。</p><h2 id="可访问性栅栏（Reachability-fence）"><a href="#可访问性栅栏（Reachability-fence）" class="headerlink" title="可访问性栅栏（Reachability fence）"></a>可访问性栅栏（Reachability fence）</h2><p>可访问行栅栏作为静态方法定义在 <code>java.lang.ref.Reference</code> 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">ref</span>.<span class="title">Reference</span> </span>&#123;</span><br><span class="line">   <span class="comment">// add:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Ensures that the object referenced by the given reference</span></span><br><span class="line"><span class="comment">    * remains &lt;em&gt;strongly reachable&lt;/em&gt; (as defined in the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">    * java.lang.ref&#125; package documentation), regardless of any prior</span></span><br><span class="line"><span class="comment">    * actions of the program that might otherwise cause the object to</span></span><br><span class="line"><span class="comment">    * become unreachable; thus, the referenced object is not</span></span><br><span class="line"><span class="comment">    * reclaimable by garbage collection at least until after the</span></span><br><span class="line"><span class="comment">    * invocation of this method. Invocation of this method does not</span></span><br><span class="line"><span class="comment">    * itself initiate garbage collection or finalization.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ref the reference. If null, this method has no effect.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reachabilityFence</span><span class="params">(Object ref)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考 <a href="https://bugs.openjdk.java.net/browse/JDK-8133348" target="_blank" rel="noopener">JDK-8133348</a>。</p><p>现在已经太迟了，无法添加一个类似于 <code>@Finalized</code> 的东西，用于修饰一个方法，使得在编译时或运行时对应的方法体看起来像下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    &lt;method body&gt;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Reference.reachabilityFence(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以预感，类似的机制将会在某些编译期处理器得到支持。</p><h2 id="其他选择"><a href="#其他选择" class="headerlink" title="其他选择"></a>其他选择</h2><p>引入一种新形式的值类型（value type）用于支持 volatile 操作。然而，这会导致跟其他类型的性质不一致，程序员也需要付出更多努力来学习使用它。也考虑过依靠 <code>java.util.concurrent.atomic FieldUpdater</code>s 来完成这一目标，但它们的动态损耗（dynamic overhead）和使用限制使得这一选项并不适用的。</p><p>一些其他的选择，包括那些基于字段引用（field references）的方法在这些年都有人提出并讨论过，但最终因为语法上不可行、效率或者可用性问题消失了。</p><p>语法增强在这个 JEP 之前的版本考虑过，但被认为太过于奇异（magical）了。它重载了 <code>volatile</code> 关键字的语义并扩展到飘浮接口（译者注：with the overloaded use of the volatile keyword scoping to floating interfaces），一个用于引用类型而另一个用于所有支持的基本类型（primitive type）。</p><p>上一个版本的 JEP 也考虑过从 <code>VarHandle</code> 扩展出泛型类型（generic type），但这个带有多态签名的泛型加上对自动装箱类型的特殊对待，被认为是不成熟的。因为将来的 Java 版本会带有值类型（value type）、允许基于基本数据类型的泛型（参考<a href="http://openjdk.java.net/jeps/218" target="_blank" rel="noopener">JEP-218</a>）和一个增强的数组 <a href="http://cr.openjdk.java.net/~jrose/pres/201207-Arrays-2.pdf" target="_blank" rel="noopener">Arrays 2.0</a>。</p><p>基于特定实现的 <code>invokedynamic</code> 这一方法在这个 JEP 的之前版本也考虑过。这需要仔细地让带或不带 <code>invokedynamic</code> 的编译后的方法调用在语义上保持一致。此外，一些使用了 <code>invokedynamic</code> 的核心类，如 <code>ConcurrentHashMap</code> 将会导致循环依赖。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>压力测试将会使用 <a href="http://openjdk.java.net/projects/code-tools/jcstress/" target="_blank" rel="noopener">jcstress</a> 工具来开发。</p><h2 id="风险和假设"><a href="#风险和假设" class="headerlink" title="风险和假设"></a>风险和假设</h2><p>有个 <code>VarHandle</code> 的原型实现已经使用 nano-benchmarks 和 fork/join benchmarks 进行了性能测试，其中 fork/join 使用了 <code>sun.misc.Unsafe</code> 的地方都替换成了 <code>VarHandle</code>。目前为止还没有发现明显的性能损失，HotSpot 上的问题也都不太麻烦（折叠掉强制类型转换检查和改进数组范围检查）。我们对这个方法的可行性是有信心的。尽管如此，我们也启动能够进行更多的实验，来保证在性能要求非常严格的环境下有可靠的编译技术，因为这种情况会更需要 <code>VarHandle</code>。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>那些在包 <code>java.util.concurrent</code> 里的类（包括 JDK 中其他一下地方）会从 <code>sun.misc.Unsafe</code> 迁移到 <code>VarHandle</code>。</p><p>这篇 JEP 不依赖于 <a href="http://openjdk.java.net/jeps/188" target="_blank" rel="noopener">JEP 188: Java Memory Model Update</a>。</p>]]></content>
    
    <summary type="html">
    
      定义一个用来操作对象的字段、数组元素的跟 `&quot;java.util.concurrent.atomic&quot;` 和 `&quot;sun.misc.Unsafe&quot;` 等价的标准工具，它提供了一个标准的栅栏操作（fence operation）集用于精细地控制内存排序和一个标准的可达性栅栏操作（reachability-fence operation）来保证一个被引用的对象是强可达的（strongly reachable）。
    
    </summary>
    
      <category term="Java" scheme="https://jekton.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jekton.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>个人记录帖 - 编译 OpenJDK 10</title>
    <link href="https://jekton.github.io/2018/07/22/openjdk-build/"/>
    <id>https://jekton.github.io/2018/07/22/openjdk-build/</id>
    <published>2018-07-22T01:32:41.000Z</published>
    <updated>2018-08-18T12:47:22.693Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章纯粹是记录个人编译 openjdk10 的过程，不会很详细地说明各个步奏。这里就算是给自己立 flag 吧。</p><a id="more"></a><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone git@github.com:unofficial-openjdk/openjdk.git</span><br><span class="line"><span class="meta">#</span> 写作时 openjdk10 最新的 tag</span><br><span class="line"><span class="meta">$</span> git checkout -b jdk-10+46 jdk-10+46</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bash ./configure --enable-debug --with-target-bits=64 --with-jobs=8 --disable-warnings-as-errors --with-jvm-variants=server</span><br><span class="line"><span class="meta">$</span> make</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>为了方便以后使用，在 <code>.zshrc</code> 加入：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function openjdk_env &#123;</span><br><span class="line">    export JAVA_HOME="$HOME/dev/java/openjdk10/build/macosx-x86_64-normal-server-fastdebug/jdk"</span><br><span class="line">    export PATH="$JAVA_HOME/bin"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后还是回到 terminal：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> source ~/.zshrc</span><br><span class="line"><span class="meta">$</span> openjdk_env </span><br><span class="line"><span class="meta">$</span> java -version</span><br><span class="line">openjdk version "10-internal" 2018-03-20</span><br><span class="line">OpenJDK Runtime Environment (fastdebug build 10-internal+0-adhoc.jekton.openjdk10)</span><br><span class="line">OpenJDK 64-Bit Server VM (fastdebug build 10-internal+0-adhoc.jekton.openjdk10, mixed mode)</span><br></pre></td></tr></table></figure></p><h3 id="使用-idea-阅读-JDK"><a href="#使用-idea-阅读-JDK" class="headerlink" title="使用 idea 阅读 JDK"></a>使用 idea 阅读 JDK</h3><p>执行源码下的 <code>bin/idea.sh</code>，它会在源码根目录生成 <code>.idea</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 假定当前在源码根目录</span><br><span class="line"><span class="meta">$</span> cd bin</span><br><span class="line"><span class="meta">$</span> bash idea.sh</span><br></pre></td></tr></table></figure><p>这个过程可能会提示你安装 <code>ant</code>。</p><p>生成后，直接用 idea 打开就可以了，JDK 源码在 <code>src/java.base</code> 目录下。</p><h3 id="使用-VS-Code-阅读-hotspot-源码"><a href="#使用-VS-Code-阅读-hotspot-源码" class="headerlink" title="使用 VS Code 阅读 hotspot 源码"></a>使用 VS Code 阅读 hotspot 源码</h3><p>由于 idea 的 CLion 是付费的，所以这部分选用 VS Code 来阅读。没什么好说的，就不写了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章纯粹是记录个人编译 openjdk10 的过程，不会很详细地说明各个步奏。这里就算是给自己立 flag 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://jekton.github.io/categories/JVM/"/>
    
    
      <category term="openjdk" scheme="https://jekton.github.io/tags/openjdk/"/>
    
  </entry>
  
  <entry>
    <title>Android arch components 源码分析（3）—— LiveData</title>
    <link href="https://jekton.github.io/2018/07/14/android-arch-LiveData/"/>
    <id>https://jekton.github.io/2018/07/14/android-arch-LiveData/</id>
    <published>2018-07-14T07:42:06.000Z</published>
    <updated>2018-08-18T12:47:22.677Z</updated>
    
    <content type="html"><![CDATA[<p>本篇我们来看看 Android 架构组件中的 <code>LiveData</code> 。跟 <code>ViewModel</code> 相比，<code>LiveData</code> 具有生命周期感知能力，也就是说，他把 <code>ViewModel</code> 和 lifecycle 结合了起来。当应用的数据有更新时，一般我们仅希望应用对用户可见时才更新 UI；更进一步，如果应用不可见，我们甚至可以停止数据的更新。这就是所谓的“感知应用的生命周期”。</p><p>这里我们主要关注 <code>LiveData</code> 的实现，用法可以参考 Google 的<a href="https://developer.android.google.cn/topic/libraries/architecture/" target="_blank" rel="noopener">教程</a>。</p><h2 id="添加-Observer"><a href="#添加-Observer" class="headerlink" title="添加 Observer"></a>添加 Observer</h2><p>使用 <code>LiveData</code> 时，首先要做的，就是添加一个 <code>Observer&lt;T&gt;</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the data is changed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t  The new data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(@Nullable T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，他是 abstract class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有 onStart 后，对数据的修改才会触发 observer.onChanged()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无论何时，只要数据发生改变，就会触发 observer.onChanged()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observeForever</span><span class="params">(@NonNull Observer&lt;T&gt; observer)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于 <code>LiveData</code> 是一个 <code>abstract class</code>，我们不能直接生成他的实例。对于数据的<em>拥有者</em>，可以使用 <code>MutableLiveData</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableLiveData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LiveData.postValue() 是一个 protected 方法</span></span><br><span class="line">        <span class="keyword">super</span>.postValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LiveData.setValue() 是一个 protected 方法</span></span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>所谓数据的拥有者。举个例子，你使用的是 MVP 模式，那么数据就属于 Model 层，另外两层不应该修改数据。</p></blockquote><p>通过让这两个 setter 方法成为 <code>protected</code>，只要我们给客户返回的是 <code>LiveData</code>，就不用担心数据会被客户意外修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类的内部持有的是 MutableLiveData，所以我们可以调用 postValue/setValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Foo&gt; mYourData = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是 LiveData，LiveData 的 public 方法中并没有 postValue/setValue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;Foo&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mYourData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>活用 <code>public</code>, <code>protected</code>, <code>private</code>, <code>default access</code> 和 <code>final</code> 可以让我们的设计意图更加清晰。</p></blockquote><p>现在回到我们的 <code>observe()</code> 方法，<code>observeForever</code> 的实现跟 <code>observe</code> 是类似的，我们就不看了，这里只看 <code>observe()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// activity 已经 destroy，也就没必要添加 observer 了</span></span><br><span class="line">        <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">            <span class="comment">// 同一个 observer，只有对应的 lifecycleOwner 不一样，才可以重新添加</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add the same observer"</span></span><br><span class="line">                    + <span class="string">" with different lifecycles"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这种方式添加的 observer，只有 activity 可见时才会收到数据更新的通知，</span></span><br><span class="line">        <span class="comment">// 为了知道什么时候 activity 是可见的，这里需要注册到 Lifecycle。</span></span><br><span class="line">        <span class="comment">// 也是因为这个，observe() 比 observeForever() 多了一个参数 lifecycleOwner</span></span><br><span class="line">        owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们继续看 <code>LifecycleBoundObserver</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空实现，如果在 LiveData 变为 inactive 状态后想停止更新数据，可以</span></span><br><span class="line">    <span class="comment">// override 这两个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWrapper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;T&gt; mObserver;</span><br><span class="line">        <span class="keyword">boolean</span> mActive;</span><br><span class="line">        <span class="keyword">int</span> mLastVersion = START_VERSION;</span><br><span class="line"></span><br><span class="line">        ObserverWrapper(Observer&lt;T&gt; observer) &#123;</span><br><span class="line">            mObserver = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 observer 处于 active 状态，则返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// immediately set active state, so we'd never dispatch anything to inactive</span></span><br><span class="line">            <span class="comment">// owner</span></span><br><span class="line">            mActive = newActive;</span><br><span class="line">            <span class="comment">// LiveData.this.mActiveCount 表示处于 active 状态的 observer 的数量</span></span><br><span class="line">            <span class="comment">// 当 mActiveCount 大于 0 时，`LiveData` 处于 active 状态</span></span><br><span class="line">            <span class="comment">// 注意区分 observer 的 active 状态和 LiveData 的 active 状态</span></span><br><span class="line">            <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">            LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">                <span class="comment">// inactive -&gt; active</span></span><br><span class="line">                onActive();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里用 else if 比较好，因为只有一个会执行。else if 更易读</span></span><br><span class="line">            <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">                <span class="comment">// mActiveCount 在我们修改前等于 1，也就是说，`LiveData` 从 active</span></span><br><span class="line">                <span class="comment">// 状态变到了 inactive</span></span><br><span class="line">                onInactive();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">                <span class="comment">// observer 从 inactive 到 active，此时客户拿到的数据可能不是最新的，这里需要 dispatch 一下</span></span><br><span class="line">                <span class="comment">// 关于他的实现，我们下一节再看</span></span><br><span class="line">                dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@NonNull</span> <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">        LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">super</span>(observer);</span><br><span class="line">            mOwner = owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// onStart 到 onStop 之间则认为是 active 状态</span></span><br><span class="line">            <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个是 lifecycle 的回调函数</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">                removeObserver(mObserver);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 刚刚生成 LifecycleBoundObserver 的实例时，mActive == false，注册到</span></span><br><span class="line">            <span class="comment">// Lifecycle 后，Lifecycle 会同步状态给我们（也就是回调本函数）。</span></span><br><span class="line">            <span class="comment">// 不熟悉 lifecycle 的读者，可以看</span></span><br><span class="line">            <span class="comment">// https://jekton.github.io/2018/07/06/android-arch-lifecycle/</span></span><br><span class="line">            activeStateChanged(shouldBeActive());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，observer 的注册我们就看完了。下面我们看看如何发布(publish)数据给 <code>LiveData</code>。</p><h2 id="发布修改"><a href="#发布修改" class="headerlink" title="发布修改"></a>发布修改</h2><p>要修改 <code>LiveData</code>，有两种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步修改数据</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会用 Handler post 一个 runnable，然后在 runnable 里面 setValue</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>setValue</code> 比较简单，我们先看 <code>setValue</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">"setValue"</span>);</span><br><span class="line">        <span class="comment">// 每次更新 value，都会使 mVersion + 1</span></span><br><span class="line">        <span class="comment">// ObserverWrapper 也有一个字段，叫 mLastVersion</span></span><br><span class="line">        <span class="comment">// 通过比较这两个字段，可以避免重复通知客户（具体在后面会看到）</span></span><br><span class="line">        mVersion++;</span><br><span class="line">        mData = value;</span><br><span class="line">        dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 initiator == null，表示要通知所有的 observer</span></span><br><span class="line">    <span class="comment">// 不等于 null 则只通知 initiator</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">            <span class="comment">// 在 observer 的回调里面又触发了数据的修改</span></span><br><span class="line">            <span class="comment">// 设置 mDispatchInvalidated 为 true 后，可以让下面的循环知道</span></span><br><span class="line">            <span class="comment">// 数据被修改了，从而开始一轮新的迭代。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 比方说，dispatchingValue -&gt; observer.onChanged -&gt; setValue</span></span><br><span class="line">            <span class="comment">//            -&gt; dispatchingValue</span></span><br><span class="line">            <span class="comment">// 这里 return 的是后面那个 dispatchingValue，然后在第一个</span></span><br><span class="line">            <span class="comment">// dispatchingValue 会重新遍历所有的 observer，并调用他们的</span></span><br><span class="line">            <span class="comment">// onChanged。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 如果想避免这种情况，可以在回调里面使用 postValue 来更新数据</span></span><br><span class="line">            mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用 observer.onChanged()</span></span><br><span class="line">                considerNotify(initiator);</span><br><span class="line">                initiator = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                    considerNotify(iterator.next().getValue());</span><br><span class="line">                    <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                        <span class="comment">// 某个客户在回调里面更新了数据，break 后，这个 for 循环会</span></span><br><span class="line">                        <span class="comment">// 重新开始</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 当某个客户在回调里面更新了数据，mDispatchInvalidated == true</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">        mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看过我那篇 lifecycle 源码分析的读者应该对 <code>dispatchingValue</code> 处理循环调用的方式很熟悉了。以这里为例，为了防止循环调用，我们在调用客户代码前先置位一个标志（<code>mDispatchingValue</code>），结束后再设为 <code>false</code>。如果在回调里面又触发了这个方法，可以通过 <code>mDispatchingValue</code> 来检测。</p><p>检测到循环调用后，再设置第二个标志（<code>mDispatchInvalidated</code>），然后返回。返回又会回到之前的调用，前一个调用通过检查 <code>mDispatchInvalidated</code>，知道数据被修改，于是开始一轮新的迭代。</p><p>下面是 <code>considerNotify</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">        <span class="comment">// the observer moved to an active state, if we've not received that event, we better not</span></span><br><span class="line">        <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">        <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">            observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于 LifecycleBoundObserver 来说，即使 `LiveData` 的数据没有变化，只要 activity 的生命</span></span><br><span class="line">        <span class="comment">// 周期发生了改变，还是可能会调用 considerNotify 多次</span></span><br><span class="line">        <span class="comment">// 通过比较 observer.mLastVersion 和 mVersion，就能够知道 observer 是否已经拥有了最新的数据</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 实际上，observer.mLastVersion 最多只能等于 mVersion</span></span><br><span class="line">        <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        observer.mLastVersion = mVersion;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看完了 <code>setValue</code>，<code>postValue</code> 对我们来说就很简单了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，他是 volatile。因为 postValue 可以从后台线程调用，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object mPendingData = NOT_SET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mPostValueRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Object newValue;</span><br><span class="line">            <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">                newValue = mPendingData;</span><br><span class="line">                mPendingData = NOT_SET;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            setValue((T) newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> postTask;</span><br><span class="line">        <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">            postTask = mPendingData == NOT_SET;</span><br><span class="line">            mPendingData = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">            <span class="comment">// 已经有一个 post 后还没有执行的 runnable，所以就不需要再 post 了，</span></span><br><span class="line">            <span class="comment">// 前面 post 的 runnable 执行时，会拿到这个新设置的 value</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终执行的就是 handler.post()</span></span><br><span class="line">        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LiveData</code> 的核心代码我们已经看完了，其实他的实现也挺简单的，对吧？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 <code>LiveData</code>，有两个值得我们学习的，一个是循环调用的处理，另一个是 <code>mVersion</code> 的使用。关于 <code>mVersion</code>，这里再举一个之前工作中遇到的例子。在后台线程对数据进行持久化的时候（这个线程拷贝了一份数据），数据还有可能会被更新。为了判断所保存的数据是不是最新的，我当时的做法就是引入一个类似 <code>mVersion</code> 的东西，每次修改数据，都把 <code>mVersion</code> 加 1。通过比较 <code>mVersion</code> 和所保存的数据的 version，就能够知道是不是保存了最新的数据（当然，更好的做法是告诉后台线程数据已经修改，让他重新拿一次数据）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇我们来看看 Android 架构组件中的 &lt;code&gt;LiveData&lt;/code&gt; 。跟 &lt;code&gt;ViewModel&lt;/code&gt; 相比，&lt;code&gt;LiveData&lt;/code&gt; 具有生命周期感知能力，也就是说，他把 &lt;code&gt;ViewModel&lt;/code&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android arch" scheme="https://jekton.github.io/tags/Android-arch/"/>
    
  </entry>
  
  <entry>
    <title>Android arch components 源码分析（2）—— Lifecycle</title>
    <link href="https://jekton.github.io/2018/07/06/android-arch-lifecycle/"/>
    <id>https://jekton.github.io/2018/07/06/android-arch-lifecycle/</id>
    <published>2018-07-06T03:10:47.000Z</published>
    <updated>2018-08-18T12:47:22.677Z</updated>
    
    <content type="html"><![CDATA[<p><code>Lifecycle</code> 的实现跟 <code>ViewModel</code> 类似，都是利用 <code>Fragment</code> 来实现它的功能。通过添加一个 <code>fragment</code> 到 <code>activity</code> 中，这个 <code>fragment</code> 便能够接收到各个生命周期回调。</p><blockquote><p>以下源码使用 1.1.1 版本</p></blockquote><h2 id="使用方法简介"><a href="#使用方法简介" class="headerlink" title="使用方法简介"></a>使用方法简介</h2><p>这里我并不打算讲太多 lifecycle 的用法，不熟悉的同学，可以参考<a href="https://developer.android.google.cn/topic/libraries/architecture/" target="_blank" rel="noopener">这里</a>。</p><p>为了使用 lifecycle，首先需要获取到一个 <code>LifecycleOwner</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lifecycleOwner.getLifecycle().addObserver(observer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the Lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Lifecycle <span class="title">getLifecycle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 support 包时，<code>AppCompatActivity</code> 就是一个 <code>LifecycleOwner</code>。具体的实现是 <code>SupportActivity</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>下面，我们就从 <code>SupportActivity</code> 开始分析 lifecycle 组件的实现。</p><h2 id="获取生命周期"><a href="#获取生命周期" class="headerlink" title="获取生命周期"></a>获取生命周期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 初始化 ReportFragment</span></span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在上一节中我们执行的 <code>lifecycleOwner.getLifecycle()</code> 返回的，就是 <code>mLifecycleRegistry</code>。关于 <code>LifecycleRegistry</code>，我们在下一节再看，这里先看 <code>ReportFragment</code>。</p><p><code>ReportFragment</code> 就是我们在一开始说的，用于获取生命周期的 <code>fragment</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_FRAGMENT_TAG = <span class="string">"android.arch.lifecycle"</span></span><br><span class="line">            + <span class="string">".LifecycleDispatcher.report_fragment_tag"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span></span><br><span class="line">        <span class="comment">// FragmentActivity from support lib, so we use framework fragments for activities</span></span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ReportFragment <span class="title">get</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ReportFragment) activity.getFragmentManager().findFragmentByTag(</span><br><span class="line">                REPORT_FRAGMENT_TAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityInitializationListener mProcessListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchCreate</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchStart</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchResume</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        dispatchCreate(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        dispatchResume(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">        <span class="comment">// just want to be sure that we won't leak reference to an activity</span></span><br><span class="line">        mProcessListener = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        Activity activity = getActivity();</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于 SupportActivity 来说，执行的是下面这个</span></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">            <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProcessListener</span><span class="params">(ActivityInitializationListener processListener)</span> </span>&#123;</span><br><span class="line">        mProcessListener = processListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ActivityInitializationListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ReportFragment</code> 的实现很简单，读者自己看看就好。下面我们开始看不那么好理解的 <code>LifecycleRegistry</code>。</p><h2 id="生命周期事件的分发"><a href="#生命周期事件的分发" class="headerlink" title="生命周期事件的分发"></a>生命周期事件的分发</h2><p>在看代码前，我们先来了解一下 <code>Lifecycle</code> 的状态和事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Event &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onCreate event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_CREATE,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onStart event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_START,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onResume event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_RESUME,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onPause event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_PAUSE,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onStop event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_STOP,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constant for onDestroy event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_DESTROY,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * An &#123;<span class="doctag">@link</span> Event Event&#125; constant that can be used to match all events.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ON_ANY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lifecycle states. You can consider the states as the nodes in a graph and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Event&#125;s as the edges between these nodes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch</span></span><br><span class="line"><span class="comment">         * any more events. For instance, for an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state is reached</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;right before&lt;/b&gt; Activity's &#123;<span class="doctag">@link</span> android.app.Activity#onDestroy() onDestroy&#125; call.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DESTROYED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Initialized state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this is</span></span><br><span class="line"><span class="comment">         * the state when it is constructed but has not received</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        INITIALIZED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Created state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span></span><br><span class="line"><span class="comment">         * is reached in two cases:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;after &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="doctag">@link</span> android.app.Activity#onStop() onStop&#125; call.</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CREATED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Started state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span></span><br><span class="line"><span class="comment">         * is reached in two cases:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;after &#123;<span class="doctag">@link</span> android.app.Activity#onStart() onStart&#125; call;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="doctag">@link</span> android.app.Activity#onPause() onPause&#125; call.</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        STARTED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Resumed state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span></span><br><span class="line"><span class="comment">         * is reached after &#123;<span class="doctag">@link</span> android.app.Activity#onResume() onResume&#125; is called.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RESUMED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Compares if this State is greater or equal to the given &#123;<span class="doctag">@code</span> state&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> state State to compare with</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true if this State is greater or equal to the given &#123;<span class="doctag">@code</span> state&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(@NonNull State state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Lifecycle.Event</code> 对应 activity 的各个声明周期，<code>State</code> 则是 <code>Lifecycle</code> 的状态。在 <code>LifecycleRegistry</code> 中定义了状态间的转化关系：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> State <span class="title">getStateAfter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">            <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">            <span class="keyword">case</span> ON_STOP:</span><br><span class="line">                <span class="keyword">return</span> CREATED;</span><br><span class="line">            <span class="keyword">case</span> ON_START:</span><br><span class="line">            <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">                <span class="keyword">return</span> STARTED;</span><br><span class="line">            <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">                <span class="keyword">return</span> RESUMED;</span><br><span class="line">            <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">                <span class="keyword">return</span> DESTROYED;</span><br><span class="line">            <span class="keyword">case</span> ON_ANY:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected event value "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">downEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">case</span> CREATED:</span><br><span class="line">                <span class="keyword">return</span> ON_DESTROY;</span><br><span class="line">            <span class="keyword">case</span> STARTED:</span><br><span class="line">                <span class="keyword">return</span> ON_STOP;</span><br><span class="line">            <span class="keyword">case</span> RESUMED:</span><br><span class="line">                <span class="keyword">return</span> ON_PAUSE;</span><br><span class="line">            <span class="keyword">case</span> DESTROYED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">upEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">            <span class="keyword">case</span> DESTROYED:</span><br><span class="line">                <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">            <span class="keyword">case</span> CREATED:</span><br><span class="line">                <span class="keyword">return</span> ON_START;</span><br><span class="line">            <span class="keyword">case</span> STARTED:</span><br><span class="line">                <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">            <span class="keyword">case</span> RESUMED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这三个方法，可以总结为下面这样一张图：<br><img src="/2018/07/06/android-arch-lifecycle/android-arch-lifecycle-states.png" alt="android-arch-lifecycle-states"></p><p><code>downEvent</code> 在图中表示从一个状态到他下面的那个状态，<code>upEvent</code> 则是往上。</p><p>了解了 <code>Lifecycle</code> 的状态后，我们继续来看 <code>LifecycleRegistry</code>。上一节我们知道，activity 的生命周期发生变化后，会调用到 <code>LifecycleRegistry</code> 的 <code>handleLifecycleEvent</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mAddingObserverCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(@NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        State next = getStateAfter(event);</span><br><span class="line">        moveToState(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mState = next;</span><br><span class="line">        <span class="comment">// 当我们在 LifecycleRegistry 回调 LifecycleObserver 的时候触发状态变化时，</span></span><br><span class="line">        <span class="comment">// mHandlingEvent 为 true；</span></span><br><span class="line">        <span class="comment">// 添加 observer 的时候，也可能会执行回调方法，这时候如果触发了状态变化，</span></span><br><span class="line">        <span class="comment">// 则 mAddingObserverCounter != 0</span></span><br><span class="line">        <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">            mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 不需要执行 sync。</span></span><br><span class="line">            <span class="comment">// 执行到这里的情况是：sync() -&gt; LifecycleObserver -&gt; moveToState()</span></span><br><span class="line">            <span class="comment">// 这里直接返回后，还是会回到 sync()，然后继续同步状态给 observer</span></span><br><span class="line">            <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// sync() 会把状态的变化转化为生命周期事件，然后转发给 LifecycleObserver</span></span><br><span class="line">        sync();</span><br><span class="line">        mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LifecycleRegistry</code> 本来要做的事其实是很简单的，但由于他需要执行客户的代码，由此引入了很多额外的复杂度。原因是，客户代码并不处在我们的控制之下，他们可能做出任何可以做到的事。例如这里，在回调中又触发状态变化。类似的情况是，在持有锁的时候不调用客户代码，这个也会让实现变得比较复杂。</p><p>接下来我们看 <code>sync()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Custom list that keeps observers and can handle removals / additions during traversal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个 Invariant 非常重要，他会影响到 sync() 的逻辑</span></span><br><span class="line"><span class="comment">     * Invariant: at any moment of time for observer1 &amp; observer2:</span></span><br><span class="line"><span class="comment">     * if addition_order(observer1) &lt; addition_order(observer2), then</span></span><br><span class="line"><span class="comment">     * state(observer1) &gt;= state(observer2),</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class="line">            <span class="keyword">new</span> FastSafeIterableMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// happens only on the top of stack (never in reentrance),</span></span><br><span class="line">    <span class="comment">// so it doesn't have to take in account parents</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">        <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(LOG_TAG, <span class="string">"LifecycleOwner is garbage collected, you shouldn't try dispatch "</span></span><br><span class="line">                    + <span class="string">"new events from it."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">            <span class="comment">// mNewEventOccurred 是为了在 observer 触发状态变化时让 backwardPass/forwardPass()</span></span><br><span class="line">            <span class="comment">// 提前返回用的。我们刚准备调他们，这里设置为 false 即可。</span></span><br><span class="line">            mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">            <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// mObserverMap 里的元素的状态是非递增排列的，也就是说，队头的 state 最大</span></span><br><span class="line">                <span class="comment">// 如果 mState 小于队列里最大的那个，说明有元素需要更新状态</span></span><br><span class="line">                <span class="comment">// 为了维持 mObserverMap 的 Invariant，这里我们需要从队尾往前更新元素的状态</span></span><br><span class="line">                backwardPass(lifecycleOwner);</span><br><span class="line">            &#125;</span><br><span class="line">            Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">            <span class="comment">// 如果 mNewEventOccurred，说明在上面调用 backwardPass() 时，客户触发了状态修改</span></span><br><span class="line">            <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                forwardPass(lifecycleOwner);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有的 observer 的状态都已经同步完，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSynced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mObserverMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        State eldestObserverState = mObserverMap.eldest().getValue().mState;</span><br><span class="line">        State newestObserverState = mObserverMap.newest().getValue().mState;</span><br><span class="line">        <span class="comment">// 因为我们保证队头的 state &gt;= 后面的元素的 state，所以只要判断头尾就够了</span></span><br><span class="line">        <span class="keyword">return</span> eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>sync()</code> 的主要作用就是根据把 <code>mObserverMap</code> 里所有元素的状态都同步为 <code>mState</code>。我们继续看剩下的 <code>backwardPass/forwardPass</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;State&gt; mParentStates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从队头开始迭代</span></span><br><span class="line">        Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">                mObserverMap.iteratorWithAdditions();</span><br><span class="line">        <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">            Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">            ObserverWithState observer = entry.getValue();</span><br><span class="line">            <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                    <span class="comment">// 可能在回调客户代码的时候，客户把自己移除了</span></span><br><span class="line">                    &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">                <span class="comment">// pushParentState 和 popParentState 我们下一小节再看，这里先忽略</span></span><br><span class="line">                pushParentState(observer.mState);</span><br><span class="line">                observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">                popParentState();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从队尾开始迭代</span></span><br><span class="line">        Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class="line">                mObserverMap.descendingIterator();</span><br><span class="line">        <span class="keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">            Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class="line">            ObserverWithState observer = entry.getValue();</span><br><span class="line">            <span class="keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                    &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">                Event event = downEvent(observer.mState);</span><br><span class="line">                pushParentState(getStateAfter(event));</span><br><span class="line">                observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">                popParentState();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">popParentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mParentStates.remove(mParentStates.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushParentState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        mParentStates.add(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在看这两个方法时，可以参考上面的状态图。比方说，假设当前队列里的元素都处于 <code>CREATED</code>。接着收到了一个 <code>ON_START</code> 事件，从图里面可以看出，接下来应该是要到 <code>STARTED</code> 状态。由于 <code>STARTED</code> 大于 <code>CREATED</code>，所以会执行 <code>forwardPass()</code>。<code>forwardPass()</code> 里面调用 <code>upEvent(observer.mState)</code>，返回从 <code>CREATED</code> 往上到 <code>STARTED</code> 需要发送的事件，也就是 <code>ON_START</code>，于是 <code>ON_START</code> 事件发送给了客户。</p><h2 id="注册-注销-observer"><a href="#注册-注销-observer" class="headerlink" title="注册/注销 observer"></a>注册/注销 observer</h2><p>注册 observer 由 <code>addObserver</code> 方法完成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这段注释应该是这整个类里面最难理解的了吧，至少对于我来说是这样</span></span><br><span class="line">    <span class="comment">// we have to keep it for cases:</span></span><br><span class="line">    <span class="comment">// void onStart() &#123;</span></span><br><span class="line">    <span class="comment">//     // removeObserver(this)，说明 this 是一个 LifecycleObserver</span></span><br><span class="line">    <span class="comment">//     // 所以这里说的是，我们在回调里执行了下面两个操作</span></span><br><span class="line">    <span class="comment">//     mRegistry.removeObserver(this);</span></span><br><span class="line">    <span class="comment">//     mRegistry.add(newObserver);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 假定现在我们要从 CREATED 转到 STARTED 状态（也就是说，mState 现在是 STARTED）。</span></span><br><span class="line">    <span class="comment">// 这种情况下，只有将新的 observer 设置为 CREATED 状态，它的 onStart 才会被调用</span></span><br><span class="line">    <span class="comment">// 为了得到这个 CREATED，在这里才引入了 mParentStates。在 forwardPass 中执行</span></span><br><span class="line">    <span class="comment">// pushParentState(observer.mState) 时，observer.mState 就是我们需要的 CREATED。</span></span><br><span class="line">    <span class="comment">// backwardPass 的情况类似。</span></span><br><span class="line">    <span class="comment">// newObserver should be brought only to CREATED state during the execution of</span></span><br><span class="line">    <span class="comment">// this onStart method. our invariant with mObserverMap doesn't help, because parent observer</span></span><br><span class="line">    <span class="comment">// is no longer in the map.</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;State&gt; mParentStates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> State <span class="title">calculateTargetState</span><span class="params">(LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);</span><br><span class="line"></span><br><span class="line">        State siblingState = previous != <span class="keyword">null</span> ? previous.getValue().mState : <span class="keyword">null</span>;</span><br><span class="line">        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class="number">1</span>)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 返回最小的 state</span></span><br><span class="line">        <span class="keyword">return</span> min(min(mState, siblingState), parentState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">        ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">        <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在回调中执行了 addObserver()</span></span><br><span class="line">        <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">        State targetState = calculateTargetState(observer);</span><br><span class="line">        mAddingObserverCounter++;</span><br><span class="line">        <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">            pushParentState(statefulObserver.mState);</span><br><span class="line">            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">            <span class="comment">// 我们 dispatch 了一个事件给客户，在回调客户代码的时候，客户可能会修改我们的状态</span></span><br><span class="line">            <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">            targetState = calculateTargetState(observer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">            <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">            sync();</span><br><span class="line">        &#125;</span><br><span class="line">        mAddingObserverCounter--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">        State mState;</span><br><span class="line">        GenericLifecycleObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">        ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">            mLifecycleObserver = Lifecycling.getCallback(observer);</span><br><span class="line">            mState = initialState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">            State newState = getStateAfter(event);</span><br><span class="line">            mState = min(mState, newState);</span><br><span class="line">            mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">            mState = newState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于篇幅有限，这里的 <code>Lifecycling.getCallback</code> 就不看了。简单提一下，在使用 annotion 的时候，对应的 observer 会生成一个 adapter，这个 adapter 会把对应的 <code>Lifecycle.Event</code> 装换为方法调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundLocationListener</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLocationListener</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeLocationListener</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundLocationManager_BoundLocationListener_LifecycleAdapter</span> <span class="keyword">implements</span> <span class="title">GeneratedAdapter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> BoundLocationManager.BoundLocationListener mReceiver;</span><br><span class="line"></span><br><span class="line">  BoundLocationManager_BoundLocationListener_LifecycleAdapter(BoundLocationManager.BoundLocationListener receiver) &#123;</span><br><span class="line">    <span class="keyword">this</span>.mReceiver = receiver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callMethods</span><span class="params">(LifecycleOwner owner, Lifecycle.Event event, <span class="keyword">boolean</span> onAny,</span></span></span><br><span class="line"><span class="function"><span class="params">      MethodCallsLogger logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasLogger = logger != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (onAny) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_RESUME) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">"addLocationListener"</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.addLocationListener();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_PAUSE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">"removeLocationListener"</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.removeLocationListener();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注销 observer 的实现就比较简单了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we consciously decided not to send destruction events here in opposition to addObserver.</span></span><br><span class="line">        <span class="comment">// Our reasons for that:</span></span><br><span class="line">        <span class="comment">// 1. These events haven't yet happened at all. In contrast to events in addObservers, that</span></span><br><span class="line">        <span class="comment">// actually occurred but earlier.</span></span><br><span class="line">        <span class="comment">// 2. There are cases when removeObserver happens as a consequence of some kind of fatal</span></span><br><span class="line">        <span class="comment">// event. If removeObserver method sends destruction events, then a clean up routine becomes</span></span><br><span class="line">        <span class="comment">// more cumbersome. More specific example of that is: your LifecycleObserver listens for</span></span><br><span class="line">        <span class="comment">// a web connection, in the usual routine in OnStop method you report to a server that a</span></span><br><span class="line">        <span class="comment">// session has just ended and you close the connection. Now let's assume now that you</span></span><br><span class="line">        <span class="comment">// lost an internet and as a result you removed this observer. If you get destruction</span></span><br><span class="line">        <span class="comment">// events in removeObserver, you should have a special case in your onStop method that</span></span><br><span class="line">        <span class="comment">// checks if your web connection died and you shouldn't try to report anything to a server.</span></span><br><span class="line">        mObserverMap.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>恭喜你，相信你现在对 lifecycle 的实现已经胸有成竹，可以愉快地装逼了。</p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Lifecycle&lt;/code&gt; 的实现跟 &lt;code&gt;ViewModel&lt;/code&gt; 类似，都是利用 &lt;code&gt;Fragment&lt;/code&gt; 来实现它的功能。通过添加一个 &lt;code&gt;fragment&lt;/code&gt; 到 &lt;code&gt;activity&lt;/c
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android arch" scheme="https://jekton.github.io/tags/Android-arch/"/>
    
  </entry>
  
  <entry>
    <title>Android arch components 源码分析（1）—— ViewModel</title>
    <link href="https://jekton.github.io/2018/06/30/android-arch-ViewModel/"/>
    <id>https://jekton.github.io/2018/06/30/android-arch-ViewModel/</id>
    <published>2018-06-30T05:26:59.000Z</published>
    <updated>2018-08-18T12:47:22.677Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要关注 <code>ViewModel</code> 的实现而非其用法，关于他的用法，可以参考<a href="https://developer.android.google.cn/topic/libraries/architecture/" target="_blank" rel="noopener">这里</a>。</p><p><code>ViewModel</code> 主要用于在 activity/fragment 被自动销毁时保存一些数据。从实现原理上讲，主要就是利用了 <code>fragment.setRetainInstance(true)</code>。如此一来，这个 <code>fragment</code> 就能够跨越 <code>activity</code> 的生命周期。</p><blockquote><p>以下源码使用 1.1.1 版本</p></blockquote><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul><li><code>ViewModel</code>：这个是我们的主角。我们定义的 model 类需要继承它。</li><li><code>ViewModelProvider</code>：用于生成 <code>ViewModel</code> 实例</li><li><code>ViewModelStore</code>：跟他的名字一样，主要用来存储 <code>ViewModel</code> 的实例。</li><li><code>HolderFragment</code>：这个就是我们上面提到的调用了 <code>setRetainInstance(true)</code> 的那个 <code>fragment</code>。<code>ViewModelStore</code> 实例存储会在这里。</li></ul><p>下面是 Google 给出的<a href="https://github.com/googlecodelabs/android-lifecycles" target="_blank" rel="noopener">示例</a> step2 中的一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChronometerViewModel chronometerViewModel</span><br><span class="line">       = ViewModelProviders.of(<span class="keyword">this</span>).get(ChronometerViewModel.class);</span><br></pre></td></tr></table></figure></p><p>下面我们就根据这个调用来学习 <code>ViewModel</code> 的源码。</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>前面我们说过，自己定义的 model 类需要继承它。这里借花献佛，我们直接看 Google 的 sample：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChronometerViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不用关心它的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ViewModel</code> 虽然是主角，但他非常的简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCleared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就这样，他只是定义了一个空方法 <code>onCleared()</code>。当对应的 model 实例被销毁时，<code>onCleared()</code> 将会执行。通过让他成为 <code>abstract class</code> 并给予 <code>onCleared</code> 一个默认实现，让 <code>ViewModel</code> 有了 tag interface 的效果。</p><blockquote><p>所谓的 tag interface 是指不带任何方法的 <code>interface</code>。</p></blockquote><p>接下来是男二号 <code>AndroidViewModel</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Application mApplication;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidViewModel</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">        mApplication = application;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Application&gt; <span class="function">T <span class="title">getApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>没有太多可圈可点的东西，我们继续看下一个。</p><h2 id="ViewModelProvider"><a href="#ViewModelProvider" class="headerlink" title="ViewModelProvider"></a>ViewModelProvider</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChronometerViewModel chronometerViewModel</span><br><span class="line">       = ViewModelProviders.of(<span class="keyword">this</span>).get(ChronometerViewModel.class);</span><br></pre></td></tr></table></figure><p>我们继续从这个调用往下看。</p><p><code>ViewModelProviders</code> 可以看成是 <code>ViewModelProvider</code> 的工厂或相关工具类的合集。他的命名跟 JDK 里的 <code>Collections/Arrays</code> 类似。这里的 <code>this</code> 是 <code>FragmentActivity</code>，所以接下来执行的是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelProviders</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> of(activity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Factory factory)</span> </span>&#123;</span><br><span class="line">        Application application = checkApplication(activity);</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，最终 <code>ViewModelProviders</code> 会创建一个 <code>ViewModelProvider</code> 实例并返回。</p><p><code>Factory</code> 是用于创建 model 实例的工厂：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认的实现是 <code>AndroidViewModelFactory</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidViewModelFactory</span> <span class="keyword">extends</span> <span class="title">ViewModelProvider</span>.<span class="title">NewInstanceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AndroidViewModelFactory sInstance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AndroidViewModelFactory <span class="title">getInstance</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> AndroidViewModelFactory(application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">            <span class="comment">// model 类继承了 AndroidViewModel</span></span><br><span class="line">            <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> modelClass.getConstructor(Application.class).newInstance(mApplication);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，由父类 `NewInstanceFactory` 处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>父类 <code>NewInstanceFactory</code> 的实现一样很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"ClassNewInstance"</span>)</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> modelClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这里可以看出，使用默认的 <code>Factory</code> 实现时，如果 model 类继承 <code>ViewModel</code>，需要有一个默认构造函数；如果继承 <code>AndroidViewModel</code>，必须有一个以 <code>Application</code> 为唯一参数构造函数。否则，我们需要自己实现一个 <code>Factory</code>。</p><p>我们先把 <code>ViewModelStore</code> 放一放，先假设成功拿到了他的实例，于是，我们创建 <code>ViewModelProvider</code> 实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @Nullable Factory factory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(@NonNull ViewModelStore store, @NonNull Factory factory)</span> </span>&#123;</span><br><span class="line">        mFactory = factory;</span><br><span class="line">        mViewModelStore = store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 <code>ViewModelProvider</code> 获取 model 实例时，使用的是他的 <code>get</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ViewModelProvider &#123;</span><br><span class="line"></span><br><span class="line">    private static final String DEFAULT_KEY =</span><br><span class="line">            &quot;android.arch.lifecycle.ViewModelProvider.DefaultKey&quot;;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @MainThread</span><br><span class="line">    public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">        String canonicalName = modelClass.getCanonicalName();</span><br><span class="line">        if (canonicalName == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return get(DEFAULT_KEY + &quot;:&quot; + canonicalName, modelClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @MainThread</span><br><span class="line">    public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">        ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">        // 当使用不同的类加载器加载同一个类的时候，这里会是 false</span><br><span class="line">        if (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">            //noinspection unchecked</span><br><span class="line">            return (T) viewModel;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //noinspection StatementWithEmptyBody</span><br><span class="line">            if (viewModel != null) &#123;</span><br><span class="line">                // TODO: log a warning.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        viewModel = mFactory.create(modelClass);</span><br><span class="line">        mViewModelStore.put(key, viewModel);</span><br><span class="line">        //noinspection unchecked</span><br><span class="line">        return (T) viewModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ViewModelProvider</code> 他的职责就是从 <code>ViewModelStore</code> 里取出对象，如果对象不存在，就新创建一个，并把新创建的这个对象放到 <code>ViewModelStore</code>。</p><h2 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a>ViewModelStore</h2><p>和 <code>ViewModelProvider</code> 一样，<code>ViewModelStore</code> 也有一个工厂类叫 <code>ViewModelStores</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStores</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们的 activity 可以自己实现 ViewModelStoreOwner</span></span><br><span class="line">        <span class="comment">// 默认情况下，这里的判断为 false，ViewModelStoreOwner 由 HolderFragment 实现</span></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// holderFragmentFor 在 HolderFragment 中实现，我们留到下一节再看</span></span><br><span class="line">        <span class="keyword">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>HolderFragment</code> 实现了 <code>ViewModelStoreOwner</code> 接口，<code>holderFragmentFor(activity)</code> 返回 <code>activity</code> 对应的 <code>holderFragment</code> 后，即可以拿到 <code>ViewModelStore</code> 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HolderFragment"><a href="#HolderFragment" class="headerlink" title="HolderFragment"></a>HolderFragment</h2><p><code>HolderFragment</code> 是整个实现的核心。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HolderFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如此一来，当 activity 由于屏幕旋转等被系统销毁时，这个 fragment 实例也不会被销毁</span></span><br><span class="line">        setRetainInstance(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 把 activity 从 mNotCommittedActivityHolders 中移除</span></span><br><span class="line">        sHolderFragmentManager.holderFragmentCreated(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HolderFragment <span class="title">holderFragmentFor</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sHolderFragmentManager.holderFragmentFor(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderFragmentManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Activity, HolderFragment&gt; mNotCommittedActivityHolders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ActivityLifecycleCallbacks mActivityCallbacks =</span><br><span class="line">                <span class="keyword">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                        HolderFragment fragment = mNotCommittedActivityHolders.remove(activity);</span><br><span class="line">                        <span class="comment">// fragment 创建成功后，会把 activity 从 mNotCommittedActivityHolders 中</span></span><br><span class="line">                        <span class="comment">// 移除。如果 fragment != null，说明 fragment 没有创建完 activity 就跪了</span></span><br><span class="line">                        <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            Log.e(LOG_TAG, <span class="string">"Failed to save a ViewModel for "</span> + activity);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mActivityCallbacksIsAdded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">HolderFragment <span class="title">holderFragmentFor</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">            FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">            <span class="comment">// 通过 fragmentManager 获取 fragment 实例</span></span><br><span class="line">            HolderFragment holder = findHolderFragment(fm);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125;</span><br><span class="line">            holder = mNotCommittedActivityHolders.get(activity);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mActivityCallbacksIsAdded) &#123;</span><br><span class="line">                mActivityCallbacksIsAdded = <span class="keyword">true</span>;</span><br><span class="line">                activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks);</span><br><span class="line">            &#125;</span><br><span class="line">            holder = createHolderFragment(fm);</span><br><span class="line">            <span class="comment">// 我们 add 进去的 fragment 并不会马上就执行完（也就是说，这个方法执行完成后，马上再</span></span><br><span class="line">            <span class="comment">// 调用一次，上面的 findHolderFragment 会返回 null。但是这没有关系，因为接下来我们还可</span></span><br><span class="line">            <span class="comment">// 从 mNotCommittedActivityHolders 获取到对应的实例），所以我们这里先把他放在</span></span><br><span class="line">            <span class="comment">// mNotCommittedActivityHolders 中。Not Committed 表示 fragment 的 commit 还没有完成</span></span><br><span class="line">            mNotCommittedActivityHolders.put(activity, holder);</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HolderFragment <span class="title">createHolderFragment</span><span class="params">(FragmentManager fragmentManager)</span> </span>&#123;</span><br><span class="line">            HolderFragment holder = <span class="keyword">new</span> HolderFragment();</span><br><span class="line">            <span class="comment">// 这个 fragment 只是用来存数据，允许他的状态丢失可以让用户在更多情景下使用我们的API</span></span><br><span class="line">            <span class="comment">// 例如，onStop() 中也可以使用（当然，onDestroy 就不行了，因为我们需要往 activity 悄悄</span></span><br><span class="line">            <span class="comment">// 添加一个 fragment）</span></span><br><span class="line">            fragmentManager.beginTransaction().add(holder, HOLDER_TAG).commitAllowingStateLoss();</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>HolderFragment</code> 对 <code>ViewModelStoreOwner</code> 实现是相当直接的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ViewModelStore mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mViewModelStore.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，<code>ViewModel</code> 的实现我们就看完了。需要注意的是，<code>ViewModel</code> 还支持 <code>fragment</code>，这部分跟 <code>activity</code> 是类似的，有兴趣的读者自己看一看就好。</p><h2 id=""><a href="#" class="headerlink" title=""></a><br></h2><p><br></p><blockquote><p>@大熊：ViewModelStores.of(FragmentActivity)需要区分下Support Library的版本，如果在v27.1.0版本及以上的，FragmentActivity已经实现了ViewModelStoreOwner接口，最终是通过FragmentActivity.onRetainNonConfigurationInstance()完成ViewModelStore的存储的，v27.1.0版本以下才是通过Fragment.setRetainInstance(true)实现。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要关注 &lt;code&gt;ViewModel&lt;/code&gt; 的实现而非其用法，关于他的用法，可以参考&lt;a href=&quot;https://developer.android.google.cn/topic/libraries/architecture/&quot; target=&quot;_bl
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android arch" scheme="https://jekton.github.io/tags/Android-arch/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP、Socket 和协议设计</title>
    <link href="https://jekton.github.io/2018/06/23/socket-intro/"/>
    <id>https://jekton.github.io/2018/06/23/socket-intro/</id>
    <published>2018-06-23T01:12:16.000Z</published>
    <updated>2018-08-18T12:47:22.693Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由<a href="http://renyugang.io/post/75" target="_blank" rel="noopener">玉刚说写作平台</a><sup>[1]</sup>提供写作赞助，版权归玉刚说微信公众号所有<br>原作者：<a href="https://jekton.github.io/">水晶虾饺</a><sup>[2]</sup><br>版权声明：未经玉刚说许可，不得以任何形式转载</p></blockquote><p>本篇我们先简单了解一下 TCP/IP，然后通过实现一个 echo 服务器来学习 Java 的 Socket API。最后我们聊聊偏高级一点点的 socket 长连接和协议设计。</p><h2 id="TCP-IP-协议简介"><a href="#TCP-IP-协议简介" class="headerlink" title="TCP/IP 协议简介"></a>TCP/IP 协议简介</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>首先我们看 IP（Internet Protocol）协议。IP 协议提供了<strong>主机和主机</strong>间的通信。</p><p>为了完成不同主机的通信，我们需要某种方式来唯一标识一台主机，这个标识，就是著名的<strong>IP地址</strong>。通过IP地址，IP 协议就能够帮我们把一个数据包发送给对方。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>前面我们说过，IP 协议提供了主机和主机间的通信。TCP 协议在 IP 协议提供的主机间通信功能的基础上，完成这两个主机上<strong>进程对进程</strong>的通信。</p><p>有了 IP，不同主机就能够交换数据。但是，计算机收到数据后，并不知道这个数据属于哪个进程（简单讲，进程就是一个正在运行的应用程序）。TCP 的作用就在于，让我们能够知道这个数据属于哪个进程，从而完成进程间的通信。</p><p>为了标识数据属于哪个进程，我们给需要进行 TCP 通信的进程分配一个唯一的数字来标识它。这个数字，就是我们常说的<strong>端口号</strong>。</p><p>TCP 的全称是 Transmission Control Protocol，大家对它说得最多的，大概就是<strong>面向连接</strong>的特性了。之所以说它是有连接的，是说在进行通信前，通信双方需要先经过一个<em>三次握手</em>的过程。三次握手完成后，连接便建立了。这时候我们才可以开始发送/接收数据。（与之相对的是 UDP，不需要经过握手，就可以直接发送数据）。</p><p>下面我们简单了解一下三次握手的过程。</p><p><img src="/2018/06/23/socket-intro/tcp-three-way-handshake.png" alt="tcp-three-way-handshake"></p><ol><li>首先，客户向服务端发送一个 <code>SYN</code>，假设此时 sequence number 为 <code>x</code>。这个 <code>x</code> 是由操作系统根据一定的规则生成的，不妨认为它是一个随机数。</li><li>服务端收到 <code>SYN</code> 后，会向客户端再发送一个 <code>SYN</code>，此时服务器的 <code>seq number = y</code>。与此同时，会 <code>ACK x+1</code>，告诉客户端“已经收到了 <code>SYN</code>，可以发送数据了”。</li><li>客户端收到服务器的 <code>SYN</code> 后，回复一个 <code>ACK y+1</code>，这个 <code>ACK</code> 则是告诉服务器，<code>SYN</code> 已经收到，服务器可以发送数据了。</li></ol><p>经过这 3 步，TCP 连接就建立了。这里需要注意的有三点：</p><ol><li>连接是由客户端主动发起的</li><li>在第 3 步客户端向服务器回复 <code>ACK</code> 的时候，TCP 协议是允许我们携带数据的。之所以做不到，是 API 的限制导致的。</li><li>TCP 协议还允许 “四次握手” 的发生，同样的，由于 API 的限制，这个极端的情况并不会发生。</li></ol><p>TCP/IP 相关的理论知识我们就先了解到这里。关于 TCP，还有诸如可靠性、流量控制、拥塞控制等非常有趣的特性，<strong>强烈推荐</strong>读者看一看 Richard 的名著《TCP/IP 详解 - 卷1》（注意，是<strong>第1版</strong>，不是第2版）。</p><p>下面我们看一些偏实战的东西。</p><h2 id="Socket-基本用法"><a href="#Socket-基本用法" class="headerlink" title="Socket 基本用法"></a>Socket 基本用法</h2><p>Socket 是 TCP 层的封装，通过 socket，我们就能进行 TCP 通信。</p><p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。使用 socket 的步骤如下：</p><ol><li>创建 <code>ServerSocket</code> 并监听客户连接</li><li>使用 <code>Socket</code> 连接服务端</li><li>通过 <code>Socket.getInputStream()/getOutputStream()</code> 获取输入输出流进行通信</li></ol><p>下面，我们通过实现一个简单的 echo 服务来学习 socket 的使用。所谓的 echo 服务，就是客户端向服务端写入任意数据，服务器都将数据原封不动地写回给客户端。</p><h3 id="1-创建-ServerSocket-并监听客户连接"><a href="#1-创建-ServerSocket-并监听客户连接" class="headerlink" title="1. 创建 ServerSocket 并监听客户连接"></a>1. 创建 <code>ServerSocket</code> 并监听客户连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocket mServerSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个 ServerSocket 并监听端口 port</span></span><br><span class="line">        mServerSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 开始接受客户连接</span></span><br><span class="line">        Socket client = mServerSocket.accept();</span><br><span class="line">        handleClient(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleClient</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 使用 socket 进行通信 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EchoServer server = <span class="keyword">new</span> EchoServer(<span class="number">9877</span>);</span><br><span class="line">            server.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用-Socket-连接服务端"><a href="#2-使用-Socket-连接服务端" class="headerlink" title="2. 使用 Socket 连接服务端"></a>2. 使用 <code>Socket</code> 连接服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket mSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 socket 并连接服务器</span></span><br><span class="line">        mSocket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 和服务端进行通信</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 由于服务端运行在同一主机，这里我们使用 localhost</span></span><br><span class="line">            EchoClient client = <span class="keyword">new</span> EchoClient(<span class="string">"localhost"</span>, <span class="number">9877</span>);</span><br><span class="line">            client.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-通过-socket-getInputStream-getOutputStream-获取输入-输出流进行通信"><a href="#3-通过-socket-getInputStream-getOutputStream-获取输入-输出流进行通信" class="headerlink" title="3. 通过 socket.getInputStream()/getOutputStream() 获取输入/输出流进行通信"></a>3. 通过 <code>socket.getInputStream()/getOutputStream()</code> 获取输入/输出流进行通信</h3><p>首先，我们来实现服务端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleClient</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，服务端的实现其实很简单，我们不停地读取输入数据，然后写回给客户端。</p><p>下面我们看看客户端。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Thread readerThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>::readResponse);</span><br><span class="line">        readerThread.start();</span><br><span class="line"></span><br><span class="line">        OutputStream out = mSocket.getOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = System.in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream in = mSocket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端会稍微复杂一点点，在读取用户输入的同时，我们又想读取服务器的响应。所以，这里创建了一个线程来读服务器的响应。</p><p>不熟悉 lambda 的读者，可以把<code>Thread readerThread = new Thread(this::readResponse)</code> 换成下面这个代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread readerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readResponse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>打开两个 terminal 分别执行如下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> javac EchoServer.java</span><br><span class="line"><span class="meta">$</span> java EchoServer</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> javac EchoClient.java</span><br><span class="line"><span class="meta">$</span> java EchoClient</span><br><span class="line">hello Server</span><br><span class="line">hello Server</span><br><span class="line">foo</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><p>在客户端，我们会看到，输入的所有字符都打印了出来。</p><p>最后需要注意的有几点：</p><ol><li>在上面的代码中，我们所有的异常都没有处理。实际应用中，在发生异常时，需要关闭 socket，并根据实际业务做一些错误处理工作</li><li>在客户端，我们没有停止 <code>readThread</code>。实际应用中，我们可以通过关闭 socket 来让线程从阻塞读中返回。推荐读者阅读《Java并发编程实战》</li><li>我们的服务端只处理了一个客户连接。如果需要同时处理多个客户端，可以创建线程来处理请求。这个作为练习留给读者来完全。</li></ol><h2 id="Socket、ServerSocket-傻傻分不清楚"><a href="#Socket、ServerSocket-傻傻分不清楚" class="headerlink" title="Socket、ServerSocket 傻傻分不清楚"></a>Socket、ServerSocket 傻傻分不清楚</h2><p>在进入这一节的主题前，读者不妨先考虑一个问题：在上一节的实例中，我们运行 echo 服务后，在客户端连接成功时，一个有多少个 socket 存在？</p><p>答案是 3 个 socket。客户端一个，服务端有两个。跟这个问题的答案直接关联的是本节的主题——<code>Socket</code> 和 <code>ServerSocket</code> 的区别是什么。</p><p>眼尖的读者，可能会注意到在上一节我是这样描述他们的：</p><blockquote><p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。</p></blockquote><p>注意，我只说 <code>ServerSocket</code> 是用于监听客户连接，而没有说它也可以用来通信。下面我们来详细了解一下他们的区别。</p><blockquote><p>注：以下描述使用的是 UNIX/Linux 系统的 API</p></blockquote><p>首先，我们创建 <code>ServerSocket</code> 后，内核会创建一个 socket。这个 socket 既可以拿来监听客户连接，也可以连接远端的服务。由于 <code>ServerSocket</code> 是用来监听客户连接的，紧接着它就会对内核创建的这个 socket 调用 <code>listen</code> 函数。这样一来，这个 socket 就成了所谓的 listening socket，它开始监听客户的连接。</p><p>接下来，我们的客户端创建一个 <code>Socket</code>，同样的，内核也创建一个 socket 实例。内核创建的这个 socket 跟 <code>ServerSocket</code> 一开始创建的那个没有什么区别。不同的是，接下来 <code>Socket</code> 会对它执行 <code>connect</code>，发起对服务端的连接。前面我们说过，socket API 其实是 TCP 层的封装，所以 <code>connect</code> 后，内核会发送一个 <code>SYN</code> 给服务端。</p><p>现在，我们切换角色到服务端。<strong>服务端的主机在收到这个 <code>SYN</code> 后，会创建一个新的 socket</strong>，这个新创建的 socket 跟客户端继续执行三次握手过程。</p><p>三次握手完成后，我们执行的 <code>serverSocket.accept()</code> 会返回一个 <code>Socket</code> 实例，这个 socket 就是上一步内核自动帮我们创建的。</p><p>所以说，在一个客户端连接的情况下，其实有 3 个 socket。</p><p>关于内核自动创建的这个 socket，还有一个很有意思的地方。它的端口号跟 <code>ServerSocket</code> 是一毛一样的。咦！！不是说，一个端口只能绑定一个 socket 吗？其实这个说法并不够准确。</p><p>前面我说的TCP 通过端口号来区分数据属于哪个进程的说法，在 socket 的实现里需要改一改。Socket 并不仅仅使用端口号来区别不同的 socket 实例，而是使用 <code>&lt;peer addr:peer port, local addr:local port&gt;</code> 这个四元组。</p><p>在上面的例子中，我们的 <code>ServerSocket</code> 长这样：<code>&lt;*:*, *:9877&gt;</code>。意思是，可以接受任何的客户端，和本地任何 IP。</p><p><code>accept</code> 返回的 <code>Socket</code> 则是这样：<code>&lt;127.0.0.1:xxxx, 127.0.0.1:9877&gt;</code>。其中，<code>xxxx</code> 是客户端的端口号。</p><p>如果数据是发送给一个已连接的 socket，内核会找到一个完全匹配的实例，所以数据准确发送给了对端。</p><p>如果是客户端要发起连接，这时候只有 <code>&lt;*:*, *:9877&gt;</code> 会匹配成功，所以 <code>SYN</code> 也准确发送给了监听套接字。</p><p><code>Socket/ServerSocket</code> 的区别我们就讲到这里。如果读者觉得不过瘾，可以参考《TCP/IP 详解》卷1、卷2。</p><h2 id="Socket-长连接的实现"><a href="#Socket-长连接的实现" class="headerlink" title="Socket 长连接的实现"></a>Socket 长连接的实现</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。</p><p>比较熟悉 <code>Socket</code> 的读者，可能知道有这样一个 API：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.setKeepAlive(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>嗯……keep alive，“保持活着”，这个应该就是让 TCP 不断开的意思。那么，我们要实现一个 socket 的长连接，只需要这一个调用即可。</p><p>遗憾的是，生活并不总是那么美好。对于 4.4BSD 的实现来说，Socket 的这个 keep alive 选项如果打开并且<strong>两个小时</strong>内没有通信，那么底层会发一个心跳，看看对方是不是还活着。</p><p>注意，两个小时才会发一次。也就是说，在没有实际数据通信的时候，我把网线拔了，你的应用程序要经过两个小时才会知道。</p><p>在说明如果实现长连接前，我们先来理一理我们面临的问题。假定现在有一对已经连接的 socket，在以下情况发生时候，socket 将不再可用：</p><ol><li>某一端关闭是 socket（这不是废话吗）。主动关闭的一方会发送 <code>FIN</code>，通知对方要关闭 TCP 连接。在这种情况下，另一端如果去读 socket，将会读到 <code>EoF</code>（End of File）。于是我们知道对方关闭了 socket。</li><li>应用程序奔溃。此时 socket 会由内核关闭，结果跟情况1一样。</li><li>系统奔溃。这时候系统是来不及发送 <code>FIN</code> 的，因为它已经跪了。此时对方无法得知这一情况。对方在尝试读取数据时，最后会返回 read time out。如果写数据，则是 host unreachable 之类的错误。</li><li>电缆被挖断、网线被拔。跟情况3差不多，如果没有对 socket 进行读写，两边都不知道发生了事故。跟情况3不同的是，如果我们把网线接回去，socket 依旧可以正常使用。</li></ol><p>在上面的几种情形中，有一个共同点就是，只要去读、写 socket，只要 socket 连接不正常，我们就能够知道。基于这一点，要实现一个 socket 长连接，我们需要做的就是不断地给对方写数据，然后读取对方的数据，也就是所谓的<strong>心跳</strong>。只要心还在跳，socket 就是活的。写数据的间隔，需要根据实际的应用需求来决定。</p><p>心跳包不是实际的业务数据，根据通信协议的不同，需要做不同的处理。</p><p>比方说，我们使用 JSON 进行通信，那么，我们可以加一个 <code>type</code> 字段，表面这个 JSON 是心跳还是业务数据。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "type": 0,  // 0 表示心跳</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用二进制协议的情况类似。要求就是，我们能够区别一个数据包是心跳还是真实数据。这样，我们便实现了一个 socket 长连接。</p><h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h3><p>这一小节我们一起来实现一个带长连接的 Android echo 客户端。完整的代码可以在<a href="https://github.com/Jekton/Echo" target="_blank" rel="noopener">这里</a><sup>[3]</sup>找到。</p><p>首先了接口部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LongLiveSocket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorCallback</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果需要重连，返回 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">onError</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onData</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritingCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onFail</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongLiveSocket</span><span class="params">(String host, <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">                          DataCallback dataCallback, ErrorCallback errorCallback)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, WritingCallback callback)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, WritingCallback callback)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们这个支持长连接的类就叫 <code>LongLiveSocket</code> 好了。如果在 socket 断开后需要重连，只需要在对应的接口里面返回 true 即可（在真实场景里，我们还需要让客户设置重连的等待时间，还有读写、连接的 timeout等。为了简单，这里就直接不支持了。</p><p>另外需要注意的一点是，如果要做一个完整的库，需要同时提供阻塞式和回调式API。同样由于篇幅原因，这里直接省掉了。</p><p>下面我们直接看实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LongLiveSocket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"LongLiveSocket"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RETRY_INTERVAL_MILLIS = <span class="number">3</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> HEART_BEAT_INTERVAL_MILLIS = <span class="number">5</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> HEART_BEAT_TIMEOUT_MILLIS = <span class="number">2</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorCallback</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果需要重连，返回 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">onError</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onData</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritingCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onFail</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mHost;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mPort;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataCallback mDataCallback;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ErrorCallback mErrorCallback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HandlerThread mWriterThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mWriterHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mUIHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Socket mSocket;  <span class="comment">// guarded by mLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mClosed; <span class="comment">// guarded by mLock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mHeartBeatTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] mHeartBeat = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 我们使用长度为 0 的数据作为 heart beat</span></span><br><span class="line">            write(mHeartBeat, <span class="keyword">new</span> WritingCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 每隔 HEART_BEAT_INTERVAL_MILLIS 发送一次</span></span><br><span class="line">                    mWriterHandler.postDelayed(mHeartBeatTask, HEART_BEAT_INTERVAL_MILLIS);</span><br><span class="line">                    mUIHandler.postDelayed(mHeartBeatTimeoutTask, HEART_BEAT_TIMEOUT_MILLIS);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// nop</span></span><br><span class="line">                    <span class="comment">// write() 方法会处理失败</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mHeartBeatTimeoutTask = () -&gt; &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"mHeartBeatTimeoutTask#run: heart beat timeout"</span>);</span><br><span class="line">        closeSocket();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongLiveSocket</span><span class="params">(String host, <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">                          DataCallback dataCallback, ErrorCallback errorCallback)</span> </span>&#123;</span><br><span class="line">        mHost = host;</span><br><span class="line">        mPort = port;</span><br><span class="line">        mDataCallback = dataCallback;</span><br><span class="line">        mErrorCallback = errorCallback;</span><br><span class="line"></span><br><span class="line">        mWriterThread = <span class="keyword">new</span> HandlerThread(<span class="string">"socket-writer"</span>);</span><br><span class="line">        mWriterThread.start();</span><br><span class="line">        mWriterHandler = <span class="keyword">new</span> Handler(mWriterThread.getLooper());</span><br><span class="line">        mWriterHandler.post(<span class="keyword">this</span>::initSocket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Socket socket = <span class="keyword">new</span> Socket(mHost, mPort);</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="comment">// 在我们创建 socket 的时候，客户可能就调用了 close()</span></span><br><span class="line">                    <span class="keyword">if</span> (mClosed) &#123;</span><br><span class="line">                        silentlyClose(socket);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mSocket = socket;</span><br><span class="line">                    <span class="comment">// 每次创建新的 socket，会开一个线程来读数据</span></span><br><span class="line">                    Thread reader = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReaderTask(socket), <span class="string">"socket-reader"</span>);</span><br><span class="line">                    reader.start();</span><br><span class="line">                    mWriterHandler.post(mHeartBeatTask);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"initSocket: "</span>, e);</span><br><span class="line">                <span class="keyword">if</span> (closed() || !mErrorCallback.onError()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(RETRY_INTERVAL_MILLIS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    <span class="comment">// interrupt writer-thread to quit</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, WritingCallback callback)</span> </span>&#123;</span><br><span class="line">        write(data, <span class="number">0</span>, data.length, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, WritingCallback callback)</span> </span>&#123;</span><br><span class="line">        mWriterHandler.post(() -&gt; &#123;</span><br><span class="line">            Socket socket = getSocket();</span><br><span class="line">            <span class="keyword">if</span> (socket == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// initSocket 失败而客户说不需要重连，但客户又叫我们给他发送数据</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Socket not initialized"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                DataOutputStream out = <span class="keyword">new</span> DataOutputStream(outputStream);</span><br><span class="line">                out.writeInt(len);</span><br><span class="line">                out.write(data, offset, len);</span><br><span class="line">                callback.onSuccess();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"write: "</span>, e);</span><br><span class="line">                closeSocket();</span><br><span class="line">                callback.onFail(data, offset, len);</span><br><span class="line">                <span class="keyword">if</span> (!closed() &amp;&amp; mErrorCallback.onError()) &#123;</span><br><span class="line">                    initSocket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">closed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> mClosed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Socket <span class="title">getSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> mSocket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            closeSocketLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeSocketLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mSocket == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        silentlyClose(mSocket);</span><br><span class="line">        mSocket = <span class="keyword">null</span>;</span><br><span class="line">        mWriterHandler.removeCallbacks(mHeartBeatTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Looper.getMainLooper() == Looper.myLooper()) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    doClose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mClosed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 关闭 socket，从而使得阻塞在 socket 上的线程返回</span></span><br><span class="line">            closeSocketLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mWriterThread.quit();</span><br><span class="line">        <span class="comment">// 在重连的时候，有个 sleep</span></span><br><span class="line">        mWriterThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">silentlyClose</span><span class="params">(Closeable closeable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"silentlyClose: "</span>, e);</span><br><span class="line">                <span class="comment">// error ignored</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket mSocket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReaderTask</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            mSocket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                readResponse();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"ReaderTask#run: "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">// For simplicity, assume that a msg will not exceed 1024-byte</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            InputStream inputStream = mSocket.getInputStream();</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(inputStream);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> nbyte = in.readInt();</span><br><span class="line">                <span class="keyword">if</span> (nbyte == <span class="number">0</span>) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"readResponse: heart beat received"</span>);</span><br><span class="line">                    mUIHandler.removeCallbacks(mHeartBeatTimeoutTask);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nbyte &gt; buffer.length) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Receive message with len "</span> + nbyte +</span><br><span class="line">                                    <span class="string">" which exceeds limit "</span> + buffer.length);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (readn(in, buffer, nbyte) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Socket might be closed twice but it does no harm</span></span><br><span class="line">                    silentlyClose(mSocket);</span><br><span class="line">                    <span class="comment">// Socket will be re-connected by writer-thread if you want</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mDataCallback.onData(buffer, <span class="number">0</span>, nbyte);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readn</span><span class="params">(InputStream in, <span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> readBytes = in.read(buffer, offset, n);</span><br><span class="line">                <span class="keyword">if</span> (readBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// EoF</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                n -= readBytes;</span><br><span class="line">                offset += readBytes;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是我们新实现的 <code>EchoClient</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"EchoClient"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongLiveSocket mLongLiveSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        mLongLiveSocket = <span class="keyword">new</span> LongLiveSocket(</span><br><span class="line">                host, port,</span><br><span class="line">                (data, offset, len) -&gt; Log.i(TAG, <span class="string">"EchoClient: received: "</span> + <span class="keyword">new</span> String(data, offset, len)),</span><br><span class="line">                <span class="comment">// 返回 true，所以只要出错，就会一直重连</span></span><br><span class="line">                () -&gt; <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        mLongLiveSocket.write(msg.getBytes(), <span class="keyword">new</span> LongLiveSocket.WritingCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onSuccess: "</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onFail: fail to write: "</span> + <span class="keyword">new</span> String(data, offset, len));</span><br><span class="line">                <span class="comment">// 连接成功后，还会发送这个消息</span></span><br><span class="line">                mLongLiveSocket.write(data, offset, len, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就这样，一个带 socket 长连接的客户端就完成了。剩余代码跟我们这里的主题没有太大关系，感兴趣的读者可以看<a href="https://github.com/Jekton/Echo" target="_blank" rel="noopener">这里</a><sup>[3]</sup>或者自己完成这个例子。下面是一些输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">03:54:55.583 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:00.588 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:05.594 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:09.638 12691-12710/com.example.echo D/EchoClient: onSuccess: </span><br><span class="line">03:55:09.639 12691-12713/com.example.echo I/EchoClient: EchoClient: received: hello</span><br><span class="line">03:55:10.595 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:14.652 12691-12710/com.example.echo D/EchoClient: onSuccess: </span><br><span class="line">03:55:14.654 12691-12713/com.example.echo I/EchoClient: EchoClient: received: echo</span><br><span class="line">03:55:15.596 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:20.597 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:25.602 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br></pre></td></tr></table></figure></p><p>最后需要说明的是，如果想节省资源，在有客户发送数据的时候可以省略 heart beat。</p><p>我们对读出错时候的处理，可能也存在一些争议。读出错后，我们只是关闭了 socket。socket 需要等到下一次写动作发生时，才会重新连接。实际应用中，如果这是一个问题，在读出错后可以直接开始重连。这种情况下，还需要一些额外的同步，避免重复创建 socket。heart beat timeout 的情况类似。</p><h2 id="跟-TCP-IP-学协议设计"><a href="#跟-TCP-IP-学协议设计" class="headerlink" title="跟 TCP/IP 学协议设计"></a>跟 TCP/IP 学协议设计</h2><p>如果仅仅是为了使用是 socket，我们大可以不去理会协议的细节。之所以推荐大家去看一看《TCP/IP 详解》，是因为它们有太多值得学习的地方。很多我们工作中遇到的问题，都可以在这里找到答案。</p><p>以下每一个小节的标题都是一个小问题，建议读者独立思考一下，再继续往下看。如果你发现你的答案比我的更好，请一定发送邮件到 ljtong64 AT gmail DOT com 告诉我。</p><h3 id="协议版本如何升级？"><a href="#协议版本如何升级？" class="headerlink" title="协议版本如何升级？"></a>协议版本如何升级？</h3><p>有这么一句流行的话：这个世界唯一不变的，就是变化。当我们对协议版本进行升级的时候，正确识别不同版本的协议对软件的兼容非常重要。那么，我们如何设计协议，才能够为将来的版本升级做准备呢？</p><p>答案可以在 IP 协议找到。</p><p>IP 协议的第一个字段叫 version，目前使用的是 4 或 6，分别表示 IPv4 和 IPv6。由于这个字段在协议的开头，接收端收到数据后，只要根据第一个字段的值就能够判断这个数据包是 IPv4 还是 IPv6。</p><p>再强调一下，这个字段在两个版本的IP协议都位于第一个字段，为了做兼容处理，对应的这个字段必须位于同一位置。文本协议（如，JSON、HTML）的情况类似。</p><h3 id="如何发送不定长数据的数据包"><a href="#如何发送不定长数据的数据包" class="headerlink" title="如何发送不定长数据的数据包"></a>如何发送不定长数据的数据包</h3><p>举个例子，我们用微信发送一条消息。这条消息的长度是不确定的，并且每条消息都有它的边界。我们如何来处理这个边界呢？</p><p>还是一样，看看 IP。IP 的头部有个 header length 和 data length 两个字段。通过添加一个 len 域，我们就能够把数据根据应用逻辑分开。</p><p>跟这个相对的，还有另一个方案，那就是在数据的末尾放置终止符。比方说，想 C 语言的字符串那样，我们在每个数据的末尾放一个 <code>\0</code> 作为终止符，用以标识一条消息的尾部。这个方法带来的问题是，用户的数据也可能存在 <code>\0</code>。此时，我们就需要对用户的数据进行<strong>转义</strong>。比方说，把用户数据的所有 <code>\0</code> 都变成 <code>\0\0</code>。读消息的过程总，如果遇到 <code>\0\0</code>，那它就代表 <code>\0</code>，如果只有一个 <code>\0</code>，那就是消息尾部。</p><p>使用 len 字段的好处是，我们不需要对数据进行转义。读取数据的时候，只要根据 len 字段，一次性把数据都读进来就好，效率会更高一些。</p><p>终止符的方案虽然要求我们对数据进行扫描，但是如果我们可能从任意地方开始读取数据，就需要这个终止符来确定哪里才是消息的开头了。</p><p>当然，这两个方法不是互斥的，可以一起使用。</p><h3 id="上传多个文件，只有所有文件都上传成功时才算成功"><a href="#上传多个文件，只有所有文件都上传成功时才算成功" class="headerlink" title="上传多个文件，只有所有文件都上传成功时才算成功"></a>上传多个文件，只有所有文件都上传成功时才算成功</h3><p>现在我们有一个需求，需要一次上传多个文件到服务器，只有在所有文件都上传成功的情况下，才算成功。我们该如何来实现呢？</p><p>IP 在数据报过大的时候，会把一个数据报拆分成多个，并设置一个 MF （more fragments）位，表示这个包只是被拆分后的数据的一部分。</p><p>好，我们也学一学 IP。这里，我们可以给每个文件从 0 开始编号。上传文件的同时，也携带这个编号，并额外附带一个 MF 标志。除了编号最大的文件，所有文件的 MF 标志都置位。因为 MF 没有置位的是最后一个文件，服务器就可以根据这个得出总共有多少个文件。</p><p>另一种不使用 MF 标志的方法是，我们在上传文件前，就告诉服务器总共有多少个文件。</p><p>如果读者对数据库比较熟悉，学数据库用事务来处理，也是可以的。这里就不展开讨论了。</p><h3 id="如何保证数据的有序性"><a href="#如何保证数据的有序性" class="headerlink" title="如何保证数据的有序性"></a>如何保证数据的有序性</h3><p>这里讲一个我曾经遇到过的面试题。现在有一个任务队列，多个工作线程从中取出任务并执行，执行结果放到一个结果队列中。先要求，放入结果队列的时候，顺序顺序需要跟从工作队列取出时的一样（也就是说，先取出的任务，执行结果需要先放入结果队列）。</p><p>我们看看 TCP/IP 是怎么处理的。IP 在发送数据的时候，不同数据报到达对端的时间是不确定的，后面发送的数据有可能较先到达。TCP 为了解决这个问题，给所发送数据的每个字节都赋了一个序列号，通过这个序列号，TCP 就能够把数据按原顺序重新组装。</p><p>一样，我们也给每个任务赋一个值，根据进入工作队列的顺序依次递增。工作线程完成任务后，在将结果放入结果队列前，先检查要放入对象的写一个序列号是不是跟自己的任务相同，如果不同，这个结果就不能放进去。此时，最简单的做法是等待，知道下一个可以放入队列的结果是自己所执行的那一个。但是，这个线程就没办法继续处理任务了。</p><p>更好的方法是，我们维护多一个结果队列的缓冲，这个缓冲里面的数据按序列号从小到大排序。工作线程要将结果放入，有两种可能：</p><ol><li>刚刚完成的任务刚好是下一个，将这个结果放入队列。然后从缓冲的头部开始，将所有可以放入结果队列的数据都放进去。</li><li>所完成的任务不能放入结果队列，这个时候就插入结果队列。然后，跟上一种情况一样，需要检查缓冲。</li></ol><p>如果测试表明，这个结果缓冲的数据不多，那么使用普通的链表就可以。如果数据比较多，可以使用一个最小堆。</p><h3 id="如何保证对方收到了消息"><a href="#如何保证对方收到了消息" class="headerlink" title="如何保证对方收到了消息"></a>如何保证对方收到了消息</h3><p>我们说，TCP 提供了可靠的传输。这样不就能够保证对方收到消息了吗？</p><p>很遗憾，其实不能。在我们往 socket 写入的数据，只要对端的内核收到后，就会返回 <code>ACK</code>，此时，socket 就认为数据已经写入成功。然而要注意的是，这里只是对方所运行的系统的内核成功收到了数据，并不表示应用程序已经成功处理了数据。</p><p>解决办法还是一样，我们学 <code>TCP</code>，添加一个应用层的 <code>APP ACK</code>。应用接收到消息并处理成功后，发送一个 <code>APP ACK</code> 给对方。</p><p>有了 <code>APP ACK</code>，我们需要处理的另一个问题是，如果对方真的没有收到，需要怎么做？</p><p>TCP 发送数据的时候，消息一样可能丢失。TCP 发送数据后，如果长时间没有收到对方的 <code>ACK</code>，就假设数据已经丢失，并重新发送。</p><p>我们也一样，如果长时间没有收到 <code>APP ACK</code>，就假设数据丢失，重新发送一个。</p><p><br><br></p><p>附：<br>[1] <a href="http://renyugang.io/post/75" target="_blank" rel="noopener">http://renyugang.io/post/75</a><br>[2] <a href="https://jekton.github.io/">https://jekton.github.io</a><br>[3] <a href="https://github.com/Jekton/Echo" target="_blank" rel="noopener">https://github.com/Jekton/Echo</a></p>]]></content>
    
    <summary type="html">
    
      本篇我们先简单了解一下 TCP/IP，然后通过实现一个 echo 服务器来学习 Java 的 Socket API。最后我们聊聊偏高级一点点的 socket 长连接和协议设计。
    
    </summary>
    
      <category term="Java" scheme="https://jekton.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jekton.github.io/tags/Java/"/>
    
      <category term="Socket" scheme="https://jekton.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析(2) - 内存缓存和数组缓存</title>
    <link href="https://jekton.github.io/2018/06/20/glide-mem-cache1/"/>
    <id>https://jekton.github.io/2018/06/20/glide-mem-cache1/</id>
    <published>2018-06-20T06:59:29.000Z</published>
    <updated>2018-08-18T12:47:22.684Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2018/06/08/glide-disk-cache/">上篇</a>我们了解了 Glide 的硬盘缓存，现在，我们继续看他的内存缓存和数组缓存。</p><h2 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h2><h3 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h3><p>首先，虽然没有什么意思，出于完整性，我们还是先看看 <code>MemoryCache</code> 这个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An interface for adding and removing resources from an in memory cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemoryCache</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * An interface that will be called whenever a bitmap is removed from the cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">ResourceRemovedListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onResourceRemoved</span><span class="params">(@NonNull Resource&lt;?&gt; removed)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the sum of the sizes of all the contents of the cache in bytes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">getCurrentSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the current maximum size in bytes of the cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">getMaxSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Adjust the maximum size of the cache by multiplying the original size of the cache by the given</span></span><br><span class="line"><span class="comment">   * multiplier.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; If the size multiplier causes the size of the cache to be decreased, items will be evicted</span></span><br><span class="line"><span class="comment">   * until the cache is smaller than the new size. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> multiplier A size multiplier &gt;= 0.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setSizeMultiplier</span><span class="params">(<span class="keyword">float</span> multiplier)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Removes the value for the given key and returns it if present or null otherwise.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  Resource&lt;?&gt; remove(<span class="meta">@NonNull</span> Key key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add bitmap to the cache with the given key.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key      The key to retrieve the bitmap.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> resource The &#123;<span class="doctag">@link</span> com.bumptech.glide.load.engine.EngineResource&#125; to store.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The old value of key (null if key is not in map).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  Resource&lt;?&gt; put(<span class="meta">@NonNull</span> Key key, <span class="meta">@Nullable</span> Resource&lt;?&gt; resource);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the listener to be called when a bitmap is removed from the cache.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> listener The listener.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setResourceRemovedListener</span><span class="params">(@NonNull ResourceRemovedListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evict all items from the memory cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearMemory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Trim the memory cache to the appropriate level. Typically called on the callback onTrimMemory.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> level This integer represents a trim level as specified in &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   *              android.content.ComponentCallbacks2&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trimMemory</span><span class="params">(<span class="keyword">int</span> level)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Glide 将内存缓存里的缓存实例抽象为 <code>Resource</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A resource interface that wraps a particular type so that it can be pooled and reused.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;Z&gt; The type of resource wrapped by this class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span>&lt;<span class="title">Z</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the &#123;<span class="doctag">@link</span> Class&#125; of the wrapped resource.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function">Class&lt;Z&gt; <span class="title">getResourceClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns an instance of the wrapped resource.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; Note - This does not have to be the same instance of the wrapped resource class and in fact</span></span><br><span class="line"><span class="comment">   * it is often appropriate to return a new instance for each call. For example,</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> android.graphics.drawable.Drawable Drawable&#125;s should only be used by a single</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> android.view.View View&#125; at a time so each call to this method for Resources that wrap</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> android.graphics.drawable.Drawable Drawable&#125;s should always return a new</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> android.graphics.drawable.Drawable Drawable&#125;. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function">Z <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the size in bytes of the wrapped resource to use to determine how much of the memory</span></span><br><span class="line"><span class="comment">   * cache this resource uses.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Cleans up and recycles internal resources.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; It is only safe to call this method if there are no current resource consumers and if this</span></span><br><span class="line"><span class="comment">   * method has not yet been called. Typically this occurs at one of two times:</span></span><br><span class="line"><span class="comment">   * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   *   &lt;li&gt;During a resource load when the resource is transformed or transcoded before any consumer</span></span><br><span class="line"><span class="comment">   *   have ever had access to this resource&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *   &lt;li&gt;After all consumers have released this resource and it has been evicted from the cache</span></span><br><span class="line"><span class="comment">   *   &lt;/li&gt;</span></span><br><span class="line"><span class="comment">   * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * For most users of this class, the only time this method should ever be called is during</span></span><br><span class="line"><span class="comment">   * transformations or transcoders, the framework will call this method when all consumers have</span></span><br><span class="line"><span class="comment">   * released this resource and it has been evicted from the cache. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>和大多数接口一样，<code>MemoryCache</code> 也有一个“傻瓜实现” <code>MemoryCacheAdapter</code>。这个类虽然实现了接口，但其实什么也没干。当我们想要完全关闭内存缓存的时候，就可以使用它。具体的代码这里就不看了。</p><p><code>MemoryCache</code> 的真正实现是 <code>LruResourceCache</code>，它继承了 <code>LruCache</code>。在看 <code>LruResourceCache</code> 之前，我们先看看 <code>LruCache</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A general purpose size limited cache that evicts items using an LRU algorithm. By default every</span></span><br><span class="line"><span class="comment"> * item is assumed to have a size of one. Subclasses can override &#123;<span class="doctag">@link</span> #getSize(Object)&#125;&#125; to</span></span><br><span class="line"><span class="comment"> * change the size on a per item basis.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; The type of the keys.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;Y&gt; The type of the values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span>&lt;<span class="title">T</span>, <span class="title">Y</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// LinkedHashMap 的最后一个参数是 accessOrder，设置为 true 后，每次我们访问一个</span></span><br><span class="line">  <span class="comment">// 元素，对应的元素都会被移到链表的末尾</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, Y&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">100</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> initialMaxSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> maxSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> currentSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor for LruCache.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> size The maximum size of the cache, the units must match the units used in &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   *             #getSize(Object)&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initialMaxSize = size;</span><br><span class="line">    <span class="keyword">this</span>.maxSize = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets a size multiplier that will be applied to the size provided in the constructor to put the</span></span><br><span class="line"><span class="comment">   * new size of the cache. If the new size is less than the current size, entries will be evicted</span></span><br><span class="line"><span class="comment">   * until the current size is less than or equal to the new size.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> multiplier The multiplier to apply.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSizeMultiplier</span><span class="params">(<span class="keyword">float</span> multiplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (multiplier &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Multiplier must be &gt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    maxSize = Math.round(initialMaxSize * multiplier);</span><br><span class="line">    evict();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the size of a given item, defaulting to one. The units must match those used in the</span></span><br><span class="line"><span class="comment">   * size passed in to the constructor. Subclasses can override this method to return sizes in</span></span><br><span class="line"><span class="comment">   * various units, usually bytes.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> item The item to get the size of.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(@Nullable Y item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the number of entries stored in cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A callback called whenever an item is evicted from the cache. Subclasses can override.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key  The key of the evicted item.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> item The evicted item.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onItemEvicted</span><span class="params">(@NonNull T key, @Nullable Y item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// optional override</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the current maximum size of the cache in bytes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getMaxSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the sum of the sizes of all items in the cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getCurrentSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns true if there is a value for the given key in the cache.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key to check.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(@NonNull T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.containsKey(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the item in the cache for the given key or null if no such item exists.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key to check.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Y <span class="title">get</span><span class="params">(@NonNull T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Adds the given item to the cache with the given key and returns any previous entry for the</span></span><br><span class="line"><span class="comment">   * given key that may have already been in the cache.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If the size of the item is larger than the total cache size, the item will not be added to</span></span><br><span class="line"><span class="comment">   * the cache and instead &#123;<span class="doctag">@link</span> #onItemEvicted(Object, Object)&#125; will be called synchronously with</span></span><br><span class="line"><span class="comment">   * the given key and item.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key  The key to add the item at.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> item The item to add.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Y <span class="title">put</span><span class="params">(@NonNull T key, @Nullable Y item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> itemSize = getSize(item);</span><br><span class="line">    <span class="keyword">if</span> (itemSize &gt;= maxSize) &#123;</span><br><span class="line">      onItemEvicted(key, item);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentSize += itemSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span> <span class="keyword">final</span> Y old = cache.put(key, item);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentSize -= getSize(old);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!old.equals(item)) &#123;</span><br><span class="line">        onItemEvicted(key, old);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    evict();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Removes the item at the given key and returns the removed item if present, and null otherwise.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key to remove the item at.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Y <span class="title">remove</span><span class="params">(@NonNull T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Y value = cache.remove(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentSize -= getSize(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clears all items in the cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trimToSize(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Removes the least recently used items from the cache until the current size is less than the</span></span><br><span class="line"><span class="comment">   * given size.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> size The size the cache should be less than.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;T, Y&gt; last;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;T, Y&gt;&gt; cacheIterator;</span><br><span class="line">    <span class="keyword">while</span> (currentSize &gt; size) &#123;</span><br><span class="line">      cacheIterator  = cache.entrySet().iterator();</span><br><span class="line">      last = cacheIterator.next();</span><br><span class="line">      <span class="keyword">final</span> Y toRemove = last.getValue();</span><br><span class="line">      currentSize -= getSize(toRemove);</span><br><span class="line">      <span class="keyword">final</span> T key = last.getKey();</span><br><span class="line">      cacheIterator.remove();</span><br><span class="line">      onItemEvicted(key, toRemove);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个 <code>LruCache</code> 的实现，唯一需要注意的就是开头那一句代码，我们把 <code>accessOrder</code> 设置为 <code>true</code>。其余的都很简单，读者自己看一看就好。</p><p>接下来，我们看看更简单的 <code>LruResourceCache</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An LRU in memory cache for &#123;<span class="doctag">@link</span> com.bumptech.glide.load.engine.Resource&#125;s.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruResourceCache</span> <span class="keyword">extends</span> <span class="title">LruCache</span>&lt;<span class="title">Key</span>, <span class="title">Resource</span>&lt;?&gt;&gt; <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ResourceRemovedListener listener;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor for LruResourceCache.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> size The maximum size in bytes the in memory cache can use.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LruResourceCache</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceRemovedListener</span><span class="params">(@NonNull ResourceRemovedListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onItemEvicted</span><span class="params">(@NonNull Key key, @Nullable Resource&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span> &amp;&amp; item != <span class="keyword">null</span>) &#123;</span><br><span class="line">      listener.onResourceRemoved(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(@Nullable Resource&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getSize(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressLint</span>(<span class="string">"InlinedApi"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) &#123;</span><br><span class="line">      <span class="comment">// Entering list of cached background apps</span></span><br><span class="line">      <span class="comment">// Evict our entire bitmap cache</span></span><br><span class="line">      clearMemory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level &gt;= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN</span><br><span class="line">        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) &#123;</span><br><span class="line">      <span class="comment">// The app's UI is no longer visible, or app is in the foreground but system is running</span></span><br><span class="line">      <span class="comment">// critically low on memory</span></span><br><span class="line">      <span class="comment">// Evict oldest half of our bitmap cache</span></span><br><span class="line">      trimToSize(getMaxSize() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>鉴于这两个类的实现是在是没有太多可圈可点的地方，为了不让读者白看一场，这里还是简单讲一下 LRU 的实现好了。</p><p>为了实现 LRU，关键的有两点：</p><ol><li>为了快速查找，我们需要一个 hash map</li><li>访问元素后，我们需要把元素标记为“最新”。并且需要一种机制，可以让我们按访问时间依次遍历元素。这个时候，我们就需要一个双端链表。</li></ol><p>把 hash map 和 double linked list 组合起来，就可以实现一个 LRU 了。这里使用的是 JDK 实现的 <code>LinkedHashMap</code>。</p><h2 id="ArrayPool"><a href="#ArrayPool" class="headerlink" title="ArrayPool"></a>ArrayPool</h2><p>现在我们看看 <code>ArrayPool</code>。<code>ArrayPool</code> 的主要作用是缓存 <code>int[]</code> 和 <code>byte[]</code>。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface for an array pool that pools arrays of different types.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArrayPool</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A standard size to use to increase hit rates when the required size isn't defined.</span></span><br><span class="line"><span class="comment">   * Currently 64KB.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> STANDARD_BUFFER_SIZE_BYTES = <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Optionally adds the given array of the given type to the pool.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Arrays may be ignored, for example if the array is larger than the maximum size of the</span></span><br><span class="line"><span class="comment">   * pool.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #put(Object)&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(T array, Class&lt;T&gt; arrayClass)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Optionally adds the given array of the given type to the pool.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Arrays may be ignored, for example if the array is larger than the maximum size of the</span></span><br><span class="line"><span class="comment">   * pool.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(T array)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a non-null array of the given type with a length &gt;= to the given size.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If an array of the given size isn't in the pool, a new one will be allocated.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;This class makes no guarantees about the contents of the returned array.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> #getExact(int, Class)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> size, Class&lt;T&gt; arrayClass)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a non-null array of the given type with a length exactly equal to the given size.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If an array of the given size isn't in the pool, a new one will be allocated.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;This class makes no guarantees about the contents of the returned array.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> #get(int, Class)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">getExact</span><span class="params">(<span class="keyword">int</span> size, Class&lt;T&gt; arrayClass)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clears all arrays from the pool.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearMemory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Trims the size to the appropriate level.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> level A trim specified in &#123;<span class="doctag">@link</span> android.content.ComponentCallbacks2&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trimMemory</span><span class="params">(<span class="keyword">int</span> level)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>在看 <code>ArrapPool</code> 的实现前，我们先看他用到的辅助类 <code>ArrayAdapterInterface</code> 和 <code>GroupedLinkedMap</code>。</p><h4 id="ArrayAdapterInterface"><a href="#ArrayAdapterInterface" class="headerlink" title="ArrayAdapterInterface"></a>ArrayAdapterInterface</h4><p>前面我们提过，<code>ArrayPool</code> 的作用是缓存 <code>int[]</code> 和 <code>byte[]</code>。 <code>ArrayAdapterInterface</code> 的作用，就是隔离这两者的差别。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface for handling operations on a primitive array type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; Array type (e.g. byte[], int[])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ArrayAdapterInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * TAG for logging.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getTag</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the length of the given array.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getArrayLength</span><span class="params">(T array)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Allocate and return an array of the specified size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">T <span class="title">newArray</span><span class="params">(<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the size of an element in the array in bytes (e.g. for int return 4).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getElementSizeInBytes</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final class IntegerArrayAdapter implements ArrayAdapterInterface&lt;int[]&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"IntegerArrayPool"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TAG;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArrayLength</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] newArray(<span class="keyword">int</span> length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getElementSizeInBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟 <code>byte[]</code> 相对应的是 <code>ByteArrayAdapter</code>，他的实现跟 <code>IntegerArrayAdapter</code> 基本是一样的，这里就不看了。</p><h4 id="GroupedLinkedMap"><a href="#GroupedLinkedMap" class="headerlink" title="GroupedLinkedMap"></a>GroupedLinkedMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Similar to &#123;<span class="doctag">@link</span> java.util.LinkedHashMap&#125; when access ordered except that it is access ordered</span></span><br><span class="line"><span class="comment"> * on groups of bitmaps rather than individual objects. The idea is to be able to find the LRU</span></span><br><span class="line"><span class="comment"> * bitmap size, rather than the LRU bitmap object. We can then remove bitmaps from the least</span></span><br><span class="line"><span class="comment"> * recently used size of bitmap when we need to reduce our cache size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For the purposes of the LRU, we count gets for a particular size of bitmap as an access, even if</span></span><br><span class="line"><span class="comment"> * no bitmaps of that size are present. We do not count addition or removal of bitmaps as an</span></span><br><span class="line"><span class="comment"> * access.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupedLinkedMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Poolable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// head 是链表的头节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LinkedEntry&lt;K, V&gt; head = <span class="keyword">new</span> LinkedEntry&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, LinkedEntry&lt;K, V&gt;&gt; keyToEntry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; entry = keyToEntry.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">      entry = <span class="keyword">new</span> LinkedEntry&lt;&gt;(key);</span><br><span class="line">      <span class="comment">// 放到链表末尾</span></span><br><span class="line">      makeTail(entry);</span><br><span class="line">      keyToEntry.put(key, entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不需要用到这个 key。key 是 poolable 的，offer 后会放回 pool</span></span><br><span class="line">      key.offer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entry.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; entry = keyToEntry.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">      entry = <span class="keyword">new</span> LinkedEntry&lt;&gt;(key);</span><br><span class="line">      keyToEntry.put(key, entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      key.offer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刚刚访问过的元素，要移到链表的开头</span></span><br><span class="line">    makeHead(entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是刚刚 new 出来的 LinkedEntry，这里会返回 null</span></span><br><span class="line">    <span class="keyword">return</span> entry.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LinkedEntry 组成的是一个双向的链表，head.prev 是链表的尾节点</span></span><br><span class="line">    LinkedEntry&lt;K, V&gt; last = head.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!last.equals(head)) &#123;</span><br><span class="line">      V removed = last.removeLast();</span><br><span class="line">      <span class="keyword">if</span> (removed != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We will clean up empty lru entries since they are likely to have been one off or</span></span><br><span class="line">        <span class="comment">// unusual sizes and</span></span><br><span class="line">        <span class="comment">// are not likely to be requested again so the gc thrash should be minimal. Doing so will</span></span><br><span class="line">        <span class="comment">// speed up our</span></span><br><span class="line">        <span class="comment">// removeLast operation in the future and prevent our linked list from growing to</span></span><br><span class="line">        <span class="comment">// arbitrarily large</span></span><br><span class="line">        <span class="comment">// sizes.</span></span><br><span class="line">        removeEntry(last);</span><br><span class="line">        keyToEntry.remove(last.key);</span><br><span class="line">        last.key.offer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last = last.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"GroupedLinkedMap( "</span>);</span><br><span class="line">    LinkedEntry&lt;K, V&gt; current = head.next;</span><br><span class="line">    <span class="keyword">boolean</span> hadAtLeastOneItem = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!current.equals(head)) &#123;</span><br><span class="line">      hadAtLeastOneItem = <span class="keyword">true</span>;</span><br><span class="line">      sb.append(<span class="string">'&#123;'</span>).append(current.key).append(<span class="string">':'</span>).append(current.size()).append(<span class="string">"&#125;, "</span>);</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hadAtLeastOneItem) &#123;</span><br><span class="line">      sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.append(<span class="string">" )"</span>).toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the entry the most recently used item.</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeHead</span><span class="params">(LinkedEntry&lt;K, V&gt; entry)</span> </span>&#123;</span><br><span class="line">    removeEntry(entry);</span><br><span class="line">    entry.prev = head;</span><br><span class="line">    entry.next = head.next;</span><br><span class="line">    updateEntry(entry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the entry the least recently used item.</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeTail</span><span class="params">(LinkedEntry&lt;K, V&gt; entry)</span> </span>&#123;</span><br><span class="line">    removeEntry(entry);</span><br><span class="line">    entry.prev = head.prev;</span><br><span class="line">    entry.next = head;</span><br><span class="line">    updateEntry(entry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">void</span> <span class="title">updateEntry</span><span class="params">(LinkedEntry&lt;K, V&gt; entry)</span> </span>&#123;</span><br><span class="line">    entry.next.prev = entry;</span><br><span class="line">    entry.prev.next = entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeEntry</span><span class="params">(LinkedEntry&lt;K, V&gt; entry)</span> </span>&#123;</span><br><span class="line">    entry.prev.next = entry.next;</span><br><span class="line">    entry.next.prev = entry.prev;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Synthetic</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; values;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; next;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used only for the first item in the list which we will treat specially and which will not</span></span><br><span class="line">    <span class="comment">// contain a value.</span></span><br><span class="line">    LinkedEntry() &#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedEntry(K key) &#123;</span><br><span class="line">      next = prev = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> valueSize = size();</span><br><span class="line">      <span class="keyword">return</span> valueSize &gt; <span class="number">0</span> ? values.remove(valueSize - <span class="number">1</span>) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> values != <span class="keyword">null</span> ? values.size() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">        values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">      values.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LruArrayPool"><a href="#LruArrayPool" class="headerlink" title="LruArrayPool"></a>LruArrayPool</h4><p><code>LruArrayPool</code> 是 <code>ArrayPool</code> 的实现。我们先看看如何把数组放到这个 pool 里，这个功能由 <code>put</code> 方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, NavigableMap&lt;Integer, Integer&gt;&gt; sortedSizes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, ArrayAdapterInterface&lt;?&gt;&gt; adapters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(T array)</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  Class&lt;T&gt; arrayClass = (Class&lt;T&gt;) array.getClass();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getAdapterFromType 会跟进 class 返回 IntegerArrayAdapter 或 ByteArrayAdapter</span></span><br><span class="line">  ArrayAdapterInterface&lt;T&gt; arrayAdapter = getAdapterFromType(arrayClass);</span><br><span class="line">  <span class="keyword">int</span> size = arrayAdapter.getArrayLength(array);</span><br><span class="line">  <span class="keyword">int</span> arrayBytes = size * arrayAdapter.getElementSizeInBytes();</span><br><span class="line">  <span class="keyword">if</span> (!isSmallEnoughForReuse(arrayBytes)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Key key = keyPool.get(size, arrayClass);</span><br><span class="line"></span><br><span class="line">  groupedMap.put(key, array);</span><br><span class="line">  NavigableMap&lt;Integer, Integer&gt; sizes = getSizesForAdapter(arrayClass);</span><br><span class="line">  <span class="comment">// key.size 其实就是数组长度</span></span><br><span class="line">  Integer current = sizes.get(key.size);</span><br><span class="line">  <span class="comment">// TreeMap 里面记录的是每个 size 对应的数组有多少个</span></span><br><span class="line">  sizes.put(key.size, current == <span class="keyword">null</span> ? <span class="number">1</span> : current + <span class="number">1</span>);</span><br><span class="line">  currentSize += arrayBytes;</span><br><span class="line">  evict();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ArrayAdapterInterface&lt;T&gt; <span class="title">getAdapterFromType</span><span class="params">(Class&lt;T&gt; arrayPoolClass)</span> </span>&#123;</span><br><span class="line">  ArrayAdapterInterface&lt;?&gt; adapter = adapters.get(arrayPoolClass);</span><br><span class="line">  <span class="keyword">if</span> (adapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arrayPoolClass.equals(<span class="keyword">int</span>[].class)) &#123;</span><br><span class="line">      adapter = <span class="keyword">new</span> IntegerArrayAdapter();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arrayPoolClass.equals(<span class="keyword">byte</span>[].class)) &#123;</span><br><span class="line">      adapter = <span class="keyword">new</span> ByteArrayAdapter();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No array pool found for: "</span></span><br><span class="line">            + arrayPoolClass.getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    adapters.put(arrayPoolClass, adapter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (ArrayAdapterInterface&lt;T&gt;) adapter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> NavigableMap&lt;Integer, Integer&gt; <span class="title">getSizesForAdapter</span><span class="params">(Class&lt;?&gt; arrayClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 一个数组类型对应一个 TreeMap（int[]/byte[] 分别对应一个 TreeMap）</span></span><br><span class="line">  NavigableMap&lt;Integer, Integer&gt; sizes = sortedSizes.get(arrayClass);</span><br><span class="line">  <span class="keyword">if</span> (sizes == <span class="keyword">null</span>) &#123;</span><br><span class="line">    sizes = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    sortedSizes.put(arrayClass, sizes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sizes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加一个元素到缓存里，有可能使得缓存的总量超过了最大限度，所以在最后调用 <code>evict()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  evictToSize(maxSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evictToSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (currentSize &gt; size) &#123;</span><br><span class="line">    Object evicted = groupedMap.removeLast();</span><br><span class="line">    Preconditions.checkNotNull(evicted);</span><br><span class="line">    ArrayAdapterInterface&lt;Object&gt; arrayAdapter = getAdapterFromObject(evicted);</span><br><span class="line">    currentSize -= arrayAdapter.getArrayLength(evicted) * arrayAdapter.getElementSizeInBytes();</span><br><span class="line">    decrementArrayOfSize(arrayAdapter.getArrayLength(evicted), evicted.getClass());</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(arrayAdapter.getTag(), <span class="string">"evicted: "</span> + arrayAdapter.getArrayLength(evicted));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementArrayOfSize</span><span class="params">(<span class="keyword">int</span> size, Class&lt;?&gt; arrayClass)</span> </span>&#123;</span><br><span class="line">  NavigableMap&lt;Integer, Integer&gt; sizes = getSizesForAdapter(arrayClass);</span><br><span class="line">  Integer current = sizes.get(size);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</span><br><span class="line">        <span class="string">"Tried to decrement empty size"</span> + <span class="string">", size: "</span> + size + <span class="string">", this: "</span> + <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="number">1</span>) &#123;</span><br><span class="line">    sizes.remove(size);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sizes.put(size, current - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的实现跟其他缓存差不多，就不说太多了。</p><p>下面我们看元素的获取。从缓存取出数组有两个方法，<code>getExact</code> 和 <code>get</code>。区别是，前者只会返回刚好符合所请求长度的数组，后者返回的数组则可能超过所请求长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; <span class="function">T <span class="title">getExact</span><span class="params">(<span class="keyword">int</span> size, Class&lt;T&gt; arrayClass)</span> </span>&#123;</span><br><span class="line">  Key key = keyPool.get(size, arrayClass);</span><br><span class="line">  <span class="keyword">return</span> getForKey(key, arrayClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getForKey</span><span class="params">(Key key, Class&lt;T&gt; arrayClass)</span> </span>&#123;</span><br><span class="line">  ArrayAdapterInterface&lt;T&gt; arrayAdapter = getAdapterFromType(arrayClass);</span><br><span class="line">  T result = getArrayForKey(key);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">    currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();</span><br><span class="line">    decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(arrayAdapter.getTag(), <span class="string">"Allocated "</span> + key.size + <span class="string">" bytes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = arrayAdapter.newArray(key.size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Our cast is safe because the Key is based on the type.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"TypeParameterUnusedInFormals"</span>&#125;)</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getArrayForKey</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// groupedMap 的实现我们在前面看过了</span></span><br><span class="line">  <span class="keyword">return</span> (T) groupedMap.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getExact</code> 的实现比较简单，反正要多少（长度）给多少就是了。下面我们看 <code>get</code> 方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> size, Class&lt;T&gt; arrayClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ceilingKey 的返回值大于等于 size</span></span><br><span class="line">  <span class="comment">// 这里就是我们要用 NavigableMap 的原因了，我们需要他的 ceilingKey()</span></span><br><span class="line">  Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);</span><br><span class="line">  <span class="keyword">final</span> Key key;</span><br><span class="line">  <span class="keyword">if</span> (mayFillRequest(size, possibleSize)) &#123;</span><br><span class="line">    key = keyPool.get(possibleSize, arrayClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    key = keyPool.get(size, arrayClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getForKey(key, arrayClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">mayFillRequest</span><span class="params">(<span class="keyword">int</span> requestedSize, Integer actualSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> actualSize != <span class="keyword">null</span></span><br><span class="line">      &amp;&amp; (isNoMoreThanHalfFull() || actualSize &lt;= (MAX_OVER_SIZE_MULTIPLE * requestedSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为缓存里可能没有我们需要的 size，但是有更大的。返回长度更大的对客户端并不会有什么影响，在某些情况下，还能增加缓存的利用率。但是，如果我们返回了一个更大的数组，就意味着有一部分空间客户端并不会使用，所以要对这个浪费的空间做一些限制。这个限制由 <code>MAX_OVER_SIZE_MULTIPLE</code> 控制。按照 4.7.1 版本的实现，这个值为 8，也就是说，可能会返回 8 倍于所请求长度的数组。</p><p>好了。<code>ArrayPool</code> 我们也看完啦。</p><p><br></p>]]></content>
    
    <summary type="html">
    
      在上篇我们了解了 Glide 的硬盘缓存，现在，我们继续看他的内存缓存和数组缓存。
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Glide" scheme="https://jekton.github.io/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析(1) - DiskCache 详解</title>
    <link href="https://jekton.github.io/2018/06/08/glide-disk-cache/"/>
    <id>https://jekton.github.io/2018/06/08/glide-disk-cache/</id>
    <published>2018-06-08T10:32:03.000Z</published>
    <updated>2018-08-18T12:47:22.683Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个合格的图片加载框架，一般都会有内存缓存和硬盘缓存。在本篇，我们就先来看看 Glide 的硬盘缓存实现。</p><a id="more"></a><blockquote><p>Glide 使用版本 4.7.1</p></blockquote><h2 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h2><p>Glide 的硬盘缓存由接口 <code>DiskCache</code> 定义，用户可以根据需要，提供自己实现的 <code>DiskCache</code>，或者使用 Glide 内置的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An interface for writing to and reading from a disk cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiskCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * An interface for lazily creating a disk cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 250 MB of cache. */</span></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_DISK_CACHE_SIZE = <span class="number">250</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    String DEFAULT_DISK_CACHE_DIR = <span class="string">"image_manager_disk_cache"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a new disk cache, or &#123;<span class="doctag">@code</span> null&#125; if no disk cache could be created. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">DiskCache <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * An interface to actually write data to a key in the disk cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Writes data to the file and returns true if the write was successful and should be committed,</span></span><br><span class="line"><span class="comment">     * and false if the write should be aborted.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file The File the Writer should write to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">write</span><span class="params">(@NonNull File file)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the cache for the value at the given key.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; Note - This is potentially dangerous, someone may write a new value to the file at any</span></span><br><span class="line"><span class="comment">   * point in time and we won't know about it. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key in the cache.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> An InputStream representing the data at key at the time get is called.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">File <span class="title">get</span><span class="params">(Key key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write to a key in the cache. &#123;<span class="doctag">@link</span> Writer&#125; is used so that the cache implementation can</span></span><br><span class="line"><span class="comment">   * perform actions after the write finishes, like commit (via atomic file rename).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key    The key to write to.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> writer An interface that will write data given an OutputStream for the key.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Writer writer)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove the key and value from the cache.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key to remove.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// Public API.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clear the cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口并没有太多值得玩味的地方，读者自己看一看就好。</p><h2 id="Factory-工厂"><a href="#Factory-工厂" class="headerlink" title="Factory 工厂"></a>Factory 工厂</h2><p><code>DiskCache.Factory</code> 作为一个工厂，用来 build 出实际的 <code>DiskCache</code> 实例。Glide 内部共有 3 个 <code>Factory</code> 的实现，分别是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiskLruCacheFactory</span> <span class="keyword">implements</span> <span class="title">DiskCache</span>.<span class="title">Factory</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InternalCacheDiskCacheFactory</span> <span class="keyword">extends</span> <span class="title">DiskLruCacheFactory</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExternalPreferredCacheDiskCacheFactory</span> <span class="keyword">extends</span> <span class="title">DiskLruCacheFactory</span></span>;</span><br></pre></td></tr></table></figure><p><code>InternalCacheDiskCacheFactory</code> 所创建的 <code>DiskCache</code> 将文件存储在 internal storage，存放在这里的文件只有我们自己能够读取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalCacheDiskCacheFactory</span> <span class="keyword">extends</span> <span class="title">DiskLruCacheFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InternalCacheDiskCacheFactory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认情况下，文件夹名字是 image_manager_disk_cache</span></span><br><span class="line">    <span class="comment">// 缓存大小为 250M</span></span><br><span class="line">    <span class="keyword">this</span>(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,</span><br><span class="line">        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InternalCacheDiskCacheFactory</span><span class="params">(Context context, <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InternalCacheDiskCacheFactory</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> String diskCacheName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> CacheDirectoryGetter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从这里可以看到，我们确实是用的 internal storage</span></span><br><span class="line">        File cacheDirectory = context.getCacheDir();</span><br><span class="line">        <span class="keyword">if</span> (cacheDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (diskCacheName != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> File(cacheDirectory, diskCacheName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheDirectory;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ExternalPreferredCacheDiskCacheFactory</code> 优先使用 external storage，在 external storage 不可写的情况下，会转而使用 internal storage。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@link</span> com.bumptech.glide.disklrucache.DiskLruCache&#125; based disk cache in the external</span></span><br><span class="line"><span class="comment"> * disk cache directory, which falls back to the internal disk cache if no external storage is</span></span><br><span class="line"><span class="comment"> * available. If ever fell back to the internal disk cache, will use that one from that moment on.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Images can be read by everyone when using external disk cache.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Public API.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"WeakerAccess"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalPreferredCacheDiskCacheFactory</span> <span class="keyword">extends</span> <span class="title">DiskLruCacheFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExternalPreferredCacheDiskCacheFactory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,</span><br><span class="line">        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExternalPreferredCacheDiskCacheFactory</span><span class="params">(Context context, <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExternalPreferredCacheDiskCacheFactory</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> String diskCacheName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">final</span> <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> CacheDirectoryGetter() &#123;</span><br><span class="line">      <span class="meta">@Nullable</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> File <span class="title">getInternalCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File cacheDirectory = context.getCacheDir();</span><br><span class="line">        <span class="keyword">if</span> (cacheDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (diskCacheName != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> File(cacheDirectory, diskCacheName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheDirectory;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File internalCacheDirectory = getInternalCacheDirectory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Already used internal cache, so keep using that one,</span></span><br><span class="line">        <span class="comment">// thus avoiding using both external and internal with transient errors.</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">null</span> != internalCacheDirectory) &amp;&amp; internalCacheDirectory.exists()) &#123;</span><br><span class="line">          <span class="keyword">return</span> internalCacheDirectory;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File cacheDirectory = context.getExternalCacheDir();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shared storage is not available.</span></span><br><span class="line">        <span class="keyword">if</span> ((cacheDirectory == <span class="keyword">null</span>) || (!cacheDirectory.canWrite())) &#123;</span><br><span class="line">          <span class="keyword">return</span> internalCacheDirectory;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (diskCacheName != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> File(cacheDirectory, diskCacheName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheDirectory;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当使用 external storage 的时候，路径为 <code>/sdcard/Android/data/your.package.name/</code>，这里路径所有程序都可以访问。我们自己往里面写东西，也不需要声明权限，在应用被删除后，这个文件夹会被系统一起删除。</p><p>缓存不管是放在 internal storage 还是 external storage，唯一的差异，其实就是存放的路径不同。所以，<code>InternalCacheDiskCacheFactory</code>、<code>ExternalPreferredCacheDiskCacheFactory</code> 都只是用于指定一个路径，实际的 factory 的职责由他们共同的父类 <code>DiskLruCacheFactory</code> 来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@link</span> com.bumptech.glide.disklrucache.DiskLruCache&#125; based disk cache in the specified</span></span><br><span class="line"><span class="comment"> * disk cache directory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If you need to make I/O access before returning the cache directory use the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, long)&#125; constructor variant.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Public API.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskLruCacheFactory</span> <span class="keyword">implements</span> <span class="title">DiskCache</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> diskCacheSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CacheDirectoryGetter cacheDirectoryGetter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Interface called out of UI thread to get the cache folder.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheDirectoryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">File <span class="title">getCacheDirectory</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们可以不使用 InternalCacheDiskCacheFactory、ExternalPreferredCacheDiskCacheFactory</span></span><br><span class="line">  <span class="comment">// 直接通过这个接口构建 DiskLruCacheFactory。通过这种方式，我们可以指定任意的缓存路</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DiskLruCacheFactory</span><span class="params">(<span class="keyword">final</span> String diskCacheFolder, <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> CacheDirectoryGetter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(diskCacheFolder);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DiskLruCacheFactory</span><span class="params">(<span class="keyword">final</span> String diskCacheFolder, <span class="keyword">final</span> String diskCacheName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> CacheDirectoryGetter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(diskCacheFolder, diskCacheName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * When using this constructor &#123;<span class="doctag">@link</span> CacheDirectoryGetter#getCacheDirectory()&#125; will be called out</span></span><br><span class="line"><span class="comment">   * of UI thread, allowing to do I/O access without performance impacts.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> cacheDirectoryGetter Interface called out of UI thread to get the cache folder.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> diskCacheSize        Desired max bytes size for the LRU disk cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// Public API.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DiskLruCacheFactory</span><span class="params">(CacheDirectoryGetter cacheDirectoryGetter, <span class="keyword">long</span> diskCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.diskCacheSize = diskCacheSize;</span><br><span class="line">    <span class="keyword">this</span>.cacheDirectoryGetter = cacheDirectoryGetter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DiskCache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File cacheDir = cacheDirectoryGetter.getCacheDirectory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cacheDir.mkdirs() &amp;&amp; (!cacheDir.exists() || !cacheDir.isDirectory())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 DiskLruCacheWrapper 的工厂方法构造一个 DiskLruCacheWrapper，DiskLruCacheWrapper</span></span><br><span class="line">    <span class="comment">// 是 glide 内建的 DiskCache 实现</span></span><br><span class="line">    <span class="keyword">return</span> DiskLruCacheWrapper.create(cacheDir, diskCacheSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Factory</code> 的实现很简单，到这里我们就看完了。下面我们看看 DiskLruCacheWrapper。</p><h2 id="wrapper-实现"><a href="#wrapper-实现" class="headerlink" title="wrapper 实现"></a>wrapper 实现</h2><p>Glide 的硬盘缓存，实际上上并不是自己实现的，而是使用别人实现好的 disklrucache。在 build.gradle 可以看到：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// library/build.gradle</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    api <span class="keyword">project</span>(<span class="string">':third_party:disklrucache'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于 <code>DiskCache</code> 是 Glide 自动定义的接口，disklrucache 并没有实现它，所以这里我们借助 <code>DiskLruCacheWrapper</code> 来解决接口的问题（设计模式迷此时估计会大喊：adapter 模式!）。</p><h3 id="DiskLruCacheWrapper-的构造"><a href="#DiskLruCacheWrapper-的构造" class="headerlink" title="DiskLruCacheWrapper 的构造"></a>DiskLruCacheWrapper 的构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new DiskCache in the given directory with a specified max size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> directory The directory for the disk cache</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxSize   The max size for the disk cache</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The new disk cache with the given arguments</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskCache <span class="title">create</span><span class="params">(File directory, <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DiskLruCacheWrapper(directory, maxSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> Do not extend this class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="comment">// Deprecated public API.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"WeakerAccess"</span>, <span class="string">"DeprecatedIsStillUsed"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DiskLruCacheWrapper</span><span class="params">(File directory, <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.directory = directory;</span><br><span class="line">  <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">  <span class="keyword">this</span>.safeKeyGenerator = <span class="keyword">new</span> SafeKeyGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SafeKeyGenerator</code> 用于将一个 <code>Key</code> 转换为 <code>String</code> 类型的 key，它跟主干逻辑没有太多关系，这里我们就不看了。</p><h3 id="获取文件"><a href="#获取文件" class="headerlink" title="获取文件"></a>获取文件</h3><p>获取文件由 <code>get(Key)</code> 完成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DiskLruCache diskLruCache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> DiskLruCache <span class="title">getDiskCache</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 懒加载</span></span><br><span class="line">  <span class="comment">// 注意，这里跟 double check 不一样，diskLruCache 并不需要是 volatile。具体原因这里就不展开谈了。</span></span><br><span class="line">  <span class="keyword">if</span> (diskLruCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">    diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> diskLruCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  String safeKey = safeKeyGenerator.getSafeKey(key);</span><br><span class="line">  <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">    Log.v(TAG, <span class="string">"Get: Obtained: "</span> + safeKey + <span class="string">" for for Key: "</span> + key);</span><br><span class="line">  &#125;</span><br><span class="line">  File result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// It is possible that the there will be a put in between these two gets. If so that shouldn't</span></span><br><span class="line">    <span class="comment">// be a problem because we will always put the same value at the same key so our input streams</span></span><br><span class="line">    <span class="comment">// will still represent the same data.</span></span><br><span class="line">    <span class="keyword">final</span> DiskLruCache.Value value = getDiskCache().get(safeKey);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = value.getFile(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">      Log.w(TAG, <span class="string">"Unable to get from disk cache"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DiskCacheWriteLocker writeLocker = <span class="keyword">new</span> DiskCacheWriteLocker();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Writer writer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We want to make sure that puts block so that data is available when put completes. We may</span></span><br><span class="line">  <span class="comment">// actually not write any data if we find that data is written by the time we acquire the lock.</span></span><br><span class="line">  String safeKey = safeKeyGenerator.getSafeKey(key);</span><br><span class="line">  <span class="comment">// 获取针对 safeKey 的锁</span></span><br><span class="line">  writeLocker.acquire(safeKey);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">"Put: Obtained: "</span> + safeKey + <span class="string">" for for Key: "</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// We assume we only need to put once, so if data was written while we were trying to get</span></span><br><span class="line">      <span class="comment">// the lock, we can simply abort.</span></span><br><span class="line">      DiskLruCache diskCache = getDiskCache();</span><br><span class="line">      Value current = diskCache.get(safeKey);</span><br><span class="line">      <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      DiskLruCache.Editor editor = diskCache.edit(safeKey);</span><br><span class="line">      <span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Had two simultaneous puts for: "</span> + safeKey);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = editor.getFile(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (writer.write(file)) &#123;</span><br><span class="line">          editor.commit();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// DiskLruCache 实现了日志系统，写文件作为一个事务来处理</span></span><br><span class="line">        editor.abortUnlessCommitted();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Unable to put to disk cache"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLocker.release(safeKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写文件的时候，不同的文件直接的写并不会相互影响，<code>writeLocker.acquire(safeKey)</code> 中会给每个 key 分配一个锁。关于 <code>DiskCacheWriteLocker</code> 的实现，由于篇幅关系，这里就不看了。</p><h3 id="删除文件、情况缓存"><a href="#删除文件、情况缓存" class="headerlink" title="删除文件、情况缓存"></a>删除文件、情况缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  String safeKey = safeKeyGenerator.getSafeKey(key);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    getDiskCache().remove(safeKey);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">      Log.w(TAG, <span class="string">"Unable to delete from disk cache"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    getDiskCache().delete();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">      Log.w(TAG, <span class="string">"Unable to clear disk cache or disk cache cleared externally"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Delete can close the cache but still throw. If we don't null out the disk cache here, every</span></span><br><span class="line">    <span class="comment">// subsequent request will try to act on a closed disk cache and fail. By nulling out the disk</span></span><br><span class="line">    <span class="comment">// cache we at least allow for attempts to open the cache in the future. See #2465.</span></span><br><span class="line">    resetDiskCache();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">resetDiskCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  diskLruCache = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法是在没有什么值得说的。下面我们接着看 <code>DiskLruCache</code> 的实现。</p><h2 id="DiskLruCache-实现"><a href="#DiskLruCache-实现" class="headerlink" title="DiskLruCache 实现"></a>DiskLruCache 实现</h2><p>在看代码之前，我们先来聊聊为什么需要日志。最简单的情况，我们想要把某个图片缓存起来，由于写硬盘是一个比较耗时的操作，我们把它放到一个后台线程来执行。假设在写文件的过程中，很不幸的，其他某个线程抛出了未捕获的异常，导致程序终止了。这时候，我们刚才想要保存的图片，其实才写了一半。在这种情况下，我们就需要一种机制，可以表明这个文件是损坏了的，在程序下次启动的时候移它。</p><p>为了实现日志（journal）系统，一般的思路是，比方说上面的情况，我们在保存文件的前，先往一个日志文件写入一条日志，说我们马上就要写某某某文件了。写完后，我们再来执行文件保存动作。保存成功后，我们再一次修改日志文件，说我们已经保存成功了。</p><p>这时候，万一我们在保存文件的过程中跪了，程序下次启动的时候，只要检查日志文件，就知道哪些文件是损坏的（最倒霉的情况是，我们保存成功，在修改日志的时候跪了。此时，正常的这个文件也会被清除，但是，对于一个缓存，这又有什么所谓呢）。</p><p>我们先看看 <code>DiskLruCache</code> 里面关于日志文件的一段注释，它对我们理解代码有非常大的帮助：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This cache uses a journal file named &quot;journal&quot;. A typical journal file</span><br><span class="line"> * looks like this:</span><br><span class="line"> *     libcore.io.DiskLruCache</span><br><span class="line"> *     1</span><br><span class="line"> *     100</span><br><span class="line"> *     2</span><br><span class="line"> *</span><br><span class="line"> *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054</span><br><span class="line"> *     DIRTY 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342</span><br><span class="line"> *     REMOVE 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> *     DIRTY 1ab96a171faeeee38496d8b330771a7a</span><br><span class="line"> *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</span><br><span class="line"> *     READ 335c4c6028171cfddfbaae1a9c313c52</span><br><span class="line"> *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</span><br><span class="line"> *</span><br><span class="line"> * The first five lines of the journal form its header. They are the</span><br><span class="line"> * constant string &quot;libcore.io.DiskLruCache&quot;, the disk cache&apos;s version,</span><br><span class="line"> * the application&apos;s version, the value count, and a blank line.</span><br><span class="line"> *</span><br><span class="line"> * Each of the subsequent lines in the file is a record of the state of a</span><br><span class="line"> * cache entry. Each line contains space-separated values: a state, a key,</span><br><span class="line"> * and optional state-specific values.</span><br><span class="line"> *   o DIRTY lines track that an entry is actively being created or updated.</span><br><span class="line"> *     Every successful DIRTY action should be followed by a CLEAN or REMOVE</span><br><span class="line"> *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that</span><br><span class="line"> *     temporary files may need to be deleted.</span><br><span class="line"> *   o CLEAN lines track a cache entry that has been successfully published</span><br><span class="line"> *     and may be read. A publish line is followed by the lengths of each of</span><br><span class="line"> *     its values.</span><br><span class="line"> *   o READ lines track accesses for LRU.</span><br><span class="line"> *   o REMOVE lines track entries that have been deleted.</span><br><span class="line"> *</span><br><span class="line"> * The journal file is appended to as cache operations occur. The journal may</span><br><span class="line"> * occasionally be compacted by dropping redundant lines. A temporary file named</span><br><span class="line"> * &quot;journal.tmp&quot; will be used during compaction; that file should be deleted if</span><br><span class="line"> * it exists when the cache is opened.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><h3 id="DiskLruCache-实例的创建"><a href="#DiskLruCache-实例的创建" class="headerlink" title="DiskLruCache 实例的创建"></a>DiskLruCache 实例的创建</h3><p>上面看 <code>DiskLruCacheWrapper</code> 的时候我们就知道，创建 <code>DiskLruCache</code> 时使用的是它的静态方法 <code>open</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Opens the cache in &#123;<span class="doctag">@code</span> directory&#125;, creating a cache if none exists</span></span><br><span class="line"><span class="comment"> * there.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> directory a writable directory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueCount the number of values per cache entry. Must be positive.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxSize the maximum number of bytes this cache should use to store</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if reading or writing the cache directory fails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"valueCount &lt;= 0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a bkp file exists, use it instead.</span></span><br><span class="line">  File backupFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">  <span class="keyword">if</span> (backupFile.exists()) &#123;</span><br><span class="line">    File journalFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE);</span><br><span class="line">    <span class="comment">// If journal file also exists just delete backup file.</span></span><br><span class="line">    <span class="keyword">if</span> (journalFile.exists()) &#123;</span><br><span class="line">      backupFile.delete();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      renameTo(backupFile, journalFile, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prefer to pick up where we left off.</span></span><br><span class="line">  DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">  <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cache.readJournal();</span><br><span class="line">      cache.processJournal();</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line">      System.out</span><br><span class="line">          .println(<span class="string">"DiskLruCache "</span></span><br><span class="line">              + directory</span><br><span class="line">              + <span class="string">" is corrupt: "</span></span><br><span class="line">              + journalIsCorrupt.getMessage()</span><br><span class="line">              + <span class="string">", removing"</span>);</span><br><span class="line">      cache.delete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new empty cache.</span></span><br><span class="line">  directory.mkdirs();</span><br><span class="line">  cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">  cache.rebuildJournal();</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，跟我们上面讲的差不多，在创建的时候，会读取日志文件，然后做一些清理工作。下面我们先看 <code>readJournal</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  StrictLineReader reader = <span class="keyword">new</span> StrictLineReader(<span class="keyword">new</span> FileInputStream(journalFile), Util.US_ASCII);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String magic = reader.readLine();</span><br><span class="line">    String version = reader.readLine();</span><br><span class="line">    String appVersionString = reader.readLine();</span><br><span class="line">    String valueCountString = reader.readLine();</span><br><span class="line">    String blank = reader.readLine();</span><br><span class="line">    <span class="comment">// 判断一些文件头。关于文件头的格式，在上面那段注释中有说明</span></span><br><span class="line">    <span class="keyword">if</span> (!MAGIC.equals(magic)</span><br><span class="line">        || !VERSION_1.equals(version)</span><br><span class="line">        || !Integer.toString(appVersion).equals(appVersionString)</span><br><span class="line">        || !Integer.toString(valueCount).equals(valueCountString)</span><br><span class="line">        || !<span class="string">""</span>.equals(blank)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal header: ["</span> + magic + <span class="string">", "</span> + version + <span class="string">", "</span></span><br><span class="line">          + valueCountString + <span class="string">", "</span> + blank + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lineCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取并处理一条日志记录</span></span><br><span class="line">        readJournalLine(reader.readLine());</span><br><span class="line">        lineCount++;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (EOFException endOfJournal) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// readJournalLine 会把已经 REMOVE 的 entry 移除掉，多出来的行数是冗余的(redundant)；</span></span><br><span class="line">    <span class="comment">// 并且，一个缓存项也可能对应多行（DIRTY/CLEAN/READ/...)，但其实只需要一个 CLEAN 就够了。</span></span><br><span class="line">    <span class="comment">// 当冗余的行数过多的时候，我们就需要清理日志文件</span></span><br><span class="line">    redundantOpCount = lineCount - lruEntries.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写了一半，应用就跪了</span></span><br><span class="line">    <span class="comment">// If we ended on a truncated line, rebuild the journal before appending to it.</span></span><br><span class="line">    <span class="keyword">if</span> (reader.hasUnterminatedLine()) &#123;</span><br><span class="line">      rebuildJournal();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">          <span class="keyword">new</span> FileOutputStream(journalFile, <span class="keyword">true</span>), Util.US_ASCII));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Util.closeQuietly(reader);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournalLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> firstSpace = line.indexOf(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">if</span> (firstSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> keyBegin = firstSpace + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> secondSpace = line.indexOf(<span class="string">' '</span>, keyBegin);</span><br><span class="line">  <span class="keyword">final</span> String key;</span><br><span class="line">  <span class="keyword">if</span> (secondSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">    key = line.substring(keyBegin);</span><br><span class="line">    <span class="keyword">if</span> (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123;</span><br><span class="line">      <span class="comment">// 每个操作就会记录一个日志信息，当我们删除一个缓存项的时候，添加一个 REMOVE。</span></span><br><span class="line">      <span class="comment">// 既然缓存都已经 remove 掉了，这个 entry 也就就没有存在的必要的了</span></span><br><span class="line">      <span class="comment">// 在 REMOVE 前，一定会有对应的 DIRTY/CLEAN 等，所以此时这个 key 对应的 entry</span></span><br><span class="line">      <span class="comment">// 一定是存在的</span></span><br><span class="line">      lruEntries.remove(key);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    key = line.substring(keyBegin, secondSpace);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 Entry 代表缓存中的一项</span></span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">    lruEntries.put(key, entry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (secondSpace != -<span class="number">1</span> &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</span><br><span class="line">    String[] parts = line.substring(secondSpace + <span class="number">1</span>).split(<span class="string">" "</span>);</span><br><span class="line">    entry.readable = <span class="keyword">true</span>;</span><br><span class="line">    entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">    entry.setLengths(parts);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</span><br><span class="line">    entry.currentEditor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</span><br><span class="line">    <span class="comment">// This work was already done by calling lruEntries.get().</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们再看看 <code>rebuildJournal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new journal that omits redundant information. This replaces the</span></span><br><span class="line"><span class="comment"> * current journal if it exists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">rebuildJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (journalWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    journalWriter.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Writer writer = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">      <span class="comment">// 注意，这里我们写的是 tmp 文件</span></span><br><span class="line">      <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(journalFileTmp), Util.US_ASCII));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    writer.write(MAGIC);</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(VERSION_1);</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(Integer.toString(appVersion));</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(Integer.toString(valueCount));</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        writer.write(DIRTY + <span class="string">' '</span> + entry.key + <span class="string">'\n'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writer.write(CLEAN + <span class="string">' '</span> + entry.key + entry.getLengths() + <span class="string">'\n'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writer.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (journalFile.exists()) &#123;</span><br><span class="line">    renameTo(journalFile, journalFileBackup, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  renameTo(journalFileTmp, journalFile, <span class="keyword">false</span>);</span><br><span class="line">  journalFileBackup.delete();</span><br><span class="line"></span><br><span class="line">  journalWriter = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">      <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(journalFile, <span class="keyword">true</span>), Util.US_ASCII));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">renameTo</span><span class="params">(File from, File to, <span class="keyword">boolean</span> deleteDestination)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (deleteDestination) &#123;</span><br><span class="line">    deleteIfExists(to);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!from.renameTo(to)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，就是先写一个文件头，然后把已有的 entry 一条一条写进去。</p><p>比较有意思的是后面那几个 rename。前面我们说，日志文件是为了在程序崩溃（还有内核崩溃，但这个比较少见）时恢复信息用的。当日志中冗余的行数太多的时候，我们也需要 rebuild 一下。在这里，我们同样需要写文件，万一在 rebuild journal 的时候跪了呢？！</p><p>解决办法就是，原来的日志文件不动，我们先把新的日志写到一个 tmp 文件里，等写完再用一个相对清理的 rename 来替换文件。由于 rename 的时候会删除原文件，这就存在一种可能，我们删除了 journal，而 rename tmp to journal 却失败了。此时，日志就丢失了。</p><p>所以，在把 tmp rename 为 journal 前，我们又把 journal rename 为 backup。在这种情况下，如果第一个 rename 成功，第二个失败，我们就能够通过这个 backup 来恢复原来的日志（在 <code>DiskLruCache</code> 的构造函数中，我们就检查了 backup 是否存在）。接着，如果第二个 rename 成功了，那么 backup 就没用了，于是删掉它。</p><p><code>Entry</code> 的主要代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Lengths of this entry's files. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Memoized File objects for this entry to avoid char[] allocations. */</span></span><br><span class="line">  File[] cleanFiles;</span><br><span class="line">  File[] dirtyFiles;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** True if this entry has ever been published. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> readable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The ongoing edit or null if this entry is not being edited. */</span></span><br><span class="line">  <span class="keyword">private</span> Editor currentEditor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.lengths = <span class="keyword">new</span> <span class="keyword">long</span>[valueCount];</span><br><span class="line">    cleanFiles = <span class="keyword">new</span> File[valueCount];</span><br><span class="line">    dirtyFiles = <span class="keyword">new</span> File[valueCount];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The names are repetitive so re-use the same builder to avoid allocations.</span></span><br><span class="line">    StringBuilder fileBuilder = <span class="keyword">new</span> StringBuilder(key).append(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">int</span> truncateTo = fileBuilder.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">        fileBuilder.append(i);</span><br><span class="line">        cleanFiles[i] = <span class="keyword">new</span> File(directory, fileBuilder.toString());</span><br><span class="line">        fileBuilder.append(<span class="string">".tmp"</span>);</span><br><span class="line">        dirtyFiles[i] = <span class="keyword">new</span> File(directory, fileBuilder.toString());</span><br><span class="line">        fileBuilder.setLength(truncateTo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，对于 entry 中的每个数据项，都有对应 dirty/clean 两个文件。这个也是为了数据的一致性而存在的，后面我们会看到他们的作用。</p><p>读取完日志文件后，<code>DiskLruCache</code> 又调用 <code>processJournal</code> 来处理它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes the initial size and collects garbage as a part of opening the</span></span><br><span class="line"><span class="comment"> * cache. Dirty entries are assumed to be inconsistent and will be deleted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  deleteIfExists(journalFileTmp);</span><br><span class="line">  <span class="keyword">for</span> (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    Entry entry = i.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor == <span class="keyword">null</span>) &#123; <span class="comment">// 这个 entry 处于 CLEAN 状态</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">        <span class="comment">// size 是当前硬盘缓存占用的字节数</span></span><br><span class="line">        size += entry.lengths[t];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// DIRTY，说明上次有人写了一半就跪了。这种情况下，需要删除对应的文件</span></span><br><span class="line">      entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// valueCount 是我们在构造 DiskLruCache 时传递进来的，表示一个 entry 有多少个 value</span></span><br><span class="line">      <span class="comment">// 我们用它来缓存文件，一个 entry 对应一个文件，valueCount == 1</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">        deleteIfExists(entry.getCleanFile(t));</span><br><span class="line">        deleteIfExists(entry.getDirtyFile(t));</span><br><span class="line">      &#125;</span><br><span class="line">      i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，<code>DiskLruCache</code> 就构建完成了。</p><h3 id="写文件到缓存"><a href="#写文件到缓存" class="headerlink" title="写文件到缓存"></a>写文件到缓存</h3><p>我们先来回顾一下 <code>DiskLruCacheWrapper</code> 中是怎么写文件的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Writer writer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  DiskLruCache.Editor editor = diskCache.edit(safeKey);</span><br><span class="line">  <span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Had two simultaneous puts for: "</span> + safeKey);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    File file = editor.getFile(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (writer.write(file)) &#123;</span><br><span class="line">      editor.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    editor.abortUnlessCommitted();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基本上分为 4 步：</p><ol><li>获取一个 editor</li><li>写文件</li><li>commit</li><li>如果失败了，做一些清理工作</li></ol><p>下面我们一个个来看。</p><ol><li>获取一个 editor</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an editor for the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if another</span></span><br><span class="line"><span class="comment"> * edit is in progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> edit(key, ANY_SEQUENCE_NUMBER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Editor <span class="title">edit</span><span class="params">(String key, <span class="keyword">long</span> expectedSequenceNumber)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == <span class="keyword">null</span></span><br><span class="line">      || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Value is stale.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 新建一个缓存</span></span><br><span class="line">    entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">    lruEntries.put(key, entry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Another edit is in progress.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Editor editor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">  entry.currentEditor = editor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush the journal before creating files to prevent file leaks.</span></span><br><span class="line">  journalWriter.append(DIRTY);</span><br><span class="line">  journalWriter.append(<span class="string">' '</span>);</span><br><span class="line">  journalWriter.append(key);</span><br><span class="line">  journalWriter.append(<span class="string">'\n'</span>);</span><br><span class="line">  journalWriter.flush();</span><br><span class="line">  <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里验证了我上面说的，在实际写文件前，先写了一个日志（啊，当然，你也可以说我是先看了代码，才写了上面那段话。如果如果能够做到这个，也是很不错的。学习一个特定的知识点，把它泛化后，你就得到了一个通用的问题解决方案）。</p><ol start="2"><li>写文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = editor.getFile(<span class="number">0</span>);</span><br><span class="line">writer.write(file);</span><br></pre></td></tr></table></figure><p>写文件分两步，或者一个 file，然后 write 进去实际的数据。前面我们提到过，<code>valueCount</code> 代表每个缓存项中的数据数，我们只是存一个文件，所以这个 <code>getFile(0)</code> 获取第一个数据项（也是唯一的一个）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">        written[index] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File dirtyFile = entry.getDirtyFile(index);</span><br><span class="line">    <span class="keyword">if</span> (!directory.exists()) &#123;</span><br><span class="line">        directory.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dirtyFile;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们知道，写入的实际上是 dirty file。</p><ol start="3"><li>commit</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Commits this edit so it is visible to readers.  This releases the</span></span><br><span class="line"><span class="comment"> * edit lock so another edit may be started on the same key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// The object using this Editor must catch and handle any errors</span></span><br><span class="line">  <span class="comment">// during the write. If there is an error and they call commit</span></span><br><span class="line">  <span class="comment">// anyway, we will assume whatever they managed to write was valid.</span></span><br><span class="line">  <span class="comment">// Normally they should call abort.</span></span><br><span class="line">  completeEdit(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">  committed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">completeEdit</span><span class="params">(Editor editor, <span class="keyword">boolean</span> success)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Entry entry = editor.entry;</span><br><span class="line">  <span class="keyword">if</span> (entry.currentEditor != editor) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this edit is creating the entry for the first time, every index must have a value.</span></span><br><span class="line">  <span class="keyword">if</span> (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!editor.written[i]) &#123;</span><br><span class="line">        editor.abort();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Newly created entry didn't create value for index "</span> + i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">        editor.abort();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">    File dirty = entry.getDirtyFile(i);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty.exists()) &#123;</span><br><span class="line">        File clean = entry.getCleanFile(i);</span><br><span class="line">        dirty.renameTo(clean);</span><br><span class="line">        <span class="keyword">long</span> oldLength = entry.lengths[i];</span><br><span class="line">        <span class="keyword">long</span> newLength = clean.length();</span><br><span class="line">        entry.lengths[i] = newLength;</span><br><span class="line">        size = size - oldLength + newLength;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      deleteIfExists(dirty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (entry.readable | success) &#123;</span><br><span class="line">    entry.readable = <span class="keyword">true</span>;</span><br><span class="line">    journalWriter.append(CLEAN);</span><br><span class="line">    journalWriter.append(<span class="string">' '</span>);</span><br><span class="line">    journalWriter.append(entry.key);</span><br><span class="line">    journalWriter.append(entry.getLengths());</span><br><span class="line">    journalWriter.append(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      entry.sequenceNumber = nextSequenceNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 写失败，对应的缓存项也不再有效</span></span><br><span class="line">    lruEntries.remove(entry.key);</span><br><span class="line">    journalWriter.append(REMOVE);</span><br><span class="line">    journalWriter.append(<span class="string">' '</span>);</span><br><span class="line">    journalWriter.append(entry.key);</span><br><span class="line">    journalWriter.append(<span class="string">'\n'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  journalWriter.flush();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用的总空间太多，或者冗余的日志太多</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; maxSize || journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;Void&gt; cleanupCallable = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Closed.</span></span><br><span class="line">      &#125;</span><br><span class="line">      trimToSize();</span><br><span class="line">      <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        rebuildJournal();</span><br><span class="line">        redundantOpCount = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (size &gt; maxSize) &#123;</span><br><span class="line">    Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.entrySet().iterator().next();</span><br><span class="line">    remove(toEvict.getKey());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一需要注意的是，我们必须在 rename dirty to clean 成功后，才能写一个 CLEAN 日志。否则，如果我们写入 CLEAN 成功但 rename 却失败了，就会导致客户读取到错误的缓存数据。</p><ol start="4"><li>如果失败了，做一些清理工作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor.abortUnlessCommitted();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Aborts this edit. This releases the edit lock so another edit may be</span></span><br><span class="line"><span class="comment"> * started on the same key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 传入 false 会导致对应的 entry 被删除</span></span><br><span class="line">  completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abortUnlessCommitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!committed) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      abort();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们再看读文件部分。</p><h3 id="从缓存中读取文件"><a href="#从缓存中读取文件" class="headerlink" title="从缓存中读取文件"></a>从缓存中读取文件</h3><p>还是一样，我们先看看 <code>DiskLruCacheWrapper</code> 中对 <code>DiskLruCache</code> 的调用方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> DiskLruCache.Value value = getDiskCache().get(safeKey);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = value.getFile(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot of the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if it doesn't</span></span><br><span class="line"><span class="comment"> * exist is not currently readable. If a value is returned, it is moved to</span></span><br><span class="line"><span class="comment"> * the head of the LRU queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Value <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (File file : entry.cleanFiles) &#123;</span><br><span class="line">      <span class="comment">// A file must have been deleted manually!</span></span><br><span class="line">      <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  journalWriter.append(READ);</span><br><span class="line">  journalWriter.append(<span class="string">' '</span>);</span><br><span class="line">  journalWriter.append(key);</span><br><span class="line">  journalWriter.append(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Value(key, entry.sequenceNumber, entry.cleanFiles, entry.lengths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较简单，读者自己看一看就好。</p><h3 id="删除一个缓存项"><a href="#删除一个缓存项" class="headerlink" title="删除一个缓存项"></a>删除一个缓存项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Drops the entry for &#123;<span class="doctag">@code</span> key&#125; if it exists and can be removed. Entries</span></span><br><span class="line"><span class="comment"> * actively being edited cannot be removed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if an entry was removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span> || entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">    File file = entry.getCleanFile(i);</span><br><span class="line">    <span class="keyword">if</span> (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"failed to delete "</span> + file);</span><br><span class="line">    &#125;</span><br><span class="line">    size -= entry.lengths[i];</span><br><span class="line">    entry.lengths[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  journalWriter.append(REMOVE);</span><br><span class="line">  journalWriter.append(<span class="string">' '</span>);</span><br><span class="line">  journalWriter.append(key);</span><br><span class="line">  journalWriter.append(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">  lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面其他文件况类似，这里我们需要先删除文件，然后再写日志。这样一来，即便文件删除成功而写日志失败，只要在下次读取时检测文件是否存在就可以了。如果反过来写日志成功但删除文件失败，则会导致缓存文件残留下来。</p><h3 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes the cache and deletes all of its stored values. This will delete</span></span><br><span class="line"><span class="comment"> * all files in the cache directory including files that weren't created by</span></span><br><span class="line"><span class="comment"> * the cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  close();</span><br><span class="line">  <span class="comment">// 所有的缓存文件都放在 directory 里，整个目录删掉就“清空”了</span></span><br><span class="line">  Util.deleteContents(directory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Closes this cache. Stored values will remain on the filesystem. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// Already closed.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Entry entry : <span class="keyword">new</span> ArrayList&lt;Entry&gt;(lruEntries.values())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      entry.currentEditor.abort();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  trimToSize();</span><br><span class="line">  journalWriter.close();</span><br><span class="line">  journalWriter = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不容易啊，到这里，<code>DiskCache</code> 就算是讲完了。</p><hr><h2 id="2018-06-20-补几个面试遇到的问题"><a href="#2018-06-20-补几个面试遇到的问题" class="headerlink" title="2018.06.20 补几个面试遇到的问题"></a>2018.06.20 补几个面试遇到的问题</h2><h3 id="日志文件的作用"><a href="#日志文件的作用" class="headerlink" title="日志文件的作用"></a>日志文件的作用</h3><ol><li>应用崩溃后回收损坏的文件</li><li>日志文件记录了访问的顺序，通过日志文件，我们可以重新建立 LRU</li></ol><h3 id="考虑日志文件对回收损坏文件的作用，不用日志文件能够解决吗？"><a href="#考虑日志文件对回收损坏文件的作用，不用日志文件能够解决吗？" class="headerlink" title="考虑日志文件对回收损坏文件的作用，不用日志文件能够解决吗？"></a>考虑日志文件对回收损坏文件的作用，不用日志文件能够解决吗？</h3><p>不能，因为我们没有办法知道一个文件是否是有效文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个合格的图片加载框架，一般都会有内存缓存和硬盘缓存。在本篇，我们就先来看看 Glide 的硬盘缓存实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Glide" scheme="https://jekton.github.io/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>Android log 机制 - 读取 logd 中的 log 数据</title>
    <link href="https://jekton.github.io/2018/05/25/logd-reading/"/>
    <id>https://jekton.github.io/2018/05/25/logd-reading/</id>
    <published>2018-05-25T05:56:56.000Z</published>
    <updated>2018-08-18T12:47:22.692Z</updated>
    
    <content type="html"><![CDATA[<p>当客户端想要读取 log 数据的时候，可以使用 socket 连接至 <code>/dev/socket/logdr</code>。对应的连接由 <code>LogReader</code> 处理。这里的 reader 是从用户的角度来看的。如果站在 logd 的位置，实际上是把 log 数据写入 socket。为了避免混淆，后文统称“写回数据”。</p><h2 id="LogReader-初始化"><a href="#LogReader-初始化" class="headerlink" title="LogReader 初始化"></a>LogReader 初始化</h2><p>在 <a href="/2018/05/11/logd-overview">logd 总览</a>一篇中，我们知道，<code>LogReader</code> 是在 <code>main</code> 函数里启动的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogReader listens on /dev/socket/logdr. When a client</span></span><br><span class="line">    <span class="comment">// connects, log entries in the LogBuffer are written to the client.</span></span><br><span class="line"></span><br><span class="line">    LogReader* reader = <span class="keyword">new</span> LogReader(logBuf);</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们看看它的构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogReader.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogReader</span> :</span> <span class="keyword">public</span> SocketListener &#123;</span><br><span class="line">    LogBuffer&amp; mLogbuf;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line">LogReader::LogReader(LogBuffer* logbuf)</span><br><span class="line">    : SocketListener(getLogSocket(), <span class="literal">true</span>), mLogbuf(*logbuf) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line"><span class="keyword">int</span> LogReader::getLogSocket() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> socketName[] = <span class="string">"logdr"</span>;</span><br><span class="line">    <span class="keyword">int</span> sock = android_get_control_socket(socketName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sock = socket_local_server(</span><br><span class="line">            socketName, ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_SEQPACKET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和 <code>LogListener</code> 一样，<code>LogReader</code> 也继承了 <code>SocketListener</code>，关于 <code>SocketListener</code>，不熟悉的读者，可以看<a href="/2018/05/16/logd-writing-part1">这篇</a>。</p><h2 id="读取客户请求参数"><a href="#读取客户请求参数" class="headerlink" title="读取客户请求参数"></a>读取客户请求参数</h2><p>当有客户端连接的时候，<code>SocketListener</code> 会回调子类的 <code>onDataAvailable</code> 函数。在这个函数中，<code>LogReader</code> 主要做 3 件事：</p><ol><li>设置线程名</li><li>读取客户端传过来的参数</li><li>生成一个 <code>FlushCommand</code> 用于向客户端写回 log 数据。</li></ol><p>这里我们先看前两个工作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line"><span class="keyword">bool</span> LogReader::onDataAvailable(SocketClient* cli) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> name_set;</span><br><span class="line">    <span class="keyword">if</span> (!name_set) &#123;</span><br><span class="line">        prctl(PR_SET_NAME, <span class="string">"logd.reader"</span>);</span><br><span class="line">        name_set = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = read(cli-&gt;getSocket(), buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        doSocketDelete(cli);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[len] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _tail[] = <span class="string">" tail="</span>;</span><br><span class="line">    <span class="keyword">char</span>* cp = <span class="built_in">strstr</span>(buffer, _tail);</span><br><span class="line">    <span class="keyword">if</span> (cp) &#123;</span><br><span class="line">        tail = atol(cp + <span class="keyword">sizeof</span>(_tail) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">log_time <span class="title">start</span><span class="params">(log_time::EPOCH)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _start[] = <span class="string">" start="</span>;</span><br><span class="line">    cp = <span class="built_in">strstr</span>(buffer, _start);</span><br><span class="line">    <span class="keyword">if</span> (cp) &#123;</span><br><span class="line">        <span class="comment">// Parse errors will result in current time</span></span><br><span class="line">        start.strptime(cp + <span class="keyword">sizeof</span>(_start) - <span class="number">1</span>, <span class="string">"%s.%q"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _timeout[] = <span class="string">" timeout="</span>;</span><br><span class="line">    cp = <span class="built_in">strstr</span>(buffer, _timeout);</span><br><span class="line">    <span class="keyword">if</span> (cp) &#123;</span><br><span class="line">        timeout = atol(cp + <span class="keyword">sizeof</span>(_timeout) - <span class="number">1</span>) * NS_PER_SEC +</span><br><span class="line">                  log_time(CLOCK_REALTIME).nsec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> logMask = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _logIds[] = <span class="string">" lids="</span>;</span><br><span class="line">    cp = <span class="built_in">strstr</span>(buffer, _logIds);</span><br><span class="line">    <span class="keyword">if</span> (cp) &#123;</span><br><span class="line">        logMask = <span class="number">0</span>;</span><br><span class="line">        cp += <span class="keyword">sizeof</span>(_logIds) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*cp &amp;&amp; *cp != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*cp)) &#123;</span><br><span class="line">                val = val * <span class="number">10</span> + *cp - <span class="string">'0'</span>;</span><br><span class="line">                ++cp;</span><br><span class="line">            &#125;</span><br><span class="line">            logMask |= <span class="number">1</span> &lt;&lt; val;</span><br><span class="line">            <span class="keyword">if</span> (*cp != <span class="string">','</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _pid[] = <span class="string">" pid="</span>;</span><br><span class="line">    cp = <span class="built_in">strstr</span>(buffer, _pid);</span><br><span class="line">    <span class="keyword">if</span> (cp) &#123;</span><br><span class="line">        pid = atol(cp + <span class="keyword">sizeof</span>(_pid) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> nonBlock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fastcmp&lt;<span class="built_in">strncmp</span>&gt;(buffer, <span class="string">"dumpAndClose"</span>, <span class="number">12</span>)) &#123;</span><br><span class="line">        <span class="comment">// Allow writer to get some cycles, and wait for pending notifications</span></span><br><span class="line">        sched_yield();</span><br><span class="line">        LogTimeEntry::lock();</span><br><span class="line">        LogTimeEntry::unlock();</span><br><span class="line">        sched_yield();</span><br><span class="line">        nonBlock = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，通信用的是文本协议，主要设置 <code>tail, start, timeout, logMask, pid, 和 nonblock</code>。如果客户没有传递对应的参数，会使用默认值。</p><p>其中，<code>tail</code> 表示读取 log 的最新 <code>tail</code> 条数据；<code>start</code> 是 log 的起始时间；<code>timeout</code> 比较诡异，表示读取 log 前，先睡 <code>timeout</code> 这么一个时长。</p><p>在实际读取 log 前，会先执行下面一个优化措施：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line"><span class="keyword">bool</span> LogReader::onDataAvailable(SocketClient* cli) &#123;</span><br><span class="line">    <span class="comment">// 参数读取部分</span></span><br><span class="line"></span><br><span class="line">    log_time sequence = start;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This somewhat expensive data validation operation is required</span></span><br><span class="line">    <span class="comment">// for non-blocking, with timeout.  The incoming timestamp must be</span></span><br><span class="line">    <span class="comment">// in range of the list, if not, return immediately.  This is</span></span><br><span class="line">    <span class="comment">// used to prevent us from from getting stuck in timeout processing</span></span><br><span class="line">    <span class="comment">// with an invalid time.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Find if time is really present in the logs, monotonic or real, implicit</span></span><br><span class="line">    <span class="comment">// conversion from monotonic or real as necessary to perform the check.</span></span><br><span class="line">    <span class="comment">// Exit in the check loop ASAP as you find a transition from older to</span></span><br><span class="line">    <span class="comment">// newer, but use the last entry found to ensure overlap.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (nonBlock &amp;&amp; (sequence != log_time::EPOCH) &amp;&amp; timeout) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LogFindStart</span> &#123;</span>  <span class="comment">// A lambda by another name</span></span><br><span class="line">           <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">pid_t</span> mPid;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">unsigned</span> mLogMask;</span><br><span class="line">            <span class="keyword">bool</span> mStartTimeSet;</span><br><span class="line">            log_time mStart;</span><br><span class="line">            <span class="comment">// 注意，mSequence 是一个引用</span></span><br><span class="line">            log_time&amp; mSequence;</span><br><span class="line">            log_time mLast;</span><br><span class="line">            <span class="keyword">bool</span> mIsMonotonic;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">public</span>:</span><br><span class="line">            LogFindStart(<span class="keyword">pid_t</span> pid, <span class="keyword">unsigned</span> logMask, log_time&amp; sequence,</span><br><span class="line">                         <span class="keyword">bool</span> isMonotonic)</span><br><span class="line">                : mPid(pid),</span><br><span class="line">                  mLogMask(logMask),</span><br><span class="line">                  mStartTimeSet(<span class="literal">false</span>),</span><br><span class="line">                  mStart(sequence),</span><br><span class="line">                  mSequence(sequence),</span><br><span class="line">                  mLast(sequence),</span><br><span class="line">                  mIsMonotonic(isMonotonic) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> LogBufferElement* element, <span class="keyword">void</span>* obj)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// ojb 就是我们传递给 LogBuffer::flushTo 的第 7 个参数</span></span><br><span class="line">                LogFindStart* me = <span class="keyword">reinterpret_cast</span>&lt;LogFindStart*&gt;(obj);</span><br><span class="line">                <span class="keyword">if</span> ((!me-&gt;mPid || (me-&gt;mPid == element-&gt;getPid())) &amp;&amp;</span><br><span class="line">                    (me-&gt;mLogMask &amp; (<span class="number">1</span> &lt;&lt; element-&gt;getLogId()))) &#123;</span><br><span class="line">                    log_time real = element-&gt;getRealTime();</span><br><span class="line">                    <span class="keyword">if</span> (me-&gt;mStart == real) &#123;</span><br><span class="line">                        me-&gt;mSequence = real;</span><br><span class="line">                        me-&gt;mStartTimeSet = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!me-&gt;mIsMonotonic || android::isMonotonic(real)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (me-&gt;mStart &lt; real) &#123;</span><br><span class="line">                            me-&gt;mSequence = me-&gt;mLast;</span><br><span class="line">                            me-&gt;mStartTimeSet = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        me-&gt;mLast = real;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        me-&gt;mLast = real;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">found</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mStartTimeSet;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; logFindStart(pid, logMask, sequence,</span><br><span class="line">                       logbuf().isMonotonic() &amp;&amp; android::isMonotonic(start));</span><br><span class="line"></span><br><span class="line">        logbuf().flushTo(cli, sequence, <span class="literal">nullptr</span>, FlushCommand::hasReadLogs(cli),</span><br><span class="line">                         FlushCommand::hasSecurityLogs(cli),</span><br><span class="line">                         logFindStart.callback, &amp;logFindStart);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!logFindStart.found()) &#123;</span><br><span class="line">            doSocketDelete(cli);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当 <code>nonBlock &amp;&amp; (sequence != log_time::EPOCH) &amp;&amp; timeout</code> 成立时，这里会先扫描一遍 log 队列，确保有符合条件的 log 项，如果没有，直接关闭 socket 并返回。</p><p>关于 <code>LogBuffer::flushTo</code> 函数，我们后面再仔细看它的实现。</p><p>他的第 6 个参数是一个函数指针，作为过滤器使用：</p><ol><li>如果返回 <code>true</code>，则写入对应的 log 项</li><li>返回 <code>false</code>，跳过 log 项</li><li>返回其他值，则结束迭代</li></ol><p>接下来，生成一个 <code>FlushCommand</code> 实例，开始真正的读取 log 工作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line"><span class="keyword">bool</span> LogReader::onDataAvailable(SocketClient* cli) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function">FlushCommand <span class="title">command</span><span class="params">(*<span class="keyword">this</span>, nonBlock, tail, logMask, pid, sequence, timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set acceptable upper limit to wait for slow reader processing b/27242723</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t</span> = &#123;</span> LOGD_SNDTIMEO, <span class="number">0</span> &#125;;</span><br><span class="line">    setsockopt(cli-&gt;getSocket(), SOL_SOCKET, SO_SNDTIMEO, (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;t,</span><br><span class="line">               <span class="keyword">sizeof</span>(t));</span><br><span class="line"></span><br><span class="line">    command.runSocketCommand(cli);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="启动读-log-线程"><a href="#启动读-log-线程" class="headerlink" title="启动读 log 线程"></a>启动读 log 线程</h2><p><code>FlushCommand</code> 继承了 <code>SocketClientCommand</code>，<code>SocketClientCommand</code> 是 <code>SocketListener</code> 框架的一部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/FlushCommand.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlushCommand</span> :</span> <span class="keyword">public</span> SocketClientCommand &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">runSocketCommand</span><span class="params">(SocketClient* client)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之所以如此，是为了在写入 log 的时候，利用 <code>SocketListener</code> 的“广播”功能。在 <a href="/2018/05/17/logd-writing-part2/">log的写入</a>一篇中我们说过，当写入 log 数据后，由于此时可能有客户端在等待读取数据，所以需要唤醒他们：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogReader.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// When we are notified a new log entry is available, inform</span></span><br><span class="line"><span class="comment">// all of our listening sockets.</span></span><br><span class="line"><span class="keyword">void</span> LogReader::notifyNewLog() &#123;</span><br><span class="line">    <span class="function">FlushCommand <span class="title">command</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    runOnEachSocket(&amp;command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>runOnEachSocket</code> 会对所有的 socket 执行 <code>command-&gt;runSocketCommand(client)</code>。</p><p>就像本节的标题预示的那样，<code>FlushCommand</code> 的实际工作其实是启动读取 log 线程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/FlushCommand.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// runSocketCommand is called once for every open client on the</span></span><br><span class="line"><span class="comment">// log reader socket. Here we manage and associated the reader</span></span><br><span class="line"><span class="comment">// client tracking and log region locks LastLogTimes list of</span></span><br><span class="line"><span class="comment">// LogTimeEntrys, and spawn a transitory per-client thread to</span></span><br><span class="line"><span class="comment">// work at filing data to the  socket.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// global LogTimeEntry::lock() is used to protect access,</span></span><br><span class="line"><span class="comment">// reference counts are used to ensure that individual</span></span><br><span class="line"><span class="comment">// LogTimeEntry lifetime is managed when not protected.</span></span><br><span class="line"><span class="keyword">void</span> FlushCommand::runSocketCommand(SocketClient* client) &#123;</span><br><span class="line">    LogTimeEntry* entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 每个读者都对应 times 列表里的一个元素</span></span><br><span class="line">    LastLogTimes&amp; times = mReader.logbuf().mTimes;</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::lock();</span><br><span class="line">    LastLogTimes::iterator it = times.begin();</span><br><span class="line">    <span class="keyword">while</span> (it != times.end()) &#123;</span><br><span class="line">        entry = (*it);</span><br><span class="line">        <span class="comment">// 遍历列表，找到自己</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;mClient == client) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;mTimeout.tv_sec || entry-&gt;mTimeout.tv_nsec) &#123;</span><br><span class="line">                <span class="comment">// 等 timeout 结束后就会醒来，所以直接 return</span></span><br><span class="line">                <span class="keyword">if</span> (mReader.logbuf().isMonotonic()) &#123;</span><br><span class="line">                    LogTimeEntry::unlock();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If the user changes the time in a gross manner that</span></span><br><span class="line">                <span class="comment">// invalidates the timeout, fall through and trigger.</span></span><br><span class="line">                <span class="function">log_time <span class="title">now</span><span class="params">(CLOCK_REALTIME)</span></span>;</span><br><span class="line">                <span class="comment">// 如果时间被修改，可能会导致 timeout 无效，用当前时间判断 timeout 是否还有效</span></span><br><span class="line">                <span class="comment">// 这里其实是一个bug，mEnd 是创建 entry 时的时间，而后面在使用 mTimeout 的时候，直</span></span><br><span class="line">                <span class="comment">// 接把它传递给了 pthread_cond_timedwait，也就是说， mTimeout 也是一个绝对时间</span></span><br><span class="line">                <span class="keyword">if</span> (((entry-&gt;mEnd + entry-&gt;mTimeout) &gt; now) &amp;&amp;</span><br><span class="line">                    (now &gt; entry-&gt;mEnd)) &#123;</span><br><span class="line">                    LogTimeEntry::unlock();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒读 log 线程</span></span><br><span class="line">            entry-&gt;triggerReader_Locked();</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;runningReader_Locked()) &#123;</span><br><span class="line">                <span class="comment">// 线程已经在运行，直接返回</span></span><br><span class="line">                LogTimeEntry::unlock();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有在创建是 entry 后，创建线程失败才会执行到这些，后面重新尝试启动线程</span></span><br><span class="line">            entry-&gt;incRef_Locked();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it == times.end()) &#123;</span><br><span class="line">        <span class="comment">// Create LogTimeEntry in notifyNewLog() ?</span></span><br><span class="line">        <span class="keyword">if</span> (mTail == (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">            LogTimeEntry::unlock();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        entry = <span class="keyword">new</span> LogTimeEntry(mReader, client, mNonBlock, mTail, mLogMask,</span><br><span class="line">                                 mPid, mStart, mTimeout);</span><br><span class="line">        times.push_front(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client-&gt;incRef();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release client and entry reference counts once done</span></span><br><span class="line">    entry-&gt;startReader_Locked();</span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>entry-&gt;startReader_Locked()</code> 会启动读 log 的线程，从 <code>LogBuffer</code> 读取 log 后写回客户端：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogTimes.cpp</span></span><br><span class="line"><span class="keyword">void</span> LogTimeEntry::startReader_Locked(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    threadRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pthread_attr_init(&amp;attr)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pthread_create(&amp;mThread, &amp;attr, LogTimeEntry::threadStart,</span><br><span class="line">                                <span class="keyword">this</span>)) &#123;</span><br><span class="line">                pthread_attr_destroy(&amp;attr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line">    &#125;</span><br><span class="line">    threadRunning = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mClient) &#123;</span><br><span class="line">        mClient-&gt;decRef();</span><br><span class="line">    &#125;</span><br><span class="line">    decRef_Locked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的逻辑比较简单，读者自己看一看就好。</p><h2 id="log-读取线程"><a href="#log-读取线程" class="headerlink" title="log 读取线程"></a>log 读取线程</h2><p>现在，我们来看看上一节所启动的线程到底做了些什么工作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogTimes.cpp</span></span><br><span class="line"><span class="keyword">void</span>* LogTimeEntry::threadStart(<span class="keyword">void</span>* obj) &#123;</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">"logd.reader.per"</span>);</span><br><span class="line"></span><br><span class="line">    LogTimeEntry* me = <span class="keyword">reinterpret_cast</span>&lt;LogTimeEntry*&gt;(obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个清理函数</span></span><br><span class="line">    pthread_cleanup_push(threadStop, obj);</span><br><span class="line"></span><br><span class="line">    SocketClient* client = me-&gt;mClient;</span><br><span class="line">    <span class="keyword">if</span> (!client) &#123;</span><br><span class="line">        me-&gt;error();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogBuffer&amp; logbuf = me-&gt;mReader.logbuf();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> privileged = FlushCommand::hasReadLogs(client);</span><br><span class="line">    <span class="keyword">bool</span> security = FlushCommand::hasSecurityLogs(client);</span><br><span class="line"></span><br><span class="line">    me-&gt;leadingDropped = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    lock();</span><br><span class="line"></span><br><span class="line">    log_time start = me-&gt;mStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (me-&gt;threadRunning &amp;&amp; !me-&gt;isError_Locked()) &#123;</span><br><span class="line">        <span class="comment">// 如果带 timeout，先睡 timeout 时长，再读 log</span></span><br><span class="line">        <span class="keyword">if</span> (me-&gt;mTimeout.tv_sec || me-&gt;mTimeout.tv_nsec) &#123;</span><br><span class="line">            <span class="comment">// LogBuffer::prune 可能会唤醒它，此时返回值不等于 ETIMEDOUT，下个循环还将继续</span></span><br><span class="line">            <span class="comment">// 等待 timeout 时长</span></span><br><span class="line">            <span class="keyword">if</span> (pthread_cond_timedwait(&amp;me-&gt;threadTriggeredCondition,</span><br><span class="line">                                       &amp;timesLock, &amp;me-&gt;mTimeout) == ETIMEDOUT) &#123;</span><br><span class="line">                <span class="comment">// 清零后，就不再执行这个操作了</span></span><br><span class="line">                me-&gt;mTimeout.tv_sec = <span class="number">0</span>;</span><br><span class="line">                me-&gt;mTimeout.tv_nsec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!me-&gt;threadRunning || me-&gt;isError_Locked()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unlock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mTail 表示读取最新的 mTail 条 log，为了达到这个目的，需要先遍历一遍</span></span><br><span class="line">        <span class="keyword">if</span> (me-&gt;mTail) &#123;</span><br><span class="line">            logbuf.flushTo(client, start, <span class="literal">nullptr</span>, privileged, security,</span><br><span class="line">                           FilterFirstPass, me);</span><br><span class="line">            me-&gt;leadingDropped = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实际的读取 log 操作</span></span><br><span class="line">        start = logbuf.flushTo(client, start, me-&gt;mLastTid, privileged,</span><br><span class="line">                               security, FilterSecondPass, me);</span><br><span class="line"></span><br><span class="line">        lock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果向客户端写回 log 数据失败，将返回 LogBufferElement::FLUSH_ERROR</span></span><br><span class="line">        <span class="keyword">if</span> (start == LogBufferElement::FLUSH_ERROR) &#123;</span><br><span class="line">            me-&gt;error_Locked();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        me-&gt;mStart = start + log_time(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mNonBlock 的情况下，读完当前的 log 后，就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (me-&gt;mNonBlock || !me-&gt;threadRunning || me-&gt;isError_Locked()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip 表示要跳过的 log 条数，我们刚读了所有的 log，skip 已经没有意义了</span></span><br><span class="line">        me-&gt;cleanSkip_Locked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!me-&gt;mTimeout.tv_sec &amp;&amp; !me-&gt;mTimeout.tv_nsec) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;me-&gt;threadTriggeredCondition, &amp;timesLock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行清理函数 threadStop </span></span><br><span class="line">    pthread_cleanup_pop(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们假定 <code>mTail != 0</code>，这个时候会执行两次遍历操作。第一次遍历的回调函数如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogTimes.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A first pass to count the number of elements</span></span><br><span class="line"><span class="keyword">int</span> LogTimeEntry::FilterFirstPass(<span class="keyword">const</span> LogBufferElement* element, <span class="keyword">void</span>* obj) &#123;</span><br><span class="line">    LogTimeEntry* me = <span class="keyword">reinterpret_cast</span>&lt;LogTimeEntry*&gt;(obj);</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;leadingDropped) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element-&gt;getDropped()) &#123;</span><br><span class="line">            LogTimeEntry::unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        me-&gt;leadingDropped = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;mCount == <span class="number">0</span>) &#123;</span><br><span class="line">        me-&gt;mStart = element-&gt;getRealTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((!me-&gt;mPid || (me-&gt;mPid == element-&gt;getPid())) &amp;&amp;</span><br><span class="line">        (me-&gt;isWatching(element-&gt;getLogId()))) &#123;</span><br><span class="line">        ++me-&gt;mCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就跟函数的注释说的，这里就是计算所有复合条件的 log 的数目。</p><p>下面我们看第二个：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogTimes.cpp</span></span><br><span class="line"><span class="comment">// A second pass to send the selected elements</span></span><br><span class="line"><span class="keyword">int</span> LogTimeEntry::FilterSecondPass(<span class="keyword">const</span> LogBufferElement* element, <span class="keyword">void</span>* obj) &#123;</span><br><span class="line">    LogTimeEntry* me = <span class="keyword">reinterpret_cast</span>&lt;LogTimeEntry*&gt;(obj);</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::lock();</span><br><span class="line"></span><br><span class="line">    me-&gt;mStart = element-&gt;getRealTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip 是在 LogBuffer::prune 里设置的，快速跳过对应的 log 项后，prune 就能够把他们</span></span><br><span class="line">    <span class="comment">// 释放掉了</span></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;skipAhead[element-&gt;getLogId()]) &#123;</span><br><span class="line">        me-&gt;skipAhead[element-&gt;getLogId()]--;</span><br><span class="line">        <span class="keyword">goto</span> skip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leading drop 其实是空的 log 项</span></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;leadingDropped) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element-&gt;getDropped()) &#123;</span><br><span class="line">            <span class="keyword">goto</span> skip;</span><br><span class="line">        &#125;</span><br><span class="line">        me-&gt;leadingDropped = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Truncate to close race between first and second pass</span></span><br><span class="line">    <span class="comment">// 总共只有 mCount 条 log，mIndex &gt;= mCount 表示已经没有更多的 log 了</span></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;mNonBlock &amp;&amp; me-&gt;mTail &amp;&amp; (me-&gt;mIndex &gt;= me-&gt;mCount)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> stop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!me-&gt;isWatching(element-&gt;getLogId())) &#123;</span><br><span class="line">        <span class="keyword">goto</span> skip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;mPid &amp;&amp; (me-&gt;mPid != element-&gt;getPid())) &#123;</span><br><span class="line">        <span class="keyword">goto</span> skip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;isError_Locked()) &#123;</span><br><span class="line">        <span class="keyword">goto</span> stop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!me-&gt;mTail) &#123;</span><br><span class="line">        <span class="keyword">goto</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++me-&gt;mIndex;</span><br><span class="line">    <span class="comment">// 我们只需要读取 mTail 条 log，所以忽略前面的 mCount - mTail 条 log</span></span><br><span class="line">    <span class="keyword">if</span> ((me-&gt;mCount &gt; me-&gt;mTail) &amp;&amp; (me-&gt;mIndex &lt;= (me-&gt;mCount - me-&gt;mTail))) &#123;</span><br><span class="line">        <span class="keyword">goto</span> skip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!me-&gt;mNonBlock) &#123;</span><br><span class="line">        me-&gt;mTail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">    <span class="keyword">if</span> (!me-&gt;skipAhead[element-&gt;getLogId()]) &#123;</span><br><span class="line">        LogTimeEntry::unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// FALLTHRU</span></span><br><span class="line"></span><br><span class="line">skip:</span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线程清理函数比较简单，就不看了。</p><h2 id="读取-log"><a href="#读取-log" class="headerlink" title="读取 log"></a>读取 log</h2><p>现在，是时候看看那个神秘的 <code>LogBuffer::flushTo</code> 了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line">log_time LogBuffer::flushTo(SocketClient* reader, <span class="keyword">const</span> log_time&amp; start,</span><br><span class="line">                            <span class="keyword">pid_t</span>* lastTid, <span class="keyword">bool</span> privileged, <span class="keyword">bool</span> security,</span><br><span class="line">                            <span class="keyword">int</span> (*filter)(<span class="keyword">const</span> LogBufferElement* element,</span><br><span class="line">                                          <span class="keyword">void</span>* arg),</span><br><span class="line">                            <span class="keyword">void</span>* arg) &#123;</span><br><span class="line">    LogBufferElementCollection::iterator it;</span><br><span class="line">    <span class="keyword">uid_t</span> uid = reader-&gt;getUid();</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mLogElementsLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 start 参数找到开始迭代的地方</span></span><br><span class="line">    <span class="keyword">if</span> (start == log_time::EPOCH) &#123;</span><br><span class="line">        <span class="comment">// client wants to start from the beginning</span></span><br><span class="line">        it = mLogElements.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3 second limit to continue search for out-of-order entries.</span></span><br><span class="line">        log_time min = start - pruneMargin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cap to 300 iterations we look back for out-of-order entries.</span></span><br><span class="line">        <span class="keyword">size_t</span> count = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Client wants to start from some specified time. Chances are</span></span><br><span class="line">        <span class="comment">// we are better off starting from the end of the time sorted list.</span></span><br><span class="line">        LogBufferElementCollection::iterator last;</span><br><span class="line">        <span class="keyword">for</span> (last = it = mLogElements.end(); it != mLogElements.begin();</span><br><span class="line">             <span class="comment">/* do nothing */</span>) &#123;</span><br><span class="line">            --it;</span><br><span class="line">            LogBufferElement* element = *it;</span><br><span class="line">            <span class="keyword">if</span> (element-&gt;getRealTime() &gt; start) &#123;</span><br><span class="line">                last = it;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!--count || (element-&gt;getRealTime() &lt; min)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_time max = start;</span><br><span class="line"></span><br><span class="line">    LogBufferElement* lastElement = <span class="literal">nullptr</span>;  <span class="comment">// iterator corruption paranoia</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxSkip = <span class="number">4194304</span>;    <span class="comment">// maximum entries to skip</span></span><br><span class="line">    <span class="keyword">size_t</span> skip = maxSkip;</span><br><span class="line">    <span class="keyword">for</span> (; it != mLogElements.end(); ++it) &#123;</span><br><span class="line">        LogBufferElement* element = *it;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!--skip) &#123;</span><br><span class="line">            android::prdebug(<span class="string">"reader.per: too many elements skipped"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (element == lastElement) &#123;</span><br><span class="line">            android::prdebug(<span class="string">"reader.per: identical elements"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastElement = element;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!privileged &amp;&amp; (element-&gt;getUid() != uid)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!security &amp;&amp; (element-&gt;getLogId() == LOG_ID_SECURITY)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (element-&gt;getRealTime() &lt;= start) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// filter 就是我们前面多次传递进来的函数</span></span><br><span class="line">        <span class="comment">// 1. 返回 true 表示写回该 log 项</span></span><br><span class="line">        <span class="comment">// 2. false 表示忽略</span></span><br><span class="line">        <span class="comment">// 3. 其他值则结束迭代</span></span><br><span class="line">        <span class="comment">// NB: calling out to another object with mLogElementsLock held (safe)</span></span><br><span class="line">        <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = (*filter)(element, arg);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> sameTid = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (lastTid) &#123;</span><br><span class="line">            sameTid = lastTid[element-&gt;getLogId()] == element-&gt;getTid();</span><br><span class="line">            <span class="comment">// Dropped (chatty) immediately following a valid log from the</span></span><br><span class="line">            <span class="comment">// same source in the same log buffer indicates we have a</span></span><br><span class="line">            <span class="comment">// multiple identical squash.  chatty that differs source</span></span><br><span class="line">            <span class="comment">// is due to spam filter.  chatty to chatty of different</span></span><br><span class="line">            <span class="comment">// source is also due to spam filter.</span></span><br><span class="line">            lastTid[element-&gt;getLogId()] =</span><br><span class="line">                (element-&gt;getDropped() &amp;&amp; !sameTid) ? <span class="number">0</span> : element-&gt;getTid();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里把单个 log 项的数据写回客户端</span></span><br><span class="line">        <span class="comment">// range locking in LastLogTimes looks after us</span></span><br><span class="line">        max = element-&gt;flushTo(reader, <span class="keyword">this</span>, privileged, sameTid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (max == element-&gt;FLUSH_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skip = maxSkip;</span><br><span class="line">        pthread_mutex_lock(&amp;mLogElementsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们看看 <code>LogBufferElement::flushTo</code> 函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBufferElement.cpp</span></span><br><span class="line">log_time LogBufferElement::flushTo(SocketClient* reader, LogBuffer* parent,</span><br><span class="line">                                   <span class="keyword">bool</span> privileged, <span class="keyword">bool</span> lastSame) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">logger_entry_v4</span> <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;entry, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct logger_entry_v4));</span><br><span class="line"></span><br><span class="line">    entry.hdr_size = privileged ? <span class="keyword">sizeof</span>(struct logger_entry_v4)</span><br><span class="line">                                : <span class="keyword">sizeof</span>(struct logger_entry_v3);</span><br><span class="line">    entry.lid = mLogId;</span><br><span class="line">    entry.pid = mPid;</span><br><span class="line">    entry.tid = mTid;</span><br><span class="line">    entry.uid = mUid;</span><br><span class="line">    entry.sec = mRealTime.tv_sec;</span><br><span class="line">    entry.nsec = mRealTime.tv_nsec;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec</span>[2];</span></span><br><span class="line">    iovec[<span class="number">0</span>].iov_base = &amp;entry;</span><br><span class="line">    iovec[<span class="number">0</span>].iov_len = entry.hdr_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mMsg) &#123;</span><br><span class="line">        entry.len = populateDroppedMessage(buffer, parent, lastSame);</span><br><span class="line">        <span class="keyword">if</span> (!entry.len) <span class="keyword">return</span> mRealTime;</span><br><span class="line">        iovec[<span class="number">1</span>].iov_base = buffer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry.len = mMsgLen;</span><br><span class="line">        iovec[<span class="number">1</span>].iov_base = mMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    iovec[<span class="number">1</span>].iov_len = entry.len;</span><br><span class="line"></span><br><span class="line">    log_time retval = reader-&gt;sendDatav(iovec, <span class="number">1</span> + (entry.len != <span class="number">0</span>))</span><br><span class="line">                          ? FLUSH_ERROR</span><br><span class="line">                          : mRealTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer) <span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于我们需要将多个缓冲的数据写回客户端，这里使用是是 <code>writev</code>。实际的数据写入在 <code>SocketClient</code> 中实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libsysutils/src/SocketClient.cpp</span></span><br><span class="line"><span class="keyword">int</span> SocketClient::sendDatav(struct iovec *iov, <span class="keyword">int</span> iovcnt) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mWriteMutex);</span><br><span class="line">    <span class="keyword">int</span> rc = sendDataLockedv(iov, iovcnt);</span><br><span class="line">    pthread_mutex_unlock(&amp;mWriteMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SocketClient::sendDataLockedv(struct iovec *iov, <span class="keyword">int</span> iovcnt) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSocket &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errno = EHOSTUNREACH;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iovcnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>; <span class="comment">// SLOGW and sigaction are not inert regarding errno</span></span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当向一个写入端已经被关闭的 socket 写入数据的时候，内核会发送 SIGPIPE，</span></span><br><span class="line">    <span class="comment">// 默认的行为是结束进程。这里我们要忽略它</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">new_action</span>, <span class="title">old_action</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;new_action, <span class="number">0</span>, <span class="keyword">sizeof</span>(new_action));</span><br><span class="line">    new_action.sa_handler = SIG_IGN;</span><br><span class="line">    sigaction(SIGPIPE, &amp;new_action, &amp;old_action);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> rc = TEMP_FAILURE_RETRY(</span><br><span class="line">            writev(mSocket, iov + current, iovcnt - current));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> written = rc;</span><br><span class="line">            <span class="comment">// 可能只是部分写入了数据。逐个检查那些已经写入成功的 iov</span></span><br><span class="line">            <span class="keyword">while</span> ((current &lt; iovcnt) &amp;&amp; (written &gt;= iov[current].iov_len)) &#123;</span><br><span class="line">                written -= iov[current].iov_len;</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current == iovcnt) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这个 iov 有部分数据已经写入</span></span><br><span class="line">            iov[current].iov_base = (<span class="keyword">char</span> *)iov[current].iov_base + written;</span><br><span class="line">            iov[current].iov_len -= written;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            e = EIO;</span><br><span class="line">            SLOGW(<span class="string">"0 length write :("</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            e = errno;</span><br><span class="line">            SLOGW(<span class="string">"write error (%s)"</span>, strerror(e));</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGPIPE, &amp;old_action, &amp;new_action);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="number">0</span>) &#123;</span><br><span class="line">        errno = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，恭喜你，log 数据的读取到这里就结束了。</p><p><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当客户端想要读取 log 数据的时候，可以使用 socket 连接至 &lt;code&gt;/dev/socket/logdr&lt;/code&gt;。对应的连接由 &lt;code&gt;LogReader&lt;/code&gt; 处理。这里的 reader 是从用户的角度来看的。如果站在 logd 的位置，实际
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
      <category term="logd" scheme="https://jekton.github.io/tags/logd/"/>
    
  </entry>
  
  <entry>
    <title>Android log 机制 - 删除过多的 log</title>
    <link href="https://jekton.github.io/2018/05/17/logd-prune/"/>
    <id>https://jekton.github.io/2018/05/17/logd-prune/</id>
    <published>2018-05-17T06:09:46.000Z</published>
    <updated>2018-08-18T12:47:22.692Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，每种 log 数据类型都有一个总量限制，如果超过了这个限制，为了腾出空间，就需要删除一些旧数据。这个删除旧数据的功能，便是 <code>LogBuffer::prune</code> 来完成的。</p><a id="more"></a><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>由写入 log 触发的 log 删除动作，是在 <code>maybePrune</code> 函数发起的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="keyword">void</span> LogBuffer::maybePrune(<span class="keyword">log_id_t</span> id) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    prune(id, pruneRows);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogBuffer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">prune</span><span class="params">(<span class="keyword">log_id_t</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> pruneRows, <span class="keyword">uid_t</span> uid = AID_ROOT)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// prune "pruneRows" of type "id" from the buffer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This garbage collection task is used to expire log entries. It is called to</span></span><br><span class="line"><span class="comment">// remove all logs (clear), all UID logs (unprivileged clear), or every</span></span><br><span class="line"><span class="comment">// 256 or 10% of the total logs (whichever is less) to prune the logs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// First there is a prep phase where we discover the reader region lock that</span></span><br><span class="line"><span class="comment">// acts as a backstop to any pruning activity to stop there and go no further.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// There are three major pruning loops that follow. All expire from the oldest</span></span><br><span class="line"><span class="comment">// entries. Since there are multiple log buffers, the Android logging facility</span></span><br><span class="line"><span class="comment">// will appear to drop entries 'in the middle' when looking at multiple log</span></span><br><span class="line"><span class="comment">// sources and buffers. This effect is slightly more prominent when we prune</span></span><br><span class="line"><span class="comment">// the worst offender by logging source. Thus the logs slowly loose content</span></span><br><span class="line"><span class="comment">// and value as you move back in time. This is preferred since chatty sources</span></span><br><span class="line"><span class="comment">// invariably move the logs value down faster as less chatty sources would be</span></span><br><span class="line"><span class="comment">// expired in the noise.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The first loop performs blacklisting and worst offender pruning. Falling</span></span><br><span class="line"><span class="comment">// through when there are no notable worst offenders and have not hit the</span></span><br><span class="line"><span class="comment">// region lock preventing further worst offender pruning. This loop also looks</span></span><br><span class="line"><span class="comment">// after managing the chatty log entries and merging to help provide</span></span><br><span class="line"><span class="comment">// statistical basis for blame. The chatty entries are not a notification of</span></span><br><span class="line"><span class="comment">// how much logs you may have, but instead represent how much logs you would</span></span><br><span class="line"><span class="comment">// have had in a virtual log buffer that is extended to cover all the in-memory</span></span><br><span class="line"><span class="comment">// logs without loss. They last much longer than the represented pruned logs</span></span><br><span class="line"><span class="comment">// since they get multiplied by the gains in the non-chatty log sources.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The second loop get complicated because an algorithm of watermarks and</span></span><br><span class="line"><span class="comment">// history is maintained to reduce the order and keep processing time</span></span><br><span class="line"><span class="comment">// down to a minimum at scale. These algorithms can be costly in the face</span></span><br><span class="line"><span class="comment">// of larger log buffers, or severly limited processing time granted to a</span></span><br><span class="line"><span class="comment">// background task at lowest priority.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This second loop does straight-up expiration from the end of the logs</span></span><br><span class="line"><span class="comment">// (again, remember for the specified log buffer id) but does some whitelist</span></span><br><span class="line"><span class="comment">// preservation. Thus whitelist is a Hail Mary low priority, blacklists and</span></span><br><span class="line"><span class="comment">// spam filtration all take priority. This second loop also checks if a region</span></span><br><span class="line"><span class="comment">// lock is causing us to buffer too much in the logs to help the reader(s),</span></span><br><span class="line"><span class="comment">// and will tell the slowest reader thread to skip log entries, and if</span></span><br><span class="line"><span class="comment">// persistent and hits a further threshold, kill the reader thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The third thread is optional, and only gets hit if there was a whitelist</span></span><br><span class="line"><span class="comment">// and more needs to be pruned against the backstop of the region lock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mLogElementsLock must be held when this function is called.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">bool</span> LogBuffer::prune(<span class="keyword">log_id_t</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> pruneRows, <span class="keyword">uid_t</span> caller_uid) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>maybePrune</code> 调用它的时候，<code>caller_uid</code> 用的是默认的参数，<code>caller_uid == AID_ROOT</code>。</p><p>函数的注释有点长，有兴趣的看一看，没兴趣的读者直接略过就好。</p><h2 id="实际的删除工作"><a href="#实际的删除工作" class="headerlink" title="实际的删除工作"></a>实际的删除工作</h2><p><code>prune</code> 函数比较复杂（也很长，有好几百行），他主要完成下面几件事：</p><ol><li>计算一个 <code>watermark</code>，表示所有客户正在读取的最早的log。时间小于 <code>watermark</code> 的 log 都不能删除</li><li>如果是客户请求删除 log，删除对应 uid 的 log</li><li>删除黑名单里的 log</li><li>如果已删除的条数还不够，删除不在白名单里的 log</li><li>如果已删除的条数还不够，删除白名单里的 log</li></ol><p>下面我们一步一步来看。</p><h3 id="1-计算-watermark"><a href="#1-计算-watermark" class="headerlink" title="1. 计算 watermark"></a>1. 计算 <code>watermark</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="keyword">const</span> log_time LogBuffer::pruneMargin(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> LogBuffer::prune(<span class="keyword">log_id_t</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> pruneRows, <span class="keyword">uid_t</span> caller_uid) &#123;</span><br><span class="line">    LogTimeEntry* oldest = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">bool</span> busy = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> clearAll = pruneRows == ULONG_MAX;</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Region locked?</span></span><br><span class="line">    LastLogTimes::iterator times = mTimes.begin();</span><br><span class="line">    <span class="keyword">while</span> (times != mTimes.end()) &#123;</span><br><span class="line">        LogTimeEntry* entry = (*times);</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;owned_Locked() &amp;&amp; entry-&gt;isWatching(id) &amp;&amp;</span><br><span class="line">            (!oldest || (oldest-&gt;mStart &gt; entry-&gt;mStart) ||</span><br><span class="line">             <span class="comment">// 对于带 timeout 的客户端，我们需要唤醒他们，所以时间相等的情况下，他们更优先</span></span><br><span class="line">             ((oldest-&gt;mStart == entry-&gt;mStart) &amp;&amp;</span><br><span class="line">              (entry-&gt;mTimeout.tv_sec || entry-&gt;mTimeout.tv_nsec)))) &#123;</span><br><span class="line">            oldest = entry;</span><br><span class="line">        &#125;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">log_time <span class="title">watermark</span><span class="params">(log_time::tv_sec_max, log_time::tv_nsec_max)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (oldest) watermark = oldest-&gt;mStart - pruneMargin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分比较简单，就是找到所有正在读取 log 的客户端里面 <code>mStart</code> 最老的那个（mStart 值最小）。然后，在 <code>mStart</code> 的基础上减多 <code>pruneMargin</code>。</p><p>由于很快会有客户读取，log 时间大于 <code>watermark</code> 的那部分不能删除。</p><h3 id="2-如果是客户请求删除-log，删除对应-uid-的-log"><a href="#2-如果是客户请求删除-log，删除对应-uid-的-log" class="headerlink" title="2. 如果是客户请求删除 log，删除对应 uid 的 log"></a>2. 如果是客户请求删除 log，删除对应 uid 的 log</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="keyword">bool</span> LogBuffer::prune(<span class="keyword">log_id_t</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> pruneRows, <span class="keyword">uid_t</span> caller_uid) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    LogBufferElementCollection::iterator it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__predict_false(caller_uid != AID_ROOT)) &#123;  <span class="comment">// unlikely</span></span><br><span class="line">        <span class="comment">// Only here if clear all request from non system source, so chatty</span></span><br><span class="line">        <span class="comment">// filter logistics is not required.</span></span><br><span class="line">        it = mLastSet[id] ? mLast[id] : mLogElements.begin();</span><br><span class="line">        <span class="keyword">while</span> (it != mLogElements.end()) &#123;</span><br><span class="line">            LogBufferElement* element = *it;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 我们只删除目标 log-id 和 uid == caller_uid 的 log</span></span><br><span class="line">            <span class="keyword">if</span> ((element-&gt;getLogId() != id) ||</span><br><span class="line">                (element-&gt;getUid() != caller_uid)) &#123;</span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mLastSet[id] || ((*mLast[id])-&gt;getLogId() != id)) &#123;</span><br><span class="line">                mLast[id] = it;</span><br><span class="line">                mLastSet[id] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只有在 oldest 不等于 nullptr 时 watermark 才有效</span></span><br><span class="line">            <span class="comment">// 如果当前的条目的时间已经超过了 watermark，就不能再继续删除了</span></span><br><span class="line">            <span class="keyword">if</span> (oldest &amp;&amp; (watermark &lt;= element-&gt;getRealTime())) &#123;</span><br><span class="line">                busy = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 带 timeout 的客户此时可能正在睡眠，唤醒他</span></span><br><span class="line">                <span class="keyword">if</span> (oldest-&gt;mTimeout.tv_sec || oldest-&gt;mTimeout.tv_nsec) &#123;</span><br><span class="line">                    oldest-&gt;triggerReader_Locked();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不带 timeout，让它跳过 pruneRows 条记录</span></span><br><span class="line">                    oldest-&gt;triggerSkip_Locked(id, pruneRows);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it = erase(it);</span><br><span class="line">            <span class="comment">// 如果删除了足够的条数，就可以停止了</span></span><br><span class="line">            <span class="keyword">if</span> (--pruneRows == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LogTimeEntry::unlock();</span><br><span class="line">        <span class="keyword">return</span> busy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在我们分析的情景里这个 <code>if</code> 语句并不会执行，但这部分比较简单，还是看看吧。</p><h3 id="3-删除黑名单或打了最多-log-的“用户”的-log-数据"><a href="#3-删除黑名单或打了最多-log-的“用户”的-log-数据" class="headerlink" title="3. 删除黑名单或打了最多 log 的“用户”的 log 数据"></a>3. 删除黑名单或打了最多 log 的“用户”的 log 数据</h3><p>在计算那些写 log 最多的“用户”时，这个用户可能是真正的用户，也可能是 system 用户的某个进程；或者是 event 类型的 log 的某个 tag。为了方便，以下统称“用户”，并加上引号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="keyword">bool</span> LogBuffer::prune(<span class="keyword">log_id_t</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> pruneRows, <span class="keyword">uid_t</span> caller_uid) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// prune by worst offenders; by blacklist, UID, and by PID of system UID</span></span><br><span class="line">    <span class="keyword">bool</span> hasBlacklist = (id != LOG_ID_SECURITY) &amp;&amp; mPrune.naughty();</span><br><span class="line">    <span class="keyword">while</span> (!clearAll &amp;&amp; (pruneRows &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// recalculate the worst offender on every batched pass</span></span><br><span class="line">        <span class="keyword">int</span> worst = <span class="number">-1</span>;  <span class="comment">// not valid for getUid() or getKey()</span></span><br><span class="line">        <span class="keyword">size_t</span> worst_sizes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> second_worst_sizes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">pid_t</span> worstPid = <span class="number">0</span>;  <span class="comment">// POSIX guarantees PID != 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (worstUidEnabledForLogid(id) &amp;&amp; mPrune.worstUidEnabled()) &#123;</span><br><span class="line">            <span class="comment">// Calculate threshold as 12.5% of available storage</span></span><br><span class="line">            <span class="keyword">size_t</span> threshold = log_buffer_size(id) / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((id == LOG_ID_EVENTS) || (id == LOG_ID_SECURITY)) &#123;</span><br><span class="line">                <span class="comment">// 按照 tag 来区分，选出写入 log 数据最多的 tag</span></span><br><span class="line">                <span class="comment">// 对应 tag 的总数据必须大于 threshold</span></span><br><span class="line">                stats.sortTags(AID_ROOT, (<span class="keyword">pid_t</span>)<span class="number">0</span>, <span class="number">2</span>, id)</span><br><span class="line">                    .findWorst(worst, worst_sizes, second_worst_sizes,</span><br><span class="line">                               threshold);</span><br><span class="line">                <span class="comment">// per-pid filter for AID_SYSTEM sources is too complex</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 按照 uid 来区分，选出写入 log 数据最多的用户</span></span><br><span class="line">                stats.sort(AID_ROOT, (<span class="keyword">pid_t</span>)<span class="number">0</span>, <span class="number">2</span>, id)</span><br><span class="line">                    .findWorst(worst, worst_sizes, second_worst_sizes,</span><br><span class="line">                               threshold);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// system 用户对应着多个应用，需求根据 pid 再找一遍</span></span><br><span class="line">                <span class="keyword">if</span> ((worst == AID_SYSTEM) &amp;&amp; mPrune.worstPidOfSystemEnabled()) &#123;</span><br><span class="line">                    stats.sortPids(worst, (<span class="keyword">pid_t</span>)<span class="number">0</span>, <span class="number">2</span>, id)</span><br><span class="line">                        .findWorst(worstPid, worst_sizes, second_worst_sizes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip if we have neither worst nor naughty filters</span></span><br><span class="line">        <span class="keyword">if</span> ((worst == <span class="number">-1</span>) &amp;&amp; !hasBlacklist) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> kick = <span class="literal">false</span>;     <span class="comment">// 表示是否“踢掉”了 log 最多的那个“用户”的某个 log</span></span><br><span class="line">        <span class="keyword">bool</span> leading = <span class="literal">true</span>;   <span class="comment">// 当前是否在 log 列表的开头</span></span><br><span class="line">        it = mLastSet[id] ? mLast[id] : mLogElements.begin();</span><br><span class="line">        <span class="comment">// Perform at least one mandatory garbage collection cycle in following</span></span><br><span class="line">        <span class="comment">// - clear leading chatty tags</span></span><br><span class="line">        <span class="comment">// - coalesce chatty tags</span></span><br><span class="line">        <span class="comment">// - check age-out of preserved logs</span></span><br><span class="line">        <span class="keyword">bool</span> gc = pruneRows &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!gc &amp;&amp; (worst != <span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果这个 worst 不是初犯，那我们从上次删除结束的地方继续开始就好</span></span><br><span class="line">            &#123;  <span class="comment">// begin scope for worst found iterator</span></span><br><span class="line">                LogBufferIteratorMap::iterator found =</span><br><span class="line">                    mLastWorst[id].find(worst);</span><br><span class="line">                <span class="keyword">if</span> ((found != mLastWorst[id].end()) &amp;&amp;</span><br><span class="line">                    (found-&gt;second != mLogElements.end())) &#123;</span><br><span class="line">                    leading = <span class="literal">false</span>;</span><br><span class="line">                    it = found-&gt;second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (worstPid) &#123;  <span class="comment">// begin scope for pid worst found iterator</span></span><br><span class="line">                <span class="comment">// FYI: worstPid only set if !LOG_ID_EVENTS and</span></span><br><span class="line">                <span class="comment">//      !LOG_ID_SECURITY, not going to make that assumption ...</span></span><br><span class="line">                LogBufferPidIteratorMap::iterator found =</span><br><span class="line">                    mLastWorstPidOfSystem[id].find(worstPid);</span><br><span class="line">                <span class="keyword">if</span> ((found != mLastWorstPidOfSystem[id].end()) &amp;&amp;</span><br><span class="line">                    (found-&gt;second != mLogElements.end())) &#123;</span><br><span class="line">                    leading = <span class="literal">false</span>;</span><br><span class="line">                    it = found-&gt;second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> timespec too_old = &#123; EXPIRE_HOUR_THRESHOLD * <span class="number">60</span> * <span class="number">60</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        LogBufferElementCollection::iterator lastt;</span><br><span class="line">        lastt = mLogElements.end();</span><br><span class="line">        --lastt;</span><br><span class="line">        LogBufferElementLast last;</span><br><span class="line">        <span class="keyword">while</span> (it != mLogElements.end()) &#123;</span><br><span class="line">            LogBufferElement* element = *it;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前的 log 已经超过了 watermark，不应该继续删除 log</span></span><br><span class="line">            <span class="keyword">if</span> (oldest &amp;&amp; (watermark &lt;= element-&gt;getRealTime())) &#123;</span><br><span class="line">                busy = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 和上面一样，唤醒带 timeout 的客户端</span></span><br><span class="line">                <span class="keyword">if</span> (oldest-&gt;mTimeout.tv_sec || oldest-&gt;mTimeout.tv_nsec) &#123;</span><br><span class="line">                    oldest-&gt;triggerReader_Locked();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (element-&gt;getLogId() != id) &#123;</span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// below this point element-&gt;getLogId() == id</span></span><br><span class="line">            <span class="comment">// 从头开始剔除 log 的情况下，才需要设置 mLast，用来加速下次的剔除过程</span></span><br><span class="line">            <span class="keyword">if</span> (leading &amp;&amp; (!mLastSet[id] || ((*mLast[id])-&gt;getLogId() != id))) &#123;</span><br><span class="line">                mLast[id] = it;</span><br><span class="line">                mLastSet[id] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> dropped = element-&gt;getDropped();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remove any leading drops</span></span><br><span class="line">            <span class="keyword">if</span> (leading &amp;&amp; dropped) &#123;</span><br><span class="line">                it = erase(it);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试合并一些空的(dropped)的 log 项</span></span><br><span class="line">            <span class="keyword">if</span> (dropped &amp;&amp; last.coalesce(element, dropped)) &#123;</span><br><span class="line">                <span class="comment">// 成功的话，第二个参数为 true</span></span><br><span class="line">                it = erase(it, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> key = ((id == LOG_ID_EVENTS) || (id == LOG_ID_SECURITY))</span><br><span class="line">                          ? element-&gt;getTag()</span><br><span class="line">                          : element-&gt;getUid();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这条 log 在黑名单里面</span></span><br><span class="line">            <span class="keyword">if</span> (hasBlacklist &amp;&amp; mPrune.naughty(element)) &#123;</span><br><span class="line">                last.clear(element);</span><br><span class="line">                it = erase(it);</span><br><span class="line">                <span class="keyword">if</span> (dropped) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pruneRows--;</span><br><span class="line">                <span class="keyword">if</span> (pruneRows == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key == worst) &#123;</span><br><span class="line">                    kick = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 写 log 最多的“应用”已经比第二名少，此时它不再是 worst</span></span><br><span class="line">                    <span class="comment">// 既然如此，就应该停止这个过程</span></span><br><span class="line">                    <span class="comment">// 注意，这里是内层循环，break 后重新开始外层循环。下一个循环里，这里的第二名就变成了第一名</span></span><br><span class="line">                    <span class="keyword">if</span> (worst_sizes &lt; second_worst_sizes) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    worst_sizes -= element-&gt;getMsgLen();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((element-&gt;getRealTime() &lt; ((*lastt)-&gt;getRealTime() - too_old)) ||</span><br><span class="line">                (element-&gt;getRealTime() &gt; (*lastt)-&gt;getRealTime())) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dropped) &#123;</span><br><span class="line">                <span class="comment">// 如果是 dropped log，添加到 last 里面，下个循环里的其他需要删除的 log 可以跟这一条合并</span></span><br><span class="line">                last.add(element);</span><br><span class="line">                <span class="comment">// 还记得前面刚进入循环时的工作吗，这里把当前的迭代器缓存起来，可以加速以后的 prune 调用</span></span><br><span class="line">                <span class="comment">// 需要注意的是，第一条 add 到 LogBufferElementLast 里的 log 条目并不会被删除，这样</span></span><br><span class="line">                <span class="comment">// 才能保证接下来我们保存的迭代器是有效的</span></span><br><span class="line">                <span class="keyword">if</span> (worstPid &amp;&amp;</span><br><span class="line">                    ((!gc &amp;&amp; (element-&gt;getPid() == worstPid)) ||</span><br><span class="line">                     (mLastWorstPidOfSystem[id].find(element-&gt;getPid()) ==</span><br><span class="line">                      mLastWorstPidOfSystem[id].end()))) &#123;</span><br><span class="line">                    <span class="comment">// element-&gt;getUid() may not be AID_SYSTEM, next best</span></span><br><span class="line">                    <span class="comment">// watermark if current one empty. id is not LOG_ID_EVENTS</span></span><br><span class="line">                    <span class="comment">// or LOG_ID_SECURITY because of worstPid check.</span></span><br><span class="line">                    mLastWorstPidOfSystem[id][element-&gt;getPid()] = it;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((!gc &amp;&amp; !worstPid &amp;&amp; (key == worst)) ||</span><br><span class="line">                    (mLastWorst[id].find(key) == mLastWorst[id].end())) &#123;</span><br><span class="line">                    mLastWorst[id][key] = it;</span><br><span class="line">                &#125;</span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个 log 项是无辜的，放过它</span></span><br><span class="line">            <span class="keyword">if</span> ((key != worst) ||</span><br><span class="line">                (worstPid &amp;&amp; (element-&gt;getPid() != worstPid))) &#123;</span><br><span class="line">                <span class="comment">// 已经至少跳过了一条 log，所以 leading = false</span></span><br><span class="line">                leading = <span class="literal">false</span>;</span><br><span class="line">                last.clear(element);</span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// key == worst below here</span></span><br><span class="line">            <span class="comment">// If worstPid set, then element-&gt;getPid() == worstPid below here</span></span><br><span class="line"></span><br><span class="line">            pruneRows--;</span><br><span class="line">            <span class="keyword">if</span> (pruneRows == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            kick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> len = element-&gt;getMsgLen();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do not create any leading drops</span></span><br><span class="line">            <span class="keyword">if</span> (leading) &#123;</span><br><span class="line">                <span class="comment">// 不创建 leading drops，因为创建了没有用。这个 dropped log 主要是为了</span></span><br><span class="line">                <span class="comment">// 加速后面对同一个“用户”的 log 的删除操作。如果 dropped log 在列表最前面，</span></span><br><span class="line">                <span class="comment">// 我们只需要从 mLogElements.begin() 开始查找就可以了</span></span><br><span class="line">                it = erase(it);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stats.drop(element);</span><br><span class="line">                element-&gt;setDropped(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (last.coalesce(element, <span class="number">1</span>)) &#123;</span><br><span class="line">                    it = erase(it, <span class="literal">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 和上面那段一样</span></span><br><span class="line">                    last.add(element);</span><br><span class="line">                    <span class="keyword">if</span> (worstPid &amp;&amp;</span><br><span class="line">                        (!gc || (mLastWorstPidOfSystem[id].find(worstPid) ==</span><br><span class="line">                                 mLastWorstPidOfSystem[id].end()))) &#123;</span><br><span class="line">                        <span class="comment">// element-&gt;getUid() may not be AID_SYSTEM, next best</span></span><br><span class="line">                        <span class="comment">// watermark if current one empty. id is not</span></span><br><span class="line">                        <span class="comment">// LOG_ID_EVENTS or LOG_ID_SECURITY because of worstPid.</span></span><br><span class="line">                        mLastWorstPidOfSystem[id][worstPid] = it;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((!gc &amp;&amp; !worstPid) ||</span><br><span class="line">                        (mLastWorst[id].find(worst) == mLastWorst[id].end())) &#123;</span><br><span class="line">                        mLastWorst[id][worst] = it;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++it;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (worst_sizes &lt; second_worst_sizes) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            worst_sizes -= len;</span><br><span class="line">        &#125;</span><br><span class="line">        last.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一整个循环都没有删除那些写了太多 log 的条目，黑名单也没有启用，就不需要再开始下一次循环了</span></span><br><span class="line">        <span class="keyword">if</span> (!kick || !mPrune.worstUidEnabled()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// the following loop will ask bad clients to skip/drop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要放弃，后面的就简单了。</p><h3 id="4-删除不在白名单里的-log"><a href="#4-删除不在白名单里的-log" class="headerlink" title="4. 删除不在白名单里的 log"></a>4. 删除不在白名单里的 log</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="keyword">bool</span> LogBuffer::prune(<span class="keyword">log_id_t</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> pruneRows, <span class="keyword">uid_t</span> caller_uid) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> whitelist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasWhitelist = (id != LOG_ID_SECURITY) &amp;&amp; mPrune.nice() &amp;&amp; !clearAll;</span><br><span class="line">    it = mLastSet[id] ? mLast[id] : mLogElements.begin();</span><br><span class="line">    <span class="keyword">while</span> ((pruneRows &gt; <span class="number">0</span>) &amp;&amp; (it != mLogElements.end())) &#123;</span><br><span class="line">        LogBufferElement* element = *it;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (element-&gt;getLogId() != id) &#123;</span><br><span class="line">            it++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mLastSet[id] || ((*mLast[id])-&gt;getLogId() != id)) &#123;</span><br><span class="line">            mLast[id] = it;</span><br><span class="line">            mLastSet[id] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldest &amp;&amp; (watermark &lt;= element-&gt;getRealTime())) &#123;</span><br><span class="line">            busy = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (whitelist) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有 log 属于白名单，在删除白名单的 log 后，再进行下面这个判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stats.sizes(id) &gt; (<span class="number">2</span> * log_buffer_size(id))) &#123;</span><br><span class="line">                <span class="comment">// 如果某个读 log 客户端一直不读取数据，将会导致我们无法删除旧 log</span></span><br><span class="line">                <span class="comment">// 这种情况下，会导致 log 使用的空间超出预定的总量</span></span><br><span class="line">                <span class="comment">// kick a misbehaving log reader client off the island</span></span><br><span class="line">                oldest-&gt;release_Locked();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldest-&gt;mTimeout.tv_sec || oldest-&gt;mTimeout.tv_nsec) &#123;</span><br><span class="line">                oldest-&gt;triggerReader_Locked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oldest-&gt;triggerSkip_Locked(id, pruneRows);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasWhitelist &amp;&amp; !element-&gt;getDropped() &amp;&amp; mPrune.nice(element)) &#123;</span><br><span class="line">            <span class="comment">// WhiteListed</span></span><br><span class="line">            whitelist = <span class="literal">true</span>;</span><br><span class="line">            it++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        it = erase(it);</span><br><span class="line">        pruneRows--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-删除白名单里的-log"><a href="#5-删除白名单里的-log" class="headerlink" title="5. 删除白名单里的 log"></a>5. 删除白名单里的 log</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="keyword">bool</span> LogBuffer::prune(<span class="keyword">log_id_t</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> pruneRows, <span class="keyword">uid_t</span> caller_uid) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not save the whitelist if we are reader range limited</span></span><br><span class="line">    <span class="keyword">if</span> (whitelist &amp;&amp; (pruneRows &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        it = mLastSet[id] ? mLast[id] : mLogElements.begin();</span><br><span class="line">        <span class="keyword">while</span> ((it != mLogElements.end()) &amp;&amp; (pruneRows &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            LogBufferElement* element = *it;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (element-&gt;getLogId() != id) &#123;</span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mLastSet[id] || ((*mLast[id])-&gt;getLogId() != id)) &#123;</span><br><span class="line">                mLast[id] = it;</span><br><span class="line">                mLastSet[id] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oldest &amp;&amp; (watermark &lt;= element-&gt;getRealTime())) &#123;</span><br><span class="line">                busy = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (stats.sizes(id) &gt; (<span class="number">2</span> * log_buffer_size(id))) &#123;</span><br><span class="line">                    <span class="comment">// kick a misbehaving log reader client off the island</span></span><br><span class="line">                    oldest-&gt;release_Locked();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldest-&gt;mTimeout.tv_sec || oldest-&gt;mTimeout.tv_nsec) &#123;</span><br><span class="line">                    oldest-&gt;triggerReader_Locked();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    oldest-&gt;triggerSkip_Locked(id, pruneRows);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 已经到了这一步，就不需要再做什么判断了，直接删除就好</span></span><br><span class="line">            it = erase(it);</span><br><span class="line">            pruneRows--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (pruneRows &gt; <span class="number">0</span>) &amp;&amp; busy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于啊，<code>prune</code> 函数我们看完了（大松一口气）。</p><p><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，每种 log 数据类型都有一个总量限制，如果超过了这个限制，为了腾出空间，就需要删除一些旧数据。这个删除旧数据的功能，便是 &lt;code&gt;LogBuffer::prune&lt;/code&gt; 来完成的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
      <category term="logd" scheme="https://jekton.github.io/tags/logd/"/>
    
  </entry>
  
  <entry>
    <title>Android log 机制 - logd 如何接收 log 数据（下）</title>
    <link href="https://jekton.github.io/2018/05/17/logd-writing-part2/"/>
    <id>https://jekton.github.io/2018/05/17/logd-writing-part2/</id>
    <published>2018-05-17T00:34:22.000Z</published>
    <updated>2018-08-18T12:47:22.693Z</updated>
    
    <content type="html"><![CDATA[<p>写入 log 数据时，我们先通过 socket 读取客户端 log，然后调用 <code>logBuffer-&gt;log</code> 函数写入 log 缓冲并唤醒读 log 的客户端。由于每种类型的 log 数据都有总量限制，写入数据后可能需要删除旧数据。由于篇幅关系，删除旧数据这一部分下一篇再讲。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p><a href="/2018/05/16/logd-writing-part1/">上一篇</a>中我们知道，当有数据可读的时候，<code>SocketListener</code> 会回调子类的 <code>onDataAvailable()</code>。对于 <code>LogListener</code> 来说，就是在这个函数里面完成对 log 的读取的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogListener.cpp</span></span><br><span class="line"><span class="keyword">bool</span> LogListener::onDataAvailable(SocketClient* cli) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> name_set;</span><br><span class="line">    <span class="keyword">if</span> (!name_set) &#123;</span><br><span class="line">        prctl(PR_SET_NAME, <span class="string">"logd.writer"</span>);</span><br><span class="line">        name_set = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="keyword">sizeof_log_id_t</span> + <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>) + <span class="keyword">sizeof</span>(log_time) +</span><br><span class="line">                LOGGER_ENTRY_MAX_PAYLOAD];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> = &#123;</span> buffer, <span class="keyword">sizeof</span>(buffer) &#125;;</span><br><span class="line"></span><br><span class="line">    alignas(<span class="number">4</span>) <span class="keyword">char</span> control[CMSG_SPACE(<span class="keyword">sizeof</span>(struct ucred))];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">hdr</span> = &#123;</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, &amp;iov, <span class="number">1</span>, control, <span class="keyword">sizeof</span>(control), <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socket = cli-&gt;getSocket();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To clear the entire buffer is secure/safe, but this contributes to 1.68%</span></span><br><span class="line">    <span class="comment">// overhead under logging load. We are safe because we check counts.</span></span><br><span class="line">    <span class="comment">// memset(buffer, 0, sizeof(buffer));</span></span><br><span class="line">    <span class="keyword">ssize_t</span> n = recvmsg(socket, &amp;hdr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= (<span class="keyword">ssize_t</span>)(<span class="keyword">sizeof</span>(<span class="keyword">android_log_header_t</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucred</span>* <span class="title">cred</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span>* <span class="title">cmsg</span> = <span class="title">CMSG_FIRSTHDR</span>(&amp;<span class="title">hdr</span>);</span></span><br><span class="line">    <span class="keyword">while</span> (cmsg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp;</span><br><span class="line">            cmsg-&gt;cmsg_type == SCM_CREDENTIALS) &#123;</span><br><span class="line">            cred = (struct ucred*)CMSG_DATA(cmsg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cmsg = CMSG_NXTHDR(&amp;hdr, cmsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cred == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cred-&gt;uid == AID_LOGD) &#123;</span><br><span class="line">        <span class="comment">// ignore log messages we send to ourself.</span></span><br><span class="line">        <span class="comment">// Such log messages are often generated by libraries we depend on</span></span><br><span class="line">        <span class="comment">// which use standard Android logging.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">android_log_header_t</span>* header =</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">android_log_header_t</span>*&gt;(buffer);</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* header-&gt;id &lt; LOG_ID_MIN || */</span> header-&gt;id &gt;= LOG_ID_MAX ||</span><br><span class="line">        header-&gt;id == LOG_ID_KERNEL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((header-&gt;id == LOG_ID_SECURITY) &amp;&amp;</span><br><span class="line">        (!__android_log_security() ||</span><br><span class="line">         !clientHasLogCredentials(cred-&gt;uid, cred-&gt;gid, cred-&gt;pid))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* msg = ((<span class="keyword">char</span>*)buffer) + <span class="keyword">sizeof</span>(<span class="keyword">android_log_header_t</span>);</span><br><span class="line">    n -= <span class="keyword">sizeof</span>(<span class="keyword">android_log_header_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NB: hdr.msg_flags &amp; MSG_TRUNC is not tested, silently passing a</span></span><br><span class="line">    <span class="comment">// truncated message to the logs.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logbuf-&gt;<span class="built_in">log</span>((<span class="keyword">log_id_t</span>)header-&gt;id, header-&gt;realtime, cred-&gt;uid,</span><br><span class="line">                    cred-&gt;pid, header-&gt;tid, msg,</span><br><span class="line">                    ((<span class="keyword">size_t</span>)n &lt;= USHRT_MAX) ? (<span class="keyword">unsigned</span> <span class="keyword">short</span>)n : USHRT_MAX) &gt;=</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">        reader-&gt;notifyNewLog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>prctl</code> 系统调用用于设置进程相关的一些东西。这里使用 <code>PR_SET_NAME</code> 设置了线程的名字为 <code>logd.writer</code>。</p><p>接下来使用 <code>recvmsg</code> 从 socket 里读取数据。对网络编程不熟悉的读者，可以参考 《UNIX 网络编程》，卷1。需要注意的是，<code>LogListener</code> 创建的 socket 是 dgram，客户不需要连接。传递给 <code>onDataAvailable()</code> 的这个 socket，就是我们自己创建的那一个。</p><p>由于我们创建 socket 时打开了 <code>SO_PASSCRED</code> 选项，这里我们可以读取一个用于表示客户端身份的 <code>struct ucred</code>。</p><p>执行一些基本判断后，调用 <code>logbuf-&gt;log</code> 将数据写入 <code>LogBuffer</code>。</p><p>此时可能有客户端在等待读取数据，于是也调用 <code>reader-&gt;notifyNewLog()</code>。关于 <code>LogReader</code>，后面我们再讨论。下面看 <code>LogBuffer</code> 的 <code>log</code> 函数。</p><h2 id="写入-LogBuffer"><a href="#写入-LogBuffer" class="headerlink" title="写入 LogBuffer"></a>写入 LogBuffer</h2><p>log 的写入主要是一下 4 个步骤：</p><ol><li>根据 tag 和优先级判断该 log 是否可以写入</li><li>使用一个状态机去除重复的 log</li><li>写入 log</li><li>如果需要，删除一些 log 以避免 log 数据过多</li></ol><p>下面我们一步一步来看。</p><h3 id="1-根据-tag-和优先级判断该-log-是否可以写入"><a href="#1-根据-tag-和优先级判断该-log-是否可以写入" class="headerlink" title="1. 根据 tag 和优先级判断该 log 是否可以写入"></a>1. 根据 tag 和优先级判断该 log 是否可以写入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="keyword">int</span> LogBuffer::<span class="built_in">log</span>(<span class="keyword">log_id_t</span> log_id, log_time realtime, <span class="keyword">uid_t</span> uid, <span class="keyword">pid_t</span> pid,</span><br><span class="line">                   <span class="keyword">pid_t</span> tid, <span class="keyword">const</span> <span class="keyword">char</span>* msg, <span class="keyword">unsigned</span> <span class="keyword">short</span> len) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((log_id &gt;= LOG_ID_MAX) || (log_id &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogBufferElement* elem =</span><br><span class="line">        <span class="keyword">new</span> LogBufferElement(log_id, realtime, uid, pid, tid, msg, len);</span><br><span class="line">    <span class="keyword">if</span> (log_id != LOG_ID_SECURITY) &#123;</span><br><span class="line">        <span class="keyword">int</span> prio = ANDROID_LOG_INFO;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* tag = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (log_id == LOG_ID_EVENTS) &#123;</span><br><span class="line">            tag = tagToName(elem-&gt;getTag());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prio = *msg;</span><br><span class="line">            tag = msg + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!__android_log_is_loggable(prio, tag, ANDROID_LOG_VERBOSE)) &#123;</span><br><span class="line">            <span class="comment">// Log traffic received to total</span></span><br><span class="line">            pthread_mutex_lock(&amp;mLogElementsLock);</span><br><span class="line">            stats.add(elem);</span><br><span class="line">            stats.subtract(elem);</span><br><span class="line">            pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line">            <span class="keyword">delete</span> elem;</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一需要注意的是，如果 <code>log_id</code> 是 <code>LOG_ID_EVENTS</code>，优先级 <code>prio == ANDROID_LOG_INFO</code>。</p><h3 id="2-使用一个状态机去除重复的-log"><a href="#2-使用一个状态机去除重复的-log" class="headerlink" title="2. 使用一个状态机去除重复的 log"></a>2. 使用一个状态机去除重复的 log</h3><p>状态机这部分是最复杂的，幸运的是，程序员已经帮我们写好了注释，看看注释，知道它做了什么就好。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="keyword">int</span> LogBuffer::<span class="built_in">log</span>(<span class="keyword">log_id_t</span> log_id, log_time realtime, <span class="keyword">uid_t</span> uid, <span class="keyword">pid_t</span> pid,</span><br><span class="line">                   <span class="keyword">pid_t</span> tid, <span class="keyword">const</span> <span class="keyword">char</span>* msg, <span class="keyword">unsigned</span> <span class="keyword">short</span> len) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mLogElementsLock);</span><br><span class="line">    LogBufferElement* currentLast = lastLoggedElements[log_id];</span><br><span class="line">    <span class="keyword">if</span> (currentLast) &#123;</span><br><span class="line">        LogBufferElement* dropped = droppedElements[log_id];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> count = dropped ? dropped-&gt;getDropped() : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// State Init</span></span><br><span class="line">        <span class="comment">//     incoming:</span></span><br><span class="line">        <span class="comment">//         dropped = nullptr</span></span><br><span class="line">        <span class="comment">//         currentLast = nullptr;</span></span><br><span class="line">        <span class="comment">//         elem = incoming message</span></span><br><span class="line">        <span class="comment">//     outgoing:</span></span><br><span class="line">        <span class="comment">//         dropped = nullptr -&gt; State 0</span></span><br><span class="line">        <span class="comment">//         currentLast = copy of elem</span></span><br><span class="line">        <span class="comment">//         log elem</span></span><br><span class="line">        <span class="comment">// State 0</span></span><br><span class="line">        <span class="comment">//     incoming:</span></span><br><span class="line">        <span class="comment">//         count = 0</span></span><br><span class="line">        <span class="comment">//         dropped = nullptr</span></span><br><span class="line">        <span class="comment">//         currentLast = copy of last message</span></span><br><span class="line">        <span class="comment">//         elem = incoming message</span></span><br><span class="line">        <span class="comment">//     outgoing: if match != DIFFERENT</span></span><br><span class="line">        <span class="comment">//         dropped = copy of first identical message -&gt; State 1</span></span><br><span class="line">        <span class="comment">//         currentLast = reference to elem</span></span><br><span class="line">        <span class="comment">//     break: if match == DIFFERENT</span></span><br><span class="line">        <span class="comment">//         dropped = nullptr -&gt; State 0</span></span><br><span class="line">        <span class="comment">//         delete copy of last message (incoming currentLast)</span></span><br><span class="line">        <span class="comment">//         currentLast = copy of elem</span></span><br><span class="line">        <span class="comment">//         log elem</span></span><br><span class="line">        <span class="comment">// State 1</span></span><br><span class="line">        <span class="comment">//     incoming:</span></span><br><span class="line">        <span class="comment">//         count = 0</span></span><br><span class="line">        <span class="comment">//         dropped = copy of first identical message</span></span><br><span class="line">        <span class="comment">//         currentLast = reference to last held-back incoming</span></span><br><span class="line">        <span class="comment">//                       message</span></span><br><span class="line">        <span class="comment">//         elem = incoming message</span></span><br><span class="line">        <span class="comment">//     outgoing: if match == SAME</span></span><br><span class="line">        <span class="comment">//         delete copy of first identical message (dropped)</span></span><br><span class="line">        <span class="comment">//         dropped = reference to last held-back incoming</span></span><br><span class="line">        <span class="comment">//                   message set to chatty count of 1 -&gt; State 2</span></span><br><span class="line">        <span class="comment">//         currentLast = reference to elem</span></span><br><span class="line">        <span class="comment">//     outgoing: if match == SAME_LIBLOG</span></span><br><span class="line">        <span class="comment">//         dropped = copy of first identical message -&gt; State 1</span></span><br><span class="line">        <span class="comment">//         take sum of currentLast and elem</span></span><br><span class="line">        <span class="comment">//         if sum overflows:</span></span><br><span class="line">        <span class="comment">//             log currentLast</span></span><br><span class="line">        <span class="comment">//             currentLast = reference to elem</span></span><br><span class="line">        <span class="comment">//         else</span></span><br><span class="line">        <span class="comment">//             delete currentLast</span></span><br><span class="line">        <span class="comment">//             currentLast = reference to elem, sum liblog.</span></span><br><span class="line">        <span class="comment">//     break: if match == DIFFERENT</span></span><br><span class="line">        <span class="comment">//         delete dropped</span></span><br><span class="line">        <span class="comment">//         dropped = nullptr -&gt; State 0</span></span><br><span class="line">        <span class="comment">//         log reference to last held-back (currentLast)</span></span><br><span class="line">        <span class="comment">//         currentLast = copy of elem</span></span><br><span class="line">        <span class="comment">//         log elem</span></span><br><span class="line">        <span class="comment">// State 2</span></span><br><span class="line">        <span class="comment">//     incoming:</span></span><br><span class="line">        <span class="comment">//         count = chatty count</span></span><br><span class="line">        <span class="comment">//         dropped = chatty message holding count</span></span><br><span class="line">        <span class="comment">//         currentLast = reference to last held-back incoming</span></span><br><span class="line">        <span class="comment">//                       message.</span></span><br><span class="line">        <span class="comment">//         dropped = chatty message holding count</span></span><br><span class="line">        <span class="comment">//         elem = incoming message</span></span><br><span class="line">        <span class="comment">//     outgoing: if match != DIFFERENT</span></span><br><span class="line">        <span class="comment">//         delete chatty message holding count</span></span><br><span class="line">        <span class="comment">//         dropped = reference to last held-back incoming</span></span><br><span class="line">        <span class="comment">//                   message, set to chatty count + 1</span></span><br><span class="line">        <span class="comment">//         currentLast = reference to elem</span></span><br><span class="line">        <span class="comment">//     break: if match == DIFFERENT</span></span><br><span class="line">        <span class="comment">//         log dropped (chatty message)</span></span><br><span class="line">        <span class="comment">//         dropped = nullptr -&gt; State 0</span></span><br><span class="line">        <span class="comment">//         log reference to last held-back (currentLast)</span></span><br><span class="line">        <span class="comment">//         currentLast = copy of elem</span></span><br><span class="line">        <span class="comment">//         log elem</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">enum</span> match_type match = identical(elem, currentLast);</span><br><span class="line">        <span class="keyword">if</span> (match != DIFFERENT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dropped) &#123;</span><br><span class="line">                <span class="comment">// Sum up liblog tag messages?</span></span><br><span class="line">                <span class="keyword">if</span> ((count == <span class="number">0</span>) <span class="comment">/* at Pass 1 */</span> &amp;&amp; (match == SAME_LIBLOG)) &#123;</span><br><span class="line">                    <span class="keyword">android_log_event_int_t</span>* event =</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">android_log_event_int_t</span>*&gt;(</span><br><span class="line">                            <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(currentLast-&gt;getMsg()));</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// To unit test, differentiate with something like:</span></span><br><span class="line">                    <span class="comment">//    event-&gt;header.tag = htole32(CHATTY_LOG_TAG);</span></span><br><span class="line">                    <span class="comment">// here, then instead of delete currentLast below,</span></span><br><span class="line">                    <span class="comment">// log(currentLast) to see the incremental sums form.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">uint32_t</span> swab = event-&gt;payload.data;</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> total = htole32(swab);</span><br><span class="line">                    event = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">android_log_event_int_t</span>*&gt;(</span><br><span class="line">                        <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(elem-&gt;getMsg()));</span><br><span class="line">                    swab = event-&gt;payload.data;</span><br><span class="line"></span><br><span class="line">                    lastLoggedElements[LOG_ID_EVENTS] = elem;</span><br><span class="line">                    total += htole32(swab);</span><br><span class="line">                    <span class="comment">// check for overflow</span></span><br><span class="line">                    <span class="keyword">if</span> (total &gt;= UINT32_MAX) &#123;</span><br><span class="line">                        <span class="built_in">log</span>(currentLast);</span><br><span class="line">                        pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line">                        <span class="keyword">return</span> len;</span><br><span class="line">                    &#125;</span><br><span class="line">                    stats.add(currentLast);</span><br><span class="line">                    stats.subtract(currentLast);</span><br><span class="line">                    <span class="keyword">delete</span> currentLast;</span><br><span class="line">                    swab = total;</span><br><span class="line">                    event-&gt;payload.data = htole32(swab);</span><br><span class="line">                    pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line">                    <span class="keyword">return</span> len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == USHRT_MAX) &#123;</span><br><span class="line">                    <span class="built_in">log</span>(dropped);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">delete</span> dropped;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count) &#123;</span><br><span class="line">                stats.add(currentLast);</span><br><span class="line">                stats.subtract(currentLast);</span><br><span class="line">                currentLast-&gt;setDropped(count);</span><br><span class="line">            &#125;</span><br><span class="line">            droppedElements[log_id] = currentLast;</span><br><span class="line">            lastLoggedElements[log_id] = elem;</span><br><span class="line">            pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropped) &#123;         <span class="comment">// State 1 or 2</span></span><br><span class="line">            <span class="keyword">if</span> (count) &#123;       <span class="comment">// State 2</span></span><br><span class="line">                <span class="built_in">log</span>(dropped);  <span class="comment">// report chatty</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;           <span class="comment">// State 1</span></span><br><span class="line">                <span class="keyword">delete</span> dropped;</span><br><span class="line">            &#125;</span><br><span class="line">            droppedElements[log_id] = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">log</span>(currentLast);  <span class="comment">// report last message in the series</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;               <span class="comment">// State 0</span></span><br><span class="line">            <span class="keyword">delete</span> currentLast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastLoggedElements[log_id] = <span class="keyword">new</span> LogBufferElement(*elem);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span>(elem);</span><br><span class="line">    pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，实际的 log 写入动作，是由另一个 <code>log</code> 函数来完成的。</p><h3 id="3-写入-log"><a href="#3-写入-log" class="headerlink" title="3. 写入 log"></a>3. 写入 log</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// assumes mLogElementsLock held, owns elem, will look after garbage collection</span></span><br><span class="line"><span class="keyword">void</span> LogBuffer::<span class="built_in">log</span>(LogBufferElement* elem) &#123;</span><br><span class="line">    <span class="comment">// cap on how far back we will sort in-place, otherwise append</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> too_far_back = <span class="number">5</span>;  <span class="comment">// five seconds</span></span><br><span class="line">    <span class="comment">// Insert elements in time sorted order if possible</span></span><br><span class="line">    <span class="comment">//  NB: if end is region locked, place element at end of list</span></span><br><span class="line">    LogBufferElementCollection::iterator it = mLogElements.end();</span><br><span class="line">    LogBufferElementCollection::iterator last = it;</span><br><span class="line">    <span class="comment">// 让 it 指向列表的最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (__predict_true(it != mLogElements.begin())) --it;</span><br><span class="line">    <span class="keyword">if</span> (__predict_false(it == mLogElements.begin()) ||</span><br><span class="line">        __predict_true((*it)-&gt;getRealTime() &lt;= elem-&gt;getRealTime()) ||</span><br><span class="line">        __predict_false((((*it)-&gt;getRealTime().tv_sec - too_far_back) &gt;</span><br><span class="line">                         elem-&gt;getRealTime().tv_sec) &amp;&amp;</span><br><span class="line">                        (elem-&gt;getLogId() != LOG_ID_KERNEL) &amp;&amp;</span><br><span class="line">                        ((*it)-&gt;getLogId() != LOG_ID_KERNEL))) &#123;</span><br><span class="line">        mLogElements.push_back(elem);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_time end = log_time::EPOCH;</span><br><span class="line">        <span class="keyword">bool</span> end_set = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> end_always = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        LogTimeEntry::lock();</span><br><span class="line"></span><br><span class="line">        LastLogTimes::iterator times = mTimes.begin();</span><br><span class="line">        <span class="keyword">while</span> (times != mTimes.end()) &#123;</span><br><span class="line">            LogTimeEntry* entry = (*times);</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;owned_Locked()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!entry-&gt;mNonBlock) &#123;</span><br><span class="line">                    end_always = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// it passing mEnd is blocked by the following checks.</span></span><br><span class="line">                <span class="keyword">if</span> (!end_set || (end &lt;= entry-&gt;mEnd)) &#123;</span><br><span class="line">                    end = entry-&gt;mEnd;</span><br><span class="line">                    end_set = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end_always || (end_set &amp;&amp; (end &gt; (*it)-&gt;getRealTime()))) &#123;</span><br><span class="line">            mLogElements.push_back(elem);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// should be short as timestamps are localized near end()</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                last = it;</span><br><span class="line">                <span class="keyword">if</span> (__predict_false(it == mLogElements.begin())) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                --it;</span><br><span class="line">            &#125; <span class="keyword">while</span> (((*it)-&gt;getRealTime() &gt; elem-&gt;getRealTime()) &amp;&amp;</span><br><span class="line">                     (!end_set || (end &lt;= (*it)-&gt;getRealTime())));</span><br><span class="line">            mLogElements.insert(last, elem);</span><br><span class="line">        &#125;</span><br><span class="line">        LogTimeEntry::unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stats.add(elem);</span><br><span class="line">    maybePrune(elem-&gt;getLogId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__predict_true</code> 和 <code>__predict_false</code> 用来提示编译器对应的判断很可能是 <code>true/false</code>，类似于 Linux 内核的 <code>likely/unlikely</code>。如果判断正确，可以得到很大的性能提升。</p><p>客户端使用 Unix-domain socket 来写入 log，读出来的时候，很可能就已经按时间顺序排好，这个时候，只需要把 <code>LogBufferElement</code> 插入列表末尾就可以了。</p><p>万一很不幸的，上面的判断失败了，就只能从后往前遍历列表，找到一个合适的位置来插入 <code>LogBufferElement</code>。这个过程类似于插入排序。</p><p>关于 <code>mTimes</code>，后面我们看 <code>LogReader</code> 的时候还会再详细分析它，现在我们只需要知道，一个读客户端对应着 <code>mTimes</code> 里的一项。当对应的客户端在读 log 时，<code>entry-&gt;owned_Locked()</code> 返回 <code>true</code>。</p><p>如果 <code>!entry-&gt;mNonBlock</code> 为真，说明有客户端在阻塞地读取 log，此时我们只能把新的 log 放入列表的末尾。考虑这样一种比较极端的情况，它已经读取了所有的 log 并等待新的 log，我们又没有把新的 log 放入列表的末尾，就会导致客户端无法读取新写入的这条 log，毕竟，此时它应该读列表最后面的 log。</p><p>另一种和上面类似的情形是，有客户端在读 log，并且它读到的最后一条 log 已经超过了我们正要写入的 log。此时最简单的做法就是把新 log 放到末尾，这样客户才能读取到新写入的 log。</p><h3 id="4-如果需要，删除一些-log-以避免-log-数据过多"><a href="#4-如果需要，删除一些-log-以避免-log-数据过多" class="headerlink" title="4. 如果需要，删除一些 log 以避免 log 数据过多"></a>4. 如果需要，删除一些 log 以避免 log 数据过多</h3><p>添加 log 后，调用 <code>maybePrune</code>，根据 log 总量判断是否需要删除一些 log。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prune at most 10% of the log entries or maxPrune, whichever is less.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mLogElementsLock must be held when this function is called.</span></span><br><span class="line"><span class="keyword">void</span> LogBuffer::maybePrune(<span class="keyword">log_id_t</span> id) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> sizes = stats.sizes(id);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> maxSize = log_buffer_size(id);</span><br><span class="line">    <span class="keyword">if</span> (sizes &gt; maxSize) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> sizeOver = sizes - ((maxSize * <span class="number">9</span>) / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">size_t</span> elements = stats.realElements(id);</span><br><span class="line">        <span class="keyword">size_t</span> minElements = elements / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (minElements &lt; minPrune) &#123;</span><br><span class="line">            minElements = minPrune;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pruneRows = elements * sizeOver / sizes;</span><br><span class="line">        <span class="keyword">if</span> (pruneRows &lt; minElements) &#123;</span><br><span class="line">            pruneRows = minElements;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pruneRows &gt; maxPrune) &#123;</span><br><span class="line">            pruneRows = maxPrune;</span><br><span class="line">        &#125;</span><br><span class="line">        prune(id, pruneRows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> minPrune = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> maxPrune = <span class="number">256</span>;</span><br></pre></td></tr></table></figure></p><p>如果 <code>id</code> 类型的 log 超过了总量限制，就删除 10% 的 log。在这个前提下，所删除的 log 调试大于 <code>minElements</code> 和 <code>minPrune</code>，小于 <code>maxPrune</code>。<br>其中，<code>minElements</code> 是所有 <code>id</code> 类型的 log 的总条数的百分之一。</p><p>当每条 log 都很大、log 总量又很小，限制最小值可以避免总是需要剔除旧 log。如果 log 每条很小，限制最大数目可以避免删除过多的 log。</p><p>实际的删除工作由 <code>prune</code> 方法完成，由于篇幅关系，<code>prune</code> 单独作为一篇，后面再来了解。它的实现并不影响 log 写入逻辑，log 的写入到这里就算告一段落。</p><p><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写入 log 数据时，我们先通过 socket 读取客户端 log，然后调用 &lt;code&gt;logBuffer-&amp;gt;log&lt;/code&gt; 函数写入 log 缓冲并唤醒读 log 的客户端。由于每种类型的 log 数据都有总量限制，写入数据后可能需要删除旧数据。由于篇幅关系
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
      <category term="logd" scheme="https://jekton.github.io/tags/logd/"/>
    
  </entry>
  
  <entry>
    <title>Android log 机制 - logd 如何接收 log 数据（上）</title>
    <link href="https://jekton.github.io/2018/05/16/logd-writing-part1/"/>
    <id>https://jekton.github.io/2018/05/16/logd-writing-part1/</id>
    <published>2018-05-16T11:43:29.000Z</published>
    <updated>2018-08-18T12:47:22.692Z</updated>
    
    <content type="html"><![CDATA[<p>按计划，在本篇，我们先看 <code>LogBuffer</code> 的初始化，然后深入 <code>LogListener</code>。<code>LogListener</code> 用于接受客户写入的 log 数据。虽然在 <code>main</code> 函数里先创建的是 <code>LogReader</code>，这里我们还是先看 <code>LogListener</code>，毕竟，先写了 log，才有东西可以读。</p><p>可是计划总是赶不上变化，<code>LogListener</code> 的镜头被 <code>SocketListener</code> 抢了，所以还是 log 数据的读取这一部分留到下一篇吧。</p><h2 id="LogBuffer-的初始化"><a href="#LogBuffer-的初始化" class="headerlink" title="LogBuffer 的初始化"></a>LogBuffer 的初始化</h2><p>在<a href="/2018/05/11/logd-overview/">上一篇</a>我们了解到，<code>LogBuffer</code> 是在 <code>main</code> 函数里初始化的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serves the purpose of managing the last logs times read on a</span></span><br><span class="line">    <span class="comment">// socket connection, and as a reader lock on a range of log</span></span><br><span class="line">    <span class="comment">// entries.</span></span><br><span class="line"></span><br><span class="line">    LastLogTimes* times = <span class="keyword">new</span> LastLogTimes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogBuffer is the object which is responsible for holding all</span></span><br><span class="line">    <span class="comment">// log entries.</span></span><br><span class="line"></span><br><span class="line">    logBuf = <span class="keyword">new</span> LogBuffer(times);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LastLogTimes</code> 实际上是一个 <code>std::list</code>，可以看到，实际上这里只是 new 了一个空的 <code>list</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogTimes.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;LogTimeEntry*&gt; LastLogTimes;</span><br></pre></td></tr></table></figure></p><p>下面我们看看 <code>LogBuffer</code> 构造函数里面做了什么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line">LogBuffer::LogBuffer(LastLogTimes* times)</span><br><span class="line">    : monotonic(android_log_clockid() == CLOCK_MONOTONIC), mTimes(*times) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;mLogElementsLock, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    log_id_for_each(i) &#123;</span><br><span class="line">        lastLoggedElements[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        droppedElements[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/liblog/include/log/log_id.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> log_id &#123;</span><br><span class="line">  LOG_ID_MIN = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  LOG_ID_MAIN = <span class="number">0</span>,</span><br><span class="line">  LOG_ID_RADIO = <span class="number">1</span>,</span><br><span class="line">  LOG_ID_EVENTS = <span class="number">2</span>,</span><br><span class="line">  LOG_ID_SYSTEM = <span class="number">3</span>,</span><br><span class="line">  LOG_ID_CRASH = <span class="number">4</span>,</span><br><span class="line">  LOG_ID_SECURITY = <span class="number">5</span>,</span><br><span class="line">  LOG_ID_KERNEL = <span class="number">6</span>, <span class="comment">/* place last, third-parties can not use it */</span></span><br><span class="line"></span><br><span class="line">  LOG_ID_MAX</span><br><span class="line">&#125; <span class="keyword">log_id_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogStatistics.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_id_for_each(i) \</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">log_id_t</span> i = LOG_ID_MIN; (i) &lt; LOG_ID_MAX; (i) = (<span class="keyword">log_id_t</span>)((i) + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><p><code>monotonic</code> 表示时间的格式，如果为 <code>true</code>，表示使用的是 CPU 的 up time（系统上电后从 0 开始计数）。一般我们用的是 real time（就是我们一般说的时间的概念）。这里就假定它是 <code>false</code> 好了。</p><p><code>mLogElementsLock</code> 用于保护内部的数据结构。</p><p><code>log_id_for_each</code> 是一个宏，用来遍历所有的 log 类型。每一种 log 类型，都有一个 <code>log_id</code> 来表示。</p><p><code>lastLoggedElements</code> 和 <code>droppedElements</code> 是<code>LogBufferElement *</code>类型的数组，数组的每个元素对应一种 log 类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogBuffer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    LogBufferElement* lastLoggedElements[LOG_ID_MAX];</span><br><span class="line">    LogBufferElement* droppedElements[LOG_ID_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，调用 <code>init</code> 函数，我们把它分成 3 个部分来看。</p><p>先看 <code>init</code> 函数的第 1 部分，这部分依然是做一些初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="keyword">void</span> LogBuffer::init() &#123;</span><br><span class="line">    log_id_for_each(i) &#123;</span><br><span class="line">        mLastSet[i] = <span class="literal">false</span>;</span><br><span class="line">        mLast[i] = mLogElements.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (setSize(i, __android_logger_get_buffer_size(i))) &#123;</span><br><span class="line">            setSize(i, LOG_BUFFER_MIN_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogBuffer.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;LogBufferElement*&gt; LogBufferElementCollection;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogBuffer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    LogBufferElementCollection mLogElements;</span><br><span class="line">    LogBufferElementCollection::iterator mLast[LOG_ID_MAX];</span><br><span class="line">    <span class="keyword">bool</span> mLastSet[LOG_ID_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又是一个 <code>typedef</code>，*￥#%#&amp;￥%#￥%#@，此处略去一百字。</p><p><code>setSize()</code> 用于设置各种 log 的最大容量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log_buffer_size(id) mMaxSize[id]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set the total space allocated to "id"</span></span><br><span class="line"><span class="keyword">int</span> LogBuffer::setSize(<span class="keyword">log_id_t</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> size) &#123;</span><br><span class="line">    <span class="comment">// Reasonable limits ...</span></span><br><span class="line">    <span class="keyword">if</span> (!__android_logger_valid_buffer_size(size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_lock(&amp;mLogElementsLock);</span><br><span class="line">    log_buffer_size(id) = size;</span><br><span class="line">    pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着，是 <code>init()</code> 的第二部分。这部分检查时间格式是否发生了变化，如果是，就变换已经存在 log 的时间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="keyword">void</span> LogBuffer::init() &#123;</span><br><span class="line">    <span class="comment">// 第一部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> lastMonotonic = monotonic;</span><br><span class="line">    monotonic = android_log_clockid() == CLOCK_MONOTONIC;</span><br><span class="line">    <span class="keyword">if</span> (lastMonotonic != monotonic) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Fixup all timestamps, may not be 100% accurate, but better than</span></span><br><span class="line">        <span class="comment">// throwing what we have away when we get 'surprised' by a change.</span></span><br><span class="line">        <span class="comment">// In-place element fixup so no need to check reader-lock. Entries</span></span><br><span class="line">        <span class="comment">// should already be in timestamp order, but we could end up with a</span></span><br><span class="line">        <span class="comment">// few out-of-order entries if new monotonics come in before we</span></span><br><span class="line">        <span class="comment">// are notified of the reinit change in status. A Typical example would</span></span><br><span class="line">        <span class="comment">// be:</span></span><br><span class="line">        <span class="comment">//  --------- beginning of system</span></span><br><span class="line">        <span class="comment">//      10.494082   184   201 D Cryptfs : Just triggered post_fs_data</span></span><br><span class="line">        <span class="comment">//  --------- beginning of kernel</span></span><br><span class="line">        <span class="comment">//       0.000000     0     0 I         : Initializing cgroup subsys</span></span><br><span class="line">        <span class="comment">// as the act of mounting /data would trigger persist.logd.timestamp to</span></span><br><span class="line">        <span class="comment">// be corrected. 1/30 corner case YMMV.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        pthread_mutex_lock(&amp;mLogElementsLock);</span><br><span class="line">        LogBufferElementCollection::iterator it = mLogElements.begin();</span><br><span class="line">        <span class="keyword">while</span> ((it != mLogElements.end())) &#123;</span><br><span class="line">            LogBufferElement* e = *it;</span><br><span class="line">            <span class="keyword">if</span> (monotonic) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!android::isMonotonic(e-&gt;mRealTime)) &#123;</span><br><span class="line">                    LogKlog::convertRealToMonotonic(e-&gt;mRealTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (android::isMonotonic(e-&gt;mRealTime)) &#123;</span><br><span class="line">                    LogKlog::convertMonotonicToReal(e-&gt;mRealTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mLogElementsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LogKlog::convertRealToMonotonic()</code> 和 <code>LogKlog::convertMonotonicToReal()</code> 的工作是相当直观的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogKlog.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convertMonotonicToReal</span><span class="params">(log_time&amp; real)</span> </span>&#123;</span><br><span class="line">    real += correction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convertRealToMonotonic</span><span class="params">(log_time&amp; real)</span> </span>&#123;</span><br><span class="line">    real -= correction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>correction</code> 是一个静态的成员变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogKlog.h</span></span><br><span class="line">log_time LogKlog::correction =</span><br><span class="line">    (log_time(CLOCK_REALTIME) &lt; log_time(CLOCK_MONOTONIC))</span><br><span class="line">        ? log_time::EPOCH</span><br><span class="line">        : (log_time(CLOCK_REALTIME) - log_time(CLOCK_MONOTONIC));</span><br></pre></td></tr></table></figure></p><p>正常情况下，<code>correction = (log_time(CLOCK_REALTIME) - log_time(CLOCK_MONOTONIC))</code>，即这行代码执行时实际时间跟 monotonic 时间的差值。</p><p>最后，我们看 <code>init()</code> 的第3部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogBuffer.cpp</span></span><br><span class="line"><span class="keyword">void</span> LogBuffer::init() &#123;</span><br><span class="line">    <span class="comment">// 第 1 部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 2 部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We may have been triggered by a SIGHUP. Release any sleeping reader</span></span><br><span class="line">    <span class="comment">// threads to dump their current content.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NB: this is _not_ performed in the context of a SIGHUP, it is</span></span><br><span class="line">    <span class="comment">// performed during startup, and in context of reinit administrative thread</span></span><br><span class="line">    LogTimeEntry::lock();</span><br><span class="line"></span><br><span class="line">    LastLogTimes::iterator times = mTimes.begin();</span><br><span class="line">    <span class="keyword">while</span> (times != mTimes.end()) &#123;</span><br><span class="line">        LogTimeEntry* entry = (*times);</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;owned_Locked()) &#123;</span><br><span class="line">            entry-&gt;triggerReader_Locked();</span><br><span class="line">        &#125;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogTimeEntry::unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每一个需要读取 log 数据的客户端都对应 <code>mTimes</code> 里面的一个元素。就像注释里说的，收到信号 <code>SIGHUP</code> 会调用 <code>init</code>，这个时候需要重新唤醒 <code>LogTimeEntry</code>。如果是刚刚初始化 <code>LogBuffer</code>，<code>mTimes</code> 为空，循环不执行。<code>SIGHUP</code> 在 <code>main</code> 函数中注册，这一部分就不展开讲了，后面有机会再聊。</p><p>到这里，<code>LogBuffer</code> 就的初始化就完成了。</p><h2 id="LogListener-的初始化"><a href="#LogListener-的初始化" class="headerlink" title="LogListener 的初始化"></a>LogListener 的初始化</h2><p><code>LogListener</code> 是在 <code>main</code> 函数里初始化的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogReader listens on /dev/socket/logdr. When a client</span></span><br><span class="line">    <span class="comment">// connects, log entries in the LogBuffer are written to the client.</span></span><br><span class="line"></span><br><span class="line">    LogReader* reader = <span class="keyword">new</span> LogReader(logBuf);</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogListener listens on /dev/socket/logdw for client</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogListener* swl = <span class="keyword">new</span> LogListener(logBuf, reader);</span><br><span class="line">    <span class="comment">// Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value</span></span><br><span class="line">    <span class="keyword">if</span> (swl-&gt;startListener(<span class="number">600</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogListener.cpp</span></span><br><span class="line">LogListener::LogListener(LogBuffer* buf, LogReader* reader)</span><br><span class="line">    : SocketListener(getLogSocket(), <span class="literal">false</span>), logbuf(buf), reader(reader) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LogReader</code> 在客户从 logd 中读取数据时使用，这里我们先把它放一放。在本篇，我们先看往 logd 写数据这一部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogListener.cpp</span></span><br><span class="line">LogListener::LogListener(LogBuffer* buf, LogReader* reader)</span><br><span class="line">    : SocketListener(getLogSocket(), <span class="literal">false</span>), logbuf(buf), reader(reader) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/logd/LogListener.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogListener</span> :</span> <span class="keyword">public</span> SocketListener &#123;</span><br><span class="line">    LogBuffer* logbuf;</span><br><span class="line">    LogReader* reader;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    LogListener(LogBuffer* buf, LogReader* reader);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">onDataAvailable</span><span class="params">(SocketClient* cli)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLogSocket</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，<code>LogListener</code> 构造函数里并没有太多的工作要做，只是调用父类的构造函数，然后把传递进来的参数存起来。</p><p><code>getLogSocket()</code> 用于获取 UNIX 域 socket <code>/dev/socket/logdw</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/LogListener.cpp</span></span><br><span class="line"><span class="keyword">int</span> LogListener::getLogSocket() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> socketName[] = <span class="string">"logdw"</span>;</span><br><span class="line">    <span class="keyword">int</span> sock = android_get_control_socket(socketName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sock = socket_local_server(</span><br><span class="line">            socketName, ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_DGRAM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_PASSCRED, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libcutils/include/cutils/sockets.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux "abstract" (non-filesystem) namespace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_SOCKET_NAMESPACE_ABSTRACT 0</span></span><br><span class="line"><span class="comment">// Android "reserved" (/dev/socket) namespace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_SOCKET_NAMESPACE_RESERVED 1</span></span><br><span class="line"><span class="comment">// Normal filesystem namespace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_SOCKET_NAMESPACE_FILESYSTEM 2</span></span><br></pre></td></tr></table></figure></p><p>这里需要关注的是 <code>setsockopt()</code>，通过设置 <code>SO_PASSCRED</code>，能够接收一个 <code>SCM_CREDENTIALS</code> 消息，消息中包含发送者的 pid, uid, 和 gid。该消息通过 <code>struct ucred</code> 结构返回。通过这个选项，我们就能够知道是谁写入了 log。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> &#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;    <span class="comment">/* process ID of the sending process */</span></span><br><span class="line">    <span class="keyword">uid_t</span> uid;    <span class="comment">/* user ID of the sending process */</span></span><br><span class="line">    <span class="keyword">gid_t</span> gid;    <span class="comment">/* group ID of the sending process */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>另外，由于 <code>/dev/socket/logdw</code> 的类型是 dgram，所以传给 <code>SocketListener</code> 的第二个参数 <code>listen == false</code>。</p><p>父类 <code>SocketListener</code> 是 sysutils 库提供的类，用于监听 socket。当有数据可读的时候，<code>SocketListener</code> 会回调子类的 <code>onDataAvailable</code>。在本篇，我们先看看它的实现。</p><p>不多废话了，直接看代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SocketListener::SocketListener(<span class="keyword">int</span> socketFd, <span class="keyword">bool</span> listen) &#123;</span><br><span class="line">    init(<span class="literal">NULL</span>, socketFd, listen, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SocketListener::init(<span class="keyword">const</span> <span class="keyword">char</span> *socketName, <span class="keyword">int</span> socketFd, <span class="keyword">bool</span> listen, <span class="keyword">bool</span> useCmdNum) &#123;</span><br><span class="line">    mListen = listen;</span><br><span class="line">    mSocketName = socketName;</span><br><span class="line">    mSock = socketFd;</span><br><span class="line">    mUseCmdNum = useCmdNum;</span><br><span class="line">    pthread_mutex_init(&amp;mClientsLock, <span class="literal">NULL</span>);</span><br><span class="line">    mClients = <span class="keyword">new</span> SocketClientCollection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libsysutils/include/sysutils/SocketClient.h</span></span><br><span class="line"><span class="keyword">typedef</span> android::sysutils::List&lt;SocketClient *&gt; SocketClientCollection;</span><br></pre></td></tr></table></figure></p><p><code>LocketListener</code> 的构造函数里，依然是很简单的。其中，<code>SocketClient</code> 表示一个客户的连接。</p><h2 id="监听客户端请求"><a href="#监听客户端请求" class="headerlink" title="监听客户端请求"></a>监听客户端请求</h2><p>初始化 <code>LogListener</code> 后，<code>main</code> 函数执行 <code>swl-&gt;startListener(600)</code> 开始监听客户请求。<code>startListener</code> 是 <code>SocketListener</code> 中的方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> SocketListener::startListener(<span class="keyword">int</span> backlog) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mSocketName &amp;&amp; mSock == <span class="number">-1</span>) &#123;</span><br><span class="line">        SLOGE(<span class="string">"Failed to start unbound listener"</span>);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSocketName) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mSock = android_get_control_socket(mSocketName)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            SLOGE(<span class="string">"Obtaining file descriptor socket '%s' failed: %s"</span>,</span><br><span class="line">                 mSocketName, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SLOGV(<span class="string">"got mSock = %d for %s"</span>, mSock, mSocketName);</span><br><span class="line">        fcntl(mSock, F_SETFD, FD_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mListen &amp;&amp; listen(mSock, backlog) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        SLOGE(<span class="string">"Unable to listen on socket (%s)"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mListen)</span><br><span class="line">        mClients-&gt;push_back(<span class="keyword">new</span> SocketClient(mSock, <span class="literal">false</span>, mUseCmdNum));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(mCtrlPipe)) &#123;</span><br><span class="line">        SLOGE(<span class="string">"pipe failed (%s)"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;mThread, <span class="literal">NULL</span>, SocketListener::threadStart, <span class="keyword">this</span>)) &#123;</span><br><span class="line">        SLOGE(<span class="string">"pthread_create (%s)"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于 <code>LogListener</code> 的情况，<code>mSocketName == null, mSock != -1, mListen == false, mUseCmdNum == false</code>，这里实际执行的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mClients-&gt;push_back(<span class="keyword">new</span> SocketClient(mSock, <span class="literal">false</span>, mUseCmdNum));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe(mCtrlPipe)) &#123;</span><br><span class="line">    SLOGE(<span class="string">"pipe failed (%s)"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_create(&amp;mThread, <span class="literal">NULL</span>, SocketListener::threadStart, <span class="keyword">this</span>)) &#123;</span><br><span class="line">    SLOGE(<span class="string">"pthread_create (%s)"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>现在，是时候看看 <code>SocketClient</code> 了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libsysutils/src/SocketClient.cpp</span></span><br><span class="line">SocketClient::SocketClient(<span class="keyword">int</span> socket, <span class="keyword">bool</span> owned, <span class="keyword">bool</span> useCmdNum) &#123;</span><br><span class="line">    init(socket, owned, useCmdNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libsysutils/src/SocketClient.cpp</span></span><br><span class="line"><span class="keyword">void</span> SocketClient::init(<span class="keyword">int</span> socket, <span class="keyword">bool</span> owned, <span class="keyword">bool</span> useCmdNum) &#123;</span><br><span class="line">    mSocket = socket;</span><br><span class="line">    mSocketOwned = owned;</span><br><span class="line">    mUseCmdNum = useCmdNum;</span><br><span class="line">    pthread_mutex_init(&amp;mWriteMutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mRefCountMutex, <span class="literal">NULL</span>);</span><br><span class="line">    mPid = <span class="number">-1</span>;</span><br><span class="line">    mUid = <span class="number">-1</span>;</span><br><span class="line">    mGid = <span class="number">-1</span>;</span><br><span class="line">    mRefCount = <span class="number">1</span>;</span><br><span class="line">    mCmdNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> <span class="title">creds</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> szCreds = <span class="keyword">sizeof</span>(creds);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;creds, <span class="number">0</span>, szCreds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &amp;creds, &amp;szCreds);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">        mPid = creds.pid;</span><br><span class="line">        mUid = creds.uid;</span><br><span class="line">        mGid = creds.gid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里要注意的是，上面的那个 <code>getsockopt</code> 虽然会返回成功，但是 <code>creds</code> 里面的指都是无效的，毕竟，这个就是我们本地生成的 socket （而不是某个客户的连接）。</p><p>把 <code>mSock</code> 放到 <code>mClients</code> 里面后，再创建一个 <code>mCtrlPipe</code>，这个 pipe 将会用于唤醒 <code>select</code> 系统调用。这是一种非常常见的用法。</p><p>随后，创建一个线程监听 <code>mClients</code> 和 <code>mCtrlPipe</code>。下面我们看看这个线程里做了什么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libsysutils/src/SocketListener.cpp</span></span><br><span class="line"><span class="keyword">void</span> *SocketListener::threadStart(<span class="keyword">void</span> *obj) &#123;</span><br><span class="line">    SocketListener *me = <span class="keyword">reinterpret_cast</span>&lt;SocketListener *&gt;(obj);</span><br><span class="line"></span><br><span class="line">    me-&gt;runListener();</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libsysutils/src/SocketListener.cpp</span></span><br><span class="line"><span class="keyword">void</span> SocketListener::runListener() &#123;</span><br><span class="line"></span><br><span class="line">    SocketClientCollection pendingList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        SocketClientCollection::iterator it;</span><br><span class="line">        fd_set read_fds;</span><br><span class="line">        <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        FD_ZERO(&amp;read_fds);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mListen) &#123;</span><br><span class="line">            max = mSock;</span><br><span class="line">            FD_SET(mSock, &amp;read_fds);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FD_SET(mCtrlPipe[<span class="number">0</span>], &amp;read_fds);</span><br><span class="line">        <span class="keyword">if</span> (mCtrlPipe[<span class="number">0</span>] &gt; max)</span><br><span class="line">            max = mCtrlPipe[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">        <span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123;</span><br><span class="line">            <span class="comment">// NB: calling out to an other object with mClientsLock held (safe)</span></span><br><span class="line">            <span class="keyword">int</span> fd = (*it)-&gt;getSocket();</span><br><span class="line">            FD_SET(fd, &amp;read_fds);</span><br><span class="line">            <span class="keyword">if</span> (fd &gt; max) &#123;</span><br><span class="line">                max = fd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line">        SLOGV(<span class="string">"mListen=%d, max=%d, mSocketName=%s"</span>, mListen, max, mSocketName);</span><br><span class="line">        <span class="keyword">if</span> ((rc = select(max + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            SLOGE(<span class="string">"select failed (%s) mListen=%d, max=%d"</span>, strerror(errno), mListen, max);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!rc)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(mCtrlPipe[<span class="number">0</span>], &amp;read_fds)) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = CtrlPipe_Shutdown;</span><br><span class="line">            TEMP_FAILURE_RETRY(read(mCtrlPipe[<span class="number">0</span>], &amp;c, <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (c == CtrlPipe_Shutdown) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mListen &amp;&amp; FD_ISSET(mSock, &amp;read_fds)) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = TEMP_FAILURE_RETRY(accept4(mSock, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, SOCK_CLOEXEC));</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                SLOGE(<span class="string">"accept failed (%s)"</span>, strerror(errno));</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">            mClients-&gt;push_back(<span class="keyword">new</span> SocketClient(c, <span class="literal">true</span>, mUseCmdNum));</span><br><span class="line">            pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Add all active clients to the pending list first */</span></span><br><span class="line">        pendingList.clear();</span><br><span class="line">        pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">        <span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123;</span><br><span class="line">            SocketClient* c = *it;</span><br><span class="line">            <span class="comment">// NB: calling out to an other object with mClientsLock held (safe)</span></span><br><span class="line">            <span class="keyword">int</span> fd = c-&gt;getSocket();</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(fd, &amp;read_fds)) &#123;</span><br><span class="line">                pendingList.push_back(c);</span><br><span class="line">                c-&gt;incRef();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Process the pending list, since it is owned by the thread,</span></span><br><span class="line"><span class="comment">         * there is no need to lock it */</span></span><br><span class="line">        <span class="keyword">while</span> (!pendingList.empty()) &#123;</span><br><span class="line">            <span class="comment">/* Pop the first item from the list */</span></span><br><span class="line">            it = pendingList.begin();</span><br><span class="line">            SocketClient* c = *it;</span><br><span class="line">            pendingList.erase(it);</span><br><span class="line">            <span class="comment">/* Process it, if false is returned, remove from list */</span></span><br><span class="line">            <span class="keyword">if</span> (!onDataAvailable(c)) &#123;</span><br><span class="line">                release(c, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            c-&gt;decRef();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然这段代码很长，但是它的逻辑还是很直接的：</p><ol><li>用 <code>select</code> 在所有描述符上等待</li><li>往 <code>mCtrlPipe</code> 写入 <code>CtrlPipe_Shutdown</code> 后，线程退出。其他字符只会唤醒 <code>select</code></li><li>如果 <code>mSock</code> 是个监听套接字并且可读，表示有客户连接，<code>accept</code> socket 连接</li><li>处理所有可读的 socket（回调子类的 <code>onDataAvailable</code> 函数）</li></ol><p>对于 <code>LogListener</code> 来说，<code>mClients</code> 永远只会有一个 socket（就是前面我们创建的那一个）。当它可读时，表示有客户端要写入 log。</p><p>如果 <code>onDataAvailable</code> 返回了 <code>false</code>，调用 <code>release</code> 函数删除对应的 socket：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libsysutils/src/SocketListener.cpp</span></span><br><span class="line"><span class="keyword">bool</span> SocketListener::release(SocketClient* c, <span class="keyword">bool</span> wakeup) &#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* if our sockets are connection-based, remove and destroy it */</span></span><br><span class="line">    <span class="keyword">if</span> (mListen &amp;&amp; c) &#123;</span><br><span class="line">        <span class="comment">/* Remove the client from our array */</span></span><br><span class="line">        SLOGV(<span class="string">"going to zap %d for %s"</span>, c-&gt;getSocket(), mSocketName);</span><br><span class="line">        pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">        SocketClientCollection::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it == c) &#123;</span><br><span class="line">                mClients-&gt;erase(it);</span><br><span class="line">                ret = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            ret = c-&gt;decRef();</span><br><span class="line">            <span class="keyword">if</span> (wakeup) &#123;</span><br><span class="line">                <span class="keyword">char</span> b = CtrlPipe_Wakeup;</span><br><span class="line">                TEMP_FAILURE_RETRY(write(mCtrlPipe[<span class="number">1</span>], &amp;b, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为此时我们还在工作线程的循环里，把对应的 <code>SocketClient</code> 删掉后，在下一轮循环就会重新初始化 <code>select</code> 的参数，所以这里传递给 <code>release</code> 的 <code>wakeup</code> 参数为 <code>false</code>。</p><p>刚创建的 <code>SocketClient</code> 的 <code>mRefCount == 1</code>，所以，<code>SocketListener::release()</code> 里面执行 <code>c-&gt;decRef()</code> 后还不会删除对象。对象要在 <code>release</code> 返回后再次执行 <code>c-&gt;decRef()</code> 时才会真正释放。</p><p>按道理，接下来就应该看 <code>LogListener::onDataAvailable</code>，但是，这篇文章实在是太长了，我已经写得很不耐烦。所以，还是把它留到下一篇吧。</p><p>出于完整性，下面我们顺便看看 <code>SocketListener</code> 是如何停止的工作线程的。</p><h2 id="SocketListener-的停止"><a href="#SocketListener-的停止" class="headerlink" title="SocketListener 的停止"></a>SocketListener 的停止</h2><p><code>SocketListener</code> 的停止由 <code>stopListener</code> 负责：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libsysutils/src/SocketListener.cpp</span></span><br><span class="line"><span class="keyword">int</span> SocketListener::stopListener() &#123;</span><br><span class="line">    <span class="keyword">char</span> c = CtrlPipe_Shutdown;</span><br><span class="line">    <span class="keyword">int</span>  rc;</span><br><span class="line"></span><br><span class="line">    rc = TEMP_FAILURE_RETRY(write(mCtrlPipe[<span class="number">1</span>], &amp;c, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        SLOGE(<span class="string">"Error writing to control pipe (%s)"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(mThread, &amp;ret)) &#123;</span><br><span class="line">        SLOGE(<span class="string">"Error joining to listener thread (%s)"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(mCtrlPipe[<span class="number">0</span>]);</span><br><span class="line">    close(mCtrlPipe[<span class="number">1</span>]);</span><br><span class="line">    mCtrlPipe[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    mCtrlPipe[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSocketName &amp;&amp; mSock &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        close(mSock);</span><br><span class="line">        mSock = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SocketClientCollection::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end();) &#123;</span><br><span class="line">        <span class="keyword">delete</span> (*it);</span><br><span class="line">        it = mClients-&gt;erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用 <code>stopListener</code> 的时候，工作线程可能还在 <code>select</code> 上阻塞。这里，通过往 <code>mCtrlPipe</code> 写入数据，就可以唤醒 <code>select</code>。随后，就像我们上面看到，写入 <code>CtrlPipe_Shutdown</code> 后将导致工作线程退出循环。</p><p><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;按计划，在本篇，我们先看 &lt;code&gt;LogBuffer&lt;/code&gt; 的初始化，然后深入 &lt;code&gt;LogListener&lt;/code&gt;。&lt;code&gt;LogListener&lt;/code&gt; 用于接受客户写入的 log 数据。虽然在 &lt;code&gt;main&lt;/code&gt; 函数
      
    
    </summary>
    
      <category term="Android" scheme="https://jekton.github.io/categories/Android/"/>
    
    
      <category term="Android source" scheme="https://jekton.github.io/tags/Android-source/"/>
    
      <category term="logd" scheme="https://jekton.github.io/tags/logd/"/>
    
  </entry>
  
</feed>
