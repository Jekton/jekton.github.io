<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android P 源码分析 1 - 轻量级智能指针的实现 | 初级程序员虾饺</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android P 源码分析 1 - 轻量级智能指针的实现</h1><a id="logo" href="/.">初级程序员虾饺</a><p class="description">Learning for fun</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android P 源码分析 1 - 轻量级智能指针的实现</h1><div class="post-meta">Mar 6, 2019<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2019/03/06/android9-light-sp/" href="/2019/03/06/android9-light-sp/#disqus_thread"></a><div class="post-content"><h2 id="开篇词"><a href="#开篇词" class="headerlink" title="开篇词"></a>开篇词</h2><p>去年（2018）二季度写过几篇 Android 源码相关的文章，后来由于太懒中断了，一晃眼一整年什么也没干成。经过几个月的迷茫，终于在年底开始发奋学习。慢慢把一些基础捡回来后，兜兜转转，看源码的时机又来了。文章标题里的那个“1”显然表示此刻的我雄心勃勃，也希望自己能够坚持下去，改掉虎头蛇尾的毛病。</p>
<p>分析 Android 源码的书籍中，最厚重的无疑是老罗的《Android 源代码情景分析》，目前我也是使用它作为主要的参考书。前期的写作基本会按照老罗书中的脉络进行，如果有幸坚持下来，再另外找话题继续探索。跟老罗书中不同的是，喜新厌旧的我将会基于 Android P（<code>pie-release</code>分支）来讲解，不然就太没意思了。</p>
<p>由于作者水平有限，没办法在文章把涉及的知识点给大家一一罗列，只能在相关地方推荐几本参考书。如果大家对某个知识点有疑惑，可以是找个安静的时间，慢慢享受一本纸质书。</p>
<p>下面我们进入正题，先拿 Android 的轻量级指针来热热身。</p>
<h2 id="关于智能指针的一点点背景知识"><a href="#关于智能指针的一点点背景知识" class="headerlink" title="关于智能指针的一点点背景知识"></a>关于智能指针的一点点背景知识</h2><p>文章假设你有一定的 C++ 基础，不熟悉的读者可以参考《C++ Primer》。也希望读者可以下载一份源码，毕竟在网页上没法在代码直接进行跳转，整体性也差一点。如果你想了解更多智能指针的知识，《More Effective》将会是一本很棒的书，很值得一读。</p>
<p>标准的 C++ 并支持垃圾收集，这就需要用户手动释放内存资源。当多个模块通过一个指针共享对象实例时，对象的所有权往往非常地模糊，这就很容易让用户在什么时候删除对象这个问题上产生疑惑。幸运的时候，利用 RAII(Resource Acquisition Is Initialization，参考《The C++ Programming Language》，不了解也没关系)，我们可以系统地、自动地管理对象的生命周期。</p>
<p>所谓的智能指针，就是在对象的内部维持一个计数；我们在类的构造函数里对计数增加 1，并在析构函数减 1。如果当前我们是最后一个人引用这个对象，那么计数值在析构函数里减 1 后就应该等于 0，此时对象可以被安全地删除。</p>
<h2 id="轻量级指针的用法"><a href="#轻量级指针的用法" class="headerlink" title="轻量级指针的用法"></a>轻量级指针的用法</h2><p>先了解一下 API，对我们阅读源码是非常有帮助的，这里我们先看看一个小例子，学一学怎么使用轻量级指针。</p>
<p>首先，对应希望被智能指针引用的类应该继承 <code>LightRefBase</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> LightRefBase&lt;Foo&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们通过 <code>sp</code> 来引用它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 sp，sp 指 strong pointer，它是一个智能指针，用来管理我们的 Foo 对象</span></span><br><span class="line">  sp&lt;Foo&gt; p&#123;<span class="keyword">new</span> Foo&#125;;   <span class="comment">// 此时计数值为 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> p2 = p;    <span class="comment">// 计数值 = 2</span></span><br><span class="line">    p2-&gt;foo();</span><br><span class="line">  &#125; <span class="comment">// p2 销毁，计数值 = 1</span></span><br><span class="line">  p-&gt;foo();</span><br><span class="line">&#125;   <span class="comment">// p 销毁，计数值 = 0，Foo 对象也销毁</span></span><br></pre></td></tr></table></figure></p>
<p>下面我们一起来看看它的源码。</p>
<h2 id="计数器-LightRefBase-的实现"><a href="#计数器-LightRefBase-的实现" class="headerlink" title="计数器 LightRefBase 的实现"></a>计数器 LightRefBase 的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/LightRefBase.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LightRefBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    inline LightRefBase() : mCount(0) &#123; &#125;</span><br><span class="line">    inline void incStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">        mCount.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCount.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! DEBUGGING ONLY: Get current strong ref count.</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> int32_t <span class="title">getStrongCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mCount.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> LightRefBase&lt;T&gt; basetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 注意，析构函数是 protected，这就限定了 LightRefBase 只能被继承</span></span><br><span class="line">    <span class="keyword">inline</span> ~LightRefBase() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int32_t</span>&gt; mCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>incStrong</code> 的实现很简单，由于引用计数 <code>mCount</code> 不跟其他数据具有依赖关系，这里直接用 <code>memory_order_relaxed</code> 就可以了。</p>
<p><code>decStrong</code> 里，<code>fetch_sub</code> 在给 <code>mCount</code> 减 1 的同时返回了原来的值，如果旧值是 1，说明我们是最后一个引用对象的人，接下来就改删除对象了。<code>if</code> 语句里的 <code>atomic_thread_fence</code> 和 <code>fetch_sub</code> 构成了一个 <em>Atomic-fence synchronization</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo : public LightRefBase &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Thread A                                Thread B</span><br><span class="line">---------                               -----------</span><br><span class="line">do with Foo*                            do with Foo*</span><br><span class="line">fetch_sub(1, memory_order_release)</span><br><span class="line">  =&gt; mCount = 1</span><br><span class="line">                                        fetch_sub(1, memory_order_release)</span><br><span class="line">                                        atomic_thread_fense(memory_order_acquire)</span><br><span class="line">                                        delete Foo*</span><br></pre></td></tr></table></figure></p>
<p>假定存在这么一个对象 Foo*，它同时被线程 A、B 引用。线程 A 使用完以后，先执行了 <code>decStrong</code>；在线程 B <code>decStrong</code> 的时候，检查到 <code>mCount</code> 的旧值为 1，于是执行 <code>if</code> 语句中的内容。</p>
<p>所谓的 <em>Atomic-fense synchronization</em> 就是，在线程 A 中，do with Foo<em> 比 fetch_sub 先执行；线程 A 的 fetch_sub 比 线程 B 的 fetch_sub 先执行；线程 B 的 atomic_thread_fense 保证了 fetch_sub 比 delete Foo</em> 先执行。所以，线程 B 删除对象的引用的时候，线程 A 的 do with Foo<em> 一定以及执行完了。如果没有这个 fense，那么 delete Foo</em> 就可以在 fetch_sub 前面执行，而此时可能其他线程还在使用该对象。</p>
<p>原因 momory order 和 atomic_thread_fense 的更多信息，读者可以参考 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">memory_order</a> 和 <a href="https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence" target="_blank" rel="noopener">atomic_thread_fence</a>。</p>
<p>说了这么多，你可能就会想问，有没有其他更简单的方法来实现 <code>decStrong</code> 呢？有的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCount.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acq_rel) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题在于，<code>if</code> 语句的条件只在最后一个持有引用的人执行时才会为 <code>true</code>；这种情况下，我们才需要一个 <code>acquire operation</code>。这是通过性能换取代码复杂性的一个例子。</p>
<h2 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h2><p>智能指针的实现是 <code>sp</code>，这里我们只看最关键的几个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/include/utils/StrongPointer.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    sp(T* other);  <span class="comment">// NOLINT(implicit)</span></span><br><span class="line">    ~sp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> T&amp;       <span class="keyword">operator</span>* () <span class="keyword">const</span>     &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">    <span class="keyword">inline</span> T*       <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span>    &#123; <span class="keyword">return</span> m_ptr;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T*       <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span>            </span>&#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr != <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    T* m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>直接通过指针来构造 sp 的情况很简单，如果传入的指针非空，就调用 <code>incStrong</code> 增加一个引用计数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt;::sp(T* other)</span><br><span class="line">        : m_ptr(other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other)</span><br><span class="line">        other-&gt;incStrong(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>析构的时候，调用 <code>decStrong</code>，如果引用计数降为 0，<code>decStrong</code> 将会删除 <code>m_ptr</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt;::~sp() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr)</span><br><span class="line">        m_ptr-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LightRefBase-设计问题"><a href="#LightRefBase-设计问题" class="headerlink" title="LightRefBase 设计问题"></a>LightRefBase 设计问题</h2><p>不得不说，轻量级指针除了 decStrong 的原子操作比较费解外，其他实现都是非常直观的。但如果我们留心观察，还是能够找到一些闪光点的。</p>
<h3 id="为什么要让被管理对象继承-LightRefBase"><a href="#为什么要让被管理对象继承-LightRefBase" class="headerlink" title="为什么要让被管理对象继承 LightRefBase"></a>为什么要让被管理对象继承 LightRefBase</h3><p>从易用性的角度考虑，如果被管理对象（如前面例子里的 Foo）不需要继承 <code>LightRefBase</code>，无疑用起来会更加的方便。在考虑这个问题的时候，不妨看一看 <code>LightRefBase</code> 都有什么成员变量。可以看到，我们把引用计数存放在了 <code>LightRefBase</code> 里。这样一来，在堆上创建对象的时候，我们只需要分配一次内存。</p>
<p>如果不这样做，我们将不得不在堆上分配多一个对象，用来保存引用的计数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotSoLightSP</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  NotSoLightSP(T* ptr)</span><br><span class="line">      : count_&#123;<span class="keyword">new</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>&#125;&#125;, ptr_&#123;ptr&#125; &#123;&#125;</span><br><span class="line">  NotSoLightSP(<span class="keyword">const</span> NotSoLightSP&lt;T&gt;&amp; other)</span><br><span class="line">      : count_&#123;other.count_&#125;, ptr_&#123;other.ptr_&#125; &#123;</span><br><span class="line">    count_-&gt;fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~NotSoLightSP() &#123;</span><br><span class="line">    <span class="keyword">if</span> (count_-&gt;fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release) == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">      <span class="keyword">delete</span> count_;</span><br><span class="line">      <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">RefCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count_-&gt;load(<span class="built_in">std</span>::memory_order_relaxed); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;* count_;</span><br><span class="line">  T* ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Foo() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Foo() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Foo()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NotSoLightSP&lt;Foo&gt; sp&#123;<span class="keyword">new</span> Foo&#125;;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp2 = sp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count = "</span> &lt;&lt; sp2.RefCount() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count = "</span> &lt;&lt; sp.RefCount() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo()</span><br><span class="line">ref count = 2</span><br><span class="line">ref count = 1</span><br><span class="line">~Foo()</span><br></pre></td></tr></table></figure></p>
<p>最后，我们再参考 C++ 标准库的 <code>shared_ptr</code> 来讲一讲。对 <code>shared_ptr</code> 来说，一般情况下它也是需要在堆上分配对一个对象用于保存引用计数的；不那么一般的情况是，<code>make_shared</code>，这个时候它可以分配一个大的内存块，然后使用 placement new 来构造这两个对象（待管理对象和引用计数都放在这个内存块中）。</p>
<h3 id="为什么-LightRefBase-是一个类模板（而-RefBase-却不是）"><a href="#为什么-LightRefBase-是一个类模板（而-RefBase-却不是）" class="headerlink" title="为什么 LightRefBase 是一个类模板（而 RefBase 却不是）"></a>为什么 LightRefBase 是一个类模板（而 RefBase 却不是）</h3><p>如果读者还没了解过 <code>RefBase</code>，可以在我发完下一篇文章的时候再回来看这一小节。</p>
<p>细心的读者应该留意到，我们是这样继承 LightRefBase 的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> LightRefBase&lt;Foo&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>而 <code>RefBase</code> 是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> :</span> <span class="keyword">public</span> RefBase &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>要寻找这个问题的答案，可以看看 <code>LightRefBase</code> 用模板参数来做了什么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCount.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，整个类唯一使用了 <code>T</code> 的地方就是这里。由于 <code>LightRefBase</code> 没有虚函数，所以在 delete this 指针的时候，需要把它强制转换为真正的类型 <code>T*</code>，否则将不会执行 <code>T::~T()</code>。另一方面，<code>RefBase::~Refbase()</code> 是一个虚函数，所以 <code>RefBase</code> 不需要把 this 强转回真正的类型就能够 delete this。</p>
<p><code>LightRefBase</code> 之所以搞得这么麻烦，和前一个问题一样，都是为了性能。如果把析构函数是虚函数，那么每个子类都将多消耗一个指针用于存储函数表，这样就不够“light”(轻量)了。</p>
</div><div class="tags"><a href="/tags/Android-source/">Android source</a></div><div class="post-nav"><a class="next" href="/2018/12/15/linux-wait-event/">Java 程序员眼里的 Linux 内核 —— wait_event 源码分析</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://jekton.github.io/2019/03/06/android9-light-sp/';
    this.page.identifier = '2019/03/06/android9-light-sp/';
    this.page.title = 'Android P 源码分析 1 - 轻量级智能指针的实现';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jekton-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jekton-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jekton-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dart/">Dart</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Dart/" style="font-size: 15px;">Dart</a> <a href="/tags/Android-source/" style="font-size: 15px;">Android source</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/openjdk/" style="font-size: 15px;">openjdk</a> <a href="/tags/Android-arch/" style="font-size: 15px;">Android arch</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/logd/" style="font-size: 15px;">logd</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/parallel-programming/" style="font-size: 15px;">parallel-programming</a> <a href="/tags/Glide/" style="font-size: 15px;">Glide</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/android9-light-sp/">Android P 源码分析 1 - 轻量级智能指针的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/linux-wait-event/">Java 程序员眼里的 Linux 内核 —— wait_event 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/linux-page-table-setup/">Linux 内核页表的创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/note-x86-provisional-kernel-page-table-setup/">《深入理解 LINUX 内核》读书笔记 - 临时内核页表</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/flutter-plugin-dev/">Flutter 开发（5）- 插件的使用、开发和发布</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/dart-tutorial/">Dart 语言入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/flutter-io-basic/">Flutter 开发（4）- 文件、存储和网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/29/flutter-ux-basic/">Flutter 开发（3）- 交互、动画、手势和事件处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/flutter-ui-basic/">Flutter 开发（2）- UI控件和布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/flutter-first-app/">Flutter 开发（1）- 开发框架、流程、编译打包、调试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jekton-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">初级程序员虾饺.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>