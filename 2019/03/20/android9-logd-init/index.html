<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android P 源码分析 4 - logd 的初始化 | 初级程序员虾饺</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android P 源码分析 4 - logd 的初始化</h1><a id="logo" href="/.">初级程序员虾饺</a><p class="description">Learning for fun</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android P 源码分析 4 - logd 的初始化</h1><div class="post-meta">Mar 20, 2019<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2019/03/20/android9-logd-init/" href="/2019/03/20/android9-logd-init/#disqus_thread"></a><div class="post-content"><p>为了跟老罗的书保持一个比较一致的步伐，这一篇开始我们来看 logd 的实现。当然，这个 logd 不是老罗书里讲的 log 驱动，而是在应用层实现的一个守护进程。</p>
<a id="more"></a>
<p>在进入正题之前先说明一下，logd 虽然是用 C++ 写的，但由于比较接近系统，需要读者对系统编程有一定的了解。不熟悉的读者可以通过《Linux系统编程》快速入个门，《UNIX环境高级程序设计》则是关于这一主题最好的书籍。</p>
<h2 id="logd-的启动"><a href="#logd-的启动" class="headerlink" title="logd 的启动"></a>logd 的启动</h2><p>通过查看 logd 源码目录，我们可以看到这样一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// system/core/logd/logd.rc</span><br><span class="line">service logd /system/bin/logd</span><br><span class="line">    socket logd stream 0666 logd logd</span><br><span class="line">    socket logdr seqpacket 0666 logd logd</span><br><span class="line">    socket logdw dgram+passcred 0222 logd logd</span><br><span class="line">    file /proc/kmsg r</span><br><span class="line">    file /dev/kmsg w</span><br><span class="line">    user logd</span><br><span class="line">    group logd system package_info readproc</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line"></span><br><span class="line">service logd-reinit /system/bin/logd --reinit</span><br><span class="line">    oneshot</span><br><span class="line">    disabled</span><br><span class="line">    user logd</span><br><span class="line">    group logd</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    write /dev/event-log-tags &quot;# content owned by logd</span><br><span class="line">&quot;</span><br><span class="line">    chown logd logd /dev/event-log-tags</span><br><span class="line">    chmod 0644 /dev/event-log-tags</span><br></pre></td></tr></table></figure></p>
<p>init 进程是在 post-fs 阶段启动 logd 的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// system/core/rootdir/init.rc</span><br><span class="line">on post-fs</span><br><span class="line">    # Load properties from</span><br><span class="line">    #     /system/build.prop,</span><br><span class="line">    #     /odm/build.prop,</span><br><span class="line">    #     /vendor/build.prop and</span><br><span class="line">    #     /factory/factory.prop</span><br><span class="line">    load_system_props</span><br><span class="line">    # start essential services</span><br><span class="line">    start logd</span><br><span class="line">    start servicemanager</span><br><span class="line">    start hwservicemanager</span><br><span class="line">    start vndservicemanage</span><br></pre></td></tr></table></figure></p>
<p>从这里我们可以得出几个信息：</p>
<ol>
<li>logd 是经由 init 进程启动的</li>
<li>init 进程为 logd 创建了 3 个（UNIX 域）socket，分别是 <code>/dev/socket/logd, /dev/socket/logdr, /dev/socket/logdw</code></li>
<li>init 进程为 logd 打开了两个文件 <code>/proc/kmsg, /dev/kmsg</code></li>
<li>把 logd 的 uid 设置为 logd，gid 设置为 logd、system、package_info 和 readproc</li>
<li>把 logd 进程的 pid 写到文件 /dev/cpuset/system-background/tasks</li>
</ol>
<p>关于 socket 的相关知识，读者可以参考《UNIX 网络编程，卷1》。</p>
<p>logd-reinit 用来触发 logd 的重新初始化，同样执行的是 logd 程序，只是多了一个参数 <code>--init</code>。后面我们讲 logd 的控制命令时再详细说。</p>
<p>至于 init 进程如何解析 init.rc，以后有机会写 init 进程相关文章的时候再讨论。</p>
<h2 id="logd-的初始化"><a href="#logd-的初始化" class="headerlink" title="logd 的初始化"></a>logd 的初始化</h2><p>init 进程启动 logd 后，接下来执行的自然是 logd 的 <code>main</code> 函数。这个函数有点长，这里先把代码放上来，后面再一点点慢慢看。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/logd/main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Foreground waits for exit of the main persistent threads</span></span><br><span class="line"><span class="comment">// that are started here. The threads are created to manage</span></span><br><span class="line"><span class="comment">// UNIX domain client sockets for writing, reading and</span></span><br><span class="line"><span class="comment">// controlling the user space logger, and for any additional</span></span><br><span class="line"><span class="comment">// logging plugins like auditd and restart control. Additional</span></span><br><span class="line"><span class="comment">// transitory per-client threads are created for each reader.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// logd is written under the assumption that the timezone is UTC.</span></span><br><span class="line">    <span class="comment">// If TZ is not set, persist.sys.timezone is looked up in some time utility</span></span><br><span class="line">    <span class="comment">// libc functions, including mktime. It confuses the logd time handling,</span></span><br><span class="line">    <span class="comment">// so here explicitly set TZ to UTC, which overrides the property.</span></span><br><span class="line">    setenv(<span class="string">"TZ"</span>, <span class="string">"UTC"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// issue reinit command. KISS argument parsing.</span></span><br><span class="line">    <span class="keyword">if</span> ((argc &gt; <span class="number">1</span>) &amp;&amp; argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--reinit"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> issueReinit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> dev_kmsg[] = <span class="string">"/dev/kmsg"</span>;</span><br><span class="line">    fdDmesg = android_get_control_file(dev_kmsg);</span><br><span class="line">    <span class="keyword">if</span> (fdDmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fdDmesg = TEMP_FAILURE_RETRY(open(dev_kmsg, O_WRONLY | O_CLOEXEC));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fdPmesg = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> klogd = __android_logger_property_get_bool(</span><br><span class="line">        <span class="string">"ro.logd.kernel"</span>,</span><br><span class="line">        BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_ENG | BOOL_DEFAULT_FLAG_SVELTE);</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> proc_kmsg[] = <span class="string">"/proc/kmsg"</span>;</span><br><span class="line">        fdPmesg = android_get_control_file(proc_kmsg);</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fdPmesg = TEMP_FAILURE_RETRY(</span><br><span class="line">                open(proc_kmsg, O_RDONLY | O_NDELAY | O_CLOEXEC));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) android::prdebug(<span class="string">"Failed to open %s\n"</span>, proc_kmsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reinit Thread</span></span><br><span class="line">    sem_init(&amp;reinit, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;uidName, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_name, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">if</span> (!pthread_attr_init(&amp;attr)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(param));</span><br><span class="line">        pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line">        pthread_attr_setschedpolicy(&amp;attr, SCHED_BATCH);</span><br><span class="line">        <span class="keyword">if</span> (!pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED)) &#123;</span><br><span class="line">            <span class="keyword">pthread_t</span> thread;</span><br><span class="line">            reinit_running = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (pthread_create(&amp;thread, &amp;attr, reinit_thread_start, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">                reinit_running = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> auditd =</span><br><span class="line">        __android_logger_property_get_bool(<span class="string">"ro.logd.auditd"</span>, BOOL_DEFAULT_TRUE);</span><br><span class="line">    <span class="keyword">if</span> (drop_privs(klogd, auditd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serves the purpose of managing the last logs times read on a</span></span><br><span class="line">    <span class="comment">// socket connection, and as a reader lock on a range of log</span></span><br><span class="line">    <span class="comment">// entries.</span></span><br><span class="line"></span><br><span class="line">    LastLogTimes* times = <span class="keyword">new</span> LastLogTimes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogBuffer is the object which is responsible for holding all</span></span><br><span class="line">    <span class="comment">// log entries.</span></span><br><span class="line"></span><br><span class="line">    logBuf = <span class="keyword">new</span> LogBuffer(times);</span><br><span class="line"></span><br><span class="line">    signal(SIGHUP, reinit_signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__android_logger_property_get_bool(</span><br><span class="line">            <span class="string">"logd.statistics"</span>, BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_PERSIST |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_ENG |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_SVELTE)) &#123;</span><br><span class="line">        logBuf-&gt;enableStatistics();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogReader listens on /dev/socket/logdr. When a client</span></span><br><span class="line">    <span class="comment">// connects, log entries in the LogBuffer are written to the client.</span></span><br><span class="line"></span><br><span class="line">    LogReader* reader = <span class="keyword">new</span> LogReader(logBuf);</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogListener listens on /dev/socket/logdw for client</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogListener* swl = <span class="keyword">new</span> LogListener(logBuf, reader);</span><br><span class="line">    <span class="comment">// Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value</span></span><br><span class="line">    <span class="keyword">if</span> (swl-&gt;startListener(<span class="number">600</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Command listener listens on /dev/socket/logd for incoming logd</span></span><br><span class="line">    <span class="comment">// administrative commands.</span></span><br><span class="line"></span><br><span class="line">    CommandListener* cl = <span class="keyword">new</span> CommandListener(logBuf, reader, swl);</span><br><span class="line">    <span class="keyword">if</span> (cl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogAudit listens on NETLINK_AUDIT socket for selinux</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogAudit* al = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (auditd) &#123;</span><br><span class="line">        al = <span class="keyword">new</span> LogAudit(logBuf, reader,</span><br><span class="line">                          __android_logger_property_get_bool(</span><br><span class="line">                              <span class="string">"ro.logd.auditd.dmesg"</span>, BOOL_DEFAULT_TRUE)</span><br><span class="line">                              ? fdDmesg</span><br><span class="line">                              : <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogKlog* kl = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        kl = <span class="keyword">new</span> LogKlog(logBuf, reader, fdDmesg, fdPmesg, al != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readDmesg(al, kl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// failure is an option ... messages are in dmesg (required by standard)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kl &amp;&amp; kl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> kl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (al &amp;&amp; al-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> al;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TEMP_FAILURE_RETRY(pause());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="打开-dev-kmsg"><a href="#打开-dev-kmsg" class="headerlink" title="打开 /dev/kmsg"></a>打开 /dev/kmsg</h3><p>前面我们看 init.rc 的时候已经知道，init 进程会为我们打开设备文件 <code>/dev/kmsg</code>，所以这里我们只要找到他对应的文件描述符就可以了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fdDmesg = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> dev_kmsg[] = <span class="string">"/dev/kmsg"</span>;</span><br><span class="line">    fdDmesg = android_get_control_file(dev_kmsg);</span><br><span class="line">    <span class="keyword">if</span> (fdDmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fdDmesg = TEMP_FAILURE_RETRY(open(dev_kmsg, O_WRONLY | O_CLOEXEC));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子进程想要使用父进程为其打开的文件，一般情况下有这么几种方法：</p>
<ol>
<li>约定好对应的描述符是多少（比方说，使用 shell 对输入输出进行重定向，就是在 0 1 2 上打开文件）</li>
<li>通过命令行参数告诉子进程（如，<code>--kmsg 1</code>）</li>
<li>通过环境变量。这个是 init 进程采用的方法</li>
</ol>
<p>下面我们就来看看 <code>android_get_control_file</code> 是如何实现的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libcutils/android_get_control_file.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_FILE_ENV_PREFIX <span class="meta-string">"ANDROID_FILE_"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/libcutils/android_get_control_file.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">android_get_control_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = __android_get_control_from_env(ANDROID_FILE_ENV_PREFIX, path);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__)</span></span><br><span class="line">    <span class="comment">// Find file path from /proc and make sure it is correct</span></span><br><span class="line">    <span class="keyword">char</span> *proc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (asprintf(&amp;proc, <span class="string">"/proc/self/fd/%d"</span>, fd) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!proc) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="comment">// readlink() does not guarantee a nul byte, len+2 so we catch truncation.</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(<span class="built_in">calloc</span>(<span class="number">1</span>, len + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">        <span class="built_in">free</span>(proc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">ssize_t</span> ret = TEMP_FAILURE_RETRY(readlink(proc, buf, len + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(proc);</span><br><span class="line">    <span class="keyword">int</span> cmp = (len != <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(ret)) || <span class="built_in">strcmp</span>(buf, path);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmp != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// It is what we think it is</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bionic/libc/include/unistd.h</span></span><br><span class="line"><span class="comment">/* Used to retry syscalls that can return EINTR. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_FAILURE_RETRY(exp) (&#123;         \</span></span><br><span class="line">    __typeof__(<span class="built_in">exp</span>) _rc;                   \</span><br><span class="line">    <span class="keyword">do</span> &#123;                                   \</span><br><span class="line">        _rc = (<span class="built_in">exp</span>);                       \</span><br><span class="line">    &#125; <span class="keyword">while</span> (_rc == <span class="number">-1</span> &amp;&amp; errno == EINTR); \</span><br><span class="line">    _rc; &#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>__android_get_control_from_env</code> 拿到这个 <code>fd</code> 后，如果运行的系统是 Linux，就执行后面的一些检查。具体来说就是读符号链接 <code>/proc/self/fd/#fd_num</code> 的内容，如果这个内容跟 <code>path</code> 相等，就认为这个描述符确实是我们所需要的。</p>
<p><code>TEMP_FAILURE_RETRY</code> 在系统的源码里出现的频率很高，主要用来处理系统调动被信号中断的情况。<code>__typeof__</code> 是编译器提供的运算符，类似于 C++ 的 <code>decltype</code>。</p>
<p>下面我们看看 <code>__android_get_control_from_env</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libcutils/android_get_control_file.cpp</span></span><br><span class="line">LIBCUTILS_HIDDEN <span class="keyword">int</span> __android_get_control_from_env(<span class="keyword">const</span> <span class="keyword">char</span>* prefix,</span><br><span class="line">                                                    <span class="keyword">const</span> <span class="keyword">char</span>* name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prefix || !name) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *key = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (asprintf(&amp;key, <span class="string">"%s%s"</span>, prefix, name) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *cp = key;</span><br><span class="line">    <span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(*cp)) *cp = <span class="string">'_'</span>;</span><br><span class="line">        ++cp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* val = getenv(key);</span><br><span class="line">    <span class="built_in">free</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (!val) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> fd = strtol(val, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (errno) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// validity checking</span></span><br><span class="line">    <span class="keyword">if</span> ((fd &lt; <span class="number">0</span>) || (fd &gt; INT_MAX)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since we are inheriting an fd, it could legitimately exceed _SC_OPEN_MAX</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Still open?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(F_GETFD) <span class="comment">// Lowest overhead</span></span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(fcntl(fd, F_GETFD)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(F_GETFL) <span class="comment">// Alternate lowest overhead</span></span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// Hail Mary pass</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(fstat(fd, &amp;s)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面我们传入的的 <code>ANDROID_FILE_</code> 和 <code>/dev/kmsg</code>，这里我们把他们拼接起来得到 <code>ANDROID_FILE_/dev/kmsg</code>。随后的循环把不是字母、数字的字符换成 <code>_</code>，最后这个 key 是 <code>ANDROID_FILE__dev_kmsg</code>。</p>
<p>我们拿这个 key 去 <code>getenv</code>，如果存在这个环境变量，就调用 <code>strtol</code> 将其转换为 <code>long</code>。所谓的文件描述符，其实仅仅是一个数字。这里将 <code>val</code> 转换为 <code>long</code>，我们也就拿到了文件对应的 fd。</p>
<p>拿到这个 fd 后，还要验证一下它是不是还打开着。这里使用的方法是用 <code>fcntl</code> 去获取一下 fd flag。如果成功，文件自然是打开着的。</p>
<p>获取 fd flag 一般只需要访问文件表，所以是最快的；获取 file flag 要通过文件表去拿 file 对象，这个慢一点；而  file stat 则需要再通过 file 对象拿到 inode 节点的数据，这个是最慢的。</p>
<p>我们直接通过环境变量取得描述符，这并不能保证它就是我们所期望的文件（比方说，可以先关掉这个 fd，然后再打开任意一个文件，新打开的文件 fd 的数值将会和我们刚刚关闭的那个一样），所以在 <code>android_get_control_file</code> 里还要用 <code>/proc/self/fd/##</code> 验证多一次。</p>
<p><code>/dev/kmsg</code> 设备文件是用来读写内核 log 的，有兴趣的读者可以参考文档 <a href="https://www.kernel.org/doc/Documentation/ABI/testing/dev-kmsg" target="_blank" rel="noopener">dev-kmsg</a>。logd 本身提供的就是 log 机制，但在自己还没启动完成或者出错的时候，如果需要写 log，就只能写到内核的 log 去了。</p>
<h3 id="打开-proc-kmsg"><a href="#打开-proc-kmsg" class="headerlink" title="打开 /proc/kmsg"></a>打开 /proc/kmsg</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fdPmesg = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> klogd = __android_logger_property_get_bool(</span><br><span class="line">        <span class="string">"ro.logd.kernel"</span>,</span><br><span class="line">        BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_ENG | BOOL_DEFAULT_FLAG_SVELTE);</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> proc_kmsg[] = <span class="string">"/proc/kmsg"</span>;</span><br><span class="line">        fdPmesg = android_get_control_file(proc_kmsg);</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fdPmesg = TEMP_FAILURE_RETRY(</span><br><span class="line">                open(proc_kmsg, O_RDONLY | O_NDELAY | O_CLOEXEC));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fdPmesg &lt; <span class="number">0</span>) android::prdebug(<span class="string">"Failed to open %s\n"</span>, proc_kmsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开 <code>/proc/kmsg</code> 是为了读内核的日志，但这个是可选的，这里我们通过读系统属性来判断是否需要读内核的日志。</p>
<h3 id="启动-reinit-线程"><a href="#启动-reinit-线程" class="headerlink" title="启动 reinit 线程"></a>启动 reinit 线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line">    <span class="comment">// open /proc/kmsg</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reinit Thread</span></span><br><span class="line">    sem_init(&amp;reinit, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;uidName, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_name, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">if</span> (!pthread_attr_init(&amp;attr)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(param));</span><br><span class="line">        pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line">        pthread_attr_setschedpolicy(&amp;attr, SCHED_BATCH);</span><br><span class="line">        <span class="keyword">if</span> (!pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED)) &#123;</span><br><span class="line">            <span class="keyword">pthread_t</span> thread;</span><br><span class="line">            reinit_running = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (pthread_create(&amp;thread, &amp;attr, reinit_thread_start, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">                reinit_running = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reinit 线程主要处理最开始时前面我们提到了 reinit 命令。另外，logd 还使用这个线程做 uid 转 name 的工作。关于他的实现，后面我们讲 logd 的管理接口时再看。</p>
<h3 id="设置运行时优先级、权限"><a href="#设置运行时优先级、权限" class="headerlink" title="设置运行时优先级、权限"></a>设置运行时优先级、权限</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line">    <span class="comment">// open /proc/kmsg</span></span><br><span class="line">    <span class="comment">// 启动 Reinit Thread</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> auditd =</span><br><span class="line">        __android_logger_property_get_bool(<span class="string">"ro.logd.auditd"</span>, BOOL_DEFAULT_TRUE);</span><br><span class="line">    <span class="keyword">if</span> (drop_privs(klogd, auditd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分代码跟平台相关性比较大，普通的应用开发一般不会使用到这些。这部分我们这里先略过，后面用单独的一篇文章来讲。</p>
<h3 id="启动各个-log-监听器"><a href="#启动各个-log-监听器" class="headerlink" title="启动各个 log 监听器"></a>启动各个 log 监听器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open /dev/kmsg</span></span><br><span class="line">    <span class="comment">// open /proc/kmsg</span></span><br><span class="line">    <span class="comment">// 启动 Reinit Thread</span></span><br><span class="line">    <span class="comment">// 设置运行时优先级、权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serves the purpose of managing the last logs times read on a</span></span><br><span class="line">    <span class="comment">// socket connection, and as a reader lock on a range of log</span></span><br><span class="line">    <span class="comment">// entries.</span></span><br><span class="line"></span><br><span class="line">    LastLogTimes* times = <span class="keyword">new</span> LastLogTimes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogBuffer is the object which is responsible for holding all</span></span><br><span class="line">    <span class="comment">// log entries.</span></span><br><span class="line"></span><br><span class="line">    logBuf = <span class="keyword">new</span> LogBuffer(times);</span><br><span class="line"></span><br><span class="line">    signal(SIGHUP, reinit_signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__android_logger_property_get_bool(</span><br><span class="line">            <span class="string">"logd.statistics"</span>, BOOL_DEFAULT_TRUE | BOOL_DEFAULT_FLAG_PERSIST |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_ENG |</span><br><span class="line">                                   BOOL_DEFAULT_FLAG_SVELTE)) &#123;</span><br><span class="line">        logBuf-&gt;enableStatistics();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogReader listens on /dev/socket/logdr. When a client</span></span><br><span class="line">    <span class="comment">// connects, log entries in the LogBuffer are written to the client.</span></span><br><span class="line"></span><br><span class="line">    LogReader* reader = <span class="keyword">new</span> LogReader(logBuf);</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogListener listens on /dev/socket/logdw for client</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogListener* swl = <span class="keyword">new</span> LogListener(logBuf, reader);</span><br><span class="line">    <span class="comment">// Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value</span></span><br><span class="line">    <span class="keyword">if</span> (swl-&gt;startListener(<span class="number">600</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Command listener listens on /dev/socket/logd for incoming logd</span></span><br><span class="line">    <span class="comment">// administrative commands.</span></span><br><span class="line"></span><br><span class="line">    CommandListener* cl = <span class="keyword">new</span> CommandListener(logBuf, reader, swl);</span><br><span class="line">    <span class="keyword">if</span> (cl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LogAudit listens on NETLINK_AUDIT socket for selinux</span></span><br><span class="line">    <span class="comment">// initiated log messages. New log entries are added to LogBuffer</span></span><br><span class="line">    <span class="comment">// and LogReader is notified to send updates to connected clients.</span></span><br><span class="line"></span><br><span class="line">    LogAudit* al = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (auditd) &#123;</span><br><span class="line">        al = <span class="keyword">new</span> LogAudit(logBuf, reader,</span><br><span class="line">                          __android_logger_property_get_bool(</span><br><span class="line">                              <span class="string">"ro.logd.auditd.dmesg"</span>, BOOL_DEFAULT_TRUE)</span><br><span class="line">                              ? fdDmesg</span><br><span class="line">                              : <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogKlog* kl = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (klogd) &#123;</span><br><span class="line">        kl = <span class="keyword">new</span> LogKlog(logBuf, reader, fdDmesg, fdPmesg, al != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readDmesg(al, kl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// failure is an option ... messages are in dmesg (required by standard)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kl &amp;&amp; kl-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> kl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (al &amp;&amp; al-&gt;startListener()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> al;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TEMP_FAILURE_RETRY(pause());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面的这些代码实现上算是非常直观的，各个类的作用也都通过注释写得很清楚。<code>LogAudit</code> 读的是 selinux 的 log，<code>LogKlog</code> 读的是内核的 log，<code>readDmsg</code> 用 <code>klogctl</code> 把内核的 log 读出来以后，又把数据通过 <code>LogAudit</code> 和 <code>LogKlog</code> 写到由 logd 管理的 <code>LogBuffer</code> 里面。这两个我都不太熟悉，后面我们先就直接忽略他了。哪天补上了相关知识点，有机会再来写多两篇。</p>
<p>到目前为止，我们算是了解了 logd 的骨架，后面我们再分 4 篇文章，分别写 Linux 的权限控制、logd 命令控制、读 log 写 log。</p>
</div><div class="tags"><a href="/tags/Android-source/">Android source</a></div><div class="post-nav"><a class="pre" href="/2019/03/21/android9-lmk-lmkd/">Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</a><a class="next" href="/2019/03/19/android9-sp/">Android P 源码分析 3 - SharedPreferences 源码分析</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://jekton.github.io/2019/03/20/android9-logd-init/';
    this.page.identifier = '2019/03/20/android9-logd-init/';
    this.page.title = 'Android P 源码分析 4 - logd 的初始化';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jekton-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jekton-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jekton-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dart/">Dart</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Dart/" style="font-size: 15px;">Dart</a> <a href="/tags/Android-source/" style="font-size: 15px;">Android source</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/openjdk/" style="font-size: 15px;">openjdk</a> <a href="/tags/Android-arch/" style="font-size: 15px;">Android arch</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/logd/" style="font-size: 15px;">logd</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/parallel-programming/" style="font-size: 15px;">parallel-programming</a> <a href="/tags/Glide/" style="font-size: 15px;">Glide</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/android9-lmk-lmkd/">Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/android9-logd-init/">Android P 源码分析 4 - logd 的初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/19/android9-sp/">Android P 源码分析 3 - SharedPreferences 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/android9-sp-wp/">Android P 源码分析 2 - 强弱指针的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/android9-light-sp/">Android P 源码分析 1 - 轻量级智能指针的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/linux-wait-event/">Java 程序员眼里的 Linux 内核 —— wait_event 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/linux-page-table-setup/">Linux 内核页表的创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/note-x86-provisional-kernel-page-table-setup/">《深入理解 LINUX 内核》读书笔记 - 临时内核页表</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/flutter-plugin-dev/">Flutter 开发（5）- 插件的使用、开发和发布</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/dart-tutorial/">Dart 语言入门</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jekton-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">初级程序员虾饺.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>