<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程 | 初级程序员虾饺</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</h1><a id="logo" href="/.">初级程序员虾饺</a><p class="description">Learning for fun</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</h1><div class="post-meta">Mar 21, 2019<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2019/03/21/android9-lmk-lmkd/" href="/2019/03/21/android9-lmk-lmkd/#disqus_thread"></a><div class="post-content"><p>本来按顺序这一篇应该也还是 logd，但我刚开始写就碰到了 cgroup，一顿搜索又扯上了 lmk，没办法，只能先解决这拦路的石头，然后再继续 logd。</p>
<p>Android 早先的版本的 lmk 是以驱动的形式在内核中实现的，这种方式并不为主线内核所接受。后来有人给内核添加了 memory pressure event，这就为应用层实现 lmk 提供了可能性。通过监听 memory pressure 事件，应用可以在内存 low、medium 和 critical 的时候得到通知，从而回收一些优先级比较低的应用。</p>
<p>下面我们就一起来看看他的实现。</p>
<h2 id="应用初始化"><a href="#应用初始化" class="headerlink" title="应用初始化"></a>应用初始化</h2><p>跟大多数守护进程一样，lmkd 也是由 init 进程启动的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// system/core/lmkd/lmkd.rc</span><br><span class="line">service lmkd /system/bin/lmkd</span><br><span class="line">    class core</span><br><span class="line">    group root readproc</span><br><span class="line">    critical</span><br><span class="line">    socket lmkd seqpacket 0660 system system</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br></pre></td></tr></table></figure></p>
<p>这里创建的 socket lmkd 的 user/group 都是 system，而它的权限是 0660，所以只有 system 应用才能读写（一般是 activity manager）。</p>
<p>接下来的 writepid 跟 Linux 的 cgroups 相关，目前我也不太了解（流下了没技术的泪水），后面补上相关的知识后再来单独撸一篇（文章）。</p>
<p>应用启动后，开始执行 <code>main</code> 函数，<code>main</code> 函数主要做三件事：</p>
<ol>
<li>读取配置参数</li>
<li>锁住内存页并设置进程调度器</li>
<li>初始化 epoll 事件监听</li>
<li>循环处理事件</li>
</ol>
<p>为了让读者有整体感，这里我们先把一整个 <code>main</code> 函数放上了，然后再单独看各个部分的实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/lmkd/lmkd.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span></span><br><span class="line">            .sched_priority = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* By default disable low level vmpressure events */</span></span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_LOW] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.low"</span>, OOM_SCORE_ADJ_MAX + <span class="number">1</span>);</span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_MEDIUM] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.medium"</span>, <span class="number">800</span>);</span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_CRITICAL] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.critical"</span>, <span class="number">0</span>);</span><br><span class="line">    debug_process_killing = property_get_bool(<span class="string">"ro.lmk.debug"</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* By default disable upgrade/downgrade logic */</span></span><br><span class="line">    enable_pressure_upgrade =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.critical_upgrade"</span>, <span class="literal">false</span>);</span><br><span class="line">    upgrade_pressure =</span><br><span class="line">        (<span class="keyword">int64_t</span>)property_get_int32(<span class="string">"ro.lmk.upgrade_pressure"</span>, <span class="number">100</span>);</span><br><span class="line">    downgrade_pressure =</span><br><span class="line">        (<span class="keyword">int64_t</span>)property_get_int32(<span class="string">"ro.lmk.downgrade_pressure"</span>, <span class="number">100</span>);</span><br><span class="line">    kill_heaviest_task =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.kill_heaviest_task"</span>, <span class="literal">false</span>);</span><br><span class="line">    low_ram_device = property_get_bool(<span class="string">"ro.config.low_ram"</span>, <span class="literal">false</span>);</span><br><span class="line">    kill_timeout_ms =</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>)property_get_int32(<span class="string">"ro.lmk.kill_timeout_ms"</span>, <span class="number">0</span>);</span><br><span class="line">    use_minfree_levels =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.use_minfree_levels"</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LMKD_LOG_STATS</span></span><br><span class="line">    statslog_init(&amp;log_ctx, &amp;enable_stats_log);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MCL_ONFAULT pins pages as they fault instead of loading</span></span><br><span class="line">    <span class="comment">// everything immediately all at once. (Which would be bad,</span></span><br><span class="line">    <span class="comment">// because as of this writing, we have a lot of mapped pages we</span></span><br><span class="line">    <span class="comment">// never use.) Old kernels will see MCL_ONFAULT and fail with</span></span><br><span class="line">    <span class="comment">// EINVAL; we ignore this failure.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// N.B. read the man page for mlockall. MCL_CURRENT | MCL_ONFAULT</span></span><br><span class="line">    <span class="comment">// pins ⊆ MCL_CURRENT, converging to just MCL_CURRENT as we fault</span></span><br><span class="line">    <span class="comment">// in pages.</span></span><br><span class="line">    <span class="keyword">if</span> (mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT) &amp;&amp; errno != EINVAL)</span><br><span class="line">        ALOGW(<span class="string">"mlockall failed: errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    sched_setscheduler(<span class="number">0</span>, SCHED_FIFO, &amp;param);</span><br><span class="line">    <span class="keyword">if</span> (!init())</span><br><span class="line">        mainloop();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LMKD_LOG_STATS</span></span><br><span class="line">    statslog_destroy(&amp;log_ctx);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"exiting"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="读取配置参数"><a href="#读取配置参数" class="headerlink" title="读取配置参数"></a>读取配置参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/lmkd/lmkd.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* memory pressure levels */</span></span><br><span class="line"><span class="keyword">enum</span> vmpressure_level &#123;</span><br><span class="line">    VMPRESS_LEVEL_LOW = <span class="number">0</span>,</span><br><span class="line">    VMPRESS_LEVEL_MEDIUM,</span><br><span class="line">    VMPRESS_LEVEL_CRITICAL,</span><br><span class="line">    VMPRESS_LEVEL_COUNT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> level_oomadj[VMPRESS_LEVEL_COUNT];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mpevfd[VMPRESS_LEVEL_COUNT] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> debug_process_killing;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> enable_pressure_upgrade;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> upgrade_pressure;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> downgrade_pressure;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> low_ram_device;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> kill_heaviest_task;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> kill_timeout_ms;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> use_minfree_levels;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* By default disable low level vmpressure events */</span></span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_LOW] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.low"</span>, OOM_SCORE_ADJ_MAX + <span class="number">1</span>);</span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_MEDIUM] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.medium"</span>, <span class="number">800</span>);</span><br><span class="line">    level_oomadj[VMPRESS_LEVEL_CRITICAL] =</span><br><span class="line">        property_get_int32(<span class="string">"ro.lmk.critical"</span>, <span class="number">0</span>);</span><br><span class="line">    debug_process_killing = property_get_bool(<span class="string">"ro.lmk.debug"</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* By default disable upgrade/downgrade logic */</span></span><br><span class="line">    enable_pressure_upgrade =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.critical_upgrade"</span>, <span class="literal">false</span>);</span><br><span class="line">    upgrade_pressure =</span><br><span class="line">        (<span class="keyword">int64_t</span>)property_get_int32(<span class="string">"ro.lmk.upgrade_pressure"</span>, <span class="number">100</span>);</span><br><span class="line">    downgrade_pressure =</span><br><span class="line">        (<span class="keyword">int64_t</span>)property_get_int32(<span class="string">"ro.lmk.downgrade_pressure"</span>, <span class="number">100</span>);</span><br><span class="line">    kill_heaviest_task =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.kill_heaviest_task"</span>, <span class="literal">false</span>);</span><br><span class="line">    low_ram_device = property_get_bool(<span class="string">"ro.config.low_ram"</span>, <span class="literal">false</span>);</span><br><span class="line">    kill_timeout_ms =</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>)property_get_int32(<span class="string">"ro.lmk.kill_timeout_ms"</span>, <span class="number">0</span>);</span><br><span class="line">    use_minfree_levels =</span><br><span class="line">        property_get_bool(<span class="string">"ro.lmk.use_minfree_levels"</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，就是直接从系统属性里面读配置，然后放到静态变量里。关于这些属性的含义，读者可以参考 <code>system/core/lmkd/README.md</code>。</p>
<p><code>enum vmpressure_level</code> 代表了内存压力等级，分别是我们前面提到的 low、medium 和 critical。</p>
<h3 id="锁住内存页并设置进程调度器"><a href="#锁住内存页并设置进程调度器" class="headerlink" title="锁住内存页并设置进程调度器"></a>锁住内存页并设置进程调度器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取配置参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MCL_ONFAULT pins pages as they fault instead of loading</span></span><br><span class="line">    <span class="comment">// everything immediately all at once. (Which would be bad,</span></span><br><span class="line">    <span class="comment">// because as of this writing, we have a lot of mapped pages we</span></span><br><span class="line">    <span class="comment">// never use.) Old kernels will see MCL_ONFAULT and fail with</span></span><br><span class="line">    <span class="comment">// EINVAL; we ignore this failure.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// N.B. read the man page for mlockall. MCL_CURRENT | MCL_ONFAULT</span></span><br><span class="line">    <span class="comment">// pins ⊆ MCL_CURRENT, converging to just MCL_CURRENT as we fault</span></span><br><span class="line">    <span class="comment">// in pages.</span></span><br><span class="line">    <span class="keyword">if</span> (mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT) &amp;&amp; errno != EINVAL)</span><br><span class="line">        ALOGW(<span class="string">"mlockall failed: errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span></span><br><span class="line">            .sched_priority = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    sched_setscheduler(<span class="number">0</span>, SCHED_FIFO, &amp;param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 epoll 事件监听</span></span><br><span class="line">    <span class="comment">// 循环处理事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MCL_CURRENT</code> 把应用里当前已经在内存中的页锁着；<code>MCL_FUTURE</code> 把以后分配的内存区锁着；<code>MCL_ONFAULT</code> 表示不把那些当前不在内存里的页都加载到内存，而是当 page fault 的时候，再将加载进来的页面锁着。关于 <code>mlockall</code> 的更多信息，读者可以参考 man page。</p>
<p>接下来的 <code>sched_setscheduler</code> 将自己设置为实时进程，使用的调度器是 fifo。实时进程的优先级高于所有普通进程。对 fifo 调度器来说，在进程可运行（runnable）的时候，内核不会抢占它。</p>
<h3 id="初始化-epoll-事件监听"><a href="#初始化-epoll-事件监听" class="headerlink" title="初始化 epoll 事件监听"></a>初始化 epoll 事件监听</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取配置参数</span></span><br><span class="line">    <span class="comment">// 锁住内存页并设置进程调度器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!init())</span><br><span class="line">        mainloop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>epoll 的初始化由 <code>init</code> 函数完成，<code>mainloop</code> 在一个主循环里处理事件，后者我们在下一小节讨论。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    page_k = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">if</span> (page_k == <span class="number">-1</span>)</span><br><span class="line">        page_k = PAGE_SIZE;</span><br><span class="line">    page_k /= <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    epollfd = epoll_create(MAX_EPOLL_EVENTS);</span><br><span class="line">    <span class="keyword">if</span> (epollfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"epoll_create failed (errno=%d)"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark data connections as not connected</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_DATA_CONN; i++) &#123;</span><br><span class="line">        data_sock[i].sock = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctrl_sock.sock = android_get_control_socket(<span class="string">"lmkd"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ctrl_sock.sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"get lmkd control socket failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = listen(ctrl_sock.sock, MAX_DATA_CONN);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"lmkd control socket listen failed (errno=%d)"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    ctrl_sock.handler_info.handler = ctrl_connect_handler;</span><br><span class="line">    epev.data.ptr = (<span class="keyword">void</span> *)&amp;(ctrl_sock.handler_info);</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, ctrl_sock.sock, &amp;epev) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"epoll_ctl for lmkd control socket failed (errno=%d)"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxevents++;</span><br><span class="line"></span><br><span class="line">    has_inkernel_module = !access(INKERNEL_MINFREE_PATH, W_OK);</span><br><span class="line">    use_inkernel_interface = has_inkernel_module;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_inkernel_interface) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Using in-kernel low memory killer interface"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!init_mp_common(VMPRESS_LEVEL_LOW) ||</span><br><span class="line">            !init_mp_common(VMPRESS_LEVEL_MEDIUM) ||</span><br><span class="line">            !init_mp_common(VMPRESS_LEVEL_CRITICAL)) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Kernel does not support memory pressure events or in-kernel low memory killer"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= ADJTOSLOT(OOM_SCORE_ADJ_MAX); i++) &#123;</span><br><span class="line">        procadjslot_list[i].next = &amp;procadjslot_list[i];</span><br><span class="line">        procadjslot_list[i].prev = &amp;procadjslot_list[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里初始化静态变量 <code>page_k</code>，<code>page_k</code> 表示一个内存页有多少 KB，默认的 <code>PAGE_SIZE</code> 为 4096。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> page_k;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data required to handle events */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_handler_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">void</span> (*handler)(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data required to handle socket events */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_event_handler_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_handler_info</span> <span class="title">handler_info</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* max supported number of data connections */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_DATA_CONN 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* socket event handler data */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_event_handler_info</span> <span class="title">ctrl_sock</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_event_handler_info</span> <span class="title">data_sock</span>[<span class="title">MAX_DATA_CONN</span>];</span></span><br></pre></td></tr></table></figure></p>
<p><code>ctrl_sock</code> 是由 init 进程帮我们创建的那个 socket lmkd，通过这个 socket，lmkd 进程监听这个 socket 并等待接受客户的连接。lmkd 最多支持两个客户（<code>MAX_DATA_CONN</code>），这两个客户的 socket fd 就放在 <code>data_sock</code>。</p>
<p><code>struct event_handler_info</code> 定义了一个接口，<code>epoll</code> 返回时，主循环里就这个事件对应的 <code>handler</code>。调用时，第一个参数 <code>data</code> 是用户在创建 <code>struct event_handler_info</code> 对象时初始化的字段 <code>data</code>，第二个参数 <code>events</code> 是 <code>epoll</code> 返回的事件。</p>
<p>从上面的初始化代码可以看出，当 socket lmkd 有客户连接时，对应的回调是 <code>ctrl_connect_handler</code>。这里我们没有初始化 <code>ctrl_sock.handler_info.data</code>，是因为 <code>ctrl_connect_handler</code> 不使用这个额外的参数。</p>
<p><code>INKERNEL_MINFREE_PATH</code> 宏是 <code>/sys/module/lowmemorykiller/parameters/minfree</code>，如果我们不能访问它，表示 lowmemorykiller 使用的是内核中的驱动（没错，目前有两个 lowmemorykiller，一个是我们现在在看的 lmkd，一个是在内核中实现的驱动。系统的编译的时候可以决定使用哪一个）。这里我们假设使用应用层 lmk。</p>
<p><code>init_mp_common</code> 函数初始化 memory pressure 事件的监听：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMCG_SYSFS_PATH <span class="meta-string">"/dev/memcg/"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mpevfd[VMPRESS_LEVEL_COUNT] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">init_mp_common</span><span class="params">(<span class="keyword">enum</span> vmpressure_level level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mpfd;</span><br><span class="line">    <span class="keyword">int</span> evfd;</span><br><span class="line">    <span class="keyword">int</span> evctlfd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> level_idx = (<span class="keyword">int</span>)level;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *levelstr = level_name[level_idx];</span><br><span class="line"></span><br><span class="line">    mpfd = open(MEMCG_SYSFS_PATH <span class="string">"memory.pressure_level"</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (mpfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"No kernel memory.pressure_level support (errno=%d)"</span>, errno);</span><br><span class="line">        <span class="keyword">goto</span> err_open_mpfd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    evctlfd = open(MEMCG_SYSFS_PATH <span class="string">"cgroup.event_control"</span>, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (evctlfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"No kernel memory cgroup event control (errno=%d)"</span>, errno);</span><br><span class="line">        <span class="keyword">goto</span> err_open_evctlfd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    evfd = eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (evfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"eventfd failed for level %s; errno=%d"</span>, levelstr, errno);</span><br><span class="line">        <span class="keyword">goto</span> err_eventfd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d %d %s"</span>, evfd, mpfd, levelstr);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= (<span class="keyword">ssize_t</span>)<span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cgroup.event_control line overflow for level %s"</span>, levelstr);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = TEMP_FAILURE_RETRY(write(evctlfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cgroup.event_control write failed for level %s; errno=%d"</span>,</span><br><span class="line">              levelstr, errno);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    <span class="comment">/* use data to store event level */</span></span><br><span class="line">    vmpressure_hinfo[level_idx].data = level_idx;</span><br><span class="line">    vmpressure_hinfo[level_idx].handler = mp_event_common;</span><br><span class="line">    epev.data.ptr = (<span class="keyword">void</span> *)&amp;vmpressure_hinfo[level_idx];</span><br><span class="line">    ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, evfd, &amp;epev);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"epoll_ctl for level %s failed; errno=%d"</span>, levelstr, errno);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    maxevents++;</span><br><span class="line">    mpevfd[level] = evfd;</span><br><span class="line">    close(evctlfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    close(evfd);</span><br><span class="line">err_eventfd:</span><br><span class="line">    close(evctlfd);</span><br><span class="line">err_open_evctlfd:</span><br><span class="line">    close(mpfd);</span><br><span class="line">err_open_mpfd:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mpfd</code> 打开的时候利用 C/C++ 的字符串连接特性（相邻的字符串会自动由编译器连接到一起），他打开的实际路径是 <code>/dev/memcg/memory.pressure_level</code>。<code>evctlfd</code> 打开的路径类似。<code>eventfd</code> 是 LINUX 特有的一个系统调用，读者可以查看 man page 了解它的用法。</p>
<p>这里我们只需要知道，通过这么一顿骚操作之后，我们就能够通过描述符 <code>evfd</code> 得到 memory pressure 事件，就暂时把内核当做一个黑匣子来使用吧。</p>
<p>对于 memory pressure 事件，处理函数是 <code>mp_event_common</code>，传递给他的 <code>data</code> 是 <code>level_idx</code>（用于区分是发生了哪个级别的 mp 事件）。</p>
<p>最后要留意的是，<code>evfd</code> 被我们存放在了静态数组 <code>mpevfd</code> 里了，在后面将进程回收的时候（<code>mp_event_common</code> 函数）我们还会用到这个 <code>mpevfd</code>。</p>
<h3 id="循环处理事件"><a href="#循环处理事件" class="headerlink" title="循环处理事件"></a>循环处理事件</h3><p>事件循环由 <code>mainloop</code> 函数实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mainloop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_handler_info</span>* <span class="title">handler_info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">evt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">maxevents</span>];</span></span><br><span class="line">        <span class="keyword">int</span> nevents;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        nevents = epoll_wait(epollfd, events, maxevents, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nevents == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ALOGE(<span class="string">"epoll_wait failed (errno=%d)"</span>, errno);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * First pass to see if any data socket connections were dropped.</span></span><br><span class="line"><span class="comment">         * Dropped connection should be handled before any other events</span></span><br><span class="line"><span class="comment">         * to deallocate data connection and correctly handle cases when</span></span><br><span class="line"><span class="comment">         * connection gets dropped and reestablished in the same epoll cycle.</span></span><br><span class="line"><span class="comment">         * In such cases it's essential to handle connection closures first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, evt = &amp;events[<span class="number">0</span>]; i &lt; nevents; ++i, evt++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((evt-&gt;events &amp; EPOLLHUP) &amp;&amp; evt-&gt;data.ptr) &#123;</span><br><span class="line">                ALOGI(<span class="string">"lmkd data connection dropped"</span>);</span><br><span class="line">                handler_info = (struct event_handler_info*)evt-&gt;data.ptr;</span><br><span class="line">                ctrl_data_close(handler_info-&gt;data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Second pass to handle all other events */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, evt = &amp;events[<span class="number">0</span>]; i &lt; nevents; ++i, evt++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (evt-&gt;events &amp; EPOLLERR)</span><br><span class="line">                ALOGD(<span class="string">"EPOLLERR on event #%d"</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (evt-&gt;events &amp; EPOLLHUP) &#123;</span><br><span class="line">                <span class="comment">/* This case was handled in the first pass */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (evt-&gt;data.ptr) &#123;</span><br><span class="line">                handler_info = (struct event_handler_info*)evt-&gt;data.ptr;</span><br><span class="line">                handler_info-&gt;handler(handler_info-&gt;data, evt-&gt;events);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码就很直观了，就是在一个循环里调用 <code>epoll_wait</code>，然后调用对应的处理函数。其中比较不一致的代码是当客户挂起（<code>EPOLLHUP</code>）的时候，这里我们直接把连接关掉：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ctrl_data_close</span><span class="params">(<span class="keyword">int</span> dsock_idx)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"closing lmkd data connection"</span>);</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_DEL, data_sock[dsock_idx].sock, &amp;epev) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// Log a warning and keep going</span></span><br><span class="line">        ALOGW(<span class="string">"epoll_ctl for data connection socket failed; errno=%d"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    maxevents--;</span><br><span class="line"></span><br><span class="line">    close(data_sock[dsock_idx].sock);</span><br><span class="line">    data_sock[dsock_idx].sock = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="lmkd-客户端接口"><a href="#lmkd-客户端接口" class="headerlink" title="lmkd 客户端接口"></a>lmkd 客户端接口</h2><p>进程 lmkd 的客户主要是 activity manager，它通过 socket <code>/dev/socket/lmkd</code> 跟 lmkd 进行通信。通过前面的代码我们已经知道，有客户连接时，调用的是 <code>ctrl_connect_handler</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_free_dsock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_DATA_CONN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data_sock[i].sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ctrl_connect_handler</span><span class="params">(<span class="keyword">int</span> data __unused, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> free_dscock_idx = get_free_dsock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (free_dscock_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Number of data connections exceeded max supported. This should not</span></span><br><span class="line"><span class="comment">         * happen but if it does we drop all existing connections and accept</span></span><br><span class="line"><span class="comment">         * the new one. This prevents inactive connections from monopolizing</span></span><br><span class="line"><span class="comment">         * data socket and if we drop ActivityManager connection it will</span></span><br><span class="line"><span class="comment">         * immediately reconnect.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_DATA_CONN; i++) &#123;</span><br><span class="line">            ctrl_data_close(i);</span><br><span class="line">        &#125;</span><br><span class="line">        free_dscock_idx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data_sock[free_dscock_idx].sock = accept(ctrl_sock.sock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (data_sock[free_dscock_idx].sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"lmkd control socket accept failed; errno=%d"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"lmkd data connection established"</span>);</span><br><span class="line">    <span class="comment">/* use data to store data connection idx */</span></span><br><span class="line">    data_sock[free_dscock_idx].handler_info.data = free_dscock_idx;</span><br><span class="line">    data_sock[free_dscock_idx].handler_info.handler = ctrl_data_handler;</span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.ptr = (<span class="keyword">void</span> *)&amp;(data_sock[free_dscock_idx].handler_info);</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, data_sock[free_dscock_idx].sock, &amp;epev) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"epoll_ctl for data connection socket failed; errno=%d"</span>, errno);</span><br><span class="line">        ctrl_data_close(free_dscock_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxevents++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码很简单，就是在 <code>ctrl_sock</code> 上调用 <code>accept</code> 接受一个客户的连接，然后放到 <code>data_sock</code>（回想一下，<code>data_sock</code> 存放的是 lmkd 的客户，最多可以有两个）。</p>
<p>对客户连接来说，它的处理函数是 <code>ctrl_data_handler</code>，<code>handler_info.data</code> 对应 <code>data_sock</code> 数组的下标，这样在 <code>ctrl_data_handler</code> 执行时才知道是哪个客户端可读了。</p>
<p>这就是 <code>ctrl_sock</code> 所有的职责了——接受客户的连接。下面我们看看客户 socket 可读的时候会发生什么：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ctrl_data_handler</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EPOLLIN) &#123;</span><br><span class="line">        ctrl_command_handler(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端连接后，将通过 socket 给 lmkd 发送命令，这一部分是由 <code>ctrl_command_handler</code> 处理的。lmkd 接受三种命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Supported LMKD commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> lmk_cmd &#123;</span><br><span class="line">    LMK_TARGET = <span class="number">0</span>,  <span class="comment">/* Associate minfree with oom_adj_score */</span></span><br><span class="line">    LMK_PROCPRIO,    <span class="comment">/* Register a process and set its oom_adj_score */</span></span><br><span class="line">    LMK_PROCREMOVE,  <span class="comment">/* Unregister a process */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>命令的格式分别为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LMK_TARGET:</span><br><span class="line">+---------+----------+----------------+----------+----------------+----</span><br><span class="line">| lmk_cmd | minfree1 | oom_adj_score1 | minfree2 | oom_adj_score2 | ...</span><br><span class="line">+---------+----------+----------------+----------+----------------+----</span><br><span class="line"></span><br><span class="line">LMK_PROCPRIO:</span><br><span class="line">+---------+-----+-----+---------+</span><br><span class="line">| lmk_cmd | pid | uid | oom_adj |</span><br><span class="line">+---------+-----+-----+---------+</span><br><span class="line"></span><br><span class="line">LMK_PROCREMOVE:</span><br><span class="line">+---------+-----+</span><br><span class="line">| lmk_cmd | pid |</span><br><span class="line">+---------+-----+</span><br></pre></td></tr></table></figure></p>
<p>命令的每个字段都是 4 个字节（<code>int</code> 类型），并且使用<strong>网络字节序</strong>（我也表示很懵逼，命名是在本地通信，为什么不直接使用主机字节序）。</p>
<p><code>LMK_TARGET</code> 是最长的一条协议，他最多可以接受 6 组参数（由 <code>MAX_TARGETS</code> 定义），所以一条控制命令的最大长度是 1 + 6 * 2 = 13 个 <code>int</code>，这个大小由 <code>CTRL_PACKET_MAX_SIZE</code> 定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Max number of targets in LMK_TARGET command.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TARGETS 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Max packet length in bytes.</span></span><br><span class="line"><span class="comment"> * Longest packet is LMK_TARGET followed by MAX_TARGETS</span></span><br><span class="line"><span class="comment"> * of minfree and oom_adj_score values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTRL_PACKET_MAX_SIZE (sizeof(int) * (MAX_TARGETS * 2 + 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LMKD packet - first int is lmk_cmd followed by payload */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> LMKD_CTRL_PACKET[CTRL_PACKET_MAX_SIZE / <span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br></pre></td></tr></table></figure></p>
<p>了解了基本的数据类型和协议格式后，下面我们来看 <code>ctrl_command_hander</code> 的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ctrl_command_handler</span><span class="params">(<span class="keyword">int</span> dsock_idx)</span> </span>&#123;</span><br><span class="line">    LMKD_CTRL_PACKET packet;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">enum</span> lmk_cmd cmd;</span><br><span class="line">    <span class="keyword">int</span> nargs;</span><br><span class="line">    <span class="keyword">int</span> targets;</span><br><span class="line"></span><br><span class="line">    len = ctrl_data_read(dsock_idx, (<span class="keyword">char</span> *)packet, CTRL_PACKET_MAX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Wrong control socket read length len=%d"</span>, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmd = lmkd_pack_get_cmd(packet);</span><br><span class="line">    nargs = len / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nargs &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> wronglen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> LMK_TARGET:</span><br><span class="line">        targets = nargs / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nargs &amp; <span class="number">0x1</span> || targets &gt; (<span class="keyword">int</span>)ARRAY_SIZE(lowmem_adj))</span><br><span class="line">            <span class="keyword">goto</span> wronglen;</span><br><span class="line">        cmd_target(targets, packet);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LMK_PROCPRIO:</span><br><span class="line">        <span class="keyword">if</span> (nargs != <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">goto</span> wronglen;</span><br><span class="line">        cmd_procprio(packet);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LMK_PROCREMOVE:</span><br><span class="line">        <span class="keyword">if</span> (nargs != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">goto</span> wronglen;</span><br><span class="line">        cmd_procremove(packet);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ALOGE(<span class="string">"Received unknown command code %d"</span>, cmd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">wronglen:</span><br><span class="line">    ALOGE(<span class="string">"Wrong control socket read length cmd=%d len=%d"</span>, cmd, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctrl_data_read</span><span class="params">(<span class="keyword">int</span> dsock_idx, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = TEMP_FAILURE_RETRY(read(data_sock[dsock_idx].sock, buf, bufsz));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"control data socket read failed; errno=%d"</span>, errno);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Got EOF on control data socket"</span>);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回忆一下，socket lmkd 的类型是 seqpacket，所以每次 <code>read</code> 都会恰好返回一条命令。调用 <code>ctrl_data_read</code> 读到一整条命名后，我们使用 <code>lmkd_pack_get_cmd</code> 函数得到这条命令的 <code>lmkd_cmd</code> 字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get LMKD packet command */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">enum</span> lmk_cmd <span class="title">lmkd_pack_get_cmd</span><span class="params">(LMKD_CTRL_PACKET pack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">enum</span> lmk_cmd)ntohl(pack[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面我们说，协议数据使用网络字节序，所以这里用 <code>ntohl</code> 转换为主机字节序。三个命令的 cmd 字段都在第一个 int，所以这里直接返回 <code>pack[0]</code>。</p>
<p>接下来三个命令分别由 <code>cmd_target</code>，<code>cmd_procprio</code>，<code>cmd_procremove</code>处理。我们先看 <code>cmd_target</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lowmem_adj[MAX_TARGETS];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lowmem_minfree[MAX_TARGETS];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lowmem_targets_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LMK_TARGET packet payload */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lmk_target</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minfree;</span><br><span class="line">    <span class="keyword">int</span> oom_adj_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For LMK_TARGET packet get target_idx-th payload.</span></span><br><span class="line"><span class="comment"> * Warning: no checks performed, caller should ensure valid parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lmkd_pack_get_target</span><span class="params">(LMKD_CTRL_PACKET packet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> target_idx, struct lmk_target *target)</span> </span>&#123;</span><br><span class="line">    target-&gt;minfree = ntohl(packet[target_idx * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    target-&gt;oom_adj_score = ntohl(packet[target_idx * <span class="number">2</span> + <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_target</span><span class="params">(<span class="keyword">int</span> ntargets, LMKD_CTRL_PACKET packet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lmk_target</span> <span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ntargets &gt; (<span class="keyword">int</span>)ARRAY_SIZE(lowmem_adj))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ntargets; i++) &#123;</span><br><span class="line">        lmkd_pack_get_target(packet, i, &amp;target);</span><br><span class="line">        lowmem_minfree[i] = target.minfree;</span><br><span class="line">        lowmem_adj[i] = target.oom_adj_score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lowmem_targets_size = ntargets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_inkernel_module) &#123;</span><br><span class="line">        <span class="keyword">char</span> minfreestr[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">char</span> killpriostr[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        minfreestr[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        killpriostr[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lowmem_targets_size; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i) &#123;</span><br><span class="line">                strlcat(minfreestr, <span class="string">","</span>, <span class="keyword">sizeof</span>(minfreestr));</span><br><span class="line">                strlcat(killpriostr, <span class="string">","</span>, <span class="keyword">sizeof</span>(killpriostr));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">"%d"</span>, use_inkernel_interface ? lowmem_minfree[i] : <span class="number">0</span>);</span><br><span class="line">            strlcat(minfreestr, val, <span class="keyword">sizeof</span>(minfreestr));</span><br><span class="line">            <span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">"%d"</span>, use_inkernel_interface ? lowmem_adj[i] : <span class="number">0</span>);</span><br><span class="line">            strlcat(killpriostr, val, <span class="keyword">sizeof</span>(killpriostr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writefilestring(INKERNEL_MINFREE_PATH, minfreestr);</span><br><span class="line">        writefilestring(INKERNEL_ADJ_PATH, killpriostr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>cmd_target</code> 设置 <code>lowmem_minfree</code>， <code>lowmem_adj</code>，这两组参数用于控制 low memory 时候的行为。如果使用的是驱动 lmk，那就把参数写到 <code>INKERNEL_MINFREE_PATH</code> 和 <code>INKERNEL_ADJ_PATH</code>。</p>
<p>接下来是 <code>cmd_procprio</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LMK_PROCPRIO packet payload */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lmk_procprio</span> &#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">uid_t</span> uid;</span><br><span class="line">    <span class="keyword">int</span> oomadj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For LMK_PROCPRIO packet get its payload.</span></span><br><span class="line"><span class="comment"> * Warning: no checks performed, caller should ensure valid parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lmkd_pack_get_procprio</span><span class="params">(LMKD_CTRL_PACKET packet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   struct lmk_procprio *params)</span> </span>&#123;</span><br><span class="line">    params-&gt;pid = (<span class="keyword">pid_t</span>)ntohl(packet[<span class="number">1</span>]);</span><br><span class="line">    params-&gt;uid = (<span class="keyword">uid_t</span>)ntohl(packet[<span class="number">2</span>]);</span><br><span class="line">    params-&gt;oomadj = ntohl(packet[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_procprio</span><span class="params">(LMKD_CTRL_PACKET packet)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">80</span>];</span><br><span class="line">    <span class="keyword">char</span> val[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> soft_limit_mult;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lmk_procprio</span> <span class="title">params</span>;</span></span><br><span class="line"></span><br><span class="line">    lmkd_pack_get_procprio(packet, &amp;params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (params.oomadj &lt; OOM_SCORE_ADJ_MIN ||</span><br><span class="line">        params.oomadj &gt; OOM_SCORE_ADJ_MAX) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Invalid PROCPRIO oomadj argument %d"</span>, params.oomadj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"/proc/%d/oom_score_adj"</span>, params.pid);</span><br><span class="line">    <span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">"%d"</span>, params.oomadj);</span><br><span class="line">    writefilestring(path, val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_inkernel_interface)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (low_ram_device) &#123;</span><br><span class="line">        <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">900</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">800</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">700</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">600</span>) &#123;</span><br><span class="line">            <span class="comment">// Launcher should be perceptible, don't kill it.</span></span><br><span class="line">            params.oomadj = <span class="number">200</span>;</span><br><span class="line">            soft_limit_mult = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">200</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.oomadj &gt;=   <span class="number">0</span>) &#123;</span><br><span class="line">            soft_limit_mult = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Persistent processes will have a large</span></span><br><span class="line">            <span class="comment">// soft limit 512MB.</span></span><br><span class="line">            soft_limit_mult = <span class="number">64</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path),</span><br><span class="line">             <span class="string">"/dev/memcg/apps/uid_%d/pid_%d/memory.soft_limit_in_bytes"</span>,</span><br><span class="line">             params.uid, params.pid);</span><br><span class="line">        <span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">"%d"</span>, soft_limit_mult * EIGHT_MEGA);</span><br><span class="line">        writefilestring(path, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    procp = pid_lookup(params.pid);</span><br><span class="line">    <span class="keyword">if</span> (!procp) &#123;</span><br><span class="line">            procp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct proc));</span><br><span class="line">            <span class="keyword">if</span> (!procp) &#123;</span><br><span class="line">                <span class="comment">// Oh, the irony.  May need to rebuild our state.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            procp-&gt;pid = params.pid;</span><br><span class="line">            procp-&gt;uid = params.uid;</span><br><span class="line">            procp-&gt;oomadj = params.oomadj;</span><br><span class="line">            proc_insert(procp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        proc_unslot(procp);</span><br><span class="line">        procp-&gt;oomadj = params.oomadj;</span><br><span class="line">        proc_slot(procp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>cmd_procprio</code> 用于设置进程的 oomadj，在把 oomadj 写入 <code>&quot;/proc/#pid/oom_score_adj&quot;</code> 后，如果使用的是驱动 lmk，就可以直接返回了（驱动 lmk 会处理剩下的工作）。如果不是，接着往下执行。</p>
<p>如果机子是 <code>low_ram_device</code>（小内存机器），那么 lmkd 会根据应用的 oomadj 调整应用可用的内存大小。（震惊，原来还有这种骚操作。那在小内存机器里，应用处于后台时就更容易 OOM 了）</p>
<p>最后的一小段代码将这个应用的 oomadj 保存在一个哈希表里：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> <span class="title">asl</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">uid_t</span> uid;</span><br><span class="line">    <span class="keyword">int</span> oomadj;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pidhash_next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIDHASH_SZ 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pidhash</span>[<span class="title">PIDHASH_SZ</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid_hashfn(x) ((((x) &gt;&gt; 8) ^ (x)) &amp; (PIDHASH_SZ - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc *<span class="title">pid_lookup</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (procp = pidhash[pid_hashfn(pid)]; procp &amp;&amp; procp-&gt;pid != pid;</span><br><span class="line">         procp = procp-&gt;pidhash_next)</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> procp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proc_insert</span><span class="params">(struct proc *procp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hval = pid_hashfn(procp-&gt;pid);</span><br><span class="line"></span><br><span class="line">    procp-&gt;pidhash_next = pidhash[hval];</span><br><span class="line">    pidhash[hval] = procp;</span><br><span class="line">    proc_slot(procp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哈希表 <code>pidhash</code> 是以 pid 做 key，<code>proc_slot</code> 则是把 <code>struct proc</code> 插入到以 <code>oomadj</code> 为 key 的哈希表 <code>procadjslot_list</code> 里面：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* OOM score values used by both kernel and framework */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_SCORE_ADJ_MIN       (-1000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_SCORE_ADJ_MAX       1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADJTOSLOT(adj) ((adj) + -OOM_SCORE_ADJ_MIN)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> <span class="title">procadjslot_list</span>[<span class="title">ADJTOSLOT</span>(<span class="title">OOM_SCORE_ADJ_MAX</span>) + 1];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proc_slot</span><span class="params">(struct proc *procp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> adjslot = ADJTOSLOT(procp-&gt;oomadj);</span><br><span class="line"></span><br><span class="line">    adjslot_insert(&amp;procadjslot_list[adjslot], &amp;procp-&gt;asl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjslot_insert</span><span class="params">(struct adjslot_list *head, struct adjslot_list *<span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">next</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = head;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    head-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跟 pid 值不同，oomadj 是数值范围是 <code>[-1000, 1000]</code>，最多只有 2001 种，所以其实一个 oomadj 值就对应  <code>procadjslot_list</code> 的 slot。</p>
<p>最后是 <code>cmd_procremove</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LMK_PROCREMOVE packet payload */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lmk_procremove</span> &#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For LMK_PROCREMOVE packet get its payload.</span></span><br><span class="line"><span class="comment"> * Warning: no checks performed, caller should ensure valid parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lmkd_pack_get_procremove</span><span class="params">(LMKD_CTRL_PACKET packet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     struct lmk_procremove *params)</span> </span>&#123;</span><br><span class="line">    params-&gt;pid = (<span class="keyword">pid_t</span>)ntohl(packet[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_procremove</span><span class="params">(LMKD_CTRL_PACKET packet)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lmk_procremove</span> <span class="title">params</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_inkernel_interface)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    lmkd_pack_get_procremove(packet, &amp;params);</span><br><span class="line">    pid_remove(params.pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后的 <code>pid_remove</code> 把这个 pid 对应的 <code>struct proc</code> 从 <code>pidhash</code> 和 <code>procadjslot_list</code> 里移除。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pid_remove</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hval = pid_hashfn(pid);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">prevp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (procp = pidhash[hval], prevp = <span class="literal">NULL</span>; procp &amp;&amp; procp-&gt;pid != pid;</span><br><span class="line">         procp = procp-&gt;pidhash_next)</span><br><span class="line">            prevp = procp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!procp)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prevp)</span><br><span class="line">        pidhash[hval] = procp-&gt;pidhash_next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prevp-&gt;pidhash_next = procp-&gt;pidhash_next;</span><br><span class="line"></span><br><span class="line">    proc_unslot(procp);</span><br><span class="line">    <span class="built_in">free</span>(procp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="回收进程"><a href="#回收进程" class="headerlink" title="回收进程"></a>回收进程</h2><p>前面和 socket lmkd 相关的内容主要用于设置 lmk 参数和进程 oomadj。当系统的物理内存不足时，将会触发 mp 事件，这个时候 lmkd 就需要通过杀死一些进程来释放内存页了。</p>
<p>前面我们已经知道，mp 事件发生后，执行的是 <code>mp_event_common</code>。这个函数比较长，洋洋洒洒两百来行代码，我们一点一点慢慢看：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> evcount;</span><br><span class="line">    <span class="keyword">int64_t</span> mem_usage, memsw_usage;</span><br><span class="line">    <span class="keyword">int64_t</span> mem_pressure;</span><br><span class="line">    <span class="keyword">enum</span> vmpressure_level lvl;</span><br><span class="line">    <span class="keyword">union</span> meminfo mi;</span><br><span class="line">    <span class="keyword">union</span> zoneinfo zi;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">last_report_tm</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> skip_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">enum</span> vmpressure_level level = (<span class="keyword">enum</span> vmpressure_level)data;</span><br><span class="line">    <span class="keyword">long</span> other_free = <span class="number">0</span>, other_file = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min_score_adj;</span><br><span class="line">    <span class="keyword">int</span> pages_to_free = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minfree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">reread_data</span> <span class="title">mem_usage_file_data</span> = &#123;</span></span><br><span class="line">        .filename = MEMCG_MEMORY_USAGE,</span><br><span class="line">        .fd = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">reread_data</span> <span class="title">memsw_usage_file_data</span> = &#123;</span></span><br><span class="line">        .filename = MEMCG_MEMORYSW_USAGE,</span><br><span class="line">        .fd = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面这一坨是函数用到的变量的定义。在 ANSI C 那个年代，局部变量都要在函数里先声明，但这对代码的可读性其实没有什么帮助（因为定义跟使用他的上下文脱节了）。这里我们先直接忽略它们，后面再在具体的上下文来看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> vmpressure_level lvl;</span><br><span class="line">    <span class="keyword">enum</span> vmpressure_level level = (<span class="keyword">enum</span> vmpressure_level)data;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Check all event counters from low to critical</span></span><br><span class="line"><span class="comment">     * and upgrade to the highest priority one. By reading</span></span><br><span class="line"><span class="comment">     * eventfd we also reset the event counters.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (lvl = VMPRESS_LEVEL_LOW; lvl &lt; VMPRESS_LEVEL_COUNT; lvl++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mpevfd[lvl] != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            TEMP_FAILURE_RETRY(read(mpevfd[lvl],</span><br><span class="line">                               &amp;evcount, <span class="keyword">sizeof</span>(evcount))) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            evcount &gt; <span class="number">0</span> &amp;&amp; lvl &gt; level) &#123;</span><br><span class="line">            level = lvl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面 <code>init_mp_common</code> 函数里面，我们把 <code>evfd</code> 存在了 <code>mpevfd</code> 数组里，为的就是这个时候能够通过读取它们的来判断是否有更高级别的 mp 事件。至此，变量 <code>level</code> 表示当前发生的最高 level 的 mp 事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">last_report_tm</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> skip_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kill_timeout_ms) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">curr_tm</span>;</span></span><br><span class="line">        gettimeofday(&amp;curr_tm, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (get_time_diff_ms(&amp;last_report_tm, &amp;curr_tm) &lt; kill_timeout_ms) &#123;</span><br><span class="line">            skip_count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skip_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"%lu memory pressure events were skipped after a kill!"</span>,</span><br><span class="line">              skip_count);</span><br><span class="line">        skip_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>kill_timeout_ms</code> 是我们在 <code>main</code> 函数里通过读系统属性设置的，表示上一次 kill 后，等多 <code>kill_timeout_ms</code> 再杀下一个。<code>last_report_tm</code> 在后面我们成功回收进程后会更新他的时间。这里要注意，<code>skip_count</code> 和 <code>last_report_tm</code> 都是 <code>static</code> 变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> zoneinfo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int64_t</span> nr_free_pages;</span><br><span class="line">        <span class="keyword">int64_t</span> nr_file_pages;</span><br><span class="line">        <span class="keyword">int64_t</span> nr_shmem;</span><br><span class="line">        <span class="keyword">int64_t</span> nr_unevictable;</span><br><span class="line">        <span class="keyword">int64_t</span> workingset_refault;</span><br><span class="line">        <span class="keyword">int64_t</span> high;</span><br><span class="line">        <span class="comment">/* fields below are calculated rather than read from the file */</span></span><br><span class="line">        <span class="keyword">int64_t</span> totalreserve_pages;</span><br><span class="line">    &#125; field;</span><br><span class="line">    <span class="keyword">int64_t</span> arr[ZI_FIELD_COUNT];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> meminfo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int64_t</span> nr_free_pages;</span><br><span class="line">        <span class="keyword">int64_t</span> cached;</span><br><span class="line">        <span class="keyword">int64_t</span> swap_cached;</span><br><span class="line">        <span class="keyword">int64_t</span> buffers;</span><br><span class="line">        <span class="keyword">int64_t</span> shmem;</span><br><span class="line">        <span class="keyword">int64_t</span> unevictable;</span><br><span class="line">        <span class="keyword">int64_t</span> free_swap;</span><br><span class="line">        <span class="keyword">int64_t</span> dirty;</span><br><span class="line">        <span class="comment">/* fields below are calculated rather than read from the file */</span></span><br><span class="line">        <span class="keyword">int64_t</span> nr_file_pages;</span><br><span class="line">    &#125; field;</span><br><span class="line">    <span class="keyword">int64_t</span> arr[MI_FIELD_COUNT];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> meminfo mi;</span><br><span class="line">    <span class="keyword">union</span> zoneinfo zi;</span><br><span class="line">    <span class="keyword">if</span> (meminfo_parse(&amp;mi) &lt; <span class="number">0</span> || zoneinfo_parse(&amp;zi) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to get free memory!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>union meminfo mi</code> 和 <code>union zoneinfo zi</code> 表示系统当前的内存使用情况。<code>meminfo_parse</code> 和 <code>zoneinfo_parse</code> 分别读取 <code>/proc/meminfo</code> 和 <code>/proc/zoneinfo</code> 并将解析得到的数据填充到 <code>mi/zi</code>。（读者可以开个机器，然后 <code>cat /proc/meminfo</code> 看看具体的输出。关于他们解释，参考 <code>man 5 proc</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> other_free = <span class="number">0</span>, other_file = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min_score_adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_minfree_levels) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        other_free = mi.field.nr_free_pages - zi.field.totalreserve_pages;</span><br><span class="line">        <span class="keyword">if</span> (mi.field.nr_file_pages &gt; (mi.field.shmem + mi.field.unevictable + mi.field.swap_cached)) &#123;</span><br><span class="line">            other_file = (mi.field.nr_file_pages - mi.field.shmem -</span><br><span class="line">                          mi.field.unevictable - mi.field.swap_cached);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            other_file = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        min_score_adj = OOM_SCORE_ADJ_MAX + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lowmem_targets_size; i++) &#123;</span><br><span class="line">            minfree = lowmem_minfree[i];</span><br><span class="line">            <span class="keyword">if</span> (other_free &lt; minfree &amp;&amp; other_file &lt; minfree) &#123;</span><br><span class="line">                min_score_adj = lowmem_adj[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min_score_adj == OOM_SCORE_ADJ_MAX + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                ALOGI(<span class="string">"Ignore %s memory pressure event "</span></span><br><span class="line">                      <span class="string">"(free memory=%ldkB, cache=%ldkB, limit=%ldkB)"</span>,</span><br><span class="line">                      level_name[level], other_free * page_k, other_file * page_k,</span><br><span class="line">                      (<span class="keyword">long</span>)lowmem_minfree[lowmem_targets_size - <span class="number">1</span>] * page_k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Free up enough pages to push over the highest minfree level */</span></span><br><span class="line">        pages_to_free = lowmem_minfree[lowmem_targets_size - <span class="number">1</span>] -</span><br><span class="line">            ((other_free &lt; other_file) ? other_free : other_file);</span><br><span class="line">        <span class="keyword">goto</span> do_kill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>use_minfree_levels</code> 同样是从系统属性读取的配置，表示使用当我们准备杀死应用的时候，使用系统剩余的内存和文件缓存阈值作为判断依据。</p>
<p><code>other_free</code> 表示系统可用的内存页的数目。</p>
<p><code>nr_file_pages</code> 等于 <code>mi-&gt;field.cached</code>（文件在内存中的缓存）加上 <code>mi-&gt;field.swap_cached</code>（swap 出去又读进了内存的数据）加上 <code>mi-&gt;field.buffers</code>（硬盘的一个临时缓存），</p>
<p><code>mi.shmem</code> 表示 tmpfs 使用的内存数，<code>unevictable</code> 表示那些不能 swap out 的内存。</p>
<p>最后 <code>other_file</code> 基本就等于除 tmpfs 和 unevictable 外的缓存在内存的文件所占用的 page 数。</p>
<p>有了 <code>other_free</code> 和 <code>other_file</code> 后，我们根据 <code>lowmem_minfree</code> 的值来确定 <code>min_score_adj</code>。<code>min_score_adj</code> 表示可以回收的最低的 oomadj 值（oomadj 越大，优先级越低，越容易被杀死），oomadj 小于 <code>min_score_adj</code> 的进程在这次回收过程中不会被杀死。</p>
<p>回想一下前面的 <code>cmd_target</code>，<code>lowmem_minfree</code> 和 <code>lowmem_adj</code> 值就是在他里面设置的。</p>
<p><code>goto do_kill</code> 在函数比较靠后的地方，我们后面再看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> min_nr_free_pages; <span class="comment">/* recorded but not used yet */</span></span><br><span class="line">    <span class="keyword">int64_t</span> max_nr_free_pages;</span><br><span class="line">&#125; low_pressure_mem = &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level == VMPRESS_LEVEL_LOW) &#123;</span><br><span class="line">        record_low_pressure_levels(&amp;mi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">record_low_pressure_levels</span><span class="params">(<span class="keyword">union</span> meminfo *mi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low_pressure_mem.min_nr_free_pages == <span class="number">-1</span> ||</span><br><span class="line">        low_pressure_mem.min_nr_free_pages &gt; mi-&gt;field.nr_free_pages) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Low pressure min memory update from %"</span> PRId64 <span class="string">" to %"</span> PRId64,</span><br><span class="line">                low_pressure_mem.min_nr_free_pages, mi-&gt;field.nr_free_pages);</span><br><span class="line">        &#125;</span><br><span class="line">        low_pressure_mem.min_nr_free_pages = mi-&gt;field.nr_free_pages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Free memory at low vmpressure events occasionally gets spikes,</span></span><br><span class="line"><span class="comment">     * possibly a stale low vmpressure event with memory already</span></span><br><span class="line"><span class="comment">     * freed up (no memory pressure should have been reported).</span></span><br><span class="line"><span class="comment">     * Ignore large jumps in max_nr_free_pages that would mess up our stats.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (low_pressure_mem.max_nr_free_pages == <span class="number">-1</span> ||</span><br><span class="line">        (low_pressure_mem.max_nr_free_pages &lt; mi-&gt;field.nr_free_pages &amp;&amp;</span><br><span class="line">         mi-&gt;field.nr_free_pages - low_pressure_mem.max_nr_free_pages &lt;</span><br><span class="line">         low_pressure_mem.max_nr_free_pages * <span class="number">0.1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Low pressure max memory update from %"</span> PRId64 <span class="string">" to %"</span> PRId64,</span><br><span class="line">                low_pressure_mem.max_nr_free_pages, mi-&gt;field.nr_free_pages);</span><br><span class="line">        &#125;</span><br><span class="line">        low_pressure_mem.max_nr_free_pages = mi-&gt;field.nr_free_pages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>low_pressure_mem.min_nr_free_pages</code> 记录的是目前遇到的最低可用内存页数，<code>low_pressure_mem.max_nr_free_pages</code> 记录的是目前遇到的最大可用的内存页数。就像代码中注释说的，有时候可用的内存数会突然暴涨，这里过滤掉了这种情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMCG_MEMORY_USAGE <span class="meta-string">"/dev/memcg/memory.usage_in_bytes"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMCG_MEMORYSW_USAGE <span class="meta-string">"/dev/memcg/memory.memsw.usage_in_bytes"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level_oomadj[level] &gt; OOM_SCORE_ADJ_MAX) &#123;</span><br><span class="line">        <span class="comment">/* Do not monitor this pressure level */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> mem_usage, memsw_usage;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">reread_data</span> <span class="title">mem_usage_file_data</span> = &#123;</span></span><br><span class="line">        .filename = MEMCG_MEMORY_USAGE,</span><br><span class="line">        .fd = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">reread_data</span> <span class="title">memsw_usage_file_data</span> = &#123;</span></span><br><span class="line">        .filename = MEMCG_MEMORYSW_USAGE,</span><br><span class="line">        .fd = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mem_usage = get_memory_usage(&amp;mem_usage_file_data)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> do_kill;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((memsw_usage = get_memory_usage(&amp;memsw_usage_file_data)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> do_kill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> int64_t <span class="title">get_memory_usage</span><span class="params">(struct reread_data *file_data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int64_t</span> mem_usage;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reread_file(file_data, buf, <span class="keyword">sizeof</span>(buf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!parse_int64(buf, &amp;mem_usage)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s parse error"</span>, file_data-&gt;filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mem_usage == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"No memory!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem_usage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get_memory_usage</code> 的实现很简单，就是读取 <code>reread_data.filename</code> 的内容并转换为 <code>int64</code>。这里还需要注意的是 <code>mem_usage_file_data</code> 和 <code>memsw_usage_file_data</code> 是静态变量。第一次打开文件后，会把文件描述符缓存在 <code>reread_data.fd</code> 里。</p>
<p><code>mem_usage</code> 是所用的内存数，<code>memsw_usage</code> 是内存数加上 swap out 的内存数。接下来的代码根据这两个数据来计算内存压力（压力越大，swap 出去的内存就越多）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate percent for swappinness.</span></span><br><span class="line">    <span class="keyword">int64_t</span> mem_pressure = (mem_usage * <span class="number">100</span>) / memsw_usage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enable_pressure_upgrade &amp;&amp; level != VMPRESS_LEVEL_CRITICAL) &#123;</span><br><span class="line">        <span class="comment">// We are swapping too much.</span></span><br><span class="line">        <span class="keyword">if</span> (mem_pressure &lt; upgrade_pressure) &#123;</span><br><span class="line">            level = upgrade_level(level);</span><br><span class="line">            <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                ALOGI(<span class="string">"Event upgraded to %s"</span>, level_name[level]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the pressure is larger than downgrade_pressure lmk will not</span></span><br><span class="line">    <span class="comment">// kill any process, since enough memory is available.</span></span><br><span class="line">    <span class="keyword">if</span> (mem_pressure &gt; downgrade_pressure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Ignore %s memory pressure"</span>, level_name[level]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level == VMPRESS_LEVEL_CRITICAL &amp;&amp;</span><br><span class="line">               mem_pressure &gt; upgrade_pressure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Downgrade critical memory pressure"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade event, since enough memory available.</span></span><br><span class="line">        level = downgrade_level(level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这里 <code>mem_pressure</code> 计算的是 <code>内存数 / (内存数 + swap)</code>，<code>mem_pressure</code> 越小，内存压力就越大。</p>
<p><code>enable_pressure_upgrade</code>、<code>upgrade_pressure</code> 和 <code>downgrade_pressure</code> 的值是我们在 <code>main</code> 函数里根据系统属性设置的。</p>
<p>在内存压力比较大并且 <code>enable_pressure_upgrade</code> 打开的情况下，我们把内存压力向上提升一个等级（以期释放更多的内存）；在内存压力小于 <code>downgrade_pressure</code> 的时候，内存是充足的，没有必要通过杀死应用来回收内存；如果内存压力中等（upgrade_pressure &lt; mem_pressure &lt; downgrade_pressure）但是 level 却是 critical，就给他降一级。</p>
<p>lmkd 在给 mp level 升级的时候需要打开 enable_pressure_upgrade（默认关闭），而降级却总是可行的，说明 lmkd 尽力在不杀死应用的情况下满足系统的内存需求。</p>
<p>到目前为止，我们得到了三组跟内存压力相关的参数：</p>
<ol>
<li>在 <code>use_minfree_levels</code> 的情况下，<code>min_score_adj</code> 和 <code>pages_to_free</code></li>
<li>内存压力 <code>level</code></li>
</ol>
<p>接下来，我们开始真正的进程回收工作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">do_kill:</span><br><span class="line">    <span class="keyword">if</span> (low_ram_device) &#123;</span><br><span class="line">        <span class="comment">/* For Go devices kill only one task */</span></span><br><span class="line">        <span class="keyword">if</span> (find_and_kill_processes(level, level_oomadj[level], <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                ALOGI(<span class="string">"Nothing to kill"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回收对象时分两大类，小内存设备和“大”内存设备。小内存设备一次就杀一个进程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_and_kill_processes</span><span class="params">(<span class="keyword">enum</span> vmpressure_level level,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> min_score_adj, <span class="keyword">int</span> pages_to_free)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> killed_size;</span><br><span class="line">    <span class="keyword">int</span> pages_freed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = OOM_SCORE_ADJ_MAX; i &gt;= min_score_adj; i--) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            procp = kill_heaviest_task ?</span><br><span class="line">                proc_get_heaviest(i) : proc_adj_lru(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!procp)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            killed_size = kill_one_process(procp, min_score_adj, level);</span><br><span class="line">            <span class="keyword">if</span> (killed_size &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pages_freed += killed_size;</span><br><span class="line">                <span class="keyword">if</span> (pages_freed &gt;= pages_to_free) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pages_freed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pages_freed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们从 oomadj 最大的应用开始回收，直到回收的内存页数达到 <code>pages_to_free</code>。对 <code>low_ram_device</code> 来说，<code>pages_to_free</code> 为 0，只有一个进程会被回收。</p>
<p><code>kill_heaviest_task</code> 是从系统属性读的，默认为 <code>false</code>。打开的情况下，在相关 oomadj 的进程里，我们优先回收使用内存最多的那个：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc *<span class="title">proc_get_heaviest</span><span class="params">(<span class="keyword">int</span> oomadj)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">head</span> = &amp;<span class="title">procadjslot_list</span>[<span class="title">ADJTOSLOT</span>(<span class="title">oomadj</span>)];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">curr</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">maxprocp</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> maxsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != head) &#123;</span><br><span class="line">        <span class="keyword">int</span> pid = ((struct proc *)curr)-&gt;pid;</span><br><span class="line">        <span class="keyword">int</span> tasksize = proc_get_size(pid);</span><br><span class="line">        <span class="keyword">if</span> (tasksize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">next</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">            pid_remove(pid);</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tasksize &gt; maxsize) &#123;</span><br><span class="line">                maxsize = tasksize;</span><br><span class="line">                maxprocp = (struct proc *)curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprocp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是 <code>false</code>，调用的则是 <code>proc_adj_lru</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct adjslot_list *<span class="title">adjslot_tail</span><span class="params">(struct adjslot_list *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adjslot_list</span> *<span class="title">asl</span> = <span class="title">head</span>-&gt;<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> asl == head ? <span class="literal">NULL</span> : asl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc *<span class="title">proc_adj_lru</span><span class="params">(<span class="keyword">int</span> oomadj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (struct proc *)adjslot_tail(&amp;procadjslot_list[ADJTOSLOT(oomadj)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们取的是列表的尾端；而插入新元素时，我们总是把它放在头端。</p>
<p><code>kill_one_process</code> 通过向应用发送信号 <code>SIGKILL</code> 来杀死对方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/* Kill one process specified by procp.  Returns the size of the process killed */</span><br><span class="line">static int kill_one_process(struct proc* procp, int min_score_adj,</span><br><span class="line">                            enum vmpressure_level level) &#123;</span><br><span class="line">    int pid = procp-&gt;pid;</span><br><span class="line">    uid_t uid = procp-&gt;uid;</span><br><span class="line">    char *taskname;</span><br><span class="line">    int tasksize;</span><br><span class="line">    int r;</span><br><span class="line"></span><br><span class="line">    taskname = proc_get_name(pid);</span><br><span class="line">    if (!taskname) &#123;</span><br><span class="line">        pid_remove(pid);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tasksize = proc_get_size(pid);</span><br><span class="line">    if (tasksize &lt;= 0) &#123;</span><br><span class="line">        pid_remove(pid);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = kill(pid, SIGKILL);</span><br><span class="line">    ALOGI(</span><br><span class="line">        &quot;Killing &apos;%s&apos; (%d), uid %d, adj %d\n&quot;</span><br><span class="line">        &quot;   to free %ldkB because system is under %s memory pressure oom_adj %d\n&quot;,</span><br><span class="line">        taskname, pid, uid, procp-&gt;oomadj, tasksize * page_k,</span><br><span class="line">        level_name[level], min_score_adj);</span><br><span class="line">    pid_remove(pid);</span><br><span class="line"></span><br><span class="line">    if (r) &#123;</span><br><span class="line">        ALOGE(&quot;kill(%d): errno=%d&quot;, pid, errno);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return tasksize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return tasksize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看不是 <code>low_ram_device</code> 的情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">do_kill:</span><br><span class="line">    <span class="keyword">if</span> (low_ram_device) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!use_minfree_levels) &#123;</span><br><span class="line">            <span class="comment">/* If pressure level is less than critical and enough free swap then ignore */</span></span><br><span class="line">            <span class="keyword">if</span> (level &lt; VMPRESS_LEVEL_CRITICAL &amp;&amp;</span><br><span class="line">                mi.field.free_swap &gt; low_pressure_mem.max_nr_free_pages) &#123;</span><br><span class="line">                <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                    ALOGI(<span class="string">"Ignoring pressure since %"</span> PRId64</span><br><span class="line">                          <span class="string">" swap pages are available "</span>,</span><br><span class="line">                          mi.field.free_swap);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Free up enough memory to downgrate the memory pressure to low level */</span></span><br><span class="line">            <span class="keyword">if</span> (mi.field.nr_free_pages &lt; low_pressure_mem.max_nr_free_pages) &#123;</span><br><span class="line">                pages_to_free = low_pressure_mem.max_nr_free_pages -</span><br><span class="line">                    mi.field.nr_free_pages;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (debug_process_killing) &#123;</span><br><span class="line">                    ALOGI(<span class="string">"Ignoring pressure since more memory is "</span></span><br><span class="line">                        <span class="string">"available (%"</span> PRId64 <span class="string">") than watermark (%"</span> PRId64 <span class="string">")"</span>,</span><br><span class="line">                        mi.field.nr_free_pages, low_pressure_mem.max_nr_free_pages);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min_score_adj = level_oomadj[level];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面我们总结过，在 <code>!use_minfree_levels</code> 的情况下，我们只有一个 mp <code>level</code>，还需要 <code>min_score_adj</code> 和 <code>pages_to_free</code> 才能开始回收进程。</p>
<p><code>low_pressure_mem.max_nr_free_pages</code> 是前面我们在 <code>record_low_pressure_levels</code> 中记录的，<code>free_swap</code> 是系统 swap 分区空余的大小；如果内存压力不是 critical 并且 swap 分区还足够大，就不回收进程了（lmkd 也是不容易啊，只有在实在没有办法了才杀我们应用）。</p>
<p>此外，在空余内存页比我们遇到过的发生 mp 事件时系统剩余内存最多的那次还要多的时候（比以往最好的情况还要好），也不回收应用。即便真的需要回收内存，我们也只回收到系统（内存）状态跟以往最好的那次为止（<code>pages_to_free = max_nr_free_pages - nr_free_pages</code>）。</p>
<p>这里计算出 <code>pages_to_free</code> 和 <code>min_scrore_adj</code> 后，我们下面就该回收进程了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp_event_common</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">uint32_t</span> events __unused)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">do_kill:</span><br><span class="line">    <span class="keyword">if</span> (low_ram_device) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!use_minfree_levels) &#123;</span><br><span class="line">            <span class="comment">// compute pages_to_free &amp; min_score_adj</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pages_freed = find_and_kill_processes(level, min_score_adj, pages_to_free);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_minfree_levels) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Killing because cache %ldkB is below "</span></span><br><span class="line">                  <span class="string">"limit %ldkB for oom_adj %d\n"</span></span><br><span class="line">                  <span class="string">"   Free memory is %ldkB %s reserved"</span>,</span><br><span class="line">                  other_file * page_k, minfree * page_k, min_score_adj,</span><br><span class="line">                  other_free * page_k, other_free &gt;= <span class="number">0</span> ? <span class="string">"above"</span> : <span class="string">"below"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pages_freed &lt; pages_to_free) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Unable to free enough memory (pages to free=%d, pages freed=%d)"</span>,</span><br><span class="line">                  pages_to_free, pages_freed);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGI(<span class="string">"Reclaimed enough memory (pages to free=%d, pages freed=%d)"</span>,</span><br><span class="line">                  pages_to_free, pages_freed);</span><br><span class="line">            gettimeofday(&amp;last_report_tm, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>find_and_kill_processes</code> 的实现在前面我们已经看了，他根据进程的 oomajd 值从大到小回收那些 oomadj 值比 <code>min_score_adj</code> 大的应用，并且只回收 <code>pages_to_free</code> 个内存页就停止。</p>
<p>最后把当前时间记录在 <code>last_report_tm</code>，他表示上次成功回收进程的时间（和 <code>kill_timeout_ms</code> 组合使用）。</p>
<p>到这里，我们就算是把 lmkd 的实现整个都读完了（长舒一口气）。</p>
</div><div class="tags"><a href="/tags/Android-source/">Android source</a></div><div class="post-nav"><a class="pre" href="/2019/04/06/native-crash-catching/">Android native 崩溃信息捕获实践</a><a class="next" href="/2019/03/20/android9-logd-init/">Android P 源码分析 4 - logd 的初始化</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://jekton.github.io/2019/03/21/android9-lmk-lmkd/';
    this.page.identifier = '2019/03/21/android9-lmk-lmkd/';
    this.page.title = 'Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jekton-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jekton-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jekton-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dart/">Dart</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Android-source/" style="font-size: 15px;">Android source</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/openjdk/" style="font-size: 15px;">openjdk</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Android-arch/" style="font-size: 15px;">Android arch</a> <a href="/tags/Dart/" style="font-size: 15px;">Dart</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/logd/" style="font-size: 15px;">logd</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/parallel-programming/" style="font-size: 15px;">parallel-programming</a> <a href="/tags/native-crash/" style="font-size: 15px;">native-crash</a> <a href="/tags/Glide/" style="font-size: 15px;">Glide</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/native-crash-catching/">Android native 崩溃信息捕获实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/android9-lmk-lmkd/">Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/android9-logd-init/">Android P 源码分析 4 - logd 的初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/19/android9-sp/">Android P 源码分析 3 - SharedPreferences 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/android9-sp-wp/">Android P 源码分析 2 - 强弱指针的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/android9-light-sp/">Android P 源码分析 1 - 轻量级智能指针的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/linux-wait-event/">Java 程序员眼里的 Linux 内核 —— wait_event 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/linux-page-table-setup/">Linux 内核页表的创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/note-x86-provisional-kernel-page-table-setup/">《深入理解 LINUX 内核》读书笔记 - 临时内核页表</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/flutter-plugin-dev/">Flutter 开发（5）- 插件的使用、开发和发布</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jekton-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">初级程序员虾饺.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>