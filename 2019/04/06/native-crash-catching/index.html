<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android native 崩溃信息捕获实践 | 初级程序员虾饺</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android native 崩溃信息捕获实践</h1><a id="logo" href="/.">初级程序员虾饺</a><p class="description">Learning for fun</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android native 崩溃信息捕获实践</h1><div class="post-meta">Apr 6, 2019<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2019/04/06/native-crash-catching/" href="/2019/04/06/native-crash-catching/#disqus_thread"></a><div class="post-content"><p>本篇是 bugly 一篇关于 native crash 捕获的文章的练习。由于他文章中已经给出了相关的大部分知识点，这里我就仅仅补充一些细节，并给出一个完整的 demo。建议大家先阅读 <a href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?" target="_blank" rel="noopener">Android 平台 Native 代码的崩溃捕获机制及实现
</a>，熟悉一下相关的知识。</p>
<p>相关代码可以在 <a href="https://github.com/Jekton/NativeCrashCatching" target="_blank" rel="noopener">https://github.com/Jekton/NativeCrashCatching</a>（目标平台是 Android 8） 找到。</p>
<h3 id="设置-signal-handler-的运行堆栈"><a href="#设置-signal-handler-的运行堆栈" class="headerlink" title="设置 signal handler 的运行堆栈"></a>设置 signal handler 的运行堆栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetUpStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">stack_t</span> <span class="built_in">stack</span>&#123;&#125;;</span><br><span class="line">  <span class="built_in">stack</span>.ss_sp = <span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) <span class="keyword">char</span>[SIGSTKSZ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">stack</span>.ss_sp) &#123;</span><br><span class="line">    LOGW(kTag, <span class="string">"fail to alloc stack for crash catching"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">stack</span>.ss_size = SIGSTKSZ;</span><br><span class="line">  <span class="built_in">stack</span>.ss_flags = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span>.ss_sp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sigaltstack(&amp;<span class="built_in">stack</span>, <span class="literal">nullptr</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      LOGERRNO(kTag, <span class="string">"fail to setup signal stack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SIGSTKSZ</code> 是一个 <code>signal.h</code> 预定义的常量，我们可以直接用它做目标的栈大小。<code>LOGERRNO, LOGD, LOGE</code> 等是我自己定义的打印 Android log 的宏。</p>
<h3 id="设置信号处理函数"><a href="#设置信号处理函数" class="headerlink" title="设置信号处理函数"></a>设置信号处理函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, struct sigaction&gt; sOldHandlers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetUpSigHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>&#123;</span>&#125;;</span><br><span class="line">  action.sa_sigaction = SignalHandler;</span><br><span class="line">  action.sa_flags = SA_SIGINFO | SA_ONSTACK;</span><br><span class="line">  <span class="keyword">int</span> signals[] = &#123;</span><br><span class="line">      SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGSEGV, SIGPIPE</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">old_action</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> signo : signals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(signo, &amp;action, &amp;old_action) == <span class="number">-1</span>) &#123;</span><br><span class="line">      LOGERRNO(kTag, <span class="string">"fail to set signal handler for signo %d"</span>, signo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (old_action.sa_handler != SIG_DFL &amp;&amp; old_action.sa_handler != SIG_IGN) &#123;</span><br><span class="line">        sOldHandlers[signo] = old_action;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们把旧的 signal handler 保存起来，执行完我们自己的函数后，再调用它们：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SignalHandler</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">siginfo_t</span>* info, <span class="keyword">void</span>* context)</span> </span>&#123;</span><br><span class="line">  DumpSignalInfo(info);</span><br><span class="line">  DumpStacks(context);</span><br><span class="line"></span><br><span class="line">  CallOldHandler(signo, info, context);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallOldHandler</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">siginfo_t</span>* info, <span class="keyword">void</span>* context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = sOldHandlers.find(signo);</span><br><span class="line">  <span class="keyword">if</span> (it != sOldHandlers.end()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second.sa_flags &amp; SA_SIGINFO) &#123;</span><br><span class="line">      it-&gt;second.sa_sigaction(signo, info, context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      it-&gt;second.sa_handler(signo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>DumpSignalInfo</code> 用来打印 <code>siginfo_t</code>，<code>DumpStacks</code> 用来打印堆栈，很快我们就会看到他的实现。</p>
<h3 id="打印-siginfo-t"><a href="#打印-siginfo-t" class="headerlink" title="打印 siginfo_t"></a>打印 siginfo_t</h3><p>打印 <code>siginfo_t</code> 没什么技术含量，就只是根据 <code>signo</code> 和 <code>si_code</code> 打印对应的消息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DumpSignalInfo</span><span class="params">(<span class="keyword">siginfo_t</span>* info)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (info-&gt;si_signo) &#123;</span><br><span class="line">  <span class="keyword">case</span> SIGILL:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGILL caught"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (info-&gt;si_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> ILL_ILLOPC:</span><br><span class="line">      LOGI(kTag, <span class="string">"illegal opcode"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_ILLOPN:</span><br><span class="line">      LOGI(kTag, <span class="string">"illegal operand"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_ILLADR:</span><br><span class="line">      LOGI(kTag, <span class="string">"illegal addressing mode"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_ILLTRP:</span><br><span class="line">      LOGI(kTag, <span class="string">"illegal trap"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_PRVOPC:</span><br><span class="line">      LOGI(kTag, <span class="string">"privileged opcode"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_PRVREG:</span><br><span class="line">      LOGI(kTag, <span class="string">"privileged register"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_COPROC:</span><br><span class="line">      LOGI(kTag, <span class="string">"coprocessor error"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ILL_BADSTK:</span><br><span class="line">      LOGI(kTag, <span class="string">"internal stack error"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOGI(kTag, <span class="string">"code = %d"</span>, info-&gt;si_code);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGFPE:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGFPE caught"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (info-&gt;si_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> FPE_INTDIV:</span><br><span class="line">      LOGI(kTag, <span class="string">"integer divide by zero"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_INTOVF:</span><br><span class="line">      LOGI(kTag, <span class="string">"integer overflow"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTDIV:</span><br><span class="line">      LOGI(kTag, <span class="string">"floating-point divide by zero"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTOVF:</span><br><span class="line">      LOGI(kTag, <span class="string">"floating-point overflow"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTUND:</span><br><span class="line">      LOGI(kTag, <span class="string">"floating-point underflow"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTRES:</span><br><span class="line">      LOGI(kTag, <span class="string">"floating-point inexact result"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTINV:</span><br><span class="line">      LOGI(kTag, <span class="string">"invalid floating-point operation"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FPE_FLTSUB:</span><br><span class="line">      LOGI(kTag, <span class="string">"subscript out of range"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOGI(kTag, <span class="string">"code = %d"</span>, info-&gt;si_code);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGSEGV:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGSEGV caught"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (info-&gt;si_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SEGV_MAPERR:</span><br><span class="line">      LOGI(kTag, <span class="string">"address not mapped to object"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEGV_ACCERR:</span><br><span class="line">      LOGI(kTag, <span class="string">"invalid permissions for mapped object"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOGI(kTag, <span class="string">"code = %d"</span>, info-&gt;si_code);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGBUS:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGBUS caught"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (info-&gt;si_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> BUS_ADRALN:</span><br><span class="line">      LOGI(kTag, <span class="string">"invalid address alignment"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BUS_ADRERR:</span><br><span class="line">      LOGI(kTag, <span class="string">"nonexistent physical address"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BUS_OBJERR:</span><br><span class="line">      LOGI(kTag, <span class="string">"object-specific hardware error"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOGI(kTag, <span class="string">"code = %d"</span>, info-&gt;si_code);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGABRT:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGABRT caught"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGPIPE:</span><br><span class="line">    LOGI(kTag, <span class="string">"signal SIGPIPE caught"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    LOGI(kTag, <span class="string">"signo %d caught"</span>, info-&gt;si_signo);</span><br><span class="line">    LOGI(kTag, <span class="string">"code = %d"</span>, info-&gt;si_code);</span><br><span class="line">  &#125;</span><br><span class="line">  LOGI(kTag, <span class="string">"errno = %d"</span>, info-&gt;si_errno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="打印堆栈"><a href="#打印堆栈" class="headerlink" title="打印堆栈"></a>打印堆栈</h3><p>最后是我们的重头戏 —— 打印堆栈。按 bugly 那文章的说法，直接在信号处理函数里调用 Java 函数经常会有问题（具体是什么问题，我也还没去看，理论上应该没关系才对），我们这里就先按他的建议，在后台起一个工作线程来打印堆栈。</p>
<p>我们在应用启动的时候，先启动一个后台线程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pid_t</span> sTidToDump;    <span class="comment">// guarded by sMutex</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* sContext;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mutex sMutex;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::condition_variable sCondition;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StackDumpingThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitCrashCaching</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOGD(kTag, <span class="string">"InitCrashCaching"</span>);</span><br><span class="line">  SetUpStack();</span><br><span class="line">  SetUpSigHandler();</span><br><span class="line">  <span class="built_in">std</span>::thread&#123;StackDumpingThread&#125;.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里 <code>mutex</code> 和 <code>condition_variable</code> 用来给信号处理函数和这个工作线程通信，我们直接通过两个静态变量传递数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StackDumpingThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock&#123;sMutex&#125;;</span><br><span class="line">  sCondition.wait(lock, [] &#123; <span class="keyword">return</span> sTidToDump &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// dump stack</span></span><br><span class="line"></span><br><span class="line">  sTidToDump = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// tell signal handler that we're done</span></span><br><span class="line">  sCondition.notify_one();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以继续看前面暂时放下的 <code>DumpStack</code> 函数了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DumpStacks</span><span class="params">(<span class="keyword">void</span>* context)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock&#123;sMutex&#125;;</span><br><span class="line">  sTidToDump = gettid();    <span class="comment">// 获取线程 id</span></span><br><span class="line">  sContext = context;</span><br><span class="line">  sCondition.notify_one();</span><br><span class="line">  <span class="comment">// 等待工作线程打印堆栈</span></span><br><span class="line">  sCondition.wait(lock, []&#123; <span class="keyword">return</span> sTidToDump == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是 native 崩溃捕获的一个基本框架，下面我们看看如何获取堆栈。</p>
<p>bugly 文章给我们推荐的 libunwind，但这里我们使用另一个朋友推荐的 libbacktrace。libbacktrace 其实也是用 libunwind 实现的。为了绕开 Android N 以后的 classloader namespace 限制，我们用 <a href="https://github.com/Rprop/ndk_dlopen" target="_blank" rel="noopener">ndk_dlopen</a> 来加载 <code>libbacktrace.so</code>。</p>
<p>使用系统内置的 so 有一个好处，就是不用自己去编译共享库，并且 so 很可能根据不同的系统版本做了调整。坏处就是我们代码的兼容性会比较差（这里我给出的代码只能运行在 Android 8 上，如果是其他版本，读者需要自己根据系统源码做一些调整）。</p>
<p>libbacktrace 的源码在 <code>system/core</code> 下面，为了了解一个库的用法，一般是看看他相关的文档、头文件。很不幸的，libbacktrace 没有文档，查看源码目录，可以看到一个 <code>Backtrace.h</code>。这种跟库名一样的头文件名，一般就是库对外的接口。</p>
<p>另一个方向是，既然 libbacktrace 在 <code>system/core</code> 里，系统可能有某个地方使用了它，我们可以全局搜索 <code>system/core</code> 找一个使用了 libbacktrace 的地方，然后参考它的用法。这里我参考的是 <code>CallStack</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/libutils/CallStack.cpp</span></span><br><span class="line"><span class="keyword">void</span> CallStack::update(<span class="keyword">int32_t</span> ignoreDepth, <span class="keyword">pid_t</span> tid) &#123;</span><br><span class="line">    mFrameLines.clear();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Backtrace&gt; backtrace(Backtrace::Create(BACKTRACE_CURRENT_PROCESS, tid));</span><br><span class="line">    <span class="keyword">if</span> (!backtrace-&gt;Unwind(ignoreDepth)) &#123;</span><br><span class="line">        ALOGW(<span class="string">"%s: Failed to unwind callstack."</span>, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; backtrace-&gt;NumFrames(); i++) &#123;</span><br><span class="line">      mFrameLines.push_back(String8(backtrace-&gt;FormatFrameData(i).c_str()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，使用 libbacktrace 一共就 3 步：</p>
<ol>
<li>使用 <code>Backtrace::Create</code> 创建一个 <code>Backtrace</code> 实例</li>
<li>调用 <code>Unwind</code> 函数 unwind 一下 stack</li>
<li><code>FormatFrameData</code> 输出每个栈帧的文本信息（也可以自己根据 frame 自己打印）</li>
</ol>
<p>下面我们先看看封装了 <code>libbacktrace</code> 的 <code>GetStackTrace</code> 接口，然后分小节来看这几个步骤。</p>
<h4 id="GetStackTrace-接口"><a href="#GetStackTrace-接口" class="headerlink" title="GetStackTrace 接口"></a>GetStackTrace 接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTraceCallback</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnFrame</span><span class="params">(<span class="keyword">size_t</span> frame_num, <span class="built_in">std</span>::<span class="built_in">string</span> frame)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnFail</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~GetTraceCallback() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @ctx can be nullptr or context from signal handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetStackTrace</span><span class="params">(<span class="keyword">pid_t</span> tid, <span class="keyword">void</span>* ctx, GetTraceCallback* callback)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>tid</code> 是需要打印对象的线程的 id，<code>ctx</code> 是信号处理函数的第三参数 <code>context</code>，<code>callback</code> 用于接收堆栈。之所以我们一个一个 frame 地传，是因为一次性打印堆栈过大，会被 Android 的 log 截断。</p>
<h4 id="创建-Backtrace-实例"><a href="#创建-Backtrace-实例" class="headerlink" title="创建 Backtrace 实例"></a>创建 <code>Backtrace</code> 实例</h4><p>为了使用 <code>ndk_dlopen</code>，我们先在 <code>InitCrashCaching</code> 的时候初始化它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_example_nativecrashcatching_CrashCatching_initNative(</span><br><span class="line">    JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">  ndk_init(env);</span><br><span class="line">  InitCrashCaching();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了找到 <code>Backtrace::Create</code> 函数的在 so 里的符号，我们可以使用 <code>nm</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ aarch64-linux-android-nm -D libbacktrace.so | grep Create</span><br><span class="line">00004e10 T _ZN12BacktraceMap6CreateEiRKNSt3__16vectorI15backtrace_map_tNS0_9allocatorIS2_EEEE</span><br><span class="line">0000aab8 T _ZN12BacktraceMap6CreateEib</span><br><span class="line">00008dec T _ZN9Backtrace6CreateEiiP12BacktraceMap</span><br></pre></td></tr></table></figure></p>
<p><code>aarch64-linux-android-nm</code> 可以在类似 <code>ndk-bundle/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin</code> 的路径里找到。</p>
<p>由于 so 里的符号都是 mangle 过的（C++ name mangling），我们可以先根据关键字 grep 出相关的符号，然后用 <a href="https://demangler.com/" target="_blank" rel="noopener">https://demangler.com/</a> demangle 出原来的符号名。<code>Backtrace::Create</code> 对应的符号是 <code>_ZN9Backtrace6CreateEiiP12BacktraceMap</code>。</p>
<p>知道函数对应的符号后，我们就可以用 <code>dlsym</code> 来找他了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* kLibBacktrace = <span class="string">"libbacktrace.so"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> BacktraceStub* <span class="title">CreateBacktrace</span><span class="params">(<span class="keyword">pid_t</span> tid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> deleter = [](<span class="keyword">void</span>* handle) &#123; ndk_dlclose(handle); &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">void</span>, <span class="keyword">decltype</span>(deleter)&gt; handle&#123;ndk_dlopen(kLibBacktrace, RTLD_LAZY), deleter&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">    LOGERRNO(kTag, <span class="string">"CrateBacktrace, fail to dlopen %s"</span>, kLibBacktrace);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> BacktraceCreate = BacktraceStub* (*)(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> tid, <span class="keyword">void</span>* <span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">union</span> &#123; <span class="keyword">void</span>* p; BacktraceCreate fn; &#125; backtrace_create;</span><br><span class="line">  backtrace_create.p = ndk_dlsym(handle.get(), <span class="string">"_ZN9Backtrace6CreateEiiP12BacktraceMap"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!backtrace_create.p) &#123;</span><br><span class="line">    LOGE(kTag, <span class="string">"CrateBacktrace, fail to get symbol Backtrace::Create: %s"</span>, ndk_dlerror());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> backtrace_create.fn(BACKTRACE_CURRENT_PROCESS, tid, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于 C++ 不给我们把 <code>void*</code> 转成函数指针，这里只能曲线救国，用一个 <code>union</code> 来转换。<code>Backtrace::Create</code> 后会返回一个 <code>Backtrace</code> 指针。这里我们有两个选择，一是把整个 <code>Backtrace</code> 类的定义后拷贝过来，二是我们仿照他的定义，只加入我们需要的一小部分。我们选择的是后者。至于他的作用，我们很快就会看到。</p>
<h4 id="调用-Unwind-函数-unwind-一下-stack"><a href="#调用-Unwind-函数-unwind-一下-stack" class="headerlink" title="调用 Unwind 函数 unwind 一下 stack"></a>调用 <code>Unwind</code> 函数 unwind 一下 stack</h4><p>查看原始的 <code>libbacktrace</code>，我们可以知道，<code>Unwind</code> 函数是一个虚函数。为了调用它，有两条路可以选择。</p>
<ol>
<li>拿到类的虚函数表，然后根据编译器的规则，算出 <code>Unwind</code> 的 offset</li>
<li>定义一个跟 <code>Backtrace</code> 具有相同虚函数表的类，然后利用这个类来得到 <code>Unwind</code> 的 offset</li>
</ol>
<p>从实现的角度，第二种方法虽然比较骚，但却比第一种简单很多。于是，我们定义了一个 <code>BacktraceStub</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BacktraceStub</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~BacktraceStub() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Unwind</span><span class="params">(<span class="keyword">size_t</span> num_ignore_frames, <span class="keyword">void</span>* context = <span class="literal">NULL</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetFunctionName</span><span class="params">(<span class="keyword">uint64_t</span> pc, <span class="keyword">uint64_t</span>* offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">backtrace_map_t</span>* <span class="built_in">map</span> = <span class="literal">NULL</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">FillInMap</span><span class="params">(<span class="keyword">uint64_t</span> pc, <span class="keyword">backtrace_map_t</span>* <span class="built_in">map</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ReadWord</span><span class="params">(<span class="keyword">uint64_t</span> ptr, <span class="keyword">word_t</span>* out_value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> size_t <span class="title">Read</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint8_t</span>* buffer, <span class="keyword">size_t</span> bytes)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">FormatFrameData</span><span class="params">(<span class="keyword">size_t</span> frame_num)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetFunctionNameRaw</span><span class="params">(<span class="keyword">uint64_t</span> pc, <span class="keyword">uint64_t</span>* offset)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">VerifyReadWordArgs</span><span class="params">(<span class="keyword">uint64_t</span> ptr, <span class="keyword">word_t</span>* out_value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除了我们需要用到的 <code>~BacktraceStub</code>、<code>Unwind</code> 和 <code>FormatFrameData</code>，其他函数其实可以随意定义。这部分相关的知识，读者可以参考《深度探索C++对象模型》。</p>
<p>有了这个 <code>BacktraceStub</code>，我们就可以调用 <code>Unwind</code> 了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetStackTrace</span><span class="params">(<span class="keyword">pid_t</span> tid, <span class="keyword">void</span>* ctx, GetTraceCallback* callback)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;BacktraceStub&gt; backtrace&#123;CreateBacktrace(tid)&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!backtrace) &#123;</span><br><span class="line">    callback-&gt;OnFail();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> ignoreDepth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!backtrace-&gt;Unwind(ignoreDepth)) &#123;</span><br><span class="line">    LOGE(kTag, <span class="string">"GetStackTrace, fail to unwind stack"</span>);</span><br><span class="line">    callback-&gt;OnFail();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ignoreDepth</code> 是忽略掉栈顶的 frame 数，我们传入 0 即可。</p>
<h4 id="FormatFrameData-输出每个栈帧的文本信息"><a href="#FormatFrameData-输出每个栈帧的文本信息" class="headerlink" title="FormatFrameData 输出每个栈帧的文本信息"></a><code>FormatFrameData</code> 输出每个栈帧的文本信息</h4><p>回忆一下前面的 <code>DumpStacks</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void DumpStacks(void* context) &#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lock&#123;sMutex&#125;;</span><br><span class="line">  sTidToDump = gettid();</span><br><span class="line">  sContext = context;</span><br><span class="line">  sCondition.notify_one();</span><br><span class="line">  sCondition.wait(lock, []&#123; return sTidToDump == 0; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于我们信号处理函数里又多执行了一部分代码，最后拿到的堆栈会多出来几个。为了去掉这些，我们需要从信号处理函数的 <code>context</code> 里拿到异常发生时的 PC 值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetStackTrace</span><span class="params">(<span class="keyword">pid_t</span> tid, <span class="keyword">void</span>* ctx, GetTraceCallback* callback)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> context = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">ucontext_t</span>*&gt;(ctx);</span><br><span class="line">  <span class="comment">// uc_mcontext.pc is the next instruction to be executed</span></span><br><span class="line">  <span class="keyword">auto</span> pc = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(context-&gt;uc_mcontext.pc) - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了拿到 libbacktrace 中栈帧的数据，我们需要再拷贝多一些类定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BacktraceUnwindError : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">  BACKTRACE_UNWIND_NO_ERROR,</span><br><span class="line">  <span class="comment">// Something failed while trying to perform the setup to begin the unwind.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_SETUP_FAILED,</span><br><span class="line">  <span class="comment">// There is no map information to use with the unwind.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_MAP_MISSING,</span><br><span class="line">  <span class="comment">// An error occurred that indicates a programming error.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_INTERNAL,</span><br><span class="line">  <span class="comment">// The thread to unwind has disappeared before the unwind can begin.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_THREAD_DOESNT_EXIST,</span><br><span class="line">  <span class="comment">// The thread to unwind has not responded to a signal in a timely manner.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_THREAD_TIMEOUT,</span><br><span class="line">  <span class="comment">// Attempt to do an unsupported operation.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_UNSUPPORTED_OPERATION,</span><br><span class="line">  <span class="comment">// Attempt to do an offline unwind without a context.</span></span><br><span class="line">  BACKTRACE_UNWIND_ERROR_NO_CONTEXT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backtrace_map_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uintptr_t</span> end = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uintptr_t</span> load_base = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backtrace_frame_data_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> num;             <span class="comment">// The current fame number.</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> pc;           <span class="comment">// The absolute pc.</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> sp;           <span class="comment">// The top of the stack.</span></span><br><span class="line">  <span class="keyword">size_t</span> stack_size;      <span class="comment">// The size of the stack, zero indicate an unknown stack size.</span></span><br><span class="line">  <span class="keyword">backtrace_map_t</span> <span class="built_in">map</span>;    <span class="comment">// The map associated with the given pc.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> func_name;  <span class="comment">// The function name associated with this pc, NULL if not found.</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> func_offset;  <span class="comment">// pc relative to the start of the function, only valid if func_name is not NULL.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">word_t</span> = <span class="keyword">unsigned</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BacktraceMap</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BacktraceStub</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// virtual functions</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> NumFrames() <span class="keyword">const</span> &#123; <span class="keyword">return</span> frames_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> backtrace_frame_data_t* <span class="title">GetFrame</span><span class="params">(<span class="keyword">size_t</span> frame_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame_num &gt;= frames_.size()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;frames_[frame_num];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">pid_t</span> pid_;</span><br><span class="line">  <span class="keyword">pid_t</span> tid_;</span><br><span class="line"></span><br><span class="line">  BacktraceMap* map_;</span><br><span class="line">  <span class="keyword">bool</span> map_shared_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">backtrace_frame_data_t</span>&gt; frames_;</span><br><span class="line">  <span class="comment">// Skip frames in libbacktrace/libunwindstack when doing a local unwind.</span></span><br><span class="line">  BacktraceUnwindError error_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>前面这些都是 libbacktrace 里拷贝出来的。由于我的测试机是 Android 8，所以使用 <code>system/core</code> 的 <code>oreo-release</code> 分支。读者需要根据自己手机系统的版本做一些调整。</p>
<p>下面是 <code>GetStackTrace</code> 的完整实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void GetStackTrace(pid_t tid, void* ctx, GetTraceCallback* callback) &#123;</span><br><span class="line">  std::unique_ptr&lt;BacktraceStub&gt; backtrace&#123;CreateBacktrace(tid)&#125;;</span><br><span class="line">  if (!backtrace) &#123;</span><br><span class="line">    callback-&gt;OnFail();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  const auto ignoreDepth = 0;</span><br><span class="line">  if (!backtrace-&gt;Unwind(ignoreDepth)) &#123;</span><br><span class="line">    LOGE(kTag, &quot;GetStackTrace, fail to unwind stack&quot;);</span><br><span class="line">    callback-&gt;OnFail();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto context = reinterpret_cast&lt;ucontext_t*&gt;(ctx);</span><br><span class="line">  // uc_mcontext.pc is the next instruction to be executed</span><br><span class="line">  auto pc = static_cast&lt;uint64_t&gt;(context-&gt;uc_mcontext.pc) - 4;</span><br><span class="line">  size_t j = 0;</span><br><span class="line">  for (size_t i = 0, size = backtrace-&gt;NumFrames(); i &lt; size; ++i) &#123;</span><br><span class="line">    auto frame = backtrace-&gt;GetFrame(i);</span><br><span class="line">    // skip frames due to notification of dumping thread</span><br><span class="line">    if (j == 0 &amp;&amp; frame-&gt;pc != pc) continue;</span><br><span class="line">    const_cast&lt;backtrace_frame_data_t*&gt;(frame)-&gt;num = j;</span><br><span class="line">    auto frame_str = backtrace-&gt;FormatFrameData(i);</span><br><span class="line">    ++j;</span><br><span class="line">    callback-&gt;OnFrame(i, frame_str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们忽略掉前面的几个栈帧后，为了让 <code>FormatFrameData</code> 输出的标号从 0 开始，我们还手动修改了 <code>frame-&gt;num</code>。下面是一个输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#00 pc 0000000000019870  /data/app/com.example.nativecrashcatching-cSDYvNiWs8hShuhH39mQUQ==/lib/arm64/libnative-lib.so (_Z3foov+16)</span><br><span class="line">#01 pc 0000000000019894  /data/app/com.example.nativecrashcatching-cSDYvNiWs8hShuhH39mQUQ==/lib/arm64/libnative-lib.so (Java_com_example_nativecrashcatching_CrashCatching_dieNative+20)</span><br><span class="line">#02 pc 00000000001fd700  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#03 pc 00000000001f4638  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#04 pc 00000000000d80b4  /system/lib64/libart.so (_ZN3art9ArtMethod6InvokeEPNS_6ThreadEPjjPNS_6JValueEPKc+260)</span><br><span class="line">#05 pc 00000000002821dc  /system/lib64/libart.so (_ZN3art11interpreter34ArtInterpreterToCompiledCodeBridgeEPNS_6ThreadEPNS_9ArtMethodEPKNS_7DexFile8CodeItemEPNS_11ShadowFrameEPNS_6JValueE+352)</span><br><span class="line">#06 pc 000000000027c8a4  /system/lib64/libart.so (_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE+672)</span><br><span class="line">#07 pc 00000000001dd130  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#08 pc 00000000001e5e94  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#09 pc 000000000025d620  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadEPKNS_7DexFile8CodeItemERNS_11ShadowFrameENS_6JValueEb+444)</span><br><span class="line">#10 pc 0000000000263d20  /system/lib64/libart.so (_ZN3art11interpreter33ArtInterpreterToInterpreterBridgeEPNS_6ThreadEPKNS_7DexFile8CodeItemEPNS_11ShadowFrameEPNS_6JValueE+212)</span><br><span class="line">#11 pc 000000000027c884  /system/lib64/libart.so (_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE+640)</span><br><span class="line">#12 pc 00000000001dd130  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#13 pc 00000000001e5e94  /system/lib64/libart.so (offset 0x2f1000)</span><br><span class="line">#14 pc 000000000025d620  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadEPKNS_7DexFile8CodeItemERNS_11ShadowFrameENS_6JValueEb+444)</span><br><span class="line">#15 pc 0000000000263d20  /system/lib64/libart.so (_ZN3art11interpreter33ArtInterpreterToInterpreterBridgeEPNS_6ThreadEPKNS_7DexFile8CodeItemEPNS_11ShadowFrameEPNS_6JValueE+212)</span><br></pre></td></tr></table></figure></p>
<p>最后再提一个小知识点。前面打印出来的 pc 是相对地址，我们从信号处理还是里拿到的 <code>pc</code> 值是绝对地址，<code>frame-&gt;pc</code> 也是绝对地址。为了把信号处理函数中的 <code>pc</code> 值转成相对地址，可以使用 <code>dladdr</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static uint64_t GetFaultPcRelative(ucontext_t* context) &#123;</span><br><span class="line">  void* pc = reinterpret_cast&lt;void*&gt;(context-&gt;uc_mcontext.pc);</span><br><span class="line">  Dl_info dl_info;</span><br><span class="line">  if (dladdr(pc, &amp;dl_info)) &#123;</span><br><span class="line">    auto base = reinterpret_cast&lt;uint64_t&gt;(dl_info.dli_fbase);</span><br><span class="line">    return reinterpret_cast&lt;uint64_t&gt;(pc) - base;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pie-release</code> 的 libbacktrace 的 <code>backtrace_frame_data_t</code> 直接带了一个成员变量 <code>rel_pc</code>。低版本的代码读者可以从 libbacktrace 源码中找到将绝对地址转换为相对地址的代码。</p>
</div><div class="tags"><a href="/tags/native-crash/">native-crash</a></div><div class="post-nav"><a class="next" href="/2019/03/21/android9-lmk-lmkd/">Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://jekton.github.io/2019/04/06/native-crash-catching/';
    this.page.identifier = '2019/04/06/native-crash-catching/';
    this.page.title = 'Android native 崩溃信息捕获实践';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jekton-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jekton-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jekton-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dart/">Dart</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/Android-source/" style="font-size: 15px;">Android source</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/openjdk/" style="font-size: 15px;">openjdk</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Android-arch/" style="font-size: 15px;">Android arch</a> <a href="/tags/Dart/" style="font-size: 15px;">Dart</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/logd/" style="font-size: 15px;">logd</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/parallel-programming/" style="font-size: 15px;">parallel-programming</a> <a href="/tags/native-crash/" style="font-size: 15px;">native-crash</a> <a href="/tags/Glide/" style="font-size: 15px;">Glide</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/native-crash-catching/">Android native 崩溃信息捕获实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/android9-lmk-lmkd/">Android P 源码分析 5 - Low memory killer 之 lmkd 守护进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/android9-logd-init/">Android P 源码分析 4 - logd 的初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/19/android9-sp/">Android P 源码分析 3 - SharedPreferences 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/android9-sp-wp/">Android P 源码分析 2 - 强弱指针的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/android9-light-sp/">Android P 源码分析 1 - 轻量级智能指针的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/linux-wait-event/">Java 程序员眼里的 Linux 内核 —— wait_event 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/linux-page-table-setup/">Linux 内核页表的创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/note-x86-provisional-kernel-page-table-setup/">《深入理解 LINUX 内核》读书笔记 - 临时内核页表</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/flutter-plugin-dev/">Flutter 开发（5）- 插件的使用、开发和发布</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jekton-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">初级程序员虾饺.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>